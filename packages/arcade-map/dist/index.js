"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target, mod2));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  AnimatedExtrusionHandler: () => AnimatedExtrusionHandler,
  AnimatedExtrusionState: () => AnimatedExtrusionState,
  ArcadeMap: () => ArcadeMap,
  AtmosphereLightMode: () => AtmosphereLightMode,
  BASE_TECHNIQUE_NON_MATERIAL_PROPS: () => BASE_TECHNIQUE_NON_MATERIAL_PROPS,
  BaseTileLoader: () => BaseTileLoader,
  BoundsGenerator: () => BoundsGenerator,
  BufferedGeometryAccessor: () => BufferedGeometryAccessor,
  BufferedGeometryAccessorBase: () => BufferedGeometryAccessorBase,
  BufferedGeometryLineAccessor: () => BufferedGeometryLineAccessor,
  BufferedGeometryObject3dAccessor: () => BufferedGeometryObject3dAccessor,
  CalculationStatus: () => CalculationStatus,
  CameraMovementDetector: () => CameraMovementDetector,
  CameraUtils: () => CameraUtils,
  Circles: () => Circles,
  ColorCache: () => ColorCache,
  ConcurrentDecoderFacade: () => ConcurrentDecoderFacade,
  ConcurrentTilerFacade: () => ConcurrentTilerFacade,
  CopyrightCoverageProvider: () => CopyrightCoverageProvider,
  CopyrightElementHandler: () => CopyrightElementHandler,
  CopyrightInfo: () => CopyrightInfo,
  DEFAULT_FONT_CATALOG_NAME: () => DEFAULT_FONT_CATALOG_NAME,
  DEFAULT_FOV_CALCULATION: () => DEFAULT_FOV_CALCULATION,
  DEFAULT_MAX_THEME_INTHERITANCE_DEPTH: () => DEFAULT_MAX_THEME_INTHERITANCE_DEPTH,
  DEFAULT_TEXT_DISTANCE_SCALE: () => DEFAULT_TEXT_DISTANCE_SCALE,
  DEPTH_PRE_PASS_STENCIL_MASK: () => DEPTH_PRE_PASS_STENCIL_MASK,
  DataSource: () => DataSource,
  DebugContext: () => DebugContext,
  ElevationBasedClipPlanesEvaluator: () => ElevationBasedClipPlanesEvaluator,
  EventDispatcher: () => EventDispatcher,
  FixedClipPlanesEvaluator: () => FixedClipPlanesEvaluator,
  FrameStats: () => FrameStats,
  FrameStatsArray: () => FrameStatsArray,
  ImageCache: () => ImageCache,
  ImageItem: () => ImageItem,
  IndexedBufferedGeometryAccessor: () => IndexedBufferedGeometryAccessor,
  IndexedBufferedGeometryLineAccessor: () => IndexedBufferedGeometryLineAccessor,
  LoadingState: () => LoadingState,
  MAX_FOV_DEG: () => MAX_FOV_DEG,
  MAX_FOV_RAD: () => MAX_FOV_RAD,
  MIN_FOV_DEG: () => MIN_FOV_DEG,
  MIN_FOV_RAD: () => MIN_FOV_RAD,
  MSAARenderPass: () => MSAARenderPass,
  MSAASampling: () => MSAASampling,
  MapAnchors: () => MapAnchors,
  MapRenderingManager: () => MapRenderingManager,
  MapView: () => MapView,
  MapViewAtmosphere: () => MapViewAtmosphere,
  MapViewEventNames: () => MapViewEventNames,
  MapViewFog: () => MapViewFog,
  MapViewImageCache: () => MapViewImageCache,
  MapViewPoints: () => MapViewPoints,
  MapViewUtils: () => MapViewUtils,
  MultiStageTimer: () => MultiStageTimer,
  Pass: () => Pass,
  PerformanceStatistics: () => PerformanceStatistics,
  PickHandler: () => PickHandler,
  PickObjectType: () => PickObjectType,
  PoiManager: () => PoiManager,
  PoiTable: () => PoiTable,
  PoiTableManager: () => PoiTableManager,
  PolarTileDataSource: () => PolarTileDataSource,
  ResourceComputationType: () => ResourceComputationType,
  RingBuffer: () => RingBuffer,
  SampledTimer: () => SampledTimer,
  SimpleTimer: () => SimpleTimer,
  Squares: () => Squares,
  Statistics: () => Statistics,
  TextElement: () => TextElement,
  TextElementType: () => TextElementType,
  TextElementsRenderer: () => TextElementsRenderer,
  TextStyleCache: () => TextStyleCache,
  TextureLoader: () => TextureLoader5,
  ThemeLoader: () => ThemeLoader,
  Tile: () => Tile,
  TileDataAccessor: () => TileDataAccessor,
  TileGeometryCreator: () => TileGeometryCreator,
  TileLoaderState: () => TileLoaderState,
  TileOffsetUtils: () => TileOffsetUtils,
  TileTaskGroups: () => TileTaskGroups,
  TiltViewClipPlanesEvaluator: () => TiltViewClipPlanesEvaluator,
  TopViewClipPlanesEvaluator: () => TopViewClipPlanesEvaluator,
  UrlCopyrightProvider: () => UrlCopyrightProvider,
  VisibleTileSet: () => VisibleTileSet,
  WorkerBasedDecoder: () => WorkerBasedDecoder,
  WorkerBasedTiler: () => WorkerBasedTiler,
  WorkerLoader: () => WorkerLoader,
  applyBaseColorToMaterial: () => applyBaseColorToMaterial,
  applySecondaryColorToMaterial: () => applySecondaryColorToMaterial,
  buildMetricValueEvaluator: () => buildMetricValueEvaluator,
  buildObject: () => buildObject,
  computeArrayAverage: () => computeArrayAverage,
  computeArrayStats: () => computeArrayStats,
  createDefaultClipPlanesEvaluator: () => createDefaultClipPlanesEvaluator,
  createDepthPrePassMaterial: () => createDepthPrePassMaterial,
  createDepthPrePassMesh: () => createDepthPrePassMesh,
  createMaterial: () => createMaterial,
  debugContext: () => debugContext,
  evaluateBaseColorProperty: () => evaluateBaseColorProperty,
  evaluateColorProperty: () => evaluateColorProperty,
  getBufferAttribute: () => getBufferAttribute,
  getFeatureDataSize: () => getFeatureDataSize,
  getMaterialConstructor: () => getMaterialConstructor,
  isDepthPrePassMesh: () => isDepthPrePassMesh,
  isLineAccessor: () => isLineAccessor,
  isObject3dAccessor: () => isObject3dAccessor,
  isRenderDepthPrePassEnabled: () => isRenderDepthPrePassEnabled,
  poiIsRenderable: () => poiIsRenderable,
  setDepthPrePassStencil: () => setDepthPrePassStencil,
  usesObject3D: () => usesObject3D
});
module.exports = __toCommonJS(src_exports);

// src/ArcadeMap/ArcadeMap.tsx
var import_react = __toESM(require("react"));

// src/geoutils/projection/SphereProjection.ts
var THREE5 = __toESM(require("three"));

// src/geoutils/coordinates/GeoCoordinates.ts
var THREE = __toESM(require("three"));

// src/geoutils/coordinates/GeoCoordinatesLike.ts
function isGeoCoordinatesLike(object) {
  return object && typeof object.latitude === "number" && typeof object.longitude === "number" && (typeof object.altitude === "number" || typeof object.altitude === "undefined");
}

// src/geoutils/coordinates/GeoPointLike.ts
function isGeoPointLike(geoPoint) {
  if (Array.isArray(geoPoint)) {
    const [longitude, latitude, altitude] = geoPoint;
    return typeof longitude === "number" && typeof latitude === "number" && (altitude === void 0 || typeof altitude === "number");
  }
  return false;
}

// src/geoutils/coordinates/LatLngLike.ts
function isLatLngLike(object) {
  return object && typeof object.lat === "number" && typeof object.lng === "number";
}

// src/geoutils/coordinates/GeoCoordinates.ts
var MAX_LATITUDE = 90;
var MIN_LATITUDE = -90;
var MAX_LONGITUDE = 180;
var tmpV0 = new THREE.Vector3();
var tmpV1 = new THREE.Vector3();
function mod(dividend, divisor) {
  const modulo = dividend % divisor;
  const modulo_sign = modulo < 0;
  const divisor_sign = divisor < 0;
  return modulo_sign === divisor_sign ? modulo : modulo + divisor;
}
var GeoCoordinates = class {
  constructor(latitude, longitude, altitude) {
    this.latitude = latitude;
    this.longitude = longitude;
    this.altitude = altitude;
  }
  static fromDegrees(latitude, longitude, altitude) {
    return new GeoCoordinates(latitude, longitude, altitude);
  }
  static fromRadians(latitude, longitude, altitude) {
    return new GeoCoordinates(THREE.MathUtils.radToDeg(latitude), THREE.MathUtils.radToDeg(longitude), altitude);
  }
  static fromLatLng(latLng) {
    return new GeoCoordinates(latLng.lat, latLng.lng);
  }
  static fromGeoPoint(geoPoint) {
    return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);
  }
  static fromObject(geoPoint) {
    if (isGeoPointLike(geoPoint)) {
      return GeoCoordinates.fromGeoPoint(geoPoint);
    } else if (isGeoCoordinatesLike(geoPoint)) {
      return GeoCoordinates.fromDegrees(geoPoint.latitude, geoPoint.longitude, geoPoint.altitude);
    } else if (isLatLngLike(geoPoint)) {
      return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);
    }
    throw new Error("Invalid input coordinate format.");
  }
  static lerp(geoCoords0, geoCoords1, factor, wrap = false, normalize = false) {
    if (wrap) {
      if (geoCoords0.lng < geoCoords1.lng) {
        const geoCoordsEnd = geoCoords0.clone();
        geoCoordsEnd.longitude += 360;
        return this.lerp(geoCoords1, geoCoordsEnd, 1 - factor);
      } else {
        const geoCoordsEnd = geoCoords1.clone();
        geoCoordsEnd.longitude += 360;
        return this.lerp(geoCoords0, geoCoordsEnd, factor);
      }
    }
    const v0 = tmpV0.set(geoCoords0.lat, geoCoords0.lng, geoCoords0.altitude ?? 0);
    const v1 = tmpV1.set(geoCoords1.lat, geoCoords1.lng, geoCoords1.altitude ?? 0);
    v0.lerp(v1, factor);
    const result = new GeoCoordinates(v0.x, v0.y, v0.z);
    return normalize ? result.normalized() : result;
  }
  get latitudeInRadians() {
    return THREE.MathUtils.degToRad(this.latitude);
  }
  get longitudeInRadians() {
    return THREE.MathUtils.degToRad(this.longitude);
  }
  get latitudeInDegrees() {
    return this.latitude;
  }
  get longitudeInDegrees() {
    return this.longitude;
  }
  get lat() {
    return this.latitude;
  }
  get lng() {
    return this.longitude;
  }
  isValid() {
    return !isNaN(this.latitude) && !isNaN(this.longitude);
  }
  normalized() {
    let { latitude, longitude } = this;
    if (isNaN(latitude) || isNaN(longitude)) {
      return this;
    }
    if (longitude < -180 || longitude > 180) {
      longitude = mod(longitude + 180, 360) - 180;
    }
    latitude = THREE.MathUtils.clamp(latitude, -90, 90);
    return new GeoCoordinates(latitude, longitude, this.altitude);
  }
  equals(other) {
    return this.latitude === other.latitude && this.longitude === other.longitude && this.altitude === other.altitude;
  }
  copy(other) {
    this.latitude = other.latitude;
    this.longitude = other.longitude;
    this.altitude = other.altitude;
    return this;
  }
  clone() {
    return new GeoCoordinates(this.latitude, this.longitude, this.altitude);
  }
  toLatLng() {
    return { lat: this.latitude, lng: this.longitude };
  }
  toGeoPoint() {
    return this.altitude !== void 0 ? [this.longitude, this.latitude, this.altitude] : [this.longitude, this.latitude];
  }
  minLongitudeSpanTo(other) {
    const minLongitude = Math.min(this.longitude, other.longitude);
    const maxLongitude = Math.max(this.longitude, other.longitude);
    return Math.min(maxLongitude - minLongitude, 360 + minLongitude - maxLongitude);
  }
};

// src/geoutils/math/Box3Like.ts
function isBox3Like(object) {
  const box3 = object;
  return box3.min !== void 0 && box3.max !== void 0;
}

// src/geoutils/math/MathUtils.ts
var THREE2 = __toESM(require("three"));
var MathUtils3;
((MathUtils38) => {
  function newEmptyBox3() {
    return {
      min: { x: Infinity, y: Infinity, z: Infinity },
      max: { x: -Infinity, y: -Infinity, z: -Infinity }
    };
  }
  MathUtils38.newEmptyBox3 = newEmptyBox3;
  function newVector3(x, y, z, v) {
    if (v === void 0) {
      return { x, y, z };
    }
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
  }
  MathUtils38.newVector3 = newVector3;
  function copyVector3(from, to) {
    to.x = from.x;
    to.y = from.y;
    to.z = from.z;
    return to;
  }
  MathUtils38.copyVector3 = copyVector3;
  MathUtils38.degToRad = THREE2.MathUtils.degToRad;
  MathUtils38.radToDeg = THREE2.MathUtils.radToDeg;
  MathUtils38.clamp = THREE2.MathUtils.clamp;
  function normalizeAngleDeg(a) {
    a = a % 360;
    if (a < 0) {
      a = a + 360;
    }
    return a;
  }
  MathUtils38.normalizeAngleDeg = normalizeAngleDeg;
  function normalizeLongitudeDeg(a) {
    a = normalizeAngleDeg(a);
    if (a > 180) {
      a = a - 360;
    }
    return a;
  }
  MathUtils38.normalizeLongitudeDeg = normalizeLongitudeDeg;
  function angleDistanceDeg(a, b) {
    a = normalizeAngleDeg(a);
    b = normalizeAngleDeg(b);
    const d = a - b;
    if (d > 180) {
      return d - 360;
    } else if (d <= -180) {
      return d + 360;
    } else {
      return d;
    }
  }
  MathUtils38.angleDistanceDeg = angleDistanceDeg;
  function interpolateAnglesDeg(p0, p1, t) {
    const d = angleDistanceDeg(p1, p0);
    const r = (p0 + d * t) % 360;
    return r;
  }
  MathUtils38.interpolateAnglesDeg = interpolateAnglesDeg;
})(MathUtils3 || (MathUtils3 = {}));

// src/geoutils/math/OrientedBox3Like.ts
function isOrientedBox3Like(object) {
  const obb = object;
  return obb.position !== void 0 && obb.xAxis !== void 0 && obb.yAxis !== void 0 && obb.zAxis !== void 0 && obb.extents !== void 0;
}

// src/geoutils/projection/EarthConstants.ts
var EarthConstants = class {
};
__publicField(EarthConstants, "EQUATORIAL_CIRCUMFERENCE", 4007501668557849e-8);
__publicField(EarthConstants, "EQUATORIAL_RADIUS", 6378137);
__publicField(EarthConstants, "MIN_ELEVATION", -433);
__publicField(EarthConstants, "MAX_ELEVATION", 8848);
__publicField(EarthConstants, "MAX_BUILDING_HEIGHT", 828);

// src/geoutils/projection/MercatorProjection.ts
var THREE4 = __toESM(require("three"));

// src/geoutils/coordinates/GeoBox.ts
var THREE3 = __toESM(require("three"));
var GeoBox = class {
  constructor(southWest, northEast) {
    this.southWest = southWest;
    this.northEast = northEast;
    if (this.west > this.east) {
      this.northEast.longitude += 360;
    }
  }
  static fromCoordinates(southWest, northEast) {
    return new GeoBox(southWest, northEast);
  }
  static fromCenterAndExtents(center, extent) {
    return new GeoBox(new GeoCoordinates(center.latitude - extent.latitudeSpan / 2, center.longitude - extent.longitudeSpan / 2), new GeoCoordinates(center.latitude + extent.latitudeSpan / 2, center.longitude + extent.longitudeSpan / 2));
  }
  get minAltitude() {
    if (this.southWest.altitude === void 0 || this.northEast.altitude === void 0) {
      return void 0;
    }
    return Math.min(this.southWest.altitude, this.northEast.altitude);
  }
  get maxAltitude() {
    if (this.southWest.altitude === void 0 || this.northEast.altitude === void 0) {
      return void 0;
    }
    return Math.max(this.southWest.altitude, this.northEast.altitude);
  }
  get south() {
    return this.southWest.latitude;
  }
  get north() {
    return this.northEast.latitude;
  }
  get west() {
    return this.southWest.longitude;
  }
  get east() {
    return this.northEast.longitude;
  }
  get center() {
    const latitude = (this.south + this.north) * 0.5;
    const { west, east } = this;
    const { minAltitude, altitudeSpan } = this;
    let altitude;
    if (minAltitude !== void 0 && altitudeSpan !== void 0) {
      altitude = minAltitude + altitudeSpan * 0.5;
    }
    if (west <= east) {
      return new GeoCoordinates(latitude, (west + east) * 0.5, altitude);
    }
    let longitude = (360 + east + west) * 0.5;
    if (longitude > 360) {
      longitude -= 360;
    }
    return new GeoCoordinates(latitude, longitude, altitude);
  }
  get latitudeSpanInRadians() {
    return THREE3.MathUtils.degToRad(this.latitudeSpan);
  }
  get longitudeSpanInRadians() {
    return THREE3.MathUtils.degToRad(this.longitudeSpan);
  }
  get latitudeSpan() {
    return this.north - this.south;
  }
  get altitudeSpan() {
    if (this.maxAltitude === void 0 || this.minAltitude === void 0) {
      return void 0;
    }
    return this.maxAltitude - this.minAltitude;
  }
  get longitudeSpan() {
    let width = this.northEast.longitude - this.southWest.longitude;
    if (width < 0) {
      width += 360;
    }
    return width;
  }
  get latitudeSpanInDegrees() {
    return this.latitudeSpan;
  }
  get longitudeSpanInDegrees() {
    return this.longitudeSpan;
  }
  contains(point) {
    if (point.altitude === void 0 || this.minAltitude === void 0 || this.maxAltitude === void 0) {
      return this.containsHelper(point);
    }
    const isFlat = this.minAltitude === this.maxAltitude;
    const isSameAltitude = this.minAltitude === point.altitude;
    const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;
    if (isFlat ? isSameAltitude : isWithinAltitudeRange) {
      return this.containsHelper(point);
    }
    return false;
  }
  clone() {
    return new GeoBox(this.southWest.clone(), this.northEast.clone());
  }
  growToContain(point) {
    this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);
    this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);
    this.southWest.altitude = this.southWest.altitude !== void 0 && point.altitude !== void 0 ? Math.min(this.southWest.altitude, point.altitude) : this.southWest.altitude !== void 0 ? this.southWest.altitude : point.altitude !== void 0 ? point.altitude : void 0;
    this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);
    this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);
    this.northEast.altitude = this.northEast.altitude !== void 0 && point.altitude !== void 0 ? Math.max(this.northEast.altitude, point.altitude) : this.northEast.altitude !== void 0 ? this.northEast.altitude : point.altitude !== void 0 ? point.altitude : void 0;
  }
  containsHelper(point) {
    if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {
      return false;
    }
    const { west, east } = this;
    let longitude = point.longitude;
    if (east > MAX_LONGITUDE) {
      while (longitude < west) {
        longitude = longitude + 360;
      }
    }
    if (longitude > east) {
      while (longitude > west + 360) {
        longitude = longitude - 360;
      }
    }
    return longitude >= west && longitude < east;
  }
};

// src/geoutils/projection/Projection.ts
var Projection = class {
  constructor(unitScale) {
    this.unitScale = unitScale;
  }
  localTangentSpace(point, result) {
    if (isGeoCoordinatesLike(point)) {
      this.projectPoint(point, result.position);
    } else {
      MathUtils3.copyVector3(point, result.position);
    }
    MathUtils3.newVector3(1, 0, 0, result.xAxis);
    MathUtils3.newVector3(0, 1, 0, result.yAxis);
    MathUtils3.newVector3(0, 0, 1, result.zAxis);
    return result;
  }
  reprojectPoint(sourceProjection, worldPos, result) {
    if (sourceProjection === this) {
      if (result === void 0) {
        return { x: worldPos.x, y: worldPos.y, z: worldPos.z };
      }
      result.x = worldPos.x;
      result.y = worldPos.y;
      result.z = worldPos.z;
      return result;
    }
    return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);
  }
};

// src/geoutils/projection/MercatorProjection.ts
var MercatorProjection = class extends Projection {
  static clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
  }
  static latitudeClamp(latitude) {
    return MercatorProjection.clamp(latitude, -MercatorConstants.MAXIMUM_LATITUDE, MercatorConstants.MAXIMUM_LATITUDE);
  }
  static latitudeProject(latitude) {
    return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;
  }
  static latitudeClampProject(latitude) {
    return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));
  }
  static unprojectLatitude(y) {
    return 2 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;
  }
  type = 0 /* Planar */;
  getScaleFactor(worldPoint) {
    return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));
  }
  worldExtent(minAltitude, maxAltitude, result) {
    if (!result) {
      result = new THREE4.Box3();
    }
    result.min.x = 0;
    result.min.y = 0;
    result.min.z = minAltitude;
    result.max.x = this.unitScale;
    result.max.y = this.unitScale;
    result.max.z = maxAltitude;
    return result;
  }
  projectPoint(geoPointLike, result) {
    let geoPoint;
    if (geoPointLike instanceof GeoCoordinates) {
      geoPoint = geoPointLike;
    } else {
      geoPoint = new GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
    }
    if (!result) {
      result = { x: 0, y: 0, z: 0 };
    }
    result.x = (geoPoint.longitude + 180) / 360 * this.unitScale;
    result.y = (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) * this.unitScale;
    result.z = geoPoint.altitude ?? 0;
    return result;
  }
  unprojectPoint(worldPoint) {
    const geoPoint = GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2), worldPoint.x / this.unitScale * 2 * Math.PI - Math.PI, worldPoint.z);
    return geoPoint;
  }
  unprojectAltitude(worldPoint) {
    return worldPoint.z;
  }
  projectBox(geoBox, result) {
    const worldCenter = this.projectPoint(geoBox.center);
    const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 + 0.5) * this.unitScale;
    const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 + 0.5) * this.unitScale;
    const worldYCenter = (worldNorth + worldSouth) * 0.5;
    worldCenter.y = worldYCenter;
    const latitudeSpan = worldNorth - worldSouth;
    const longitudeSpan = geoBox.longitudeSpan / 360 * this.unitScale;
    if (!result) {
      result = new THREE4.Box3();
    }
    if (isBox3Like(result)) {
      result.min.x = worldCenter.x - longitudeSpan * 0.5;
      result.min.y = worldCenter.y - latitudeSpan * 0.5;
      result.max.x = worldCenter.x + longitudeSpan * 0.5;
      result.max.y = worldCenter.y + latitudeSpan * 0.5;
      const altitudeSpan = geoBox.altitudeSpan;
      if (altitudeSpan !== void 0) {
        result.min.z = worldCenter.z - altitudeSpan * 0.5;
        result.max.z = worldCenter.z + altitudeSpan * 0.5;
      } else {
        result.min.z = 0;
        result.max.z = 0;
      }
    } else if (isOrientedBox3Like(result)) {
      MathUtils3.newVector3(1, 0, 0, result.xAxis);
      MathUtils3.newVector3(0, 1, 0, result.yAxis);
      MathUtils3.newVector3(0, 0, 1, result.zAxis);
      result.position.x = worldCenter.x;
      result.position.y = worldCenter.y;
      result.position.z = worldCenter.z;
      result.extents.x = longitudeSpan * 0.5;
      result.extents.y = latitudeSpan * 0.5;
      result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan ?? 0) * 0.5);
    } else {
      throw new Error("invalid bounding box");
    }
    return result;
  }
  unprojectBox(worldBox) {
    const minGeo = this.unprojectPoint(worldBox.min);
    const maxGeo = this.unprojectPoint(worldBox.max);
    const geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);
    return geoBox;
  }
  groundDistance(worldPoint) {
    return worldPoint.z;
  }
  scalePointToSurface(worldPoint) {
    worldPoint.z = 0;
    return worldPoint;
  }
  surfaceNormal(_worldPoint, normal) {
    if (normal === void 0) {
      normal = { x: 0, y: 0, z: 1 };
    } else {
      normal.x = 0;
      normal.y = 0;
      normal.z = 1;
    }
    return normal;
  }
  reprojectPoint(sourceProjection, worldPos, result) {
    if (sourceProjection !== this && (sourceProjection === webMercatorProjection || sourceProjection === mercatorProjection)) {
      if (result === void 0) {
        result = {};
      }
      result.x = worldPos.x;
      result.y = this.unitScale - worldPos.y;
      result.z = worldPos.z;
      return result;
    }
    return super.reprojectPoint(sourceProjection, worldPos, result);
  }
};
var WebMercatorProjection = class extends MercatorProjection {
  projectPoint(geoPointLike, result) {
    let geoPoint;
    if (geoPointLike instanceof GeoCoordinates) {
      geoPoint = geoPointLike;
    } else {
      geoPoint = new GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
    }
    if (!result) {
      result = { x: 0, y: 0, z: 0 };
    }
    result.x = (geoPoint.longitude + 180) / 360 * this.unitScale;
    const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));
    result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;
    result.z = geoPoint.altitude ?? 0;
    return result;
  }
  unprojectPoint(worldPoint) {
    const x = worldPoint.x / this.unitScale - 0.5;
    const y = 0.5 - worldPoint.y / this.unitScale;
    const longitude = 360 * x;
    const latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
    return new GeoCoordinates(latitude, longitude, worldPoint.z);
  }
  projectBox(geoBox, result) {
    const r = super.projectBox(geoBox, result);
    if (isBox3Like(r)) {
      const maxY = r.max.y;
      r.max.y = this.unitScale - r.min.y;
      r.min.y = this.unitScale - maxY;
    } else if (isOrientedBox3Like(r)) {
      MathUtils3.newVector3(1, 0, 0, r.xAxis);
      MathUtils3.newVector3(0, -1, 0, r.yAxis);
      MathUtils3.newVector3(0, 0, -1, r.zAxis);
      r.position.y = this.unitScale - r.position.y;
    }
    return r;
  }
  unprojectBox(worldBox) {
    const minGeo = this.unprojectPoint(worldBox.min);
    const maxGeo = this.unprojectPoint(worldBox.max);
    const geoBox = new GeoBox(new GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));
    return geoBox;
  }
  surfaceNormal(_worldPoint, normal) {
    if (normal === void 0) {
      normal = { x: 0, y: 0, z: -1 };
    } else {
      normal.x = 0;
      normal.y = 0;
      normal.z = -1;
    }
    return normal;
  }
  localTangentSpace(point, result) {
    if (isGeoCoordinatesLike(point)) {
      this.projectPoint(point, result.position);
    } else {
      MathUtils3.copyVector3(point, result.position);
    }
    MathUtils3.newVector3(1, 0, 0, result.xAxis);
    MathUtils3.newVector3(0, -1, 0, result.yAxis);
    MathUtils3.newVector3(0, 0, -1, result.zAxis);
    return result;
  }
};
var MercatorConstants = class {
};
__publicField(MercatorConstants, "MAXIMUM_LATITUDE", 1.4844222297453322);
var mercatorProjection = new MercatorProjection(EarthConstants.EQUATORIAL_CIRCUMFERENCE);
var webMercatorProjection = new WebMercatorProjection(EarthConstants.EQUATORIAL_CIRCUMFERENCE);

// src/geoutils/projection/SphereProjection.ts
function apply(xAxis, yAxis, zAxis, v) {
  const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;
  const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;
  const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;
  v.x = x;
  v.y = y;
  v.z = z;
  return v;
}
function getLongitudeQuadrant(longitude) {
  const oneOverPI = 1 / Math.PI;
  const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));
  return THREE5.MathUtils.clamp(quadrantIndex, 0, 4);
}
function lengthOfVector3(worldPoint) {
  const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);
  return d;
}
function makeBox3(geoBox, worldBox, unitScale) {
  const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude ?? 0)) * 0.5;
  const minLongitude = THREE5.MathUtils.degToRad(geoBox.west);
  const maxLongitude = THREE5.MathUtils.degToRad(geoBox.east);
  const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);
  const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);
  let xMin = Math.cos(minLongitude);
  let xMax = xMin;
  let yMin = Math.sin(minLongitude);
  let yMax = yMin;
  for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {
    const x = (quadrantIndex + 1 & 1) * ((quadrantIndex & 2) - 1);
    xMin = Math.min(x, xMin);
    xMax = Math.max(x, xMax);
    const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);
    yMin = Math.min(y, yMin);
    yMax = Math.max(y, yMax);
  }
  const cosMaxLongitude = Math.cos(maxLongitude);
  xMin = Math.min(cosMaxLongitude, xMin);
  xMax = Math.max(cosMaxLongitude, xMax);
  const sinMaxLongitude = Math.sin(maxLongitude);
  yMin = Math.min(sinMaxLongitude, yMin);
  yMax = Math.max(sinMaxLongitude, yMax);
  const xCenter = (xMax + xMin) * halfEquatorialRadius;
  const xExtent = (xMax - xMin) * halfEquatorialRadius;
  const yCenter = (yMax + yMin) * halfEquatorialRadius;
  const yExtent = (yMax - yMin) * halfEquatorialRadius;
  const minLatitude = THREE5.MathUtils.degToRad(geoBox.south);
  const maxLatutide = THREE5.MathUtils.degToRad(geoBox.north);
  const zMax = Math.sin(maxLatutide);
  const zMin = Math.sin(minLatitude);
  const zCenter = (zMax + zMin) * halfEquatorialRadius;
  const zExtent = (zMax - zMin) * halfEquatorialRadius;
  worldBox.min.x = xCenter - xExtent;
  worldBox.min.y = yCenter - yExtent;
  worldBox.min.z = zCenter - zExtent;
  worldBox.max.x = xCenter + xExtent;
  worldBox.max.y = yCenter + yExtent;
  worldBox.max.z = zCenter + zExtent;
  return worldBox;
}
function project(geoPoint, worldpoint, unitScale) {
  const radius = unitScale + (geoPoint.altitude ?? 0);
  const latitude = THREE5.MathUtils.degToRad(geoPoint.latitude);
  const longitude = THREE5.MathUtils.degToRad(geoPoint.longitude);
  const cosLatitude = Math.cos(latitude);
  worldpoint.x = radius * cosLatitude * Math.cos(longitude);
  worldpoint.y = radius * cosLatitude * Math.sin(longitude);
  worldpoint.z = radius * Math.sin(latitude);
  return worldpoint;
}
var SphereProjection = class extends Projection {
  type = 1 /* Spherical */;
  worldExtent(_minElevation, maxElevation, result = new THREE5.Box3()) {
    const radius = this.unitScale + maxElevation;
    result.min.x = -radius;
    result.min.y = -radius;
    result.min.z = -radius;
    result.max.x = radius;
    result.max.y = radius;
    result.max.z = radius;
    return result;
  }
  projectPoint(geoPoint, result = MathUtils3.newVector3(0, 0, 0)) {
    return project(geoPoint, result, this.unitScale);
  }
  unprojectPoint(point) {
    const parallelRadiusSq = point.x * point.x + point.y * point.y;
    const parallelRadius = Math.sqrt(parallelRadiusSq);
    const v = point.z / parallelRadius;
    if (isNaN(v)) {
      return GeoCoordinates.fromRadians(0, 0, -this.unitScale);
    }
    const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);
    return GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);
  }
  unprojectAltitude(point) {
    const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;
    return Math.sqrt(parallelRadiusSq) - EarthConstants.EQUATORIAL_RADIUS;
  }
  projectBox(geoBox, result = new THREE5.Box3()) {
    if (isBox3Like(result)) {
      return makeBox3(geoBox, result, this.unitScale);
    } else if (isOrientedBox3Like(result)) {
      if (geoBox.longitudeSpan >= 90) {
        const bounds = makeBox3(geoBox, new THREE5.Box3(), this.unitScale);
        MathUtils3.newVector3(1, 0, 0, result.xAxis);
        MathUtils3.newVector3(0, 1, 0, result.yAxis);
        MathUtils3.newVector3(0, 0, 1, result.zAxis);
        result.position.x = (bounds.max.x + bounds.min.x) * 0.5;
        result.position.y = (bounds.max.y + bounds.min.y) * 0.5;
        result.position.z = (bounds.max.z + bounds.min.z) * 0.5;
        result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;
        result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;
        result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;
        return result;
      }
      const { south, west, north, east, center: mid } = geoBox;
      const midX = mid.longitude;
      const midY = mid.latitude;
      const cosSouth = Math.cos(THREE5.MathUtils.degToRad(south));
      const sinSouth = Math.sin(THREE5.MathUtils.degToRad(south));
      const cosWest = Math.cos(THREE5.MathUtils.degToRad(west));
      const sinWest = Math.sin(THREE5.MathUtils.degToRad(west));
      const cosNorth = Math.cos(THREE5.MathUtils.degToRad(north));
      const sinNorth = Math.sin(THREE5.MathUtils.degToRad(north));
      const cosEast = Math.cos(THREE5.MathUtils.degToRad(east));
      const sinEast = Math.sin(THREE5.MathUtils.degToRad(east));
      const cosMidX = Math.cos(THREE5.MathUtils.degToRad(midX));
      const sinMidX = Math.sin(THREE5.MathUtils.degToRad(midX));
      const cosMidY = Math.cos(THREE5.MathUtils.degToRad(midY));
      const sinMidY = Math.sin(THREE5.MathUtils.degToRad(midY));
      MathUtils3.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);
      MathUtils3.newVector3(-sinMidX, cosMidX, 0, result.xAxis);
      MathUtils3.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);
      let width;
      let minY;
      let maxY;
      if (south >= 0) {
        width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
        minY = cosMidY * sinSouth - sinMidY * cosSouth;
        maxY = cosMidY * sinNorth - sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);
      } else {
        if (north <= 0) {
          width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
          maxY = cosMidY * sinNorth - sinMidY * cosNorth;
        } else {
          width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));
          maxY = cosMidY * sinNorth - sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);
        }
        minY = cosMidY * sinSouth - sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);
      }
      const rMax = (this.unitScale + (geoBox.maxAltitude ?? 0)) * 0.5;
      const rMin = (this.unitScale + (geoBox.minAltitude ?? 0)) * 0.5;
      const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);
      const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);
      MathUtils3.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);
      MathUtils3.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);
      apply(result.xAxis, result.yAxis, result.zAxis, result.position);
      result.position.x = result.position.x - result.zAxis.x * result.extents.z;
      result.position.y = result.position.y - result.zAxis.y * result.extents.z;
      result.position.z = result.position.z - result.zAxis.z * result.extents.z;
      return result;
    }
    throw new Error("Invalid bounding box");
  }
  unprojectBox(_worldBox) {
    throw new Error("Method not implemented.");
  }
  getScaleFactor(_worldPoint) {
    return 1;
  }
  groundDistance(worldPoint) {
    return lengthOfVector3(worldPoint) - this.unitScale;
  }
  scalePointToSurface(worldPoint) {
    const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);
    worldPoint.x *= scale;
    worldPoint.y *= scale;
    worldPoint.z *= scale;
    return worldPoint;
  }
  surfaceNormal(worldPoint, normal) {
    if (normal === void 0) {
      normal = { x: 0, y: 0, z: 0 };
    }
    const scale = 1 / (lengthOfVector3(worldPoint) || 1);
    normal.x = worldPoint.x * scale;
    normal.y = worldPoint.y * scale;
    normal.z = worldPoint.z * scale;
    return normal;
  }
  reprojectPoint(sourceProjection, worldPos, result) {
    if (sourceProjection === mercatorProjection || sourceProjection === webMercatorProjection) {
      const { x, y, z } = worldPos;
      const r = this.unitScale;
      const mx = x / r - Math.PI;
      const my = y / r - Math.PI;
      const w = Math.exp(my);
      const d = w * w;
      const gx = 2 * w / (d + 1);
      const gy = (d - 1) / (d + 1);
      const scale = r + z;
      if (result === void 0) {
        result = {};
      }
      result.x = Math.cos(mx) * gx * scale;
      result.y = Math.sin(mx) * gx * scale;
      result.z = gy * scale;
      if (sourceProjection === webMercatorProjection) {
        result.z = -result.z;
      }
      return result;
    }
    return super.reprojectPoint(sourceProjection, worldPos, result);
  }
  localTangentSpace(point, result) {
    let geoPoint;
    if (isGeoCoordinatesLike(point)) {
      this.projectPoint(point, result.position);
      geoPoint = point;
    } else {
      MathUtils3.copyVector3(point, result.position);
      geoPoint = this.unprojectPoint(point);
    }
    const latitude = THREE5.MathUtils.degToRad(geoPoint.latitude);
    const longitude = THREE5.MathUtils.degToRad(geoPoint.longitude);
    const cosLongitude = Math.cos(longitude);
    const sinLongitude = Math.sin(longitude);
    const cosLatitude = Math.cos(latitude);
    const sinLatitude = Math.sin(latitude);
    MathUtils3.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);
    MathUtils3.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);
    MathUtils3.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);
    return result;
  }
};
var sphereProjection = new SphereProjection(EarthConstants.EQUATORIAL_RADIUS);

// src/ArcadeMap/ArcadeMap.tsx
var ArcadeMap = () => {
  console.log("Hello from ArcadeMap");
  (0, import_react.useEffect)(() => {
    const mapView = new MapView({
      canvas,
      context,
      projection: sphereProjection,
      theme: "resources/berlin_tilezen_base_globe.json"
    });
    mapView.resize(window.innerWidth, window.innerHeight);
  }, []);
  return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null);
};

// src/datasource-protocol/ColorUtils.ts
var THREE6 = __toESM(require("three"));

// src/utils/assert.ts
var isProduction = process.env.NODE_ENV === "production";
function assert(condition, message) {
  if (!isProduction) {
    if (!condition) {
      throw new Error(message !== void 0 ? message : "ASSERTION failed");
    }
  }
}
function assertExists(element, message) {
  if (!isProduction) {
    if (element === void 0 || element === null) {
      throw new Error(message !== void 0 ? message : "ASSERTION failed: Element is undefined or null");
    }
  }
  return element;
}

// src/utils/ContextLogger.ts
var ContextLogger = class {
  constructor(m_logger, headerMessage) {
    this.m_logger = m_logger;
    this.headerMessage = headerMessage;
  }
  context = [];
  m_headerLogged = false;
  pushAttr(name2) {
    this.context.push(`${this.context.length > 0 ? "." : ""}${name2}`);
  }
  pushIndex(index) {
    this.context.push(`[${index}]`);
  }
  pop() {
    this.context.pop();
  }
  warn = this.createLogMethod("warn");
  info = this.createLogMethod("info");
  error = this.createLogMethod("error");
  createLogMethod(severity) {
    return (message, ...rest) => {
      if (!this.m_headerLogged) {
        this.m_logger.info(this.headerMessage);
        this.m_headerLogged = true;
      }
      this.m_logger[severity](`${this.context.join("")}: ${message}`, ...rest);
    };
  }
};

// src/utils/DOMUtils.ts
var DOMUtils;
((DOMUtils2) => {
  function getBrowserLanguages() {
    if (navigator.languages !== void 0 && navigator.languages.length > 0) {
      const languageList = [];
      for (const lang of navigator.languages) {
        languageList.push(getIsoLanguageCode(lang));
      }
      return languageList;
    }
    if (navigator.language !== void 0) {
      return [getIsoLanguageCode(navigator.language)];
    }
    return void 0;
  }
  DOMUtils2.getBrowserLanguages = getBrowserLanguages;
  function getIsoLanguageCode(language) {
    return language.substring(0, 2);
  }
})(DOMUtils || (DOMUtils = {}));

// src/utils/Functions.ts
function chainCallbacks(f1, f2) {
  return function(...args) {
    if (f1) {
      f1.apply(this, args);
    }
    return f2.apply(this, args);
  };
}

// src/utils/GlslUtils.ts
function convertVertexShaderToWebGL2(vertexShader2) {
  return [
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join("\n") + "\n" + vertexShader2;
}
function convertFragmentShaderToWebGL2(fragmentShader3) {
  return [
    "#define varying in",
    "out highp vec4 pc_fragColor;",
    "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join("\n") + "\n" + fragmentShader3;
}

// src/utils/GroupedPriorityList.ts
var PriorityListGroup = class {
  constructor(priority, elements = new Array()) {
    this.priority = priority;
    this.elements = elements;
  }
  clone() {
    return new PriorityListGroup(this.priority, this.elements.slice());
  }
  remove(element) {
    const foundIndex = this.elements.indexOf(element);
    if (foundIndex === -1) {
      return false;
    }
    this.elements.splice(foundIndex, 1);
    return true;
  }
};
var GroupedPriorityList = class {
  groups = /* @__PURE__ */ new Map();
  add(element) {
    this.getGroup(element.priority).elements.push(element);
  }
  remove(element) {
    const group = this.findGroup(element.priority);
    if (group !== void 0 && group.remove(element)) {
      if (group.elements.length === 0) {
        this.groups.delete(group.priority);
      }
      return true;
    }
    return false;
  }
  clear() {
    this.groups.clear();
  }
  merge(other) {
    for (const otherGroup of other.groups) {
      const group = this.findGroup(otherGroup[1].priority);
      if (group === void 0) {
        this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());
        continue;
      }
      group.elements = group.elements.concat(otherGroup[1].elements);
    }
    return this;
  }
  clone() {
    const clone = new GroupedPriorityList();
    for (const [priority, group] of this.groups) {
      clone.groups.set(priority, group.clone());
    }
    return clone;
  }
  forEach(fun) {
    for (const group of this.groups) {
      group[1].elements.forEach(fun);
    }
  }
  count() {
    let n = 0;
    for (const group of this.groups) {
      n += group[1].elements.length;
    }
    return n;
  }
  findGroup(priority) {
    const normalizedPriority = Math.floor(priority);
    const group = this.groups.get(normalizedPriority);
    return group;
  }
  getGroup(priority) {
    let group = this.findGroup(priority);
    if (group === void 0) {
      const normalizedPriority = Math.floor(priority);
      group = new PriorityListGroup(normalizedPriority);
      this.groups.set(group.priority, group);
    }
    return group;
  }
};

// src/utils/Logger/ConsoleChannel.ts
var ConsoleChannel = class {
  error(message, ...optionalParams) {
    console.error(message, ...optionalParams);
  }
  debug(message, ...optionalParams) {
    console.debug(message, ...optionalParams);
  }
  info(message, ...optionalParams) {
    console.info(message, ...optionalParams);
  }
  log(message, ...optionalParams) {
    console.log(message, ...optionalParams);
  }
  trace(message, ...optionalParams) {
    console.trace(message, ...optionalParams);
  }
  warn(message, ...optionalParams) {
    console.warn(message, ...optionalParams);
  }
};

// src/utils/Logger/Logger.ts
var Logger = class {
  constructor(name2, m_channel, options) {
    this.name = name2;
    this.m_channel = m_channel;
    if (options !== void 0) {
      this.update(options);
    }
  }
  enabled = true;
  level = 0 /* Trace */;
  error(message, ...optionalParams) {
    if (this.enabled && this.level <= 5 /* Error */) {
      this.m_channel.error(this.prefix, message, ...optionalParams);
    }
  }
  debug(message, ...optionalParams) {
    if (this.enabled && this.level <= 1 /* Debug */) {
      this.m_channel.debug(this.prefix, message, ...optionalParams);
    }
  }
  info(message, ...optionalParams) {
    if (this.enabled && this.level <= 3 /* Info */) {
      this.m_channel.info(this.prefix, message, ...optionalParams);
    }
  }
  log(message, ...optionalParams) {
    if (this.enabled && this.level <= 2 /* Log */) {
      this.m_channel.log(this.prefix, message, ...optionalParams);
    }
  }
  trace(message, ...optionalParams) {
    if (this.enabled && this.level <= 0 /* Trace */) {
      this.m_channel.trace(this.prefix, message, ...optionalParams);
    }
  }
  warn(message, ...optionalParams) {
    if (this.enabled && this.level <= 4 /* Warn */) {
      this.m_channel.warn(this.prefix, message, ...optionalParams);
    }
  }
  update(options) {
    this.enabled = options.enabled === void 0 ? this.enabled : options.enabled;
    this.level = options.level === void 0 ? this.level : options.level;
  }
  get prefix() {
    return this.name + ":";
  }
};

// src/utils/Logger/WorkerChannel.ts
var WORKERCHANNEL_MSG_TYPE = "worker-channel-message";
var WorkerChannel = class {
  error(message, ...optionalParams) {
    const workerMessage = {
      message: [message, ...optionalParams],
      type: WORKERCHANNEL_MSG_TYPE,
      level: 5 /* Error */
    };
    self.postMessage(workerMessage);
  }
  debug(message, ...optionalParams) {
    const workerMessage = {
      message: [message, ...optionalParams],
      type: WORKERCHANNEL_MSG_TYPE,
      level: 1 /* Debug */
    };
    self.postMessage(workerMessage);
  }
  info(message, ...optionalParams) {
    const workerMessage = {
      message: [message, ...optionalParams],
      type: WORKERCHANNEL_MSG_TYPE,
      level: 3 /* Info */
    };
    self.postMessage(workerMessage);
  }
  log(message, ...optionalParams) {
    const workerMessage = {
      message: [message, ...optionalParams],
      type: WORKERCHANNEL_MSG_TYPE,
      level: 2 /* Log */
    };
    self.postMessage(workerMessage);
  }
  trace(message, ...optionalParams) {
    const workerMessage = {
      message: [message, ...optionalParams],
      type: WORKERCHANNEL_MSG_TYPE,
      level: 0 /* Trace */
    };
    self.postMessage(workerMessage);
  }
  warn(message, ...optionalParams) {
    const workerMessage = {
      message: [message, ...optionalParams],
      type: WORKERCHANNEL_MSG_TYPE,
      level: 4 /* Warn */
    };
    self.postMessage(workerMessage);
  }
};

// src/utils/Logger/LoggerManagerImpl.ts
var LoggerManagerImpl = class {
  channel;
  m_loggers = [];
  m_levelSetForAll;
  constructor() {
    this.channel = typeof self === "undefined" || typeof self.document !== "undefined" ? new ConsoleChannel() : new WorkerChannel();
  }
  getLoggerNames() {
    return this.m_loggers.map((logger31) => logger31.name);
  }
  getLogger(name2) {
    return this.m_loggers.find((logger31) => logger31.name === name2);
  }
  create(loggerName, options = {}) {
    if (this.m_levelSetForAll !== void 0 && (options.level === void 0 || options.level < this.m_levelSetForAll)) {
      options.level = this.m_levelSetForAll;
    }
    const logger31 = new Logger(loggerName, this.channel, options);
    this.m_loggers.push(logger31);
    return logger31;
  }
  dispose(logger31) {
    const found = this.m_loggers.indexOf(logger31);
    if (found < 0) {
      throw new Error(`Cannot unregister "${logger31}" : no such logger registered.`);
    }
    this.m_loggers.splice(found, 1);
  }
  updateAll(options) {
    for (const logger31 of this.m_loggers) {
      logger31.update(options);
    }
  }
  update(loggerName, config) {
    for (const logger31 of this.m_loggers) {
      if (logger31.name === loggerName) {
        logger31.update(config);
      }
    }
  }
  enableAll(enabled) {
    for (const logger31 of this.m_loggers) {
      logger31.enabled = enabled;
    }
  }
  enable(loggerName, value2) {
    this.update(loggerName, { enabled: value2 });
  }
  setLogLevelForAll(level) {
    this.m_levelSetForAll = level;
    for (const logger31 of this.m_loggers) {
      logger31.level = level;
    }
  }
  setLogLevel(loggerName, level) {
    this.update(loggerName, { level });
  }
  setChannel(channel) {
    this.channel = channel;
  }
};

// src/utils/Logger/LoggerManager.ts
var LoggerManager = class {
  static get instance() {
    return this.m_instance || (this.m_instance = new LoggerManagerImpl());
  }
};
__publicField(LoggerManager, "m_instance");

// src/utils/LRUCache.ts
var Entry = class {
  constructor(key, value2, size, newer, older) {
    this.key = key;
    this.value = value2;
    this.size = size;
    this.newer = newer;
    this.older = older;
  }
};
var LRUCache = class {
  evictionCallback;
  canEvict;
  m_capacity;
  m_size = 0;
  m_map = /* @__PURE__ */ new Map();
  m_newest = null;
  m_oldest = null;
  m_sizeFunction;
  constructor(cacheCapacity, sizeFunction = () => 1) {
    this.m_capacity = cacheCapacity;
    this.m_sizeFunction = sizeFunction;
  }
  forEach(callbackfn, thisArg) {
    let entry = this.m_newest;
    while (entry !== null) {
      const older = entry.older;
      callbackfn.call(thisArg, entry.value, entry.key, this);
      entry = older;
    }
  }
  get size() {
    return this.m_size;
  }
  get capacity() {
    return this.m_capacity;
  }
  get map() {
    return this.m_map;
  }
  get newest() {
    return this.m_newest;
  }
  get oldest() {
    return this.m_oldest;
  }
  setCapacity(newCapacity) {
    this.m_capacity = newCapacity;
    this.evict();
  }
  setCapacityAndMeasure(newCapacity, sizeMeasure = () => 1) {
    this.m_capacity = newCapacity;
    this.m_sizeFunction = sizeMeasure;
    this.shrinkToCapacity();
  }
  shrinkToCapacity() {
    let size = 0;
    const sizeFunction = this.m_sizeFunction;
    let entry = this.m_newest;
    while (entry !== null) {
      const entrySize = sizeFunction(entry.value);
      entry.size = entrySize;
      size += entrySize;
      entry = entry.older;
    }
    this.m_size = size;
    this.evict();
  }
  set(key, value2) {
    const valueSize = this.m_sizeFunction(value2);
    let entry = this.m_map.get(key);
    if (entry !== void 0) {
      this.m_size = this.m_size - entry.size + valueSize;
      entry.value = value2;
      entry.size = valueSize;
      this.promoteEntry(entry);
      this.evict();
    } else {
      if (valueSize > this.m_capacity) {
        return;
      }
      entry = new Entry(key, value2, valueSize, null, null);
      if (this.m_map.size === 0) {
        this.m_newest = this.m_oldest = entry;
      } else {
        assert(this.m_newest !== null);
        const newest = this.m_newest;
        entry.older = this.m_newest;
        newest.newer = entry;
        this.m_newest = entry;
      }
      this.m_map.set(key, entry);
      this.m_size += valueSize;
      this.evict();
    }
  }
  get(key) {
    const entry = this.m_map.get(key);
    if (entry === void 0) {
      return void 0;
    }
    this.promoteEntry(entry);
    return entry.value;
  }
  has(key) {
    return this.m_map.has(key);
  }
  clear() {
    this.m_newest = this.m_oldest = null;
    this.m_size = 0;
    this.m_map.clear();
  }
  evictAll() {
    const cb = this.evictionCallback;
    if (cb !== void 0) {
      this.forEach((value2, key) => cb(key, value2));
    }
    this.clear();
  }
  evictSelected(selector, thisArg) {
    const cb = this.evictionCallback;
    let entry = this.m_newest;
    while (entry !== null) {
      const entryOlder = entry.older;
      if (selector.call(thisArg, entry.value, entry.key)) {
        if (cb !== void 0) {
          cb(entry.key, entry.value);
        }
        this.deleteEntry(entry);
        this.m_map.delete(entry.key);
      }
      entry = entryOlder;
    }
  }
  delete(key) {
    const entry = this.m_map.get(key);
    if (entry === void 0) {
      return false;
    }
    this.deleteEntry(entry);
    return this.m_map.delete(key);
  }
  evict() {
    while (this.m_oldest !== null && this.m_size > this.m_capacity) {
      const evicted = this.evictOldest();
      if (evicted === void 0) {
        return;
      }
    }
  }
  evictOldest() {
    assert(this.m_oldest !== null);
    const oldest = this.m_oldest;
    assert(oldest.older === null);
    let itemToRemove = oldest;
    if (this.canEvict !== void 0) {
      while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {
        if (itemToRemove.newer === null) {
          return void 0;
        }
        itemToRemove = itemToRemove.newer;
      }
    }
    if (itemToRemove === oldest) {
      this.m_oldest = itemToRemove.newer;
      if (itemToRemove.newer !== null) {
        assert(itemToRemove.newer.older === itemToRemove);
        itemToRemove.newer.older = null;
      }
    } else {
      if (itemToRemove.newer !== null) {
        assert(itemToRemove.newer.older === itemToRemove);
        itemToRemove.newer.older = itemToRemove.older;
        if (itemToRemove.older !== null) {
          itemToRemove.older.newer = itemToRemove.newer;
        }
      } else {
        return void 0;
      }
    }
    const isOk = this.m_map.delete(itemToRemove.key);
    assert(isOk === true);
    if (isOk && this.evictionCallback !== void 0) {
      this.evictionCallback(itemToRemove.key, itemToRemove.value);
    }
    this.m_size -= itemToRemove.size;
    return itemToRemove;
  }
  deleteEntry(entry) {
    if (entry === this.m_newest) {
      this.m_newest = entry.older;
    } else if (entry.newer) {
      entry.newer.older = entry.older;
    } else {
      assert(false);
    }
    if (entry === this.m_oldest) {
      this.m_oldest = entry.newer;
    } else if (entry.older) {
      entry.older.newer = entry.newer;
    } else {
      assert(false);
    }
    this.m_size -= entry.size;
  }
  promoteEntry(entry) {
    if (entry === this.m_newest) {
      return;
    }
    if (entry.newer) {
      assert(entry.newer.older === entry);
      entry.newer.older = entry.older;
    }
    if (entry.older) {
      assert(entry.older.newer === entry);
      entry.older.newer = entry.newer;
    }
    if (entry === this.m_oldest) {
      this.m_oldest = entry.newer;
    }
    entry.newer = null;
    entry.older = this.m_newest;
    assert(this.m_newest !== null);
    const newest = this.m_newest;
    assert(newest.newer === null);
    newest.newer = entry;
    this.m_newest = entry;
  }
};

// src/utils/Math2D.ts
var Math2D;
((Math2D3) => {
  class Box {
    constructor(x = 0, y = 0, w = 0, h = 0) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }
    set(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }
    copy(box) {
      this.x = box.x;
      this.y = box.y;
      this.w = box.w;
      this.h = box.h;
    }
    contains(x, y) {
      return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;
    }
    containsBox(other) {
      const xmax = other.x + other.w;
      const ymax = other.y + other.h;
      return this.contains(other.x, other.y) && this.contains(xmax, other.y) && this.contains(other.x, ymax) && this.contains(xmax, ymax);
    }
    intersects(other) {
      return this.x <= other.x + other.w && this.x + this.w >= other.x && this.y <= other.y + other.h && this.y + this.h >= other.y;
    }
  }
  Math2D3.Box = Box;
  function distSquared(ax, ay, bx, by) {
    return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
  }
  Math2D3.distSquared = distSquared;
  function computeSquaredLineLength(line) {
    let squaredLineLength = 0;
    const length = line.length - 4;
    for (let i = 0; i < length; i += 3) {
      const xDiff = line[i + 3] - line[i];
      const yDiff = line[i + 4] - line[i + 1];
      squaredLineLength += xDiff * xDiff + yDiff * yDiff;
    }
    return squaredLineLength;
  }
  Math2D3.computeSquaredLineLength = computeSquaredLineLength;
  function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {
    const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);
    if (lineLengthSuared === 0) {
      return distSquared(px, py, l0x, l0y);
    }
    let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;
    t = Math.max(0, Math.min(1, t));
    return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));
  }
  Math2D3.distToSegmentSquared = distToSegmentSquared;
  function intersectLineAndCircle(xLine1, yLine1, xLine2, yLine2, radius, xCenter = 0, yCenter = 0) {
    const epsilon3 = 1e-10;
    const dx = xLine2 - xLine1;
    const dy = yLine2 - yLine1;
    const dSq = dx * dx + dy * dy;
    const rSq = radius * radius;
    const c = xLine1 * yLine2 - xLine2 * yLine1;
    const cp = c - dy * xCenter + dx * yCenter;
    const discriminantSquared = rSq * dSq - cp * cp;
    if (discriminantSquared < -epsilon3) {
      return void 0;
    }
    const xMid = cp * dy;
    const yMid = -cp * dx;
    if (discriminantSquared < epsilon3) {
      return { x1: xCenter + xMid / dSq, y1: yCenter + yMid / dSq };
    }
    const discriminant = Math.sqrt(discriminantSquared);
    const signDy = dy < 0 ? -1 : 1;
    const absDy = Math.abs(dy);
    const xDist = signDy * dx * discriminant;
    const yDist = absDy * discriminant;
    return {
      x1: xCenter + (xMid + xDist) / dSq,
      y1: yCenter + (yMid + yDist) / dSq,
      x2: xCenter + (xMid - xDist) / dSq,
      y2: yCenter + (yMid - yDist) / dSq
    };
  }
  Math2D3.intersectLineAndCircle = intersectLineAndCircle;
  function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4, result = { x: 0, y: 0 }) {
    const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d === 0) {
      return void 0;
    }
    const px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;
    const py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;
    result.x = px;
    result.y = py;
    return result;
  }
  Math2D3.intersectLines = intersectLines;
})(Math2D || (Math2D = {}));

// src/utils/MathUtils.ts
var MathUtils6;
((MathUtils38) => {
  function clamp(value2, min, max) {
    return value2 < min ? min : value2 > max ? max : value2;
  }
  MathUtils38.clamp = clamp;
  function smoothStep(edge0, edge1, x) {
    x = clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return x * x * (3 - 2 * x);
  }
  MathUtils38.smoothStep = smoothStep;
  function smootherStep(edge0, edge1, x) {
    x = clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return x * x * x * (x * (x * 6 - 15) + 10);
  }
  MathUtils38.smootherStep = smootherStep;
  function map(val, inMin, inMax, outMin, outMax) {
    return (val - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
  }
  MathUtils38.map = map;
  function min2(a, b) {
    let result;
    if (a !== void 0) {
      result = a;
    }
    if (b !== void 0) {
      result = result === void 0 ? b : Math.min(result, b);
    }
    return result;
  }
  MathUtils38.min2 = min2;
  function max2(a, b) {
    let result;
    if (a !== void 0) {
      result = a;
    }
    if (b !== void 0) {
      result = result === void 0 ? b : Math.max(result, b);
    }
    return result;
  }
  MathUtils38.max2 = max2;
  function isClamped(value2, lowerBound, upperBound) {
    if (lowerBound !== void 0 && value2 < lowerBound) {
      return false;
    }
    if (upperBound !== void 0 && value2 > upperBound) {
      return false;
    }
    return true;
  }
  MathUtils38.isClamped = isClamped;
  function easeInOutCubic(startValue, endValue, time) {
    const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
    return startValue + (endValue - startValue) * timeValue;
  }
  MathUtils38.easeInOutCubic = easeInOutCubic;
})(MathUtils6 || (MathUtils6 = {}));

// src/utils/Mixins.ts
function applyMixinsWithoutProperties(derivedCtor, baseCtors) {
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name2) => {
      const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name2);
      if (descriptor !== void 0 && descriptor.get === void 0 && name2 !== "constructor") {
        derivedCtor.prototype[name2] = baseCtor.prototype[name2];
      }
    });
  });
}

// src/utils/ObjectUtils.ts
function pick(object, props) {
  const result = {};
  for (const propName of props) {
    if (object.hasOwnProperty(propName)) {
      result[propName] = object[propName];
    }
  }
  return result;
}

// src/utils/OptionsUtils.ts
function getOptionValue(...values) {
  for (const candidate of values) {
    if (candidate !== void 0 && candidate !== null) {
      return candidate;
    }
  }
  return void 0;
}

// src/utils/PerformanceTimer.ts
var _PerformanceTimer = class {
  static now() {
    return _PerformanceTimer.nowFunc();
  }
  static getNowFunc() {
    if (typeof performance !== "undefined" && typeof performance.now !== "undefined") {
      return () => performance.now();
    }
    return () => {
      return new Date().getTime();
    };
  }
};
var PerformanceTimer = _PerformanceTimer;
__publicField(PerformanceTimer, "instance", new _PerformanceTimer());
__publicField(PerformanceTimer, "nowFunc", _PerformanceTimer.getNowFunc());

// src/utils/SampleBilinear.ts
function sampleBilinear(texture, width, height, u, v) {
  const maxXIndex = width - 1;
  const maxYIndex = height - 1;
  const xIndex = u * maxXIndex;
  const xIndexFloor = Math.floor(xIndex);
  const yIndex = v * maxYIndex;
  const yIndexFloor = Math.floor(yIndex);
  const swIndex = yIndexFloor * width + xIndexFloor;
  const seIndex = xIndexFloor < maxXIndex ? swIndex + 1 : swIndex;
  const nwIndex = yIndexFloor < maxYIndex ? swIndex + width : swIndex;
  const neIndex = xIndexFloor < maxXIndex ? nwIndex + 1 : nwIndex;
  const swElevation = texture[swIndex];
  const seElevation = texture[seIndex];
  const nwElevation = texture[nwIndex];
  const neElevation = texture[neIndex];
  const xFrac = Number.isInteger(xIndex) ? 0 : xIndex - xIndexFloor;
  const xFracInverse = 1 - xFrac;
  const yFrac = Number.isInteger(yIndex) ? 0 : yIndex - yIndexFloor;
  const yFracInverse = 1 - yFrac;
  const result = swElevation * xFracInverse * yFracInverse + seElevation * xFrac * yFracInverse + nwElevation * xFracInverse * yFrac + neElevation * xFrac * yFrac;
  return result;
}

// src/utils/TaskQueue.ts
var TaskQueue = class {
  constructor(m_options) {
    this.m_options = m_options;
    var _a;
    (_a = this.m_options.groups) == null ? void 0 : _a.forEach((group) => {
      this.m_taskLists.set(group, []);
    });
    if (this.m_options.prioSortFn) {
      this.sort = this.m_options.prioSortFn;
    }
  }
  m_taskLists = /* @__PURE__ */ new Map();
  update(group) {
    if (group === void 0) {
      this.m_taskLists.forEach((taskList) => {
        this.updateTaskList(taskList);
      });
    } else {
      const taskList = this.getTaskList(group);
      if (taskList) {
        this.updateTaskList(taskList);
      }
    }
  }
  add(task) {
    var _a;
    if (this.m_taskLists.has(task.group)) {
      const taskList = this.m_taskLists.get(task.group);
      if (!(taskList == null ? void 0 : taskList.includes(task))) {
        (_a = this.m_taskLists.get(task.group)) == null ? void 0 : _a.push(task);
        return true;
      }
    }
    return false;
  }
  remove(task) {
    var _a, _b;
    if (this.m_taskLists.has(task.group)) {
      const index = (_a = this.m_taskLists.get(task.group)) == null ? void 0 : _a.indexOf(task);
      if (index !== -1) {
        (_b = this.m_taskLists.get(task.group)) == null ? void 0 : _b.splice(index, 1);
        return true;
      }
    }
    return false;
  }
  numItemsLeft(group) {
    var _a;
    let numLeft = 0;
    if (group === void 0) {
      this.m_taskLists.forEach((tasklist) => {
        numLeft += tasklist.length;
      });
    } else {
      numLeft += ((_a = this.getTaskList(group)) == null ? void 0 : _a.length) ?? 0;
    }
    return numLeft;
  }
  processNext(group, shouldProcess, n = 1) {
    if (!this.getTaskList(group) || this.numItemsLeft(group) <= 0) {
      return false;
    }
    for (let i = 0; i < n && this.numItemsLeft(group) > 0; i++) {
      const nextTask = this.pull(group, true);
      if (nextTask !== void 0) {
        if (!shouldProcess || (shouldProcess == null ? void 0 : shouldProcess(nextTask))) {
          nextTask.execute();
        } else {
          this.add(nextTask);
        }
      }
    }
    return true;
  }
  clear() {
    this.m_taskLists.clear();
  }
  pull(group, checkIfExpired = false) {
    var _a, _b;
    const taskList = this.getTaskList(group);
    let nextTask;
    if (taskList) {
      nextTask = (_a = this.getTaskList(group)) == null ? void 0 : _a.pop();
      if (checkIfExpired && nextTask && ((_b = nextTask.isExpired) == null ? void 0 : _b.call(nextTask))) {
        return this.pull(group, checkIfExpired);
      }
    }
    return nextTask;
  }
  sort(a, b) {
    return b.getPriority() - a.getPriority();
  }
  getTaskList(group) {
    return this.m_taskLists.get(group);
  }
  updateTaskList(taskList) {
    var _a;
    for (let i = 0; i < taskList.length; i++) {
      const task = taskList[i];
      if ((_a = task == null ? void 0 : task.isExpired) == null ? void 0 : _a.call(task)) {
        taskList.splice(i, 1);
        i--;
      }
    }
    taskList.sort(this.sort);
  }
};

// src/utils/UrlUtils.ts
function resolveReferenceUri(parentUri, childUri) {
  if (absoluteUrlWithOriginRe.test(childUri)) {
    return childUri;
  } else if (childUri.startsWith("/")) {
    const origin = getUrlOrigin(parentUri);
    return origin + childUri;
  } else {
    if (childUri.startsWith("./")) {
      childUri = childUri.substr(2);
    }
    const parentBaseUrl = baseUrl(parentUri);
    return parentBaseUrl + childUri;
  }
}
var absoluteUrlWithOriginRe = new RegExp("^(((?:[a-z]+:)?//)|(file:/)|(data:))", "i");
function baseUrl(url) {
  if (url === void 0) {
    return "./";
  }
  let idx = url.indexOf("#");
  if (idx !== -1) {
    url = url.slice(0, idx);
  }
  idx = url.indexOf("?");
  if (idx !== -1) {
    url = url.slice(0, idx);
  }
  idx = url.lastIndexOf("/");
  if (idx === -1) {
    return "./";
  } else {
    return url.substring(0, idx + 1);
  }
}
function getUrlOrigin(url) {
  if (url === void 0) {
    return "";
  }
  const parsed = getUrlHostAndProtocol(url);
  if (parsed.protocol === "file:") {
    return "file://";
  } else if (parsed.host && parsed.protocol) {
    return parsed.protocol + "//" + parsed.host;
  } else if (parsed.host) {
    return "//" + parsed.host;
  } else if (parsed.protocol) {
    return parsed.protocol + "//";
  } else {
    return "";
  }
}
function getUrlHostAndProtocol(url) {
  const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\/\/([^\/]*)/, "i");
  const match = url.match(urlOriginRe);
  if (!match) {
    throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);
  }
  return {
    protocol: match[1],
    host: match[2]
  };
}

// src/utils/UrlPlatformUtils.ts
function getAppBaseUrl() {
  if (typeof window === "undefined") {
    return `file://${process.cwd()}/`;
  }
  return baseUrl(window.location.href);
}

// src/utils/UriResolver.ts
var RelativeUriResolver = class {
  constructor(parentUri) {
    this.parentUri = parentUri;
  }
  resolveUri(uri) {
    return resolveReferenceUri(this.parentUri, uri);
  }
};
function composeUriResolvers(...resolvers) {
  return {
    resolveUri(originalUrl) {
      return resolvers.reduce((url, resolver) => {
        if (resolver !== void 0) {
          return resolver.resolveUri(url);
        } else {
          return url;
        }
      }, originalUrl);
    }
  };
}

// src/datasource-protocol/RGBA.ts
var import_three = require("three");

// src/datasource-protocol/StringEncodedNumeral.ts
var import_csscolorparser = require("csscolorparser");
var StringEncodedMeters = {
  type: 0 /* Meters */,
  size: 1,
  regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))m$/,
  decoder: (encodedValue, target) => {
    const match = StringEncodedMeters.regExp.exec(encodedValue);
    return match ? (target[0] = Number(match[1])) !== void 0 : false;
  }
};
var StringEncodedPixels = {
  type: 1 /* Pixels */,
  size: 1,
  mask: 1,
  regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/,
  decoder: (encodedValue, target) => {
    const match = StringEncodedPixels.regExp.exec(encodedValue);
    if (match === null) {
      return false;
    }
    target[0] = Number(match[1]);
    return true;
  }
};
var StringEncodedHex = {
  type: 2 /* Hex */,
  size: 4,
  regExp: /^\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,
  decoder: (encodedValue, target) => {
    const match = StringEncodedHex.regExp.exec(encodedValue);
    if (match === null) {
      return false;
    }
    const hex = match[1];
    const size = hex.length;
    assert(size === 4 || size === 8, `Matched incorrect hex color format`);
    if (size === 4) {
      target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
      target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
      target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
      target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;
    } else if (size === 8) {
      target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
      target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
      target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
      target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;
    }
    return true;
  }
};
var StringEncodedMetricFormats = [
  StringEncodedMeters,
  StringEncodedPixels
];
var StringEncodedMetricFormatMaxSize = StringEncodedMetricFormats.reduce((a, b) => Math.max(a, b.size), 0);
var StringEncodedColorFormats = [StringEncodedHex];
var StringEncodedColorFormatMaxSize = StringEncodedColorFormats.reduce((a, b) => Math.max(a, b.size), 0);
var StringEncodedNumeralFormats = [
  ...StringEncodedMetricFormats,
  ...StringEncodedColorFormats
];
var StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);
var tmpBuffer = new Array(StringEncodedNumeralFormatMaxSize);
function parseStringEncodedNumeral(numeral, pixelToMeters = 1) {
  return parseStringLiteral(numeral, StringEncodedNumeralFormats, pixelToMeters);
}
function parseStringEncodedColor(color) {
  return parseStringLiteral(color, StringEncodedColorFormats);
}
function parseStringLiteral(text, formats, pixelToMeters = 1) {
  const matchedFormat = formats.find((format) => {
    return format.decoder(text, tmpBuffer) ? true : false;
  });
  if (matchedFormat === void 0) {
    const components = (0, import_csscolorparser.parseCSSColor)(text);
    return Array.isArray(components) && !components.some((c) => isNaN(c)) ? ColorUtils.getHexFromRgba(components[0] / 255, components[1] / 255, components[2] / 255, components[3]) : void 0;
  }
  switch (matchedFormat == null ? void 0 : matchedFormat.type) {
    case 1 /* Pixels */:
      return tmpBuffer[0] * pixelToMeters;
    case 2 /* Hex */:
      return ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);
    default:
      return tmpBuffer[0];
  }
}

// src/datasource-protocol/RGBA.ts
var RGBA = class {
  constructor(r = 1, g = 1, b = 1, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  static parse(text) {
    const color = parseStringEncodedColor(text);
    if (color === void 0) {
      return void 0;
    }
    return ColorUtils.getRgbaFromHex(color);
  }
  clone() {
    return new RGBA(this.r, this.g, this.b, this.a);
  }
  getHex() {
    return ColorUtils.getHexFromRgba(this.r, this.g, this.b, this.a);
  }
  lerp(target, t) {
    this.r = import_three.MathUtils.lerp(this.r, target.r, t);
    this.g = import_three.MathUtils.lerp(this.g, target.g, t);
    this.b = import_three.MathUtils.lerp(this.b, target.b, t);
    this.a = import_three.MathUtils.lerp(this.a, target.a, t);
    return this;
  }
  toJSON() {
    return `rgba(${this.r * 255 << 0}, ${this.g * 255 << 0}, ${this.b * 255 << 0}, ${this.a})`;
  }
};

// src/datasource-protocol/ColorUtils.ts
var SHIFT_TRANSPARENCY = 24;
var SHIFT_RED = 16;
var SHIFT_GREEN = 8;
var SHIFT_BLUE = 0;
var HEX_FULL_CHANNEL = 255;
var HEX_RGB_MASK = 16777215;
var HEX_TRGB_MASK = 4294967295;
var tmpColor = new THREE6.Color();
var ColorUtils;
((ColorUtils2) => {
  function getHexFromRgba(r, g, b, a) {
    assert(a >= 0 && a <= 1);
    const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);
    return t << SHIFT_TRANSPARENCY ^ r * HEX_FULL_CHANNEL << SHIFT_RED ^ g * HEX_FULL_CHANNEL << SHIFT_GREEN ^ b * HEX_FULL_CHANNEL << SHIFT_BLUE;
  }
  ColorUtils2.getHexFromRgba = getHexFromRgba;
  function getHexFromRgb(r, g, b) {
    assert(r >= 0 && r <= 1);
    assert(g >= 0 && g <= 1);
    assert(b >= 0 && b <= 1);
    return r * HEX_FULL_CHANNEL << SHIFT_RED ^ g * HEX_FULL_CHANNEL << SHIFT_GREEN ^ b * HEX_FULL_CHANNEL << SHIFT_BLUE;
  }
  ColorUtils2.getHexFromRgb = getHexFromRgb;
  function getHexFromHsl(h, s, l) {
    assert(h >= 0 && h <= 1);
    assert(s >= 0 && s <= 1);
    assert(l >= 0 && l <= 1);
    return tmpColor.setHSL(h, s, l).getHex();
  }
  ColorUtils2.getHexFromHsl = getHexFromHsl;
  function getRgbaFromHex(hex, target = new RGBA()) {
    assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
    target.r = (hex >> SHIFT_RED & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
    target.g = (hex >> SHIFT_GREEN & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
    target.b = (hex >> SHIFT_BLUE & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
    target.a = (HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY & HEX_FULL_CHANNEL)) / HEX_FULL_CHANNEL;
    return target;
  }
  ColorUtils2.getRgbaFromHex = getRgbaFromHex;
  function hasAlphaInHex(hex) {
    assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
    return hex >> SHIFT_TRANSPARENCY !== 0;
  }
  ColorUtils2.hasAlphaInHex = hasAlphaInHex;
  function getAlphaFromHex(hex) {
    assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
    return (HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
  }
  ColorUtils2.getAlphaFromHex = getAlphaFromHex;
  function removeAlphaFromHex(hex) {
    assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
    return hex & HEX_RGB_MASK;
  }
  ColorUtils2.removeAlphaFromHex = removeAlphaFromHex;
})(ColorUtils || (ColorUtils = {}));

// src/geoutils/coordinates/GeoBoxExtentLike.ts
function isGeoBoxExtentLike(obj) {
  return obj && typeof obj === "object" && typeof obj.latitudeSpan === "number" && typeof obj.longitudeSpan === "number";
}

// src/geoutils/coordinates/GeoCoordLike.ts
function geoCoordLikeToGeoCoordinatesLike(coord) {
  return isGeoCoordinatesLike(coord) ? coord : isLatLngLike(coord) ? { latitude: coord.lat, longitude: coord.lng } : { latitude: coord[1], longitude: coord[0] };
}

// src/geoutils/coordinates/GeoPolygon.ts
var import_three2 = require("three");
function computeLonSpanAcrossGreewich(lonA, lonB) {
  return Math.max(lonA, lonB) - Math.min(lonA, lonB);
}
function isLeftToRightAntimeridianCrossing(lonStart, lonEnd) {
  return lonStart > 0 && lonEnd < 0 && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;
}
function isRightToLeftAntimeridianCrossing(lonStart, lonEnd) {
  return isLeftToRightAntimeridianCrossing(lonEnd, lonStart);
}
function isAntimeridianCrossing(lonStart, lonEnd) {
  return Math.sign(lonStart) === -Math.sign(lonEnd) && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;
}
var GeoPolygon = class {
  m_coordinates;
  constructor(coordinates, needsSort = false, needsWrapping = false) {
    this.m_coordinates = coordinates.map((coord) => {
      return geoCoordLikeToGeoCoordinatesLike(coord);
    });
    if (needsSort) {
      this.sortCCW();
    }
    if (needsWrapping) {
      this.wrapCoordinatesAround();
    }
  }
  get coordinates() {
    return this.m_coordinates;
  }
  getGeoBoundingBox() {
    const centroid = this.getCentroid();
    if (centroid === void 0) {
      return GeoBox.fromCoordinates(this.coordinates[0], this.coordinates[0]);
    }
    const { east, west } = this.getEastAndWest(centroid);
    const { north, south } = this.getNorthAndSouth();
    return GeoBox.fromCoordinates(new GeoCoordinates(south, west), new GeoCoordinates(north, east));
  }
  getCentroid() {
    const area = this.getArea();
    if (area === 0) {
      return void 0;
    }
    let latitude = 0;
    let longitude = 0;
    let f;
    let previousIndex = this.m_coordinates.length - 1;
    this.m_coordinates.forEach((coordinate, index) => {
      const previousCoordinate = this.m_coordinates[previousIndex];
      f = coordinate.latitude * previousCoordinate.longitude - previousCoordinate.latitude * coordinate.longitude;
      latitude += (coordinate.latitude + previousCoordinate.latitude) * f;
      longitude += (coordinate.longitude + previousCoordinate.longitude) * f;
      previousIndex = index;
    });
    f = area * 6;
    return new GeoCoordinates(latitude / f, area < 0 ? -180 + longitude / f : longitude / f);
  }
  sortCCW() {
    const polyCenter = this.getPolyAverageCenter();
    if (!polyCenter) {
      return;
    }
    this.m_coordinates.sort((a, b) => {
      const veca = new import_three2.Vector2(a.latitude - polyCenter.latitude, a.longitude - polyCenter.longitude).normalize();
      const vecb = new import_three2.Vector2(b.latitude - polyCenter.latitude, b.longitude - polyCenter.longitude).normalize();
      return vecb.angle() - veca.angle();
    });
  }
  wrapCoordinatesAround() {
    const firstAntimerCrossIndex = this.m_coordinates.findIndex((val, index) => {
      const prevLonIndex = index === 0 ? this.m_coordinates.length - 1 : index - 1;
      const prevLon = this.m_coordinates[prevLonIndex].longitude;
      const lon = val.longitude;
      return isLeftToRightAntimeridianCrossing(prevLon, lon);
    });
    if (firstAntimerCrossIndex < 0) {
      return;
    }
    let wrapAround = true;
    for (let i = 0; i < this.m_coordinates.length; i++) {
      const index = (firstAntimerCrossIndex + i) % this.m_coordinates.length;
      const currentLon = this.m_coordinates[index].longitude;
      const nextLon = this.m_coordinates[(index + 1) % this.m_coordinates.length].longitude;
      if (wrapAround) {
        this.m_coordinates[index].longitude += 360;
      }
      if (isRightToLeftAntimeridianCrossing(currentLon, nextLon)) {
        wrapAround = false;
      } else if (isLeftToRightAntimeridianCrossing(currentLon, nextLon)) {
        wrapAround = true;
      }
    }
  }
  getPolyAverageCenter() {
    const polySum = this.m_coordinates.reduce((prev, curr) => {
      return new GeoCoordinates(prev.latitude + curr.latitude, prev.longitude + curr.longitude);
    });
    return new GeoCoordinates(polySum.latitude / this.m_coordinates.length, polySum.longitude / this.m_coordinates.length);
  }
  getArea() {
    let area = 0;
    let previousIndex = this.m_coordinates.length - 1;
    this.m_coordinates.forEach((coordinate, index) => {
      const previousCoordinate = this.m_coordinates[previousIndex];
      area += coordinate.latitude * previousCoordinate.longitude;
      area -= coordinate.longitude * previousCoordinate.latitude;
      previousIndex = index;
    });
    return area /= 2;
  }
  getEastAndWest(center) {
    let west = center.longitude;
    let east = center.longitude;
    let previousIndex = this.m_coordinates.length - 1;
    this.m_coordinates.forEach((coordinate, index) => {
      const previousCoordinate = this.m_coordinates[previousIndex];
      previousIndex = index;
      const veca = new import_three2.Vector2(coordinate.latitude - center.latitude, coordinate.longitude - center.longitude).normalize();
      const vecb = new import_three2.Vector2(previousCoordinate.latitude - center.latitude, previousCoordinate.longitude - center.longitude).normalize();
      let ccw = Math.sign(vecb.angle() - veca.angle()) === 1;
      if (vecb.y >= 0 && veca.y < 0) {
        ccw = true;
      }
      const long = coordinate.longitude;
      if (long < center.longitude) {
        if (ccw) {
          west = Math.min(west, long);
        } else {
          east = Math.min(east, long);
        }
      } else {
        if (ccw) {
          east = Math.max(east, long);
        } else {
          west = Math.max(west, long);
        }
      }
    });
    return { east, west };
  }
  getNorthAndSouth() {
    let north = MIN_LATITUDE;
    let south = MAX_LATITUDE;
    this.m_coordinates.forEach((coordinate, index) => {
      north = Math.max(north, coordinate.latitude);
      south = Math.min(south, coordinate.latitude);
    });
    return { north, south };
  }
};

// src/geoutils/math/OrientedBox3.ts
var import_three3 = require("three");
function intersectsSlab(rayDir, p, axis, extent, t) {
  const epsilon3 = 1e-20;
  const e = axis.dot(p);
  const f = axis.dot(rayDir);
  if (Math.abs(f) < epsilon3) {
    return Math.abs(e) <= extent;
  }
  const finv = 1 / f;
  const t1 = (e + extent) * finv;
  const t2 = (e - extent) * finv;
  if (t1 > t2) {
    if (t2 > t.min) {
      t.min = t2;
    }
    if (t1 < t.max) {
      t.max = t1;
    }
  } else {
    if (t1 > t.min) {
      t.min = t1;
    }
    if (t2 < t.max) {
      t.max = t2;
    }
  }
  return t.min <= t.max && t.max >= 0;
}
var tmpVec = new import_three3.Vector3();
var tmpT = { min: -Infinity, max: Infinity };
var OrientedBox3 = class {
  position = new import_three3.Vector3();
  xAxis = new import_three3.Vector3(1, 0, 0);
  yAxis = new import_three3.Vector3(0, 1, 0);
  zAxis = new import_three3.Vector3(0, 0, 1);
  extents = new import_three3.Vector3();
  constructor(position, rotationMatrix, extents) {
    if (position !== void 0) {
      this.position.copy(position);
    }
    if (rotationMatrix !== void 0) {
      rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);
    }
    if (extents !== void 0) {
      this.extents.copy(extents);
    }
  }
  clone() {
    const newBox = new OrientedBox3();
    newBox.copy(this);
    return newBox;
  }
  copy(other) {
    this.position.copy(other.position);
    this.xAxis.copy(other.xAxis);
    this.yAxis.copy(other.yAxis);
    this.zAxis.copy(other.zAxis);
    this.extents.copy(other.extents);
  }
  getCenter(center = new import_three3.Vector3()) {
    return center.copy(this.position);
  }
  getSize(size = new import_three3.Vector3()) {
    return size.copy(this.extents).multiplyScalar(2);
  }
  getRotationMatrix(matrix = new import_three3.Matrix4()) {
    return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);
  }
  intersects(frustumOrPlanes) {
    const planes = Array.isArray(frustumOrPlanes) ? frustumOrPlanes : frustumOrPlanes.planes;
    for (const plane of planes) {
      const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) + Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) + Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);
      const d = plane.distanceToPoint(this.position);
      if (d + r < 0) {
        return false;
      }
    }
    return true;
  }
  intersectsRay(ray) {
    tmpT.min = -Infinity;
    tmpT.max = Infinity;
    tmpVec.copy(this.position).sub(ray.origin);
    if (!intersectsSlab(ray.direction, tmpVec, this.xAxis, this.extents.x, tmpT)) {
      return void 0;
    }
    if (!intersectsSlab(ray.direction, tmpVec, this.yAxis, this.extents.y, tmpT)) {
      return void 0;
    }
    if (!intersectsSlab(ray.direction, tmpVec, this.zAxis, this.extents.z, tmpT)) {
      return void 0;
    }
    return tmpT.min > 0 ? tmpT.min : tmpT.max;
  }
  contains(point) {
    const dx = point.x - this.position.x;
    const dy = point.y - this.position.y;
    const dz = point.z - this.position.z;
    const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);
    const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);
    const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);
    if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {
      return false;
    }
    return true;
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceToPointSquared(point));
  }
  distanceToPointSquared(point) {
    const d = new import_three3.Vector3();
    d.subVectors(point, this.position);
    const lengths = [
      d.dot(this.xAxis),
      d.dot(this.yAxis),
      d.dot(this.zAxis)
    ];
    let result = 0;
    for (let i = 0; i < 3; ++i) {
      const length = lengths[i];
      const extent = this.extents.getComponent(i);
      if (length < -extent) {
        const dd = extent + length;
        result += dd * dd;
      } else if (length > extent) {
        const dd = length - extent;
        result += dd * dd;
      }
    }
    return result;
  }
};

// src/geoutils/math/Vector3Like.ts
function isVector3Like(v) {
  return v && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number";
}

// src/geoutils/projection/EquirectangularProjection.ts
var THREE7 = __toESM(require("three"));
var _EquirectangularProjection = class extends Projection {
  type = 0 /* Planar */;
  getScaleFactor(_worldPoint) {
    return 1;
  }
  worldExtent(minAltitude, maxAltitude, result) {
    if (!result) {
      result = new THREE7.Box3();
    }
    result.min.x = 0;
    result.min.y = 0;
    result.min.z = minAltitude;
    result.max.x = this.unitScale;
    result.max.y = this.unitScale / 2;
    result.max.z = maxAltitude;
    return result;
  }
  projectPoint(geoPoint, result) {
    if (result === void 0) {
      result = { x: 0, y: 0, z: 0 };
    }
    result.x = (THREE7.MathUtils.degToRad(geoPoint.longitude) + Math.PI) * _EquirectangularProjection.geoToWorldScale * this.unitScale;
    result.y = (THREE7.MathUtils.degToRad(geoPoint.latitude) + Math.PI * 0.5) * _EquirectangularProjection.geoToWorldScale * this.unitScale;
    result.z = geoPoint.altitude ?? 0;
    return result;
  }
  unprojectPoint(worldPoint) {
    const geoPoint = GeoCoordinates.fromRadians(worldPoint.y * _EquirectangularProjection.worldToGeoScale / this.unitScale - Math.PI * 0.5, worldPoint.x * _EquirectangularProjection.worldToGeoScale / this.unitScale - Math.PI, worldPoint.z);
    return geoPoint;
  }
  unprojectAltitude(worldPoint) {
    return worldPoint.z;
  }
  projectBox(geoBox, result) {
    const worldCenter = this.projectPoint(new GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));
    const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;
    const sizeX = longitudeSpanInRadians * _EquirectangularProjection.geoToWorldScale;
    const sizeY = latitudeSpanInRadians * _EquirectangularProjection.geoToWorldScale;
    if (!result) {
      result = new THREE7.Box3();
    }
    if (isBox3Like(result)) {
      result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;
      result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;
      result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;
      result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;
      if (altitudeSpan !== void 0) {
        result.min.z = worldCenter.z - altitudeSpan * 0.5;
        result.max.z = worldCenter.z + altitudeSpan * 0.5;
      } else {
        result.min.z = 0;
        result.max.z = 0;
      }
    } else if (isOrientedBox3Like(result)) {
      MathUtils3.newVector3(1, 0, 0, result.xAxis);
      MathUtils3.newVector3(0, 1, 0, result.yAxis);
      MathUtils3.newVector3(0, 0, 1, result.zAxis);
      result.position.x = worldCenter.x;
      result.position.y = worldCenter.y;
      result.position.z = worldCenter.z;
      result.extents.x = sizeX * 0.5 * this.unitScale;
      result.extents.y = sizeY * 0.5 * this.unitScale;
      result.extents.z = Math.max(Number.EPSILON, (altitudeSpan ?? 0) * 0.5);
    }
    return result;
  }
  unprojectBox(worldBox) {
    const minGeo = this.unprojectPoint(worldBox.min);
    const maxGeo = this.unprojectPoint(worldBox.max);
    return GeoBox.fromCoordinates(minGeo, maxGeo);
  }
  groundDistance(worldPoint) {
    return worldPoint.z;
  }
  scalePointToSurface(worldPoint) {
    worldPoint.z = 0;
    return worldPoint;
  }
  surfaceNormal(_worldPoint, normal) {
    if (normal === void 0) {
      normal = { x: 0, y: 0, z: 1 };
    } else {
      normal.x = 0;
      normal.y = 0;
      normal.z = 1;
    }
    return normal;
  }
};
var EquirectangularProjection = _EquirectangularProjection;
__publicField(EquirectangularProjection, "geoToWorldScale", 1 / (2 * Math.PI));
__publicField(EquirectangularProjection, "worldToGeoScale", 2 * Math.PI / 1);
var normalizedEquirectangularProjection = new EquirectangularProjection(1);
var equirectangularProjection = new EquirectangularProjection(EarthConstants.EQUATORIAL_CIRCUMFERENCE);

// src/geoutils/projection/TransverseMercatorProjection.ts
var THREE8 = __toESM(require("three"));
var TransverseMercatorProjection = class extends Projection {
  constructor(unitScale) {
    super(unitScale);
    this.unitScale = unitScale;
  }
  static clampGeoPoint(geoPoint, _unitScale) {
    const lat = geoPoint.latitude;
    const lon = geoPoint.longitude;
    const r = TransverseMercatorUtils.POLE_RADIUS;
    const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;
    const nearestQuarter = Math.round(lon / 90);
    const deltaLon = nearestQuarter * 90 - lon;
    if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {
      return geoPoint;
    }
    const deltaLat = lat - 0;
    const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;
    if (distanceToPoleSq < rsq) {
      const distanceToPole = Math.sqrt(distanceToPoleSq);
      const scale = (r - distanceToPole) / distanceToPole;
      const dir = 1;
      const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;
      return new GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);
    }
    return geoPoint;
  }
  type = 0 /* Planar */;
  m_phi0 = 0;
  m_lambda0 = 0;
  getScaleFactor(worldPoint) {
    return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);
  }
  worldExtent(minAltitude, maxAltitude, result) {
    if (!result) {
      result = new THREE8.Box3();
    }
    result.min.x = 0;
    result.min.y = 0;
    result.min.z = minAltitude;
    result.max.x = this.unitScale;
    result.max.y = this.unitScale;
    result.max.z = maxAltitude;
    return result;
  }
  projectPoint(geoPoint, result) {
    if (!result) {
      result = { x: 0, y: 0, z: 0 };
    }
    const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);
    const normalLon = clamped.longitude / 360 + 0.5;
    const offset = normalLon === 1 ? 0 : Math.floor(normalLon);
    const phi = THREE8.MathUtils.degToRad(clamped.latitude);
    const lambda = THREE8.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;
    const B = Math.cos(phi) * Math.sin(lambda);
    result.x = Math.atanh(B);
    result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;
    const outScale = 0.5 / Math.PI;
    result.x = this.unitScale * (THREE8.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);
    result.y = this.unitScale * THREE8.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);
    result.z = geoPoint.altitude ?? 0;
    return result;
  }
  unprojectPoint(worldPoint) {
    const tau = Math.PI * 2;
    const nx = worldPoint.x / this.unitScale;
    const ny = worldPoint.y / this.unitScale;
    const offset = nx === 1 ? 0 : Math.floor(nx);
    const x = tau * (nx - 0.5 - offset);
    const y = tau * (ny - 0.5);
    const z = worldPoint.z || 0;
    const D = y + this.m_phi0;
    const phi = Math.asin(Math.sin(D) / Math.cosh(x));
    const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;
    const geoPoint = GeoCoordinates.fromRadians(phi, lambda, z);
    return geoPoint;
  }
  projectBox(geoBox, result) {
    const { north, south, east, west } = geoBox;
    const pointsToCheck = [
      geoBox.center,
      geoBox.northEast,
      geoBox.southWest,
      new GeoCoordinates(south, east),
      new GeoCoordinates(north, west)
    ];
    const E = TransverseMercatorUtils.POLE_EDGE_DEG;
    const containsWestCut = west < -90 && east > -90;
    const containsEastCut = west < 90 && east > 90;
    const containsCenterX = west < 0 && east > 0;
    const containsCenterY = west < E && east > -E && north > 0 && south < 0;
    if (containsWestCut) {
      pointsToCheck.push(new GeoCoordinates(north, -90));
      pointsToCheck.push(new GeoCoordinates(south, -90));
    }
    if (containsEastCut) {
      pointsToCheck.push(new GeoCoordinates(north, 90));
      pointsToCheck.push(new GeoCoordinates(south, 90));
    }
    if (containsCenterX) {
      pointsToCheck.push(new GeoCoordinates(north, 0));
      pointsToCheck.push(new GeoCoordinates(south, 0));
    }
    if (containsCenterY) {
      pointsToCheck.push(new GeoCoordinates(0, west));
      pointsToCheck.push(new GeoCoordinates(0, east));
    }
    TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);
    const projected = pointsToCheck.map((p) => this.projectPoint(p));
    const vx = projected.map((p) => p.x);
    const vy = projected.map((p) => p.y);
    const vz = projected.map((p) => p.z);
    const minX = Math.min(...vx);
    const minY = Math.min(...vy);
    const minZ = Math.min(...vz);
    const maxX = Math.max(...vx);
    const maxY = Math.max(...vy);
    const maxZ = Math.max(...vz);
    if (!result) {
      result = new THREE8.Box3();
    }
    if (isBox3Like(result)) {
      result.min.x = minX;
      result.min.y = minY;
      result.min.z = minZ;
      result.max.x = maxX;
      result.max.y = maxY;
      result.max.z = maxZ;
    } else if (isOrientedBox3Like(result)) {
      MathUtils3.newVector3(1, 0, 0, result.xAxis);
      MathUtils3.newVector3(0, 1, 0, result.yAxis);
      MathUtils3.newVector3(0, 0, 1, result.zAxis);
      result.position.x = (minX + maxX) / 2;
      result.position.y = (minY + maxY) / 2;
      result.position.z = (minZ + maxZ) / 2;
      result.extents.x = (maxX - minX) / 2;
      result.extents.y = (maxY - minY) / 2;
      result.extents.z = (maxZ - minZ) / 2;
    } else {
      throw new Error("invalid bounding box");
    }
    return result;
  }
  unprojectBox(worldBox) {
    const s = this.unitScale;
    const min = worldBox.min;
    const max = worldBox.max;
    const pointsToCheck = [
      { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },
      min,
      max,
      { x: min.x, y: max.y, z: 0 },
      { x: max.x, y: min.y, z: 0 }
    ];
    const center = 0.5 * s;
    const lowerQ = 0.25 * s;
    const upperQ = 0.75 * s;
    const containsCenterX = min.x < center && max.x > center;
    const containsCenterY = min.y < center && max.y > center;
    const containsLowerQY = min.y < lowerQ && max.y > lowerQ;
    const containsUpperQY = min.y < upperQ && max.y > upperQ;
    if (containsCenterY) {
      pointsToCheck.push({ x: min.x, y: center, z: 0 });
      pointsToCheck.push({ x: max.x, y: center, z: 0 });
      if (containsCenterX) {
        pointsToCheck.push({ x: center, y: center, z: 0 });
      }
    }
    if (containsLowerQY) {
      pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });
      pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });
      if (containsCenterX) {
        pointsToCheck.push({ x: center, y: lowerQ, z: 0 });
      }
    }
    if (containsUpperQY) {
      pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });
      pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });
      if (containsCenterX) {
        pointsToCheck.push({ x: center, y: upperQ, z: 0 });
      }
    }
    const geoPoints = pointsToCheck.map((p) => this.unprojectPoint(p));
    TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);
    const latitudes = geoPoints.map((g) => g.latitude);
    const longitudes = geoPoints.filter((g) => Math.abs(g.latitude) < 90).map((g) => g.longitude);
    const altitudes = geoPoints.map((g) => g.altitude ?? 0);
    const minGeo = new GeoCoordinates(Math.min(...latitudes), Math.min(...longitudes), Math.min(...altitudes));
    const maxGeo = new GeoCoordinates(Math.max(...latitudes), Math.max(...longitudes), Math.max(...altitudes));
    const geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);
    return geoBox;
  }
  unprojectAltitude(worldPoint) {
    return worldPoint.z;
  }
  groundDistance(worldPoint) {
    return worldPoint.z;
  }
  scalePointToSurface(worldPoint) {
    worldPoint.z = 0;
    return worldPoint;
  }
  surfaceNormal(_worldPoint, normal) {
    if (normal === void 0) {
      normal = { x: 0, y: 0, z: -1 };
    } else {
      normal.x = 0;
      normal.y = 0;
      normal.z = -1;
    }
    return normal;
  }
};
var _TransverseMercatorUtils = class {
  static alignLatitude(points, referencePoint) {
    const EPSILON = 1e-9;
    for (const point of points) {
      if (point.latitude === 0) {
        point.latitude = referencePoint.latitude * EPSILON;
      }
    }
  }
  static alignLongitude(points, referencePoint) {
    const bad = referencePoint.longitude < 0 ? 180 : -180;
    const good = referencePoint.longitude < 0 ? -180 : 180;
    for (const point of points) {
      if (point.longitude === bad) {
        point.longitude = good;
      }
    }
  }
};
var TransverseMercatorUtils = _TransverseMercatorUtils;
__publicField(TransverseMercatorUtils, "POLE_EDGE", 1.4844222297453322);
__publicField(TransverseMercatorUtils, "POLE_EDGE_DEG", THREE8.MathUtils.radToDeg(_TransverseMercatorUtils.POLE_EDGE));
__publicField(TransverseMercatorUtils, "POLE_RADIUS", 90 - _TransverseMercatorUtils.POLE_EDGE_DEG);
__publicField(TransverseMercatorUtils, "POLE_RADIUS_SQ", Math.pow(_TransverseMercatorUtils.POLE_RADIUS, 2));
var transverseMercatorProjection = new TransverseMercatorProjection(EarthConstants.EQUATORIAL_CIRCUMFERENCE);

// src/geoutils/tiling/QuadTreeSubdivisionScheme.ts
var QuadTreeSubdivisionScheme = class {
  getSubdivisionX() {
    return 2;
  }
  getSubdivisionY() {
    return 2;
  }
  getLevelDimensionX(level) {
    return 1 << level;
  }
  getLevelDimensionY(level) {
    return 1 << level;
  }
};
var quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();

// src/geoutils/tiling/FlatTileBoundingBoxGenerator.ts
var THREE9 = __toESM(require("three"));
var FlatTileBoundingBoxGenerator = class {
  constructor(tilingScheme, minElevation = 0, maxElevation = 0) {
    this.tilingScheme = tilingScheme;
    this.minElevation = minElevation;
    this.maxElevation = maxElevation;
    this.m_tilingScheme = tilingScheme;
    this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);
    const { min, max } = this.m_worldBox;
    this.m_worldDimensions = {
      x: max.x - min.x,
      y: max.y - min.y,
      z: max.z - min.z
    };
  }
  m_tilingScheme;
  m_worldDimensions;
  m_worldBox;
  get projection() {
    return this.m_tilingScheme.projection;
  }
  get subdivisionScheme() {
    return this.m_tilingScheme.subdivisionScheme;
  }
  getWorldBox(tileKey, result) {
    const level = tileKey.level;
    const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);
    const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);
    const sizeX = this.m_worldDimensions.x / levelDimensionX;
    const sizeY = this.m_worldDimensions.y / levelDimensionY;
    const originX = this.m_worldBox.min.x + sizeX * tileKey.column;
    const originY = this.m_worldBox.min.y + sizeY * tileKey.row;
    if (!result) {
      result = new THREE9.Box3();
    }
    result.min.x = originX;
    result.min.y = originY;
    result.min.z = this.m_worldBox.min.z;
    result.max.x = originX + sizeX;
    result.max.y = originY + sizeY;
    result.max.z = this.m_worldBox.max.z;
    return result;
  }
  getGeoBox(tileKey) {
    const worldBox = this.getWorldBox(tileKey);
    return this.projection.unprojectBox(worldBox);
  }
};

// src/geoutils/tiling/TileKey.ts
var powerOfTwo = [
  1,
  2,
  4,
  8,
  16,
  32,
  64,
  128,
  256,
  512,
  1024,
  2048,
  4096,
  8192,
  16384,
  32768,
  65536,
  131072,
  262144,
  524288,
  1048576,
  2097152,
  4194304,
  8388608,
  16777216,
  33554432,
  67108864,
  134217728,
  268435456,
  536870912,
  1073741824,
  2147483648,
  4294967296,
  8589934592,
  17179869184,
  34359738368,
  68719476736,
  137438953472,
  274877906944,
  549755813888,
  1099511627776,
  2199023255552,
  4398046511104,
  8796093022208,
  17592186044416,
  35184372088832,
  70368744177664,
  140737488355328,
  281474976710656,
  562949953421312,
  1125899906842624,
  2251799813685248,
  4503599627370496
];
var TileKey = class {
  constructor(row, column, level) {
    this.row = row;
    this.column = column;
    this.level = level;
  }
  static fromRowColumnLevel(row, column, level) {
    return new TileKey(row, column, level);
  }
  static fromQuadKey(quadkey) {
    const level = quadkey.length;
    let row = 0;
    let column = 0;
    for (let i = 0; i < quadkey.length; ++i) {
      const mask = 1 << i;
      const d = parseInt(quadkey.charAt(level - i - 1), 10);
      if (d & 1) {
        column |= mask;
      }
      if (d & 2) {
        row |= mask;
      }
    }
    return TileKey.fromRowColumnLevel(row, column, level);
  }
  static fromMortonCode(quadKey64) {
    let level = 0;
    let row = 0;
    let column = 0;
    let quadKey = quadKey64;
    while (quadKey > 1) {
      const mask = 1 << level;
      if (quadKey & 1) {
        column |= mask;
      }
      if (quadKey & 2) {
        row |= mask;
      }
      level++;
      quadKey = (quadKey - (quadKey & 3)) / 4;
    }
    const result = TileKey.fromRowColumnLevel(row, column, level);
    result.m_mortonCode = quadKey64;
    return result;
  }
  static fromHereTile(quadkey64) {
    const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));
    result.m_hereTile = quadkey64;
    return result;
  }
  static columnsAtLevel(level) {
    return Math.pow(2, level);
  }
  static rowsAtLevel(level) {
    return Math.pow(2, level);
  }
  static atCoords(level, coordX, coordY, totalWidth, totalHeight) {
    return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);
  }
  static parentMortonCode(mortonCode) {
    return Math.floor(mortonCode / 4);
  }
  m_mortonCode;
  m_hereTile;
  parent() {
    if (this.level === 0) {
      throw new Error("Cannot get the parent of the root tile key");
    }
    return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);
  }
  changedLevelBy(delta) {
    const level = Math.max(0, this.level + delta);
    let row = this.row;
    let column = this.column;
    if (delta >= 0) {
      row <<= delta;
      column <<= delta;
    } else {
      row >>>= -delta;
      column >>>= -delta;
    }
    return TileKey.fromRowColumnLevel(row, column, level);
  }
  changedLevelTo(level) {
    return this.changedLevelBy(level - this.level);
  }
  mortonCode() {
    if (this.m_mortonCode === void 0) {
      let column = this.column;
      let row = this.row;
      let result = powerOfTwo[this.level << 1];
      for (let i = 0; i < this.level; ++i) {
        if (column & 1) {
          result += powerOfTwo[2 * i];
        }
        if (row & 1) {
          result += powerOfTwo[2 * i + 1];
        }
        column >>>= 1;
        row >>>= 1;
      }
      this.m_mortonCode = result;
    }
    return this.m_mortonCode;
  }
  toHereTile() {
    if (this.m_hereTile === void 0) {
      this.m_hereTile = this.mortonCode().toString();
    }
    return this.m_hereTile;
  }
  toQuadKey() {
    let result = "";
    for (let i = this.level; i > 0; --i) {
      const mask = 1 << i - 1;
      const col = (this.column & mask) !== 0;
      const row = (this.row & mask) !== 0;
      if (col && row) {
        result += "3";
      } else if (row) {
        result += "2";
      } else if (col) {
        result += "1";
      } else {
        result += "0";
      }
    }
    return result;
  }
  equals(qnr) {
    return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;
  }
  addedSubKey(sub) {
    const subQuad = TileKey.fromQuadKey(sub.length === 0 ? "-" : sub);
    const child = this.changedLevelBy(subQuad.level);
    return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
  }
  addedSubHereTile(sub) {
    const subQuad = TileKey.fromHereTile(sub);
    const child = this.changedLevelBy(subQuad.level);
    return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
  }
  getSubHereTile(delta) {
    const key = this.mortonCode();
    const msb = 1 << delta * 2;
    const mask = msb - 1;
    const result = key & mask | msb;
    return result.toString();
  }
  rowCount() {
    return TileKey.rowsAtLevel(this.level);
  }
  columnCount() {
    return TileKey.columnsAtLevel(this.level);
  }
};

// src/geoutils/tiling/TileKeyUtils.ts
var powerOfTwo2 = (() => {
  let val = 0.5;
  return new Array(53).fill(0).map(() => val *= 2);
})();
var TileKeyUtils;
((TileKeyUtils2) => {
  function geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {
    const projection = tilingScheme.projection;
    const worldPoint = projection.projectPoint(geoPoint);
    return worldCoordinatesToTileKey(tilingScheme, worldPoint, level);
  }
  TileKeyUtils2.geoCoordinatesToTileKey = geoCoordinatesToTileKey;
  function worldCoordinatesToTileKey(tilingScheme, worldPoint, level) {
    const projection = tilingScheme.projection;
    const subdivisionScheme = tilingScheme.subdivisionScheme;
    const cx = subdivisionScheme.getLevelDimensionX(level);
    const cy = subdivisionScheme.getLevelDimensionY(level);
    const { min, max } = projection.worldExtent(0, 0);
    const worldSizeX = max.x - min.x;
    const worldSizeY = max.y - min.y;
    if (worldPoint.x < min.x || worldPoint.x > max.x) {
      return null;
    }
    if (worldPoint.y < min.y || worldPoint.y > max.y) {
      return null;
    }
    const column = Math.min(cx - 1, Math.floor(cx * (worldPoint.x - min.x) / worldSizeX));
    const row = Math.min(cy - 1, Math.floor(cy * (worldPoint.y - min.y) / worldSizeY));
    return TileKey.fromRowColumnLevel(row, column, level);
  }
  TileKeyUtils2.worldCoordinatesToTileKey = worldCoordinatesToTileKey;
  function geoRectangleToTileKeys(tilingScheme, geoBox, level) {
    const wrap = (value2, lower, upper) => {
      if (value2 < lower) {
        return upper - (lower - value2) % (upper - lower);
      }
      return lower + (value2 - lower) % (upper - lower);
    };
    const clamp = (x, minVal, maxVal) => {
      return Math.min(Math.max(x, minVal), maxVal);
    };
    const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);
    const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
    const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);
    const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
    const minTileKey = TileKeyUtils2.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);
    const maxTileKey = TileKeyUtils2.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);
    const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);
    if (!minTileKey || !maxTileKey) {
      throw new Error("Invalid coordinates");
    }
    const minColumn = minTileKey.column;
    let maxColumn = maxTileKey.column;
    if (southWestLongitude > northEastLongitude) {
      if (maxColumn !== minColumn) {
        maxColumn += columnCount;
      } else {
        maxColumn += columnCount - 1;
      }
    }
    const minRow = Math.min(minTileKey.row, maxTileKey.row);
    const maxRow = Math.max(minTileKey.row, maxTileKey.row);
    const keys = new Array();
    for (let row = minRow; row <= maxRow; ++row) {
      for (let column = minColumn; column <= maxColumn; ++column) {
        keys.push(TileKey.fromRowColumnLevel(row, column % columnCount, level));
      }
    }
    return keys;
  }
  TileKeyUtils2.geoRectangleToTileKeys = geoRectangleToTileKeys;
  function getKeyForTileKeyAndOffset(tileKey, offset, bitshift = 4) {
    const shiftedOffset = getShiftedOffset(offset, bitshift);
    return tileKey.mortonCode() + shiftedOffset;
  }
  TileKeyUtils2.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;
  function extractOffsetAndMortonKeyFromKey(key, bitshift = 4) {
    let offset = 0;
    let mortonCode = key;
    let i = 0;
    for (; i < bitshift; i++) {
      const num = powerOfTwo2[52 - i];
      if (mortonCode >= num) {
        mortonCode -= num;
        offset += powerOfTwo2[bitshift - 1 - i];
      }
    }
    offset -= powerOfTwo2[bitshift - 1];
    return { offset, mortonCode };
  }
  TileKeyUtils2.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;
  function getParentKeyFromKey(calculatedKey, bitshift = 4) {
    const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);
    const parentTileKey = TileKey.fromMortonCode(TileKey.parentMortonCode(mortonCode));
    return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);
  }
  TileKeyUtils2.getParentKeyFromKey = getParentKeyFromKey;
  function getShiftedOffset(offset, offsetBits = 4) {
    let result = 0;
    const totalOffsetsToStore = powerOfTwo2[offsetBits];
    offset += totalOffsetsToStore / 2;
    while (offset < 0) {
      offset += totalOffsetsToStore;
    }
    while (offset >= totalOffsetsToStore) {
      offset -= totalOffsetsToStore;
    }
    for (let i = 0; i < offsetBits && offset > 0; i++) {
      if (offset & 1) {
        result += powerOfTwo2[53 - offsetBits + i];
      }
      offset >>>= 1;
    }
    return result;
  }
})(TileKeyUtils || (TileKeyUtils = {}));

// src/geoutils/tiling/SubTiles.ts
var SubTiles = class {
  constructor(tileKey, sizeX, sizeY) {
    this.tileKey = tileKey;
    this.sizeX = sizeX;
    this.sizeY = sizeY;
  }
  [Symbol.iterator]() {
    return this.sizeX === 2 && this.sizeY === 2 ? SubTiles.ZCurveIterator(this.tileKey) : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);
  }
};
((SubTiles2) => {
  function* RowColumnIterator(parentKey, sizeX, sizeY) {
    for (let y = 0; y < sizeY; y++) {
      for (let x = 0; x < sizeX; x++) {
        yield TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);
      }
    }
  }
  SubTiles2.RowColumnIterator = RowColumnIterator;
  function* ZCurveIterator(parentKey) {
    for (let i = 0; i < 4; i++) {
      yield TileKey.fromRowColumnLevel(parentKey.row << 1 | i >> 1, parentKey.column << 1 | i & 1, parentKey.level + 1);
    }
  }
  SubTiles2.ZCurveIterator = ZCurveIterator;
})(SubTiles || (SubTiles = {}));

// src/geoutils/tiling/TileTreeTraverse.ts
var TileTreeTraverse = class {
  m_subdivisionScheme;
  constructor(subdivisionScheme) {
    this.m_subdivisionScheme = subdivisionScheme;
  }
  subTiles(tileKey) {
    const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);
    const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);
    return new SubTiles(tileKey, divX, divY);
  }
};

// src/geoutils/tiling/TilingScheme.ts
var TilingScheme = class {
  constructor(subdivisionScheme, projection) {
    this.subdivisionScheme = subdivisionScheme;
    this.projection = projection;
    this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator(this);
    this.tileTreeTraverse = new TileTreeTraverse(subdivisionScheme);
  }
  boundingBoxGenerator;
  tileTreeTraverse;
  getSubTileKeys(tileKey) {
    return this.tileTreeTraverse.subTiles(tileKey);
  }
  getTileKey(geoPoint, level) {
    return TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);
  }
  getTileKeys(geoBox, level) {
    return TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);
  }
  getGeoBox(tileKey) {
    return this.boundingBoxGenerator.getGeoBox(tileKey);
  }
  getWorldBox(tileKey, result) {
    return this.boundingBoxGenerator.getWorldBox(tileKey, result);
  }
};

// src/geoutils/tiling/PolarTilingScheme.ts
var polarTilingScheme = new TilingScheme(quadTreeSubdivisionScheme, transverseMercatorProjection);

// src/geoutils/tiling/WebMercatorTilingScheme.ts
var webMercatorTilingScheme = new TilingScheme(quadTreeSubdivisionScheme, webMercatorProjection);

// src/datasource-protocol/Expr.ts
var THREE14 = __toESM(require("three"));

// src/datasource-protocol/ExprEvaluator.ts
var THREE13 = __toESM(require("three"));

// src/datasource-protocol/operators/ArrayOperators.ts
var VALID_ELEMENT_TYPES = ["boolean", "number", "string"];
function checkElementTypes(arg, array) {
  if (!(arg instanceof StringLiteralExpr) || !VALID_ELEMENT_TYPES.includes(arg.value)) {
    throw new Error(`expected "boolean", "number" or "string" instead of '${JSON.stringify(arg)}'`);
  }
  const ty = arg.value;
  array.forEach((element, index) => {
    if (typeof element !== ty) {
      throw new Error(`expected array element at index ${index} to have type '${ty}'`);
    }
  });
}
function checkArrayLength(arg, array) {
  if (!(arg instanceof NumberLiteralExpr)) {
    throw new Error(`missing expected number of elements`);
  }
  const length = arg.value;
  if (array.length !== length) {
    throw new Error(`the array must have ${length} element(s)`);
  }
}
function checkArray(context2, arg) {
  const value2 = context2.evaluate(arg);
  if (!Array.isArray(value2)) {
    throw new Error(`'${value2}' is not an array`);
  }
  return value2;
}
var operators = {
  array: {
    call: (context2, call) => {
      switch (call.args.length) {
        case 0:
          throw new Error("not enough arguments");
        case 1:
          return checkArray(context2, call.args[0]);
        case 2: {
          const array = checkArray(context2, call.args[1]);
          checkElementTypes(call.args[0], array);
          return array;
        }
        case 3: {
          const array = checkArray(context2, call.args[2]);
          checkArrayLength(call.args[1], array);
          checkElementTypes(call.args[0], array);
          return array;
        }
        default:
          throw new Error("too many arguments");
      }
    }
  },
  "make-array": {
    call: (context2, call) => {
      if (call.args.length === 0) {
        throw new Error("not enough arguments");
      }
      return [...call.args.map((arg) => context2.evaluate(arg))];
    }
  },
  at: {
    call: (context2, call) => {
      const args = call.args;
      const index = context2.evaluate(args[0]);
      if (typeof index !== "number") {
        throw new Error(`expected the index of the element to retrieve`);
      }
      const value2 = context2.evaluate(args[1]);
      if (!Array.isArray(value2)) {
        throw new Error(`expected an array`);
      }
      return index >= 0 && index < value2.length ? value2[index] : null;
    }
  },
  slice: {
    call: (context2, call) => {
      if (call.args.length < 2) {
        throw new Error("not enough arguments");
      }
      const input = context2.evaluate(call.args[0]);
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new Error("input must be a string or an array");
      }
      const start = context2.evaluate(call.args[1]);
      if (typeof start !== "number") {
        throw new Error("expected an index");
      }
      let end;
      if (call.args.length > 2) {
        end = context2.evaluate(call.args[2]);
        if (typeof end !== "number") {
          throw new Error("expected an index");
        }
      }
      return input.slice(start, end);
    }
  }
};
var ArrayOperators = operators;

// src/datasource-protocol/operators/CastOperators.ts
var operators2 = {
  "to-boolean": {
    call: (context2, call) => {
      return Boolean(context2.evaluate(call.args[0]));
    }
  },
  "to-string": {
    call: (context2, call) => {
      return String(context2.evaluate(call.args[0]));
    }
  },
  "to-number": {
    call: (context2, call) => {
      for (const arg of call.args) {
        const value2 = Number(context2.evaluate(arg));
        if (!isNaN(value2)) {
          return value2;
        }
      }
      throw new Error("cannot convert the value to a number");
    }
  }
};
var CastOperators = operators2;

// src/datasource-protocol/operators/ColorOperators.ts
var THREE10 = __toESM(require("three"));
var operators3 = {
  alpha: {
    call: (context2, call) => {
      let color = context2.evaluate(call.args[0]);
      if (typeof color === "string") {
        color = parseStringEncodedColor(color);
      }
      const alpha = typeof color === "number" ? ColorUtils.getAlphaFromHex(color) : 1;
      return alpha;
    }
  },
  rgba: {
    call: (context2, call) => {
      const r = context2.evaluate(call.args[0]);
      const g = context2.evaluate(call.args[1]);
      const b = context2.evaluate(call.args[2]);
      const a = context2.evaluate(call.args[3]);
      if (typeof r === "number" && typeof g === "number" && typeof b === "number" && typeof a === "number" && r >= 0 && g >= 0 && b >= 0 && a >= 0 && a <= 1) {
        return rgbaToHex(r, g, b, a);
      }
      throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);
    }
  },
  rgb: {
    call: (context2, call) => {
      const r = context2.evaluate(call.args[0]);
      const g = context2.evaluate(call.args[1]);
      const b = context2.evaluate(call.args[2]);
      if (typeof r === "number" && typeof g === "number" && typeof b === "number" && r >= 0 && g >= 0 && b >= 0) {
        return rgbToHex(r, g, b);
      }
      throw new Error(`unknown color 'rgb(${r},${g},${b})'`);
    }
  },
  hsl: {
    call: (context2, call) => {
      const h = context2.evaluate(call.args[0]);
      const s = context2.evaluate(call.args[1]);
      const l = context2.evaluate(call.args[2]);
      if (typeof h === "number" && typeof s === "number" && typeof l === "number" && h >= 0 && s >= 0 && l >= 0) {
        return hslToHex(h, s, l);
      }
      throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);
    }
  }
};
function rgbaToHex(r, g, b, a) {
  return ColorUtils.getHexFromRgba(THREE10.MathUtils.clamp(r, 0, 255) / 255, THREE10.MathUtils.clamp(g, 0, 255) / 255, THREE10.MathUtils.clamp(b, 0, 255) / 255, THREE10.MathUtils.clamp(a, 0, 1));
}
function rgbToHex(r, g, b) {
  return ColorUtils.getHexFromRgb(THREE10.MathUtils.clamp(r, 0, 255) / 255, THREE10.MathUtils.clamp(g, 0, 255) / 255, THREE10.MathUtils.clamp(b, 0, 255) / 255);
}
function hslToHex(h, s, l) {
  return ColorUtils.getHexFromHsl(THREE10.MathUtils.euclideanModulo(h, 360) / 360, THREE10.MathUtils.clamp(s, 0, 100) / 100, THREE10.MathUtils.clamp(l, 0, 100) / 100);
}
var ColorOperators = operators3;

// src/datasource-protocol/operators/ComparisonOperators.ts
function compare(context2, call, strict = false) {
  const left = context2.evaluate(call.args[0]);
  const right = context2.evaluate(call.args[1]);
  if (!(typeof left === "number" && typeof right === "number" || typeof left === "string" && typeof right === "string")) {
    if (strict) {
      throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);
    }
  }
  switch (call.op) {
    case "<":
      return left < right;
    case ">":
      return left > right;
    case "<=":
      return left <= right;
    case ">=":
      return left >= right;
    default:
      throw new Error(`invalid comparison operator '${call.op}'`);
  }
}
var operators4 = {
  "!": {
    call: (context2, call) => {
      return !context2.evaluate(call.args[0]);
    }
  },
  "==": {
    call: (context2, call) => {
      const left = context2.evaluate(call.args[0]);
      const right = context2.evaluate(call.args[1]);
      return left === right;
    }
  },
  "!=": {
    call: (context2, call) => {
      const left = context2.evaluate(call.args[0]);
      const right = context2.evaluate(call.args[1]);
      return left !== right;
    }
  },
  "<": {
    call: (context2, call) => compare(context2, call)
  },
  ">": {
    call: (context2, call) => compare(context2, call)
  },
  "<=": {
    call: (context2, call) => compare(context2, call)
  },
  ">=": {
    call: (context2, call) => compare(context2, call)
  }
};
var ComparisonOperators = operators4;

// src/datasource-protocol/Env.ts
var Env = class {
  static isEnv(object) {
    return object instanceof Env;
  }
  lookup(name2) {
    return void 0;
  }
  unmap() {
    return {};
  }
};
var MapEnv = class extends Env {
  constructor(entries, parent) {
    super();
    this.entries = entries;
    this.parent = parent;
  }
  lookup(name2) {
    if (this.entries.hasOwnProperty(name2)) {
      const value2 = this.entries[name2];
      if (value2 !== void 0) {
        return value2;
      }
    }
    return this.parent ? this.parent.lookup(name2) : void 0;
  }
  unmap() {
    const obj = this.parent ? this.parent.unmap() : {};
    for (const key in this.entries) {
      if (this.entries.hasOwnProperty(key)) {
        obj[key] = this.entries[key];
      }
    }
    return obj;
  }
};

// src/datasource-protocol/operators/FeatureOperators.ts
var operators5 = {
  "geometry-type": {
    call: (context2, call) => {
      const geometryType = context2.env.lookup("$geometryType");
      switch (geometryType) {
        case "point":
          return "Point";
        case "line":
          return "LineString";
        case "polygon":
          return "Polygon";
        default:
          return null;
      }
    }
  },
  "feature-state": {
    isDynamicOperator: () => true,
    call: (context2, call) => {
      if (context2.scope !== 2 /* Dynamic */) {
        throw new Error("feature-state cannot be used in this context");
      }
      const property = context2.evaluate(call.args[0]);
      if (typeof property !== "string") {
        throw new Error(`expected the name of the property of the feature state`);
      }
      const state = context2.env.lookup("$state");
      if (Env.isEnv(state)) {
        return state.lookup(property) ?? null;
      } else if (state instanceof Map) {
        return state.get(property) ?? null;
      }
      return null;
    }
  },
  id: {
    call: (context2, call) => {
      return context2.env.lookup("$id") ?? null;
    }
  }
};
var FeatureOperators = operators5;

// src/datasource-protocol/operators/FlowOperators.ts
function conditionalCast(context2, type, args) {
  switch (type) {
    case "boolean":
    case "number":
    case "string":
      for (const childExpr of args) {
        const value2 = context2.evaluate(childExpr);
        if (typeof value2 === type) {
          return value2;
        }
      }
      throw new Error(`expected a '${type}'`);
    default:
      throw new Error(`invalid type '${type}'`);
  }
}
var operators6 = {
  all: {
    call: (context2, call) => {
      for (const childExpr of call.args) {
        if (!context2.evaluate(childExpr)) {
          return false;
        }
      }
      return true;
    }
  },
  any: {
    call: (context2, call) => {
      for (const childExpr of call.args) {
        if (context2.evaluate(childExpr)) {
          return true;
        }
      }
      return false;
    }
  },
  none: {
    call: (context2, call) => {
      for (const childExpr of call.args) {
        if (context2.evaluate(childExpr)) {
          return false;
        }
      }
      return true;
    }
  },
  boolean: {
    call: (context2, call) => {
      return conditionalCast(context2, "boolean", call.args);
    }
  },
  number: {
    call: (context2, call) => {
      return conditionalCast(context2, "number", call.args);
    }
  },
  string: {
    call: (context2, call) => {
      return conditionalCast(context2, "string", call.args);
    }
  }
};
var FlowOperators = operators6;

// src/datasource-protocol/operators/MapOperators.ts
var operators7 = {
  "ppi-scale": {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      const scaleFactor = call.args[1] ? context2.evaluate(call.args[1]) : 1;
      return value2 * scaleFactor;
    }
  },
  "world-ppi-scale": {
    isDynamicOperator: () => {
      return true;
    },
    call: (context2, call) => {
      const pixels = context2.evaluate(call.args[0]);
      const scaleFactor = call.args[1] ? context2.evaluate(call.args[1]) : 1;
      const zoom = context2.env.lookup("$zoom");
      const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);
      const v = pixels * zoomWidth * scaleFactor;
      return v;
    }
  },
  "world-discrete-ppi-scale": {
    isDynamicOperator: () => {
      return true;
    },
    call: (context2, call) => {
      const pixels = context2.evaluate(call.args[0]);
      const scaleFactor = call.args[1] ? context2.evaluate(call.args[1]) : 1;
      const zoom = context2.env.lookup("$zoom");
      const zoomWidthDiscrete = Math.pow(2, 17) / Math.pow(2, Math.floor(zoom));
      const v = pixels * zoomWidthDiscrete * scaleFactor;
      return v;
    }
  },
  ppi: {
    call: (context2) => {
      const ppi = context2.env.lookup("$ppi");
      if (typeof ppi === "number") {
        return ppi;
      }
      return 72;
    }
  },
  zoom: {
    isDynamicOperator: () => {
      return true;
    },
    call: (context2, call) => {
      if (context2.scope === 0 /* Value */) {
        return call;
      }
      return context2.env.lookup("$zoom") ?? null;
    }
  }
};
var MapOperators = operators7;

// src/datasource-protocol/operators/MathOperators.ts
var THREE11 = __toESM(require("three"));
var operators8 = {
  "^": {
    call: (context2, call) => {
      const a = context2.evaluate(call.args[0]);
      const b = context2.evaluate(call.args[1]);
      if (typeof a !== "number" || typeof b !== "number") {
        throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '^'`);
      }
      return Math.pow(a, b);
    }
  },
  "-": {
    call: (context2, call) => {
      if (call.args.length === 1) {
        const value2 = context2.evaluate(call.args[0]);
        if (typeof value2 !== "number") {
          throw new Error(`\xECnvalid operand '${typeof value2} for operator '-'`);
        }
        return -value2;
      }
      const a = context2.evaluate(call.args[0]);
      const b = context2.evaluate(call.args[1]);
      if (typeof a !== "number" || typeof b !== "number") {
        throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '-'`);
      }
      return a - b;
    }
  },
  "/": {
    call: (context2, call) => {
      const a = context2.evaluate(call.args[0]);
      const b = context2.evaluate(call.args[1]);
      if (typeof a !== "number" || typeof b !== "number") {
        throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '/'`);
      }
      return a / b;
    }
  },
  "%": {
    call: (context2, call) => {
      const a = context2.evaluate(call.args[0]);
      const b = context2.evaluate(call.args[1]);
      if (typeof a !== "number" || typeof b !== "number") {
        throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '%'`);
      }
      return a % b;
    }
  },
  "+": {
    call: (context2, call) => {
      return call.args.reduce((a, b) => Number(a) + Number(context2.evaluate(b)), 0);
    }
  },
  "*": {
    call: (context2, call) => {
      return call.args.reduce((a, b) => Number(a) * Number(context2.evaluate(b)), 1);
    }
  },
  abs: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'abs'`);
      }
      return Math.abs(value2);
    }
  },
  acos: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'acos'`);
      }
      return Math.acos(value2);
    }
  },
  asin: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'asin'`);
      }
      return Math.asin(value2);
    }
  },
  atan: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'atan'`);
      }
      return Math.atan(value2);
    }
  },
  ceil: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'ceil'`);
      }
      return Math.ceil(value2);
    }
  },
  cos: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'cos'`);
      }
      return Math.cos(value2);
    }
  },
  e: {
    call: () => {
      return Math.E;
    }
  },
  floor: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'floor'`);
      }
      return Math.floor(value2);
    }
  },
  ln: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'ln'`);
      }
      return Math.log(value2);
    }
  },
  ln2: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'ln2'`);
      }
      return Math.log2(value2);
    }
  },
  log10: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'log10'`);
      }
      return Math.log10(value2);
    }
  },
  max: {
    call: (context2, call) => {
      return Math.max(...call.args.map((v) => Number(context2.evaluate(v))));
    }
  },
  min: {
    call: (context2, call) => {
      return Math.min(...call.args.map((v) => Number(context2.evaluate(v))));
    }
  },
  clamp: {
    call: (context2, call) => {
      const v = context2.evaluate(call.args[0]);
      const min = context2.evaluate(call.args[1]);
      const max = context2.evaluate(call.args[2]);
      if (typeof v !== "number" || typeof min !== "number" || typeof max !== "number") {
        throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);
      }
      return THREE11.MathUtils.clamp(v, min, max);
    }
  },
  pi: {
    call: () => {
      return Math.PI;
    }
  },
  round: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'round'`);
      }
      return Math.round(value2);
    }
  },
  sin: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'sin'`);
      }
      return Math.sin(value2);
    }
  },
  sqrt: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'sqrt'`);
      }
      return Math.sqrt(value2);
    }
  },
  tan: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (typeof value2 !== "number") {
        throw new Error(`invalid operand '${value2}' for operator 'tan'`);
      }
      return Math.tan(value2);
    }
  }
};
var MathOperators = operators8;

// src/datasource-protocol/operators/MiscOperators.ts
function joinKeyValues(keys) {
  return keys.join("&");
}
function stringifyKeyValue(key, value2) {
  return key + "=" + JSON.stringify(value2);
}
function joinCombinations(combinations) {
  combinations.sort((lhs, rhs) => rhs.length - lhs.length);
  const result = combinations.map((keys) => joinKeyValues(keys));
  result.push("");
  return result;
}
function getAllCombinations(input, index = 0) {
  if (index >= input.length) {
    return [];
  }
  const combinations = getAllCombinations(input, index + 1);
  const initLength = combinations.length;
  for (let i = 0; i < initLength; i += 1) {
    combinations.push([...combinations[i], input[index]]);
  }
  combinations.push([input[index]]);
  return combinations;
}
function getKeyCombinations(lookupExpr, context2) {
  const keys = lookupExpr.args.slice(1);
  const result = [];
  for (let i = 0; i < keys.length; i += 2) {
    const value2 = context2.evaluate(keys[i + 1]);
    if (value2 === null) {
      continue;
    }
    const key = context2.evaluate(keys[i]);
    result.push(stringifyKeyValue(key, value2));
  }
  result.sort().reverse();
  return joinCombinations(getAllCombinations(result));
}
function createLookupMap(lookupArray) {
  const map = /* @__PURE__ */ new Map();
  for (const entry of lookupArray) {
    if (typeof entry !== "object") {
      throw new Error(`Invalid lookup table entry type (${typeof entry})`);
    }
    if (!entry.keys) {
      throw new Error(`Lookup table entry has no 'keys' property.`);
    }
    if (!entry.attributes) {
      throw new Error(`Lookup table entry has no 'attributes' property.`);
    }
    const key = joinKeyValues(Object.getOwnPropertyNames(entry.keys).sort().map((key2) => stringifyKeyValue(key2, entry.keys[key2])));
    map.set(key, entry.attributes);
  }
  return map;
}
function searchLookupMap(keys, map) {
  for (const key of keys) {
    const matchAttributes = map.get(key);
    if (matchAttributes) {
      return matchAttributes;
    }
  }
  return null;
}
var operators9 = {
  length: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      if (Array.isArray(value2) || typeof value2 === "string") {
        return value2.length;
      }
      throw new Error(`invalid operand '${value2}' for operator 'length'`);
    }
  },
  coalesce: {
    call: (context2, call) => {
      for (const childExpr of call.args) {
        const value2 = context2.evaluate(childExpr);
        if (value2 !== null) {
          return value2;
        }
      }
      return null;
    }
  },
  lookup: {
    call: (context2, lookup) => {
      assert(lookup.args.length > 0, "missing lookup table");
      const keyCombinations = getKeyCombinations(lookup, context2);
      let table = context2.evaluate(lookup.args[0]);
      assert(Array.isArray(table) || table instanceof Map, "wrong lookup table type");
      if (Array.isArray(table)) {
        table = createLookupMap(table);
        const lookupMapExpr = new ObjectLiteralExpr(table);
        lookup.args[0] = lookupMapExpr;
      }
      return searchLookupMap(keyCombinations, table);
    }
  }
};
var MiscOperators = operators9;

// src/datasource-protocol/operators/ObjectOperators.ts
var hasOwnProperty = Object.prototype.hasOwnProperty;
function lookupMember(context2, args, lookupMode) {
  const memberName = context2.evaluate(args[0]);
  if (typeof memberName !== "string") {
    throw new Error(`expected the name of an attribute`);
  }
  const object = context2.evaluate(args[1]);
  if (object && typeof object === "object") {
    if (Env.isEnv(object)) {
      const value2 = object.lookup(memberName) ?? null;
      return lookupMode === 0 /* get */ ? value2 : value2 !== null;
    }
    if (hasOwnProperty.call(object, memberName)) {
      return lookupMode === 0 /* get */ ? object[memberName] : true;
    }
  }
  return lookupMode === 0 /* get */ ? null : false;
}
var operators10 = {
  in: {
    call: (context2, call) => {
      const value2 = context2.evaluate(call.args[0]);
      const object = context2.evaluate(call.args[1]);
      if (typeof value2 === "string" && typeof object === "string") {
        return object.includes(value2);
      } else if (Array.isArray(object)) {
        return object.includes(value2);
      }
      return false;
    }
  },
  get: {
    call: (context2, call) => lookupMember(context2, call.args, 0 /* get */)
  },
  has: {
    call: (context2, call) => lookupMember(context2, call.args, 1 /* has */)
  },
  "dynamic-properties": {
    isDynamicOperator: () => true,
    call: (context2, call) => {
      if (context2.scope === 2 /* Dynamic */) {
        return context2.env;
      }
      return call;
    }
  }
};
var ObjectOperators = operators10;

// src/datasource-protocol/operators/StringOperators.ts
var operators11 = {
  concat: {
    call: (context2, call) => {
      return "".concat(...call.args.map((a) => String(context2.evaluate(a))));
    }
  },
  downcase: {
    call: (context2, call) => {
      return String(context2.evaluate(call.args[0])).toLocaleLowerCase();
    }
  },
  upcase: {
    call: (context2, call) => {
      return String(context2.evaluate(call.args[0])).toLocaleUpperCase();
    }
  },
  "~=": {
    call: (context2, call) => {
      const left = context2.evaluate(call.args[0]);
      const right = context2.evaluate(call.args[1]);
      if (typeof left === "string" && typeof right === "string") {
        return left.includes(right);
      }
      return false;
    }
  },
  "^=": {
    call: (context2, call) => {
      const left = context2.evaluate(call.args[0]);
      const right = context2.evaluate(call.args[1]);
      if (typeof left === "string" && typeof right === "string") {
        return left.startsWith(right);
      }
      return false;
    }
  },
  "$=": {
    call: (context2, call) => {
      const left = context2.evaluate(call.args[0]);
      const right = context2.evaluate(call.args[1]);
      if (typeof left === "string" && typeof right === "string") {
        return left.endsWith(right);
      }
      return false;
    }
  }
};
var StringOperators = operators11;

// src/datasource-protocol/operators/TypeOperators.ts
var operators12 = {
  typeof: {
    call: (context2, call) => {
      return typeof context2.evaluate(call.args[0]);
    }
  }
};
var TypeOperators = operators12;

// src/datasource-protocol/operators/VectorOperators.ts
var THREE12 = __toESM(require("three"));
function isVector(context2, call, type) {
  let ctor;
  switch (type) {
    case "vector2":
      ctor = THREE12.Vector2;
      break;
    case "vector3":
      ctor = THREE12.Vector3;
      break;
    case "vector4":
      ctor = THREE12.Vector4;
      break;
  }
  for (const childExpr of call.args) {
    const value2 = context2.evaluate(childExpr);
    if (value2 instanceof ctor) {
      return value2;
    }
  }
  throw new Error(`expected a "${type}"`);
}
function toVector(context2, call, type) {
  let VectorCtor;
  let components;
  switch (type) {
    case "vector2":
      VectorCtor = THREE12.Vector2;
      components = 2;
      break;
    case "vector3":
      VectorCtor = THREE12.Vector3;
      components = 3;
      break;
    case "vector4":
      VectorCtor = THREE12.Vector4;
      components = 4;
      break;
  }
  for (const childExpr of call.args) {
    const value2 = context2.evaluate(childExpr);
    if (value2 instanceof VectorCtor) {
      return value2;
    } else if (Array.isArray(value2) && value2.length === components && value2.every((v) => typeof v === "number")) {
      return new VectorCtor().fromArray(value2);
    }
  }
  throw new Error(`expected a "${type}"`);
}
var operators13 = {
  "make-vector": {
    call: (context2, call) => {
      if (call._value !== void 0) {
        return call._value;
      }
      if (call.args.length < 2) {
        throw new Error("not enough arguments");
      } else if (call.args.length > 4) {
        throw new Error("too many arguments");
      }
      const components = call.args.map((arg) => context2.evaluate(arg));
      components.forEach((element, index) => {
        if (typeof element !== "number") {
          throw new Error(`expected vector component at index ${index} to have type "number"`);
        }
      });
      let result;
      switch (components.length) {
        case 2:
          result = new THREE12.Vector2().fromArray(components);
          break;
        case 3:
          result = new THREE12.Vector3().fromArray(components);
          break;
        case 4:
          result = new THREE12.Vector4().fromArray(components);
          break;
        default:
          throw new Error("too many arguments");
      }
      if (call.args.every((arg) => arg instanceof NumberLiteralExpr)) {
        call._value = result;
      }
      return result;
    }
  },
  vector2: {
    call: (context2, call) => isVector(context2, call, "vector2")
  },
  vector3: {
    call: (context2, call) => isVector(context2, call, "vector3")
  },
  vector4: {
    call: (context2, call) => isVector(context2, call, "vector4")
  },
  "to-vector2": {
    call: (context2, call) => toVector(context2, call, "vector2")
  },
  "to-vector3": {
    call: (context2, call) => toVector(context2, call, "vector3")
  },
  "to-vector4": {
    call: (context2, call) => toVector(context2, call, "vector4")
  }
};
var VectorOperators = operators13;

// src/datasource-protocol/Pixels.ts
var RX = /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/;
var Pixels = class {
  constructor(value2) {
    this.value = value2;
  }
  static parse(text) {
    const match = RX.exec(text);
    if (match === null) {
      return void 0;
    }
    return new Pixels(Number(match[1]));
  }
  toJSON() {
    return `${this.value}px`;
  }
};

// src/datasource-protocol/ExprEvaluator.ts
var operatorDescriptors = /* @__PURE__ */ new Map();
function promoteValue(context2, expr) {
  if (expr instanceof StringLiteralExpr) {
    return expr.promotedValue ?? expr.value;
  }
  const value2 = context2.evaluate(expr);
  if (typeof value2 === "string") {
    return RGBA.parse(value2) ?? Pixels.parse(value2) ?? value2;
  }
  return value2;
}
function cubicInterpolate(context2, interp, t) {
  if (t < interp.stops[0][0]) {
    return promoteValue(context2, interp.stops[0][1]);
  } else if (t >= interp.stops[interp.stops.length - 1][0]) {
    return promoteValue(context2, interp.stops[interp.stops.length - 1][1]);
  }
  const i1 = interp.stops.findIndex((stop) => stop[0] > t);
  const i0 = Math.max(0, i1 - 1);
  const iP = i0 === 0 ? i1 : i0 - 1;
  const iN = i1 < interp.stops.length - 1 ? i1 + 1 : i1 - 1;
  const tP = interp.stops[iP][0];
  const t0 = interp.stops[i0][0];
  const t1 = interp.stops[i1][0];
  const tN = interp.stops[iN][0];
  const dt = (t1 - t0) * 0.5;
  const wP = dt / (t0 - tP);
  const wN = dt / (tN - t1);
  const p = (t - t0) / (t1 - t0);
  const pp = p * p;
  const ppp = pp * p;
  const cP = -wP * ppp + 2 * wP * pp - wP * p;
  const c0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
  const c1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
  const cN = wN * ppp - wN * pp;
  const vP = promoteValue(context2, interp.stops[iP][1]);
  const v0 = promoteValue(context2, interp.stops[i0][1]);
  const v1 = promoteValue(context2, interp.stops[i1][1]);
  const vN = promoteValue(context2, interp.stops[iN][1]);
  if (typeof vP === "number" && typeof v0 === "number" && typeof v1 === "number" && typeof vN === "number") {
    return cP * vP + c0 * v0 + c1 * v1 + cN * vN;
  } else if (vP instanceof RGBA && v0 instanceof RGBA && v1 instanceof RGBA && vN instanceof RGBA) {
    return new RGBA(THREE13.MathUtils.clamp(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, 0, 1), THREE13.MathUtils.clamp(cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, 0, 1), THREE13.MathUtils.clamp(cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b, 0, 1), THREE13.MathUtils.clamp(cP * vP.a + c0 * v0.a + c1 * v1.a + cN * vN.a, 0, 1));
  } else if (vP instanceof Pixels && v0 instanceof Pixels && v1 instanceof Pixels && vN instanceof Pixels) {
    return new Pixels(cP * vP.value + c0 * v0.value + c1 * v1.value + cN * vN.value);
  } else if (vP instanceof THREE13.Color && v0 instanceof THREE13.Color && v1 instanceof THREE13.Color && vN instanceof THREE13.Color) {
    return new THREE13.Color(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b);
  } else if (vP instanceof THREE13.Vector2 && v0 instanceof THREE13.Vector2 && v1 instanceof THREE13.Vector2 && vN instanceof THREE13.Vector2) {
    return new THREE13.Vector2(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y);
  } else if (vP instanceof THREE13.Vector3 && v0 instanceof THREE13.Vector3 && v1 instanceof THREE13.Vector3 && vN instanceof THREE13.Vector3) {
    return new THREE13.Vector3(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z);
  } else if (vP instanceof THREE13.Vector4 && v0 instanceof THREE13.Vector4 && v1 instanceof THREE13.Vector4 && vN instanceof THREE13.Vector4) {
    return new THREE13.Vector4(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z, cP * vP.w + c0 * v0.w + c1 * v1.w + cN * vN.w);
  } else if (Array.isArray(vP) && Array.isArray(v0) && Array.isArray(v1) && Array.isArray(vN)) {
    const N = vP.length;
    const r = [];
    for (let i = 0; i < N; ++i) {
      r[i] = cP * vP[i] + c0 * v0[i] + c1 * v1[i] + cN * vN[i];
    }
    return r;
  }
  throw new Error(`failed to interpolate values`);
}
var ExprEvaluatorContext = class {
  constructor(evaluator, env, scope, cache6) {
    this.evaluator = evaluator;
    this.env = env;
    this.scope = scope;
    this.cache = cache6;
  }
  evaluate(expr) {
    var _a, _b;
    if (expr === void 0) {
      throw new Error("Failed to evaluate expression");
    }
    const cachedResult = (_a = this.cache) == null ? void 0 : _a.get(expr);
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    const result = expr.accept(this.evaluator, this);
    (_b = this.cache) == null ? void 0 : _b.set(expr, result);
    return result;
  }
  wrapValue(value2) {
    return Expr3.isExpr(value2) ? value2 : LiteralExpr.fromValue(value2);
  }
};
var ExprEvaluator = class {
  static defineOperator(op, builtin) {
    operatorDescriptors.set(op, builtin);
  }
  static defineOperators(builtins) {
    Object.getOwnPropertyNames(builtins).forEach((p) => {
      this.defineOperator(p, builtins[p]);
    });
  }
  static getOperator(op) {
    return operatorDescriptors.get(op);
  }
  visitVarExpr(expr, context2) {
    const value2 = context2.env.lookup(expr.name);
    return value2 !== void 0 ? value2 : null;
  }
  visitNullLiteralExpr(expr, context2) {
    return null;
  }
  visitBooleanLiteralExpr(expr, context2) {
    return expr.value;
  }
  visitNumberLiteralExpr(expr, context2) {
    return expr.value;
  }
  visitStringLiteralExpr(expr, context2) {
    return expr.value;
  }
  visitObjectLiteralExpr(expr, context2) {
    return expr.value;
  }
  visitHasAttributeExpr(expr, context2) {
    return context2.env.lookup(expr.name) !== void 0;
  }
  visitMatchExpr(match, context2) {
    const r = context2.evaluate(match.value);
    for (const [label, body] of match.branches) {
      if (Array.isArray(label) && label.includes(r)) {
        return context2.evaluate(body);
      } else if (label === r) {
        return context2.evaluate(body);
      }
    }
    return context2.evaluate(match.fallback);
  }
  visitCaseExpr(match, context2) {
    if (context2.scope === 0 /* Value */) {
      const firstDynamicCondition = match.branches.findIndex(([condition, _]) => condition.isDynamic());
      if (firstDynamicCondition !== -1) {
        let branches;
        for (let i = 0; i < match.branches.length; ++i) {
          const [condition, body] = match.branches[i];
          const evaluatedCondition = context2.evaluate(condition);
          const evaluatedBody = context2.evaluate(body);
          if (i < firstDynamicCondition && Boolean(evaluatedCondition)) {
            return evaluatedBody;
          }
          if (!Expr3.isExpr(evaluatedCondition) && !Boolean(evaluatedCondition)) {
            continue;
          }
          if (branches === void 0) {
            branches = [];
          }
          branches == null ? void 0 : branches.push([
            context2.wrapValue(evaluatedCondition),
            context2.wrapValue(evaluatedBody)
          ]);
          if (!Expr3.isExpr(evaluatedCondition) && Boolean(evaluatedCondition)) {
            return new CaseExpr(branches, LiteralExpr.fromValue(null));
          }
        }
        const fallback = context2.evaluate(match.fallback);
        return branches === void 0 ? fallback : new CaseExpr(branches, context2.wrapValue(fallback));
      }
    }
    for (const [condition, body] of match.branches) {
      if (context2.evaluate(condition)) {
        return context2.evaluate(body);
      }
    }
    return context2.evaluate(match.fallback);
  }
  visitCallExpr(expr, context2) {
    const descriptor = expr.descriptor ?? operatorDescriptors.get(expr.op);
    if (descriptor) {
      expr.descriptor = descriptor;
      let result;
      if (context2.scope === 0 /* Value */ && expr.isDynamic()) {
        if (expr.descriptor.partialEvaluate) {
          return expr.descriptor.partialEvaluate(context2, expr);
        }
        const args = expr.args.map((arg) => {
          return context2.wrapValue(context2.evaluate(arg));
        });
        if (args.every((arg, i) => arg === expr.args[i])) {
          return expr;
        }
        result = new CallExpr7(expr.op, args);
      } else {
        result = descriptor.call(context2, expr);
      }
      return result;
    }
    throw new Error(`undefined operator '${expr.op}'`);
  }
  visitLookupExpr(expr, context2) {
    return this.visitCallExpr(expr, context2);
  }
  visitStepExpr(expr, context2) {
    if (context2.scope === 0 /* Value */) {
      const input = context2.evaluate(expr.input);
      const defaultValue = context2.evaluate(expr.defaultValue);
      return new StepExpr(context2.wrapValue(input), context2.wrapValue(defaultValue), expr.stops.map(([key, value2]) => {
        const v = context2.evaluate(value2);
        return [key, context2.wrapValue(v)];
      }));
    } else {
      const input = context2.evaluate(expr.input);
      if (typeof input !== "number") {
        throw new Error(`input '${input}' must be a number`);
      }
      if (input < expr.stops[0][0]) {
        return context2.evaluate(expr.defaultValue);
      }
      let index = expr.stops.findIndex((s) => s[0] > input);
      if (index === -1) {
        index = expr.stops.length;
      }
      return context2.evaluate(expr.stops[index - 1][1]);
    }
  }
  visitInterpolateExpr(expr, context2) {
    if (context2.scope === 0 /* Value */) {
      const input = context2.evaluate(expr.input);
      return new InterpolateExpr(expr.mode, context2.wrapValue(input), expr.stops.map(([key, value2]) => {
        const v = context2.evaluate(value2);
        return [key, context2.wrapValue(v)];
      }));
    } else {
      const param = context2.evaluate(expr.input);
      if (typeof param !== "number") {
        throw new Error(`input must be a number`);
      }
      if (expr.mode[0] === "cubic") {
        return cubicInterpolate(context2, expr, param);
      }
      const keyIndex = expr.stops.findIndex((stop) => stop[0] > param);
      if (keyIndex === -1) {
        return context2.evaluate(expr.stops[expr.stops.length - 1][1]);
      } else if (keyIndex === 0) {
        return context2.evaluate(expr.stops[0][1]);
      }
      const [key, value2] = expr.stops[keyIndex];
      const [prevKey, prevValue] = expr.stops[keyIndex - 1];
      const v0 = promoteValue(context2, prevValue);
      let t = 0;
      switch (expr.mode[0]) {
        case "discrete":
          return v0;
        case "linear":
          t = (param - prevKey) / (key - prevKey);
          break;
        case "exponential": {
          const base = expr.mode[1];
          t = base === 1 ? (param - prevKey) / (key - prevKey) : (Math.pow(base, param - prevKey) - 1) / (Math.pow(base, key - prevKey) - 1);
          break;
        }
        default:
          throw new Error(`interpolation mode ${JSON.stringify(expr.mode)} is not supported`);
      }
      const v1 = promoteValue(context2, value2);
      if (typeof v0 === "number" && typeof v1 === "number") {
        return THREE13.MathUtils.lerp(v0, v1, t);
      } else if (v0 instanceof RGBA && v1 instanceof RGBA) {
        return v0.clone().lerp(v1, t);
      } else if (v0 instanceof Pixels && v1 instanceof Pixels) {
        return new Pixels(THREE13.MathUtils.lerp(v0.value, v1.value, t));
      } else if (v0 instanceof THREE13.Color && v1 instanceof THREE13.Color) {
        return v0.clone().lerp(v1, t);
      } else if (v0 instanceof THREE13.Vector2 && v1 instanceof THREE13.Vector2) {
        return v0.clone().lerp(v1, t);
      } else if (v0 instanceof THREE13.Vector3 && v1 instanceof THREE13.Vector3) {
        return v0.clone().lerp(v1, t);
      } else if (v0 instanceof THREE13.Vector4 && v1 instanceof THREE13.Vector4) {
        return v0.clone().lerp(v1, t);
      } else if (Array.isArray(v0) && Array.isArray(v1) && v0.length === v1.length) {
        return v0.map((x, i) => THREE13.MathUtils.lerp(x, v1[i], t));
      }
      throw new Error(`todo: mix(${JSON.stringify(v0)}, ${JSON.stringify(v1)}, ${t})`);
    }
  }
};
ExprEvaluator.defineOperators(CastOperators);
ExprEvaluator.defineOperators(ComparisonOperators);
ExprEvaluator.defineOperators(MathOperators);
ExprEvaluator.defineOperators(StringOperators);
ExprEvaluator.defineOperators(ColorOperators);
ExprEvaluator.defineOperators(TypeOperators);
ExprEvaluator.defineOperators(MiscOperators);
ExprEvaluator.defineOperators(FlowOperators);
ExprEvaluator.defineOperators(ArrayOperators);
ExprEvaluator.defineOperators(ObjectOperators);
ExprEvaluator.defineOperators(FeatureOperators);
ExprEvaluator.defineOperators(MapOperators);
ExprEvaluator.defineOperators(VectorOperators);

// src/datasource-protocol/ExprInstantiator.ts
var emptyEnv = new Env();
var ExprInstantiator = class {
  visitNullLiteralExpr(expr, _context) {
    return expr;
  }
  visitBooleanLiteralExpr(expr, _context) {
    return expr;
  }
  visitNumberLiteralExpr(expr, _context) {
    return expr;
  }
  visitStringLiteralExpr(expr, _context) {
    return expr;
  }
  visitObjectLiteralExpr(expr, _context) {
    return expr;
  }
  visitVarExpr(expr, context2) {
    if (context2.preserve && context2.preserve.has(expr.name)) {
      return expr;
    }
    const value2 = context2.env.lookup(expr.name);
    return LiteralExpr.fromValue(value2 !== void 0 ? value2 : null);
  }
  visitHasAttributeExpr(expr, context2) {
    if (context2.preserve && context2.preserve.has(expr.name)) {
      return expr;
    }
    const value2 = context2.env.lookup(expr.name) !== void 0;
    return LiteralExpr.fromValue(value2);
  }
  visitCallExprImpl(expr, context2, constructor) {
    const args = expr.args.map((arg) => arg.accept(this, context2));
    if (args.some((a, i) => a !== expr.args[i])) {
      return constructor(expr.op, args);
    }
    return expr;
  }
  visitCallExpr(expr, context2) {
    return this.visitCallExprImpl(expr, context2, (op, args) => {
      return new CallExpr7(op, args);
    });
  }
  visitLookupExpr(expr, context2) {
    return this.visitCallExprImpl(expr, context2, (op, args) => {
      return new LookupExpr3(args);
    });
  }
  visitMatchExpr(match, context2) {
    const value2 = match.value.accept(this, context2);
    if (value2 instanceof LiteralExpr) {
      const r = value2.value;
      for (const [label, body] of match.branches) {
        if (Array.isArray(label) && label.includes(r)) {
          return body.accept(this, context2);
        } else if (label === r) {
          return body.accept(this, context2);
        }
      }
      return match.fallback.accept(this, context2);
    }
    let changed = match.value !== value2;
    const branches = match.branches.map(([label, branch]) => {
      const newBranch = branch.accept(this, context2);
      if (newBranch !== branch) {
        changed = true;
      }
      return [label, newBranch];
    });
    const fallback = match.fallback.accept(this, context2);
    if (fallback !== match.fallback) {
      changed = true;
    }
    return changed ? new MatchExpr2(value2, branches, fallback) : match;
  }
  visitCaseExpr(expr, context2) {
    const branches = [];
    let changed = false;
    for (const [condition, branch] of expr.branches) {
      const newCondition = condition.accept(this, context2);
      const deps = newCondition.dependencies();
      if (!condition.isDynamic() && deps.properties.size === 0) {
        if (Boolean(newCondition.evaluate(emptyEnv, 1 /* Condition */))) {
          return branch.accept(this, context2);
        }
      } else {
        if (newCondition !== condition) {
          changed = true;
        }
        branches.push([newCondition, branch]);
      }
    }
    if (branches.length === 0) {
      return expr.fallback.accept(this, context2);
    }
    if (branches.length !== expr.branches.length) {
      changed = true;
    }
    branches.forEach((branch) => {
      const instantiatedBranch = branch[1].accept(this, context2);
      if (instantiatedBranch !== branch[1]) {
        changed = true;
      }
      branch[1] = instantiatedBranch;
    });
    const fallback = expr.fallback.accept(this, context2);
    if (fallback !== expr.fallback) {
      changed = true;
    }
    if (!changed) {
      return expr;
    }
    return new CaseExpr(branches, fallback);
  }
  visitStepExpr(expr, context2) {
    const input = expr.input.accept(this, context2);
    const defaultValue = expr.defaultValue.accept(this, context2);
    const stops = expr.stops.map(([key, value2]) => [
      key,
      value2.accept(this, context2)
    ]);
    return new StepExpr(input, defaultValue, stops);
  }
  visitInterpolateExpr(expr, context2) {
    const input = expr.input.accept(this, context2);
    const stops = expr.stops.map(([key, value2]) => [
      key,
      value2.accept(this, context2)
    ]);
    return new InterpolateExpr(expr.mode, input, stops);
  }
};

// src/datasource-protocol/ExprParser.ts
function isSpace(codepoint) {
  switch (codepoint) {
    case 9 /* Tab */:
    case 10 /* Lf */:
    case 13 /* Cr */:
    case 32 /* Space */:
      return true;
    default:
      return false;
  }
}
function isNumber(codepoint) {
  return codepoint >= 48 /* _0 */ && codepoint <= 57 /* _9 */;
}
function isLetter(codepoint) {
  return codepoint >= 97 /* a */ && codepoint <= 122 /* z */ || codepoint >= 64 /* A */ && codepoint <= 90 /* Z */;
}
function isLetterOrNumber(codepoint) {
  return isLetter(codepoint) || isNumber(codepoint);
}
function isIdentChar(codepoint) {
  return isLetterOrNumber(codepoint) || codepoint === 95 /* _ */ || codepoint === 36 /* Dollar */ || codepoint === 46 /* Dot */ || codepoint === 91 /* LBracket */ || codepoint === 93 /* RBracket */;
}
function tokenSpell(token) {
  switch (token) {
    case 0 /* Eof */:
      return "eof";
    case 1 /* Error */:
      return "error";
    case 2 /* Identifier */:
      return "identifier";
    case 3 /* Number */:
      return "number";
    case 4 /* String */:
      return "string";
    case 5 /* Comma */:
      return ",";
    case 6 /* LParen */:
      return "(";
    case 7 /* RParen */:
      return ")";
    case 8 /* LBracket */:
      return "[";
    case 9 /* RBracket */:
      return "]";
    case 10 /* Exclaim */:
      return "!";
    case 11 /* TildeEqual */:
      return "~=";
    case 12 /* CaretEqual */:
      return "^=";
    case 13 /* DollarEqual */:
      return "$=";
    case 14 /* EqualEqual */:
      return "==";
    case 15 /* ExclaimEqual */:
      return "!=";
    case 16 /* Less */:
      return "<";
    case 17 /* Greater */:
      return ">";
    case 18 /* LessEqual */:
      return "<=";
    case 19 /* GreaterEqual */:
      return ">=";
    case 20 /* BarBar */:
      return "||";
    case 21 /* AmpAmp */:
      return "&&";
    default:
      throw new Error(`invalid token ${token}`);
  }
}
var Lexer = class {
  constructor(code) {
    this.code = code;
  }
  m_token = 1 /* Error */;
  m_index = 0;
  m_char = 10 /* Lf */;
  m_text;
  token() {
    return this.m_token;
  }
  text() {
    return this.m_text ?? "";
  }
  next() {
    this.m_token = this.yylex();
    if (this.m_token === 1 /* Error */) {
      throw new Error(`unexpected character ${this.m_char}`);
    }
    return this.m_token;
  }
  yyinp() {
    this.m_char = this.code.codePointAt(this.m_index++) ?? 0;
  }
  yylex() {
    this.m_text = void 0;
    while (isSpace(this.m_char)) {
      this.yyinp();
    }
    if (this.m_char === 0) {
      return 0 /* Eof */;
    }
    const ch = this.m_char;
    this.yyinp();
    switch (ch) {
      case 40 /* LParen */:
        return 6 /* LParen */;
      case 41 /* RParen */:
        return 7 /* RParen */;
      case 91 /* LBracket */:
        return 8 /* LBracket */;
      case 93 /* RBracket */:
        return 9 /* RBracket */;
      case 44 /* Comma */:
        return 5 /* Comma */;
      case 39 /* SingleQuote */:
      case 34 /* DoubleQuote */: {
        const start = this.m_index - 1;
        while (this.m_char && this.m_char !== ch) {
          this.yyinp();
        }
        if (this.m_char !== ch) {
          throw new Error("Unfinished string literal");
        }
        this.yyinp();
        this.m_text = this.code.substring(start, this.m_index - 2);
        return 4 /* String */;
      }
      case 33 /* Exclaim */:
        if (this.m_char === 61 /* Equal */) {
          this.yyinp();
          return 15 /* ExclaimEqual */;
        }
        return 10 /* Exclaim */;
      case 94 /* Caret */:
        if (this.m_char === 61 /* Equal */) {
          this.yyinp();
          return 12 /* CaretEqual */;
        }
        return 1 /* Error */;
      case 126 /* Tilde */:
        if (this.m_char === 61 /* Equal */) {
          this.yyinp();
          return 11 /* TildeEqual */;
        }
        return 1 /* Error */;
      case 61 /* Equal */:
        if (this.m_char === 61 /* Equal */) {
          this.yyinp();
          return 14 /* EqualEqual */;
        }
        return 1 /* Error */;
      case 60 /* Less */:
        if (this.m_char === 61 /* Equal */) {
          this.yyinp();
          return 18 /* LessEqual */;
        }
        return 16 /* Less */;
      case 62 /* Greater */:
        if (this.m_char === 61 /* Equal */) {
          this.yyinp();
          return 19 /* GreaterEqual */;
        }
        return 17 /* Greater */;
      case 124 /* Bar */:
        if (this.m_char === 124 /* Bar */) {
          this.yyinp();
          return 20 /* BarBar */;
        }
        return 1 /* Error */;
      case 38 /* Amp */:
        if (this.m_char === 38 /* Amp */) {
          this.yyinp();
          return 21 /* AmpAmp */;
        }
        return 1 /* Error */;
      default: {
        const start = this.m_index - 2;
        if (isLetter(ch) || ch === 95 /* _ */ || ch === 36 /* Dollar */ && isIdentChar(this.m_char)) {
          while (isIdentChar(this.m_char)) {
            this.yyinp();
          }
          this.m_text = this.code.substring(start, this.m_index - 1);
          return 2 /* Identifier */;
        } else if (isNumber(ch)) {
          while (isNumber(this.m_char)) {
            this.yyinp();
          }
          if (this.m_char === 46 /* Dot */) {
            this.yyinp();
            while (isNumber(this.m_char)) {
              this.yyinp();
            }
          }
          this.m_text = this.code.substring(start, this.m_index - 1);
          return 3 /* Number */;
        } else if (ch === 36 /* Dollar */) {
          if (this.m_char === 61 /* Equal */) {
            this.yyinp();
            return 13 /* DollarEqual */;
          }
          return 1 /* Error */;
        }
      }
    }
    return 1 /* Error */;
  }
};
function getEqualityOp(token) {
  switch (token) {
    case 11 /* TildeEqual */:
      return "~=";
    case 12 /* CaretEqual */:
      return "^=";
    case 13 /* DollarEqual */:
      return "$=";
    case 14 /* EqualEqual */:
      return "==";
    case 15 /* ExclaimEqual */:
      return "!=";
    default:
      return void 0;
  }
}
function getRelationalOp(token) {
  switch (token) {
    case 16 /* Less */:
      return "<";
    case 17 /* Greater */:
      return ">";
    case 18 /* LessEqual */:
      return "<=";
    case 19 /* GreaterEqual */:
      return ">=";
    default:
      return void 0;
  }
}
var ExprParser = class {
  lex;
  constructor(code) {
    this.lex = new Lexer(code);
    this.lex.next();
  }
  parse() {
    return this.parseLogicalOr();
  }
  yyexpect(token) {
    if (this.lex.token() !== token) {
      throw new Error(`Syntax error: Expected token '${tokenSpell(token)}' but found '${tokenSpell(this.lex.token())}'`);
    }
    this.lex.next();
  }
  parsePrimary() {
    switch (this.lex.token()) {
      case 2 /* Identifier */: {
        const text = this.lex.text();
        switch (text) {
          case "has":
            this.lex.next();
            this.yyexpect(6 /* LParen */);
            const hasAttribute = this.lex.text();
            this.yyexpect(2 /* Identifier */);
            this.yyexpect(7 /* RParen */);
            return new HasAttributeExpr3(hasAttribute);
          case "length":
            this.lex.next();
            this.yyexpect(6 /* LParen */);
            const value2 = this.parseLogicalOr();
            this.yyexpect(7 /* RParen */);
            return new CallExpr7("length", [value2]);
          default:
            const expr = new VarExpr3(text);
            this.lex.next();
            return expr;
        }
      }
      case 6 /* LParen */: {
        this.lex.next();
        const expr = this.parseLogicalOr();
        this.yyexpect(7 /* RParen */);
        return expr;
      }
      default:
        return this.parseLiteral();
    }
  }
  parseLiteral() {
    switch (this.lex.token()) {
      case 3 /* Number */: {
        const expr = new NumberLiteralExpr(parseFloat(this.lex.text()));
        this.lex.next();
        return expr;
      }
      case 4 /* String */: {
        const expr = new StringLiteralExpr(this.lex.text());
        this.lex.next();
        return expr;
      }
      default:
        throw new Error("Syntax error");
    }
  }
  parseUnary() {
    if (this.lex.token() === 10 /* Exclaim */) {
      this.lex.next();
      return new CallExpr7("!", [this.parseUnary()]);
    }
    return this.parsePrimary();
  }
  parseRelational() {
    let expr = this.parseUnary();
    while (true) {
      if (this.lex.token() === 2 /* Identifier */ && this.lex.text() === "in") {
        this.lex.next();
        this.yyexpect(8 /* LBracket */);
        const elements = [this.parseLiteral()];
        while (this.lex.token() === 5 /* Comma */) {
          this.lex.next();
          elements.push(this.parseLiteral());
        }
        this.yyexpect(9 /* RBracket */);
        expr = new CallExpr7("in", [
          expr,
          LiteralExpr.fromValue(elements.map(({ value: value2 }) => value2))
        ]);
      } else {
        const op = getRelationalOp(this.lex.token());
        if (op === void 0) {
          break;
        }
        this.lex.next();
        const right = this.parseUnary();
        expr = new CallExpr7(op, [expr, right]);
      }
    }
    return expr;
  }
  parseEquality() {
    let expr = this.parseRelational();
    while (true) {
      let op = getEqualityOp(this.lex.token());
      if (op === void 0) {
        break;
      }
      if (op === "~=") {
        op = "in";
      }
      this.lex.next();
      const right = this.parseRelational();
      expr = new CallExpr7(op, [expr, right]);
    }
    return expr;
  }
  parseLogicalAnd() {
    const expr = this.parseEquality();
    if (this.lex.token() !== 21 /* AmpAmp */) {
      return expr;
    }
    const expressions = [expr];
    do {
      this.lex.next();
      expressions.push(this.parseEquality());
    } while (this.lex.token() === 21 /* AmpAmp */);
    return new CallExpr7("all", expressions);
  }
  parseLogicalOr() {
    const expr = this.parseLogicalAnd();
    if (this.lex.token() !== 20 /* BarBar */) {
      return expr;
    }
    const expressions = [expr];
    do {
      this.lex.next();
      expressions.push(this.parseLogicalAnd());
    } while (this.lex.token() === 20 /* BarBar */);
    return new CallExpr7("any", expressions);
  }
};

// src/datasource-protocol/InterpolatedPropertyDefs.ts
function isInterpolatedPropertyDefinition(p) {
  if (p && p.interpolationMode === void 0 && Array.isArray(p.values) && p.values.length > 0 && p.values[0] !== void 0 && Array.isArray(p.zoomLevels) && p.zoomLevels.length > 0 && p.zoomLevels[0] !== void 0 && p.values.length === p.zoomLevels.length) {
    return true;
  }
  return false;
}
function interpolatedPropertyDefinitionToJsonExpr(property) {
  if (property.interpolation === void 0 || property.interpolation === "Discrete") {
    const step = ["step", ["zoom"], property.values[0]];
    for (let i = 1; i < property.zoomLevels.length; ++i) {
      step.push(property.zoomLevels[i], property.values[i]);
    }
    return step;
  }
  const interpolation = ["interpolate"];
  switch (property.interpolation) {
    case "Linear":
      interpolation.push(["linear"]);
      break;
    case "Cubic":
      interpolation.push(["cubic"]);
      break;
    case "Exponential":
      interpolation.push([
        "exponential",
        property.exponent !== void 0 ? property.exponent : 2
      ]);
      break;
    default:
      throw new Error(`interpolation mode '${property.interpolation}' is not supported`);
  }
  interpolation.push(["zoom"]);
  for (let i = 0; i < property.zoomLevels.length; ++i) {
    interpolation.push(property.zoomLevels[i], property.values[i]);
  }
  return interpolation;
}

// src/datasource-protocol/Theme.ts
function isVerboseDefinition(definition) {
  return (definition == null ? void 0 : definition.value) !== void 0;
}
function getDefinitionValue(definition) {
  return isVerboseDefinition(definition) ? definition.value : definition;
}
function isJsonExprReference(value2) {
  return Array.isArray(value2) && value2.length === 2 && value2[0] === "ref" && typeof value2[1] === "string";
}
function convertDictionaryToStyles(stylesDict) {
  const styles = [];
  for (const styleSetName in stylesDict) {
    stylesDict[styleSetName].forEach((style) => {
      if (style.styleSet === void 0) {
        style.styleSet = styleSetName;
      }
      styles.push(style);
    });
  }
  return styles;
}
function isStylesDictionary(styles) {
  return styles !== void 0 && !Array.isArray(styles);
}
function getStyles(styles) {
  if (styles === void 0) {
    return [];
  } else if (isStylesDictionary(styles)) {
    return convertDictionaryToStyles(styles);
  } else {
    return styles;
  }
}

// src/datasource-protocol/Expr.ts
var exprEvaluator = new ExprEvaluator();
var exprInstantiator = new ExprInstantiator();
var ExprDependencies = class {
  properties = /* @__PURE__ */ new Set();
  featureState;
  volatile;
};
var _ComputeExprDependencies = class {
  static of(expr) {
    const dependencies = new ExprDependencies();
    expr.accept(this.instance, dependencies);
    return dependencies;
  }
  visitNullLiteralExpr(expr, context2) {
  }
  visitBooleanLiteralExpr(expr, context2) {
  }
  visitNumberLiteralExpr(expr, context2) {
  }
  visitStringLiteralExpr(expr, context2) {
  }
  visitObjectLiteralExpr(expr, context2) {
  }
  visitVarExpr(expr, context2) {
    context2.properties.add(expr.name);
  }
  visitHasAttributeExpr(expr, context2) {
    context2.properties.add(expr.name);
  }
  visitCallExpr(expr, context2) {
    expr.args.forEach((childExpr) => childExpr.accept(this, context2));
    switch (expr.op) {
      case "dynamic-properties":
        context2.volatile = true;
        break;
      case "feature-state":
        context2.featureState = true;
        context2.properties.add("$state");
        context2.properties.add("$id");
        break;
      case "id":
        context2.properties.add("$id");
        break;
      case "zoom":
      case "world-ppi-scale":
      case "world-discrete-ppi-scale":
        context2.properties.add("$zoom");
        break;
      case "geometry-type":
        context2.properties.add("$geometryType");
        break;
      default:
        break;
    }
  }
  visitLookupExpr(expr, context2) {
    return this.visitCallExpr(expr, context2);
  }
  visitMatchExpr(expr, context2) {
    expr.value.accept(this, context2);
    expr.branches.forEach(([_, branch]) => branch.accept(this, context2));
    expr.fallback.accept(this, context2);
  }
  visitCaseExpr(expr, context2) {
    expr.branches.forEach(([condition, branch]) => {
      condition.accept(this, context2);
      branch.accept(this, context2);
    });
    expr.fallback.accept(this, context2);
  }
  visitStepExpr(expr, context2) {
    expr.input.accept(this, context2);
    expr.defaultValue.accept(this, context2);
    expr.stops.forEach(([_, value2]) => value2.accept(this, context2));
  }
  visitInterpolateExpr(expr, context2) {
    expr.input.accept(this, context2);
    expr.stops.forEach(([_, value2]) => value2.accept(this, context2));
  }
};
var ComputeExprDependencies = _ComputeExprDependencies;
__publicField(ComputeExprDependencies, "instance", new _ComputeExprDependencies());
function isJsonExpr(v) {
  return Array.isArray(v) && v.length > 0 && typeof v[0] === "string";
}
var Expr3 = class {
  static isExpr(value2) {
    return value2 instanceof Expr3;
  }
  static parse(code) {
    const parser = new ExprParser(code);
    const expr = parser.parse();
    return expr;
  }
  static fromJSON(json, definitions, definitionExprCache) {
    const referenceResolverState = definitions !== void 0 ? {
      definitions,
      lockedNames: /* @__PURE__ */ new Set(),
      cache: definitionExprCache ?? /* @__PURE__ */ new Map()
    } : void 0;
    return parseNode(json, referenceResolverState);
  }
  m_dependencies;
  m_isDynamic;
  evaluate(env, scope = 0 /* Value */, cache6) {
    return this.accept(exprEvaluator, new ExprEvaluatorContext(exprEvaluator, env, scope, cache6));
  }
  instantiate(context2) {
    return this.accept(exprInstantiator, context2);
  }
  dependencies() {
    if (!this.m_dependencies) {
      this.m_dependencies = ComputeExprDependencies.of(this);
    }
    return this.m_dependencies;
  }
  intern(pool) {
    return pool.add(this);
  }
  toJSON() {
    return new ExprSerializer().serialize(this);
  }
  isDynamic() {
    if (this.m_isDynamic === void 0) {
      this.m_isDynamic = this.exprIsDynamic();
    }
    return this.m_isDynamic;
  }
};
var VarExpr3 = class extends Expr3 {
  constructor(name2) {
    super();
    this.name = name2;
  }
  accept(visitor, context2) {
    return visitor.visitVarExpr(this, context2);
  }
  exprIsDynamic() {
    return false;
  }
};
var LiteralExpr = class extends Expr3 {
  static fromValue(value2) {
    switch (typeof value2) {
      case "boolean":
        return new BooleanLiteralExpr3(value2);
      case "number":
        return new NumberLiteralExpr(value2);
      case "string":
        return new StringLiteralExpr(value2);
      case "object":
        return value2 === null ? NullLiteralExpr3.instance : new ObjectLiteralExpr(value2);
      default:
        throw new Error(`failed to create a literal from '${value2}'`);
    }
  }
  exprIsDynamic() {
    return false;
  }
};
var _NullLiteralExpr = class extends LiteralExpr {
  value = null;
  constructor() {
    super();
  }
  accept(visitor, context2) {
    return visitor.visitNullLiteralExpr(this, context2);
  }
  exprIsDynamic() {
    return false;
  }
};
var NullLiteralExpr3 = _NullLiteralExpr;
__publicField(NullLiteralExpr3, "instance", new _NullLiteralExpr());
var BooleanLiteralExpr3 = class extends LiteralExpr {
  constructor(value2) {
    super();
    this.value = value2;
  }
  accept(visitor, context2) {
    return visitor.visitBooleanLiteralExpr(this, context2);
  }
};
var NumberLiteralExpr = class extends LiteralExpr {
  constructor(value2) {
    super();
    this.value = value2;
  }
  accept(visitor, context2) {
    return visitor.visitNumberLiteralExpr(this, context2);
  }
};
var StringLiteralExpr = class extends LiteralExpr {
  constructor(value2) {
    super();
    this.value = value2;
  }
  m_promotedValue;
  get promotedValue() {
    if (this.m_promotedValue === void 0) {
      this.m_promotedValue = RGBA.parse(this.value) ?? Pixels.parse(this.value) ?? null;
    }
    return this.m_promotedValue ?? void 0;
  }
  accept(visitor, context2) {
    return visitor.visitStringLiteralExpr(this, context2);
  }
};
var ObjectLiteralExpr = class extends LiteralExpr {
  constructor(value2) {
    super();
    this.value = value2;
  }
  get isArrayLiteral() {
    return Array.isArray(this.value);
  }
  accept(visitor, context2) {
    return visitor.visitObjectLiteralExpr(this, context2);
  }
};
var HasAttributeExpr3 = class extends Expr3 {
  constructor(name2) {
    super();
    this.name = name2;
  }
  accept(visitor, context2) {
    return visitor.visitHasAttributeExpr(this, context2);
  }
  exprIsDynamic() {
    return false;
  }
};
var CallExpr7 = class extends Expr3 {
  constructor(op, args) {
    super();
    this.op = op;
    this.args = args;
  }
  descriptor;
  get children() {
    return this.args;
  }
  accept(visitor, context2) {
    return visitor.visitCallExpr(this, context2);
  }
  exprIsDynamic() {
    const descriptor = this.descriptor ?? ExprEvaluator.getOperator(this.op);
    if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {
      return true;
    }
    return this.args.some((e) => e.isDynamic());
  }
};
var LookupExpr3 = class extends CallExpr7 {
  constructor(args) {
    super("lookup", args);
    this.args = args;
  }
  static parseArray(node, referenceResolverState) {
    const lookupTableNode = node[1];
    if (lookupTableNode === void 0) {
      throw new Error("missing lookup table in 'lookup' expression");
    }
    const lookupTableExpr = parseNode(lookupTableNode, referenceResolverState);
    if (!Array.isArray(lookupTableNode) || !(lookupTableExpr instanceof ObjectLiteralExpr)) {
      throw new Error(`Invalid lookup table expression for operator 'lookup'. It must be a literal or a ref to one.`);
    }
    const lookupTable = lookupTableExpr.value;
    if (!Array.isArray(lookupTable)) {
      throw new Error(`Invalid lookup table type (${typeof lookupTable}) for operator 'lookup'`);
    }
    const args = node.slice(2).map((childExpr) => parseNode(childExpr, referenceResolverState));
    args.unshift(lookupTableExpr);
    return new LookupExpr3(args);
  }
  accept(visitor, context2) {
    return visitor.visitLookupExpr(this, context2);
  }
};
var MatchExpr2 = class extends Expr3 {
  constructor(value2, branches, fallback) {
    super();
    this.value = value2;
    this.branches = branches;
    this.fallback = fallback;
  }
  static isValidMatchLabel(node) {
    switch (typeof node) {
      case "number":
      case "string":
        return true;
      case "object":
        if (!Array.isArray(node) || node.length === 0) {
          return false;
        }
        const elementTy = typeof node[0];
        if (elementTy === "number" || elementTy === "string") {
          return node.every((t) => typeof t === elementTy);
        }
        return false;
      default:
        return false;
    }
  }
  accept(visitor, context2) {
    return visitor.visitMatchExpr(this, context2);
  }
  exprIsDynamic() {
    return this.value.isDynamic() || this.branches.some(([_, branch]) => branch.isDynamic()) || this.fallback.isDynamic();
  }
};
var CaseExpr = class extends Expr3 {
  constructor(branches, fallback) {
    super();
    this.branches = branches;
    this.fallback = fallback;
  }
  accept(visitor, context2) {
    return visitor.visitCaseExpr(this, context2);
  }
  exprIsDynamic() {
    return this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) || this.fallback.isDynamic();
  }
};
var StepExpr = class extends Expr3 {
  constructor(input, defaultValue, stops) {
    super();
    this.input = input;
    this.defaultValue = defaultValue;
    this.stops = stops;
  }
  accept(visitor, context2) {
    return visitor.visitStepExpr(this, context2);
  }
  exprIsDynamic() {
    return this.input.isDynamic() || this.defaultValue.isDynamic() || this.stops.some(([_, value2]) => value2.isDynamic());
  }
};
var InterpolateExpr = class extends Expr3 {
  constructor(mode, input, stops) {
    super();
    this.mode = mode;
    this.input = input;
    this.stops = stops;
  }
  accept(visitor, context2) {
    return visitor.visitInterpolateExpr(this, context2);
  }
  exprIsDynamic() {
    return this.input.isDynamic() || this.stops.some(([_, value2]) => value2.isDynamic());
  }
};
var ExprSerializer = class {
  serialize(expr) {
    return expr.accept(this, void 0);
  }
  visitNullLiteralExpr(expr, context2) {
    return null;
  }
  visitBooleanLiteralExpr(expr, context2) {
    return expr.value;
  }
  visitNumberLiteralExpr(expr, context2) {
    return expr.value;
  }
  visitStringLiteralExpr(expr, context2) {
    return expr.value;
  }
  visitObjectLiteralExpr(expr, context2) {
    if (expr.value instanceof THREE14.Vector2) {
      return ["make-vector", expr.value.x, expr.value.y];
    } else if (expr.value instanceof THREE14.Vector3) {
      return ["make-vector", expr.value.x, expr.value.y, expr.value.z];
    } else if (expr.value instanceof THREE14.Vector4) {
      return [
        "make-vector",
        expr.value.x,
        expr.value.y,
        expr.value.z,
        expr.value.w
      ];
    }
    return ["literal", expr.value];
  }
  visitVarExpr(expr, context2) {
    return ["get", expr.name];
  }
  visitHasAttributeExpr(expr, context2) {
    return ["has", expr.name];
  }
  visitCallExpr(expr, context2) {
    return [
      expr.op,
      ...expr.args.map((childExpr) => this.serialize(childExpr))
    ];
  }
  visitLookupExpr(expr, context2) {
    return this.visitCallExpr(expr, context2);
  }
  visitMatchExpr(expr, context2) {
    const branches = [];
    for (const [label, body] of expr.branches) {
      branches.push(label, this.serialize(body));
    }
    return [
      "match",
      this.serialize(expr.value),
      ...branches,
      this.serialize(expr.fallback)
    ];
  }
  visitCaseExpr(expr, context2) {
    const branches = [];
    for (const [condition, body] of expr.branches) {
      branches.push(this.serialize(condition), this.serialize(body));
    }
    return ["case", ...branches, this.serialize(expr.fallback)];
  }
  visitStepExpr(expr, context2) {
    const result = ["step"];
    result.push(this.serialize(expr.input));
    result.push(this.serialize(expr.defaultValue));
    expr.stops.forEach(([key, value2]) => {
      result.push(key);
      result.push(this.serialize(value2));
    });
    return result;
  }
  visitInterpolateExpr(expr, context2) {
    const result = ["interpolate", expr.mode];
    result.push(this.serialize(expr.input));
    expr.stops.forEach(([key, value2]) => {
      result.push(key);
      result.push(this.serialize(value2));
    });
    return result;
  }
};
function parseNode(node, referenceResolverState) {
  if (Array.isArray(node)) {
    return parseCall(node, referenceResolverState);
  } else if (node === null) {
    return NullLiteralExpr3.instance;
  } else if (typeof node === "boolean") {
    return new BooleanLiteralExpr3(node);
  } else if (typeof node === "number") {
    return new NumberLiteralExpr(node);
  } else if (typeof node === "string") {
    return new StringLiteralExpr(node);
  }
  throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);
}
function parseCall(node, referenceResolverState) {
  const op = node[0];
  if (typeof op !== "string") {
    throw new Error("expected a builtin function name");
  }
  switch (op) {
    case "!has":
    case "!in":
      return new CallExpr7("!", [
        parseCall([op.slice(1), ...node.slice(1)])
      ]);
    case "ref":
      return resolveReference(node, referenceResolverState);
    case "get":
      return parseGetExpr(node, referenceResolverState);
    case "has":
      return parseHasExpr(node, referenceResolverState);
    case "literal":
      return parseLiteralExpr(node);
    case "match":
      return parseMatchExpr(node, referenceResolverState);
    case "case":
      return parseCaseExpr(node, referenceResolverState);
    case "interpolate":
      return parseInterpolateExpr(node, referenceResolverState);
    case "step":
      return parseStepExpr(node, referenceResolverState);
    case "lookup":
      return LookupExpr3.parseArray(node, referenceResolverState);
    default:
      return makeCallExpr(op, node, referenceResolverState);
  }
}
function parseGetExpr(node, referenceResolverState) {
  if (node[2] !== void 0) {
    return makeCallExpr("get", node, referenceResolverState);
  }
  const name2 = node[1];
  if (typeof name2 !== "string") {
    throw new Error(`expected the name of an attribute`);
  }
  return new VarExpr3(name2);
}
function parseHasExpr(node, referenceResolverState) {
  if (node[2] !== void 0) {
    return makeCallExpr("has", node, referenceResolverState);
  }
  const name2 = node[1];
  if (typeof name2 !== "string") {
    throw new Error(`expected the name of an attribute`);
  }
  return new HasAttributeExpr3(name2);
}
function parseLiteralExpr(node) {
  const obj = node[1];
  if (obj === null || typeof obj !== "object") {
    throw new Error("expected an object or array literal");
  }
  return new ObjectLiteralExpr(obj);
}
function parseMatchExpr(node, referenceResolverState) {
  if (node.length < 4) {
    throw new Error("not enough arguments");
  }
  if (!(node.length % 2)) {
    throw new Error("fallback is missing in 'match' expression");
  }
  const value2 = parseNode(node[1], referenceResolverState);
  const conditions = [];
  for (let i = 2; i < node.length - 1; i += 2) {
    const label = node[i];
    if (!MatchExpr2.isValidMatchLabel(label)) {
      throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);
    }
    const expr = parseNode(node[i + 1], referenceResolverState);
    conditions.push([label, expr]);
  }
  const fallback = parseNode(node[node.length - 1], referenceResolverState);
  return new MatchExpr2(value2, conditions, fallback);
}
function parseCaseExpr(node, referenceResolverState) {
  if (node.length < 3) {
    throw new Error("not enough arguments");
  }
  if (node.length % 2) {
    throw new Error("fallback is missing in 'case' expression");
  }
  const branches = [];
  for (let i = 1; i < node.length - 1; i += 2) {
    const condition = parseNode(node[i], referenceResolverState);
    const expr = parseNode(node[i + 1], referenceResolverState);
    branches.push([condition, expr]);
  }
  const caseFallback = parseNode(node[node.length - 1], referenceResolverState);
  return new CaseExpr(branches, caseFallback);
}
function isInterpolationMode(object) {
  if (!Array.isArray(object)) {
    return false;
  }
  switch (object[0]) {
    case "discrete":
    case "linear":
    case "cubic":
    case "exponential":
      return true;
    default:
      return false;
  }
}
function parseInterpolateExpr(node, referenceResolverState) {
  const mode = node[1];
  if (!isInterpolationMode(mode)) {
    throw new Error("expected an interpolation type");
  }
  if (mode[0] === "exponential" && typeof mode[1] !== "number") {
    throw new Error("expected the base of the exponential interpolation");
  }
  const input = node[2] !== void 0 ? parseNode(node[2], referenceResolverState) : void 0;
  if (!Expr3.isExpr(input)) {
    throw new Error(`expected the input of the interpolation`);
  }
  if (node.length === 3 || !(node.length % 2)) {
    throw new Error("invalid number of samples");
  }
  const stops = [];
  for (let i = 3; i < node.length - 1; i += 2) {
    const key = node[i];
    const value2 = parseNode(node[i + 1], referenceResolverState);
    stops.push([key, value2]);
  }
  return new InterpolateExpr(mode, input, stops);
}
function parseStepExpr(node, referenceResolverState) {
  if (node.length < 2) {
    throw new Error("expected the input of the 'step' operator");
  }
  if (node.length < 3 || !(node.length % 2)) {
    throw new Error("not enough arguments");
  }
  const input = parseNode(node[1], referenceResolverState);
  const defaultValue = parseNode(node[2], referenceResolverState);
  const stops = [];
  for (let i = 3; i < node.length; i += 2) {
    const key = node[i];
    const value2 = parseNode(node[i + 1], referenceResolverState);
    stops.push([key, value2]);
  }
  return new StepExpr(input, defaultValue, stops);
}
function makeCallExpr(op, node, referenceResolverState) {
  return new CallExpr7(op, node.slice(1).map((childExpr) => parseNode(childExpr, referenceResolverState)));
}
function resolveReference(node, referenceResolverState) {
  if (typeof node[1] !== "string") {
    throw new Error(`expected the name of an attribute`);
  }
  if (referenceResolverState === void 0) {
    throw new Error(`ref used with no definitions`);
  }
  const name2 = node[1];
  if (referenceResolverState.lockedNames.has(name2)) {
    throw new Error(`circular referene to '${name2}'`);
  }
  if (!(name2 in referenceResolverState.definitions)) {
    throw new Error(`definition '${name2}' not found`);
  }
  const cachedEntry = referenceResolverState.cache.get(name2);
  if (cachedEntry !== void 0) {
    return cachedEntry;
  }
  let definitionEntry = referenceResolverState.definitions[name2];
  let result;
  const definitionValue = getDefinitionValue(definitionEntry);
  if (isInterpolatedPropertyDefinition(definitionValue)) {
    return Expr3.fromJSON(interpolatedPropertyDefinitionToJsonExpr(definitionEntry));
  } else if (isJsonExpr(definitionValue)) {
    definitionEntry = definitionValue;
  } else {
    return Expr3.fromJSON(definitionValue);
  }
  if (isJsonExpr(definitionEntry)) {
    referenceResolverState.lockedNames.add(name2);
    try {
      result = parseNode(definitionEntry, referenceResolverState);
    } finally {
      referenceResolverState.lockedNames.delete(name2);
    }
  } else {
    throw new Error(`unsupported definition ${name2}`);
  }
  referenceResolverState.cache.set(name2, result);
  return result;
}

// src/datasource-protocol/PropertyValue.ts
var logger = LoggerManager.instance.create("PropertyValue");
function getPropertyValue(property, env, cache6) {
  if (Expr3.isExpr(property)) {
    try {
      let r = property.evaluate(env, 2 /* Dynamic */, cache6);
      if (typeof r === "string") {
        r = RGBA.parse(r) ?? Pixels.parse(r) ?? r;
      }
      if (r instanceof RGBA) {
        return r.getHex();
      } else if (r instanceof Pixels) {
        return r.value * (Number(env.lookup("$pixelToMeters")) ?? 1);
      }
      return r;
    } catch (error) {
      logger.error("failed to evaluate expression", JSON.stringify(property), "error", String(error));
      return null;
    }
  }
  if (property === null || typeof property === "undefined") {
    return null;
  } else if (typeof property !== "string") {
    return property;
  } else {
    const pixelToMeters = env.lookup("$pixelToMeters") || 1;
    const value2 = parseStringEncodedNumeral(property, pixelToMeters);
    return value2 !== void 0 ? value2 : property;
  }
}

// src/datasource-protocol/TechniqueParams.ts
var StandardGeometryKind = /* @__PURE__ */ ((StandardGeometryKind2) => {
  StandardGeometryKind2["All"] = "_all_";
  StandardGeometryKind2["Background"] = "background";
  StandardGeometryKind2["Terrain"] = "terrain";
  StandardGeometryKind2["Area"] = "area";
  StandardGeometryKind2["Line"] = "line";
  StandardGeometryKind2["Water"] = "water";
  StandardGeometryKind2["Border"] = "border";
  StandardGeometryKind2["Road"] = "road";
  StandardGeometryKind2["Building"] = "building";
  StandardGeometryKind2["Label"] = "label";
  StandardGeometryKind2["Detail"] = "detail";
  return StandardGeometryKind2;
})(StandardGeometryKind || {});
var GeometryKind = StandardGeometryKind;
var GeometryKindSet = class extends Set {
  isSuperset(subset) {
    for (const elem of subset) {
      if (!this.has(elem)) {
        return false;
      }
    }
    return true;
  }
  hasIntersection(set) {
    for (const elem of set) {
      if (this.has(elem)) {
        return true;
      }
    }
    return false;
  }
  hasOrIntersects(set) {
    if (set instanceof Set) {
      return this.hasIntersection(set);
    }
    return this.has(set);
  }
  hasOrIntersectsArray(subset) {
    for (const elem of subset) {
      if (this.has(elem)) {
        return true;
      }
    }
    return false;
  }
};
function transientToPickability(transient) {
  let pickability = "only-visible" /* onlyVisible */;
  if (transient !== void 0 && transient !== null) {
    pickability = typeof transient === "string" ? transient : transient === true ? "transient" /* transient */ : "only-visible" /* onlyVisible */;
  }
  return pickability;
}
function isTextureBuffer(object) {
  return object && object.buffer && typeof object.type === "string";
}

// src/datasource-protocol/Techniques.ts
var TEXTURE_PROPERTY_KEYS = [
  "map",
  "normalMap",
  "displacementMap",
  "roughnessMap",
  "emissiveMap",
  "alphaMap",
  "metalnessMap",
  "bumpMap"
];
var TRANSPARENCY_PROPERTY_KEYS = ["opacity", "transparent"];
function isCirclesTechnique(technique) {
  return technique.name === "circles";
}
function isSquaresTechnique(technique) {
  return technique.name === "squares";
}
function isPoiTechnique(technique) {
  return technique.name === "labeled-icon";
}
function isLineMarkerTechnique(technique) {
  return technique.name === "line-marker";
}
function isLineTechnique(technique) {
  return technique.name === "line";
}
function isSolidLineTechnique(technique) {
  return technique.name === "solid-line" || technique.name === "dashed-line";
}
function isSegmentsTechnique(technique) {
  return technique.name === "segments";
}
function isExtrudedLineTechnique(technique) {
  return technique.name === "extruded-line";
}
function isStandardExtrudedLineTechnique(technique) {
  return isExtrudedLineTechnique(technique) && technique.shading === "standard";
}
function isFillTechnique(technique) {
  return technique.name === "fill";
}
function isExtrudedPolygonTechnique(technique) {
  return technique.name === "extruded-polygon";
}
function isStandardTechnique(technique) {
  return technique.name === "standard";
}
function isTerrainTechnique(technique) {
  return technique.name === "terrain";
}
function isTextTechnique(technique) {
  return technique.name === "text";
}
function isShaderTechnique(technique) {
  return technique.name === "shader";
}
function needsVertexNormals(technique) {
  return isExtrudedPolygonTechnique(technique) || isFillTechnique(technique) || isStandardTechnique(technique) || isTerrainTechnique(technique) || isStandardExtrudedLineTechnique(technique);
}
function supportsTextures(technique) {
  return isFillTechnique(technique) || isStandardTechnique(technique) || isExtrudedPolygonTechnique(technique) || isTerrainTechnique(technique);
}
function composeTechniqueTextureName(imageName, technique) {
  let textureName = imageName;
  if (typeof technique.imageTexturePrefix === "string") {
    textureName = technique.imageTexturePrefix + textureName;
  }
  if (typeof technique.imageTexturePostfix === "string") {
    textureName = textureName + technique.imageTexturePostfix;
  }
  return textureName;
}
function setTechniqueRenderOrderOrPriority(technique, priorities, labelPriorities) {
  if (isTextTechnique(technique) || isPoiTechnique(technique) || isLineMarkerTechnique(technique)) {
    if (labelPriorities && typeof technique._category === "string") {
      const priority = labelPriorities.indexOf(technique._category);
      if (priority !== -1) {
        technique.priority = labelPriorities.length - priority;
      }
    }
  } else if (priorities && technique._styleSet !== void 0) {
    const computeRenderOrder = (category) => {
      const priority = priorities == null ? void 0 : priorities.findIndex((entry) => entry.group === technique._styleSet && entry.category === category);
      return priority !== void 0 && priority !== -1 ? (priority + 1) * 10 : void 0;
    };
    if (typeof technique._category === "string") {
      const renderOrder = computeRenderOrder(technique._category);
      if (renderOrder !== void 0) {
        technique.renderOrder = renderOrder;
      }
    }
    if (typeof technique._secondaryCategory === "string") {
      const secondaryRenderOrder = computeRenderOrder(technique._secondaryCategory);
      if (secondaryRenderOrder !== void 0) {
        ;
        technique.secondaryRenderOrder = secondaryRenderOrder;
      }
    }
  }
}

// src/datasource-protocol/DecodedTile.ts
function getArrayConstructor(attr) {
  switch (attr) {
    case "float":
      return Float32Array;
    case "uint8":
      return Uint8Array;
    case "uint16":
      return Uint16Array;
    case "uint32":
      return Uint32Array;
    case "int8":
      return Int8Array;
    case "int16":
      return Int16Array;
    case "int32":
      return Int32Array;
  }
}
function getProjectionName(projection) {
  if (projection === mercatorProjection) {
    return "mercator";
  } else if (projection === webMercatorProjection) {
    return "webMercator";
  } else if (projection === sphereProjection) {
    return "sphere";
  } else if (projection === normalizedEquirectangularProjection) {
    return "normalizedEquirectangular";
  } else if (projection === equirectangularProjection) {
    return "equirectangular";
  }
  throw new Error("Unknown projection");
}
function getFeatureId(attributeMap) {
  if (attributeMap === void 0) {
    return 0;
  }
  if (typeof attributeMap === "string" || typeof attributeMap === "number") {
    return attributeMap;
  } else if (attributeMap.hasOwnProperty("$id")) {
    const id = attributeMap.$id;
    if (typeof id === "string" || typeof id === "number") {
      return id;
    }
  }
  return 0;
}

// src/datasource-protocol/ExprPool.ts
var ExprPool = class {
  m_booleanLiterals = /* @__PURE__ */ new Map();
  m_numberLiterals = /* @__PURE__ */ new Map();
  m_stringLiterals = /* @__PURE__ */ new Map();
  m_objectLiterals = /* @__PURE__ */ new Map();
  m_arrayLiterals = [];
  m_varExprs = /* @__PURE__ */ new Map();
  m_hasAttributeExprs = /* @__PURE__ */ new Map();
  m_matchExprs = [];
  m_caseExprs = [];
  m_interpolateExprs = [];
  m_stepExprs = [];
  m_callExprs = /* @__PURE__ */ new Map();
  add(expr) {
    return expr.accept(this, void 0);
  }
  visitNullLiteralExpr(expr, context2) {
    return NullLiteralExpr3.instance;
  }
  visitBooleanLiteralExpr(expr, context2) {
    const e = this.m_booleanLiterals.get(expr.value);
    if (e) {
      return e;
    }
    this.m_booleanLiterals.set(expr.value, expr);
    return expr;
  }
  visitNumberLiteralExpr(expr, context2) {
    const e = this.m_numberLiterals.get(expr.value);
    if (e) {
      return e;
    }
    this.m_numberLiterals.set(expr.value, expr);
    return expr;
  }
  visitStringLiteralExpr(expr, context2) {
    const e = this.m_stringLiterals.get(expr.value);
    if (e) {
      return e;
    }
    this.m_stringLiterals.set(expr.value, expr);
    return expr;
  }
  visitObjectLiteralExpr(expr, context2) {
    const e = this.m_objectLiterals.get(expr.value);
    if (e) {
      return e;
    }
    if (Array.isArray(expr.value)) {
      const array = expr.value;
      const r = this.m_arrayLiterals.find((literal) => {
        const elements = literal.value;
        if (elements.length !== array.length) {
          return false;
        }
        return array.every((x, i) => x === elements[i]);
      });
      if (r !== void 0) {
        return r;
      }
      this.m_arrayLiterals.push(expr);
    }
    this.m_objectLiterals.set(expr.value, expr);
    return expr;
  }
  visitVarExpr(expr, context2) {
    const e = this.m_varExprs.get(expr.name);
    if (e) {
      return e;
    }
    this.m_varExprs.set(expr.name, expr);
    return expr;
  }
  visitHasAttributeExpr(expr, context2) {
    const e = this.m_hasAttributeExprs.get(expr.name);
    if (e) {
      return e;
    }
    this.m_hasAttributeExprs.set(expr.name, expr);
    return expr;
  }
  visitMatchExpr(expr, context2) {
    const value2 = expr.value.accept(this, context2);
    const branches = expr.branches.map(([label, body]) => [label, body.accept(this, context2)]);
    const fallback = expr.fallback.accept(this, context2);
    for (const candidate of this.m_matchExprs) {
      if (candidate.value !== value2) {
        continue;
      }
      if (candidate.fallback !== fallback) {
        continue;
      }
      if (candidate.branches.length !== branches.length) {
        continue;
      }
      let branchesMatching = true;
      for (let i = 0; i < branches.length; i++) {
        if (branches[i][0] !== candidate.branches[i][0] || branches[i][1] !== candidate.branches[i][1]) {
          branchesMatching = false;
          break;
        }
      }
      if (branchesMatching) {
        return candidate;
      }
    }
    const r = new MatchExpr2(value2, branches, fallback);
    this.m_matchExprs.push(r);
    return r;
  }
  visitCaseExpr(expr, context2) {
    const branches = expr.branches.map(([condition, body]) => [
      condition.accept(this, context2),
      body.accept(this, context2)
    ]);
    const fallback = expr.fallback.accept(this, context2);
    for (const candidate of this.m_caseExprs) {
      if (candidate.fallback !== fallback) {
        continue;
      }
      if (candidate.branches.length !== branches.length) {
        continue;
      }
      let branchesMatching = true;
      for (let i = 0; i < branches.length; i++) {
        if (branches[i][0] !== candidate.branches[i][0] || branches[i][1] !== candidate.branches[i][1]) {
          branchesMatching = false;
          break;
        }
      }
      if (branchesMatching) {
        return candidate;
      }
    }
    const r = new CaseExpr(branches, fallback);
    this.m_caseExprs.push(r);
    return r;
  }
  visitCallExprImpl(expr, context2, constructor) {
    const expressions = expr.args.map((childExpr) => childExpr.accept(this, context2));
    if (!this.m_callExprs.has(expr.op)) {
      this.m_callExprs.set(expr.op, []);
    }
    const calls = this.m_callExprs.get(expr.op);
    for (const call of calls) {
      if (call.args.length !== expressions.length) {
        continue;
      }
      let index = 0;
      for (; index < call.args.length; ++index) {
        if (call.args[index] !== expressions[index]) {
          break;
        }
      }
      if (index === call.args.length) {
        return call;
      }
    }
    const e = constructor(expr.op, expressions);
    e.descriptor = expr.descriptor;
    calls.push(e);
    return e;
  }
  visitCallExpr(expr, context2) {
    return this.visitCallExprImpl(expr, context2, (op, args) => {
      return new CallExpr7(op, args);
    });
  }
  visitLookupExpr(expr, context2) {
    return this.visitCallExprImpl(expr, context2, (op, args) => {
      return new LookupExpr3(args);
    });
  }
  visitStepExpr(expr, context2) {
    if (this.m_stepExprs.includes(expr)) {
      return expr;
    }
    const input = expr.input.accept(this, context2);
    const defaultValue = expr.defaultValue.accept(this, context2);
    const stops = expr.stops.map((stop) => {
      const key = stop[0];
      const value2 = stop[1].accept(this, context2);
      return value2 === stop[1] ? stop : [key, value2];
    });
    for (const step of this.m_stepExprs) {
      if (step.input === input && step.defaultValue === defaultValue && stops.length === step.stops.length && stops.every(([key, value2], i) => key === step.stops[i][0] && value2 === step.stops[i][1])) {
        return step;
      }
    }
    const e = new StepExpr(input, defaultValue, stops);
    this.m_stepExprs.push(e);
    return e;
  }
  visitInterpolateExpr(expr, context2) {
    if (this.m_interpolateExprs.includes(expr)) {
      return expr;
    }
    const input = expr.input.accept(this, context2);
    const stops = expr.stops.map((stop) => {
      const key = stop[0];
      const value2 = stop[1].accept(this, context2);
      return value2 === stop[1] ? stop : [key, value2];
    });
    for (const interp of this.m_interpolateExprs) {
      if (interp.input === input && interp.mode[0] === expr.mode[0] && interp.mode[1] === expr.mode[1] && stops.length === interp.stops.length && stops.every(([key, value2], i) => key === interp.stops[i][0] && value2 === interp.stops[i][1])) {
        return interp;
      }
    }
    const e = new InterpolateExpr(expr.mode, input, stops);
    this.m_interpolateExprs.push(e);
    return e;
  }
};

// src/datasource-protocol/TechniqueDescriptors.ts
function mergeTechniqueDescriptor(...descriptors) {
  const result = {
    attrDescriptors: {}
  };
  for (const descriptor of descriptors) {
    if (descriptor.attrTransparencyColor !== void 0) {
      result.attrTransparencyColor = descriptor.attrTransparencyColor;
    }
    if (descriptor.attrDescriptors !== void 0) {
      result.attrDescriptors = {
        ...result.attrDescriptors,
        ...descriptor.attrDescriptors
      };
    }
  }
  return result;
}
var baseTechniqueParamsDescriptor = {
  attrTransparencyColor: "color",
  attrDescriptors: {
    constantHeight: 0 /* FeatureGeometry */,
    enabled: 0 /* FeatureGeometry */,
    fadeFar: 2 /* TechniqueRendering */,
    fadeNear: 2 /* TechniqueRendering */,
    transparent: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    side: { scope: 2 /* TechniqueRendering */, automatic: true }
  }
};
var pointTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
  attrDescriptors: {
    color: { scope: 2 /* TechniqueRendering */, automatic: true },
    size: { scope: 2 /* TechniqueRendering */, automatic: true },
    opacity: { scope: 2 /* TechniqueRendering */, automatic: true }
  }
});
var squaresTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);
var circlesTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);
var lineMarkerTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
  attrDescriptors: {
    text: 0 /* FeatureGeometry */,
    label: 0 /* FeatureGeometry */,
    useAbbreviation: 0 /* FeatureGeometry */,
    useIsoCode: 0 /* FeatureGeometry */,
    poiName: 0 /* FeatureGeometry */,
    imageTexture: 0 /* FeatureGeometry */,
    iconColor: 2 /* TechniqueRendering */,
    iconBrightness: 2 /* TechniqueRendering */,
    backgroundColor: 2 /* TechniqueRendering */,
    backgroundSize: 2 /* TechniqueRendering */,
    backgroundOpacity: 2 /* TechniqueRendering */,
    color: 2 /* TechniqueRendering */,
    opacity: 2 /* TechniqueRendering */,
    size: 2 /* TechniqueRendering */
  }
});
var polygonalTechniqueDescriptor = {
  attrDescriptors: {
    polygonOffset: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    polygonOffsetFactor: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    polygonOffsetUnits: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    depthTest: { scope: 2 /* TechniqueRendering */, automatic: true },
    transparent: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    opacity: { scope: 2 /* TechniqueRendering */, automatic: true },
    color: { scope: 2 /* TechniqueRendering */, automatic: true },
    lineColor: 2 /* TechniqueRendering */,
    lineFadeFar: 2 /* TechniqueRendering */,
    lineFadeNear: 2 /* TechniqueRendering */
  }
};
var solidLineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
  attrDescriptors: {
    lineWidth: 2 /* TechniqueRendering */,
    secondaryWidth: 2 /* TechniqueRendering */,
    secondaryColor: 2 /* TechniqueRendering */,
    dashSize: 2 /* TechniqueRendering */,
    gapSize: 2 /* TechniqueRendering */,
    outlineColor: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    caps: { scope: 2 /* TechniqueRendering */, automatic: true },
    drawRangeStart: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    drawRangeEnd: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    dashes: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    dashColor: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    }
  }
});
var lineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
  attrDescriptors: {
    color: { scope: 2 /* TechniqueRendering */, automatic: true },
    opacity: { scope: 2 /* TechniqueRendering */, automatic: true },
    lineWidth: 0 /* FeatureGeometry */
  }
});
var fillTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
  attrDescriptors: {
    wireframe: { scope: 2 /* TechniqueRendering */, automatic: true },
    color: { scope: 2 /* TechniqueRendering */, automatic: true },
    opacity: { scope: 2 /* TechniqueRendering */, automatic: true },
    transparent: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    lineWidth: 2 /* TechniqueRendering */,
    map: { scope: 2 /* TechniqueRendering */, automatic: true }
  }
});
var standardTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
  attrDescriptors: {
    color: { scope: 2 /* TechniqueRendering */, automatic: true },
    vertexColors: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    wireframe: { scope: 2 /* TechniqueRendering */, automatic: true },
    roughness: { scope: 2 /* TechniqueRendering */, automatic: true },
    metalness: { scope: 2 /* TechniqueRendering */, automatic: true },
    alphaTest: { scope: 2 /* TechniqueRendering */, automatic: true },
    depthTest: { scope: 2 /* TechniqueRendering */, automatic: true },
    transparent: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    opacity: { scope: 2 /* TechniqueRendering */, automatic: true },
    emissive: { scope: 2 /* TechniqueRendering */, automatic: true },
    emissiveIntensity: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    refractionRatio: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    normalMapType: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    map: { scope: 2 /* TechniqueRendering */, automatic: true },
    normalMap: { scope: 2 /* TechniqueRendering */, automatic: true },
    displacementMap: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    roughnessMap: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    emissiveMap: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    bumpMap: { scope: 2 /* TechniqueRendering */, automatic: true },
    metalnessMap: {
      scope: 2 /* TechniqueRendering */,
      automatic: true
    },
    alphaMap: { scope: 2 /* TechniqueRendering */, automatic: true }
  }
});
var extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {
  attrDescriptors: {
    height: 0 /* FeatureGeometry */,
    floorHeight: 0 /* FeatureGeometry */,
    color: 0 /* FeatureGeometry */,
    defaultColor: 0 /* FeatureGeometry */,
    defaultHeight: 0 /* FeatureGeometry */,
    boundaryWalls: 0 /* FeatureGeometry */,
    footprint: 0 /* FeatureGeometry */,
    maxSlope: 0 /* FeatureGeometry */,
    animateExtrusion: 2 /* TechniqueRendering */,
    lineWidth: 2 /* TechniqueRendering */,
    lineFadeNear: 2 /* TechniqueRendering */,
    lineFadeFar: 2 /* TechniqueRendering */,
    lineColor: 2 /* TechniqueRendering */
  }
});
var textTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
  attrDescriptors: {
    text: 0 /* FeatureGeometry */,
    label: 0 /* FeatureGeometry */,
    useAbbreviation: 0 /* FeatureGeometry */,
    useIsoCode: 0 /* FeatureGeometry */,
    backgroundColor: 2 /* TechniqueRendering */,
    backgroundSize: 2 /* TechniqueRendering */,
    backgroundOpacity: 2 /* TechniqueRendering */,
    color: 2 /* TechniqueRendering */,
    opacity: 2 /* TechniqueRendering */,
    priority: 2 /* TechniqueRendering */,
    size: 2 /* TechniqueRendering */
  }
});
var shaderTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
  attrDescriptors: {
    params: 2 /* TechniqueRendering */
  }
});
var techniqueDescriptors = {
  "extruded-polygon": extrudedPolygonTechniqueDescriptor,
  "line-marker": lineMarkerTechniquePropTypes,
  "labeled-icon": lineMarkerTechniquePropTypes,
  "solid-line": solidLineTechniqueDescriptor,
  "dashed-line": solidLineTechniqueDescriptor,
  terrain: standardTechniqueDescriptor,
  standard: standardTechniqueDescriptor,
  squares: squaresTechniquePropTypes,
  circles: circlesTechniquePropTypes,
  line: lineTechniqueDescriptor,
  segments: lineTechniqueDescriptor,
  fill: fillTechniqueDescriptor,
  text: textTechniqueDescriptor,
  shader: shaderTechniqueDescriptor
};
function getTechniqueDescriptor(technique) {
  if (typeof technique !== "string") {
    technique = technique.name;
  }
  return techniqueDescriptors[technique];
}
function getTechniqueAttributeDescriptor(technique, attrName) {
  const techniqueDescriptor = getTechniqueDescriptor(technique);
  const attrDescriptors = techniqueDescriptor == null ? void 0 : techniqueDescriptor.attrDescriptors;
  const descriptor = attrDescriptors == null ? void 0 : attrDescriptors[attrName];
  if (typeof descriptor === void 0) {
    return void 0;
  } else if (typeof descriptor === "object") {
    return descriptor;
  }
  return { scope: descriptor };
}
var automaticAttributeCache = /* @__PURE__ */ new Map();
function getTechniqueAutomaticAttrs(technique) {
  var _a;
  if (typeof technique !== "string") {
    technique = technique.name;
  }
  if (automaticAttributeCache.has(technique)) {
    return automaticAttributeCache.get(technique);
  }
  const descriptors = [];
  const attrDescriptors = (_a = getTechniqueDescriptor(technique)) == null ? void 0 : _a.attrDescriptors;
  if (attrDescriptors === void 0) {
    return descriptors;
  }
  for (const attrName in attrDescriptors) {
    if (!attrDescriptors.hasOwnProperty(attrName)) {
      continue;
    }
    const descr = attrDescriptors[attrName];
    if (descr === void 0 || typeof descr === "number") {
      continue;
    }
    if (descr.automatic === true) {
      descriptors.push(attrName);
    }
  }
  automaticAttributeCache.set(technique, descriptors);
  return descriptors;
}

// src/datasource-protocol/WorkerDecoderProtocol.ts
var RequestController = class {
  constructor(priority = 0, abortController = new AbortController()) {
    this.priority = priority;
    this.abortController = abortController;
  }
  get signal() {
    return this.abortController.signal;
  }
  abort() {
    this.abortController.abort();
  }
};
var WorkerDecoderProtocol;
((WorkerDecoderProtocol2) => {
  let DecoderMessageName;
  ((DecoderMessageName2) => {
    DecoderMessageName2["Configuration"] = "configuration";
  })(DecoderMessageName = WorkerDecoderProtocol2.DecoderMessageName || (WorkerDecoderProtocol2.DecoderMessageName = {}));
  function isConfigurationMessage(message) {
    return message && typeof message.service === "string" && typeof message.type === "string" && message.type === "configuration" /* Configuration */;
  }
  WorkerDecoderProtocol2.isConfigurationMessage = isConfigurationMessage;
  let Requests;
  ((Requests2) => {
    Requests2["DecodeTileRequest"] = "decode-tile-request";
    Requests2["TileInfoRequest"] = "tile-info-request";
  })(Requests = WorkerDecoderProtocol2.Requests || (WorkerDecoderProtocol2.Requests = {}));
  function isDecodeTileRequest(message) {
    return message && typeof message.type === "string" && message.type === "decode-tile-request" /* DecodeTileRequest */;
  }
  WorkerDecoderProtocol2.isDecodeTileRequest = isDecodeTileRequest;
  function isTileInfoRequest(message) {
    return message && typeof message.type === "string" && message.type === "tile-info-request" /* TileInfoRequest */;
  }
  WorkerDecoderProtocol2.isTileInfoRequest = isTileInfoRequest;
})(WorkerDecoderProtocol || (WorkerDecoderProtocol = {}));

// src/datasource-protocol/WorkerServiceProtocol.ts
var WorkerServiceProtocol;
((WorkerServiceProtocol2) => {
  WorkerServiceProtocol2.WORKER_SERVICE_MANAGER_SERVICE_ID = "worker-service-manager";
  let ServiceMessageName;
  ((ServiceMessageName2) => {
    ServiceMessageName2["Initialized"] = "initialized";
    ServiceMessageName2["Request"] = "request";
    ServiceMessageName2["Response"] = "response";
  })(ServiceMessageName = WorkerServiceProtocol2.ServiceMessageName || (WorkerServiceProtocol2.ServiceMessageName = {}));
  function isInitializedMessage(message) {
    return message && typeof message.service === "string" && typeof message.type === "string" && message.type === "initialized" /* Initialized */;
  }
  WorkerServiceProtocol2.isInitializedMessage = isInitializedMessage;
  let Requests;
  ((Requests2) => {
    Requests2["CreateService"] = "create-service";
    Requests2["DestroyService"] = "destroy-service";
  })(Requests = WorkerServiceProtocol2.Requests || (WorkerServiceProtocol2.Requests = {}));
  function isUnknownServiceError(error) {
    return error.message.includes("unknown targetServiceType requested: ");
  }
  WorkerServiceProtocol2.isUnknownServiceError = isUnknownServiceError;
  function isRequestMessage(message) {
    return message && typeof message.service === "string" && typeof message.type === "string" && message.type === "request" /* Request */;
  }
  WorkerServiceProtocol2.isRequestMessage = isRequestMessage;
  function isResponseMessage(message) {
    return message && typeof message.service === "string" && typeof message.type === "string" && message.type === "response" /* Response */;
  }
  WorkerServiceProtocol2.isResponseMessage = isResponseMessage;
})(WorkerServiceProtocol || (WorkerServiceProtocol = {}));

// src/datasource-protocol/WorkerTilerProtocol.ts
var WorkerTilerProtocol;
((WorkerTilerProtocol2) => {
  let Requests;
  ((Requests2) => {
    Requests2["RegisterIndex"] = "register-index";
    Requests2["UpdateIndex"] = "update-index";
    Requests2["TileRequest"] = "tile-request";
  })(Requests = WorkerTilerProtocol2.Requests || (WorkerTilerProtocol2.Requests = {}));
  function isRegisterIndexRequest(message) {
    return message && typeof message.type === "string" && message.type === "register-index" /* RegisterIndex */;
  }
  WorkerTilerProtocol2.isRegisterIndexRequest = isRegisterIndexRequest;
  function isUpdateIndexRequest(message) {
    return message && typeof message.type === "string" && message.type === "update-index" /* UpdateIndex */;
  }
  WorkerTilerProtocol2.isUpdateIndexRequest = isUpdateIndexRequest;
  function isTileRequest(message) {
    return message && typeof message.type === "string" && message.type === "tile-request" /* TileRequest */;
  }
  WorkerTilerProtocol2.isTileRequest = isTileRequest;
})(WorkerTilerProtocol || (WorkerTilerProtocol = {}));

// src/materials/CirclePointsMaterial.ts
var THREE17 = __toESM(require("three"));

// src/materials/RawShaderMaterial.ts
var THREE16 = __toESM(require("three"));

// src/materials/Utils.ts
var THREE15 = __toESM(require("three"));
var DEFINE_BOOL_TRUE = "";
var DEFINE_BOOL_FALSE = void 0;
function insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {
  const tabChar = addTab === true ? "	" : "";
  const result = shaderContent.replace(`#include <${shaderName}>`, `#include <${shaderName}>
${tabChar}#include <${insertedShaderName}>`);
  return result;
}
function enforceBlending(material) {
  if (material.transparent) {
    return;
  }
  enableBlending(material);
  material.forcedBlending = true;
}
function enableBlending(material) {
  if (material.transparent === true || material.forcedBlending === true) {
    return;
  }
  material.blending = THREE15.CustomBlending;
  if (material.premultipliedAlpha === true) {
    material.blendSrc = THREE15.OneFactor;
    material.blendDst = THREE15.OneMinusSrcAlphaFactor;
    material.blendSrcAlpha = THREE15.OneFactor;
    material.blendDstAlpha = THREE15.OneMinusSrcAlphaFactor;
  } else {
    material.blendSrc = THREE15.SrcAlphaFactor;
    material.blendDst = THREE15.OneMinusSrcAlphaFactor;
    material.blendSrcAlpha = THREE15.OneFactor;
    material.blendDstAlpha = THREE15.OneMinusSrcAlphaFactor;
  }
}
function disableBlending(material) {
  if (material.transparent === true || material.forcedBlending === true) {
    return;
  }
  material.blending = THREE15.NormalBlending;
}
function setShaderMaterialDefine(material, key, value2) {
  assert(material.defines !== void 0, "Do not use this function in ShaderMaterial derived c-tor.");
  const semanticValue = getShaderMaterialDefine(material, key);
  const needsUpdate = value2 !== semanticValue;
  if (!needsUpdate) {
    return false;
  }
  setShaderDefine(material.defines, key, value2);
  material.needsUpdate = needsUpdate;
  return true;
}
function getShaderMaterialDefine(material, key, fallbackValue = false) {
  if (material.defines === void 0) {
    return fallbackValue;
  }
  return getShaderDefine(material.defines, key);
}
function setShaderDefine(defines, key, value2) {
  let updated = false;
  if (typeof value2 === "number") {
    updated = defines[key] !== value2;
    defines[key] = value2;
  } else if (value2 === true) {
    updated = defines[key] !== DEFINE_BOOL_TRUE;
    defines[key] = DEFINE_BOOL_TRUE;
  } else if (value2 === false && defines[key] !== void 0) {
    delete defines[key];
    updated = true;
  }
  return updated;
}
function getShaderDefine(defines, key) {
  const currentValue = defines[key];
  const semanticValue = currentValue === DEFINE_BOOL_FALSE ? false : currentValue === DEFINE_BOOL_TRUE ? true : currentValue;
  return semanticValue;
}

// src/materials/RawShaderMaterial.ts
var RawShaderMaterial2 = class extends THREE16.RawShaderMaterial {
  constructor(params) {
    const isWebGL2 = (params == null ? void 0 : params.rendererCapabilities.isWebGL2) === true;
    const shaderParams = params ? {
      ...params,
      glslVersion: isWebGL2 ? THREE16.GLSL3 : THREE16.GLSL1,
      vertexShader: isWebGL2 && params.vertexShader ? convertVertexShaderToWebGL2(params.vertexShader) : params.vertexShader,
      fragmentShader: isWebGL2 && params.fragmentShader ? convertFragmentShaderToWebGL2(params.fragmentShader) : params.fragmentShader
    } : void 0;
    if (shaderParams) {
      delete shaderParams.rendererCapabilities;
    }
    super(shaderParams);
    this.invalidateFog();
    this.setOpacity(shaderParams == null ? void 0 : shaderParams.opacity);
  }
  invalidateFog() {
    if (this.defines !== void 0 && this.fog !== getShaderMaterialDefine(this, "USE_FOG")) {
      setShaderMaterialDefine(this, "USE_FOG", this.fog);
    }
  }
  setOpacity(opacity) {
    var _a;
    if (opacity !== void 0) {
      this.opacity = opacity;
      if ((_a = this.uniforms) == null ? void 0 : _a.opacity) {
        this.uniforms.opacity.value = opacity;
      }
    }
  }
};

// src/materials/CirclePointsMaterial.ts
var vertexShader = `
uniform float size;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

attribute vec3 position;

void main() {
    vec3 transformed = vec3(position);
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
}
`;
var fragmentShader = `
precision highp float;
precision highp int;

uniform vec3 diffuseColor;
uniform float opacity;

void main() {
    float alpha = opacity;

    float radius = 0.5;
    vec2 coords = gl_PointCoord.xy - vec2(0.5);
    float len = length(coords);
    float falloff = fwidth(len);
    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);
    alpha *= threshold;

    gl_FragColor = vec4(diffuseColor, alpha);
}`;
var _CirclePointsMaterial = class extends RawShaderMaterial2 {
  constructor(parameters) {
    const defaultColor = new THREE17.Color();
    const defaultOpacity = 1;
    let sizeValue, colorValue, opacityValue;
    let shaderParameters;
    if (parameters) {
      const { size, color, opacity, ...shaderParams } = parameters;
      sizeValue = size;
      colorValue = color;
      opacityValue = opacity;
      shaderParams.name = "CirclePointsMaterial";
      shaderParams.vertexShader = vertexShader;
      shaderParams.fragmentShader = fragmentShader;
      shaderParams.uniforms = THREE17.UniformsUtils.merge([
        {
          size: new THREE17.Uniform(_CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),
          diffuseColor: new THREE17.Uniform(defaultColor),
          opacity: new THREE17.Uniform(defaultOpacity)
        },
        THREE17.UniformsLib.fog
      ]);
      shaderParams.depthTest = false;
      shaderParams.extensions = {
        ...shaderParams.extensions,
        derivatives: true
      };
      shaderParameters = shaderParams;
    }
    super(shaderParameters);
    enforceBlending(this);
    this.type = "CirclePointsMaterial";
    this.setOpacity(defaultOpacity);
    if (sizeValue !== void 0) {
      this.size = sizeValue;
    }
    if (colorValue !== void 0) {
      this.color = colorValue;
    }
    if (opacityValue !== void 0) {
      this.setOpacity(opacityValue);
    }
  }
  get size() {
    return this.uniforms.size.value;
  }
  set size(size) {
    this.uniforms.size.value = size;
  }
  get color() {
    return this.uniforms.diffuseColor.value;
  }
  set color(value2) {
    this.uniforms.diffuseColor.value.copy(value2);
  }
};
var CirclePointsMaterial = _CirclePointsMaterial;
__publicField(CirclePointsMaterial, "DEFAULT_CIRCLE_SIZE", 1);

// src/materials/CopyMaterial.ts
var THREE18 = __toESM(require("three"));
var CopyShader = {
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
  fragmentShader: `
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
    }`
};
var CopyMaterial = class extends THREE18.ShaderMaterial {
  constructor(uniforms) {
    super({
      name: "CopyMaterial",
      uniforms,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      premultipliedAlpha: true,
      transparent: false,
      blending: THREE18.NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
};

// src/materials/DisplacementFeature.ts
function hasDisplacementFeature(material) {
  return "displacementMap" in material;
}
function setDisplacementMapToMaterial(displacementMap, material) {
  if (hasDisplacementFeature(material) && material.displacementMap !== displacementMap) {
    material.displacementMap = displacementMap;
    material.needsUpdate = true;
    if (material.displacementMap !== null) {
      material.displacementMap.needsUpdate = true;
    }
  }
}

// src/materials/EdgeMaterial.ts
var THREE20 = __toESM(require("three"));

// src/materials/MapMeshMaterials.ts
var THREE19 = __toESM(require("three"));

// src/materials/MapMeshMaterialsDefs.ts
var ExtrusionFeatureDefs;
((ExtrusionFeatureDefs2) => {
  ExtrusionFeatureDefs2.DEFAULT_RATIO_MIN = 0;
  ExtrusionFeatureDefs2.DEFAULT_RATIO_MAX = 1;
  ExtrusionFeatureDefs2.MIN_BUILDING_HEIGHT = 0.1;
})(ExtrusionFeatureDefs || (ExtrusionFeatureDefs = {}));

// src/materials/ShaderChunks/ExtrusionChunks.ts
var MIN_BUILDING_HEIGHT_SQUARED = ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;
var ExtrusionChunks_default = {
  extrusion_pars_vertex: `
// Add define so we can check for it in the outline effect (see Outline.ts).
#define HAS_EXTRUSION_PARS_VERTEX
// Extrusion axis (xyz: vector, w: factor).
attribute vec4 extrusionAxis;
uniform float extrusionRatio;
#ifdef FLAT_SHADED
varying vec4 vExtrusionAxis;
#endif
#ifdef ZFIGHTING_WORKAROUND
varying float vExtrusionRatio;
#endif
`,
  extrusion_vertex: `
#define HAS_EXTRUSION_VERTEX
#ifdef ZFIGHTING_WORKAROUND
// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.
const float MIN_BUILDING_HEIGHT_SQUARED = ${MIN_BUILDING_HEIGHT_SQUARED};
float extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);
vExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;
#else
float vExtrusionRatio = extrusionRatio;
#endif
transformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);
#ifdef FLAT_SHADED
vExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);
#endif
`,
  extrusion_normal_fragment_begin: `
#ifdef FLAT_SHADED
    // Flattened this divergent path to prevent undefined behaviour in the following derivatives
    // functions. For more info:
    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches

    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...
    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));
    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));
    vec3 normal = cross( fdx, fdy );
    if (vExtrusionAxis.w > 0.999999) {
        normal = vExtrusionAxis.xyz;
    }
    normal = normalize(normal);
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);
			bitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);
		#endif
	#endif
#endif
// non perturbed normal for clearcoat among others
vec3 geometryNormal = normal;
`,
  extrusion_pars_fragment: `
#ifdef ZFIGHTING_WORKAROUND
varying float vExtrusionRatio;
#else
uniform float extrusionRatio;
#endif
varying vec4 vExtrusionAxis;
`,
  extrusion_fragment: `
#ifndef ZFIGHTING_WORKAROUND
float vExtrusionRatio = extrusionRatio;
#endif
gl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );
`
};

// src/materials/ShaderChunks/FadingChunks.ts
var FadingChunks_default = {
  fading_pars_vertex: `
varying float fadingDepth;
`,
  fading_vertex: `
fadingDepth = -mvPosition.z;
`,
  fading_pars_fragment: `
varying float fadingDepth;
uniform float fadeNear;
uniform float fadeFar;
`,
  fading_fragment: `

// lerp with "hard" edges
//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);

// smooth transitions
float fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );

gl_FragColor.a *= 1.0 - fadingFactor;

// debugging color:
// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);
`
};

// src/materials/ShaderChunks/ShadowChunks.ts
var simpleLightingShadowChunk = `
    struct PhysicalMaterial {
        vec3	diffuseColor;
        float	specularRoughness;
        vec3	specularColor;
    };

    #define DEFAULT_SPECULAR_COEFFICIENT 0.04

    void RE_Direct_Physical( const in IncidentLight directLight,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight ) {
        // directLight.color is the light color * shadow, internally three.js uses a step function, so
        // this value is either the light color or black. in order to lighten up the shadows, we
        // take add 50% of the color to grey (to give us either pure white or grey) and multiply this to
        // the material's diffuse color.
        #if defined(USE_SHADOWMAP)
            reflectedLight.directDiffuse = (0.5 * directLight.color +
                vec3(0.5,0.5,0.5)) * material.diffuseColor;
        #else
            reflectedLight.directDiffuse = material.diffuseColor;
        #endif
    }

    void RE_IndirectDiffuse_Physical( const in vec3 irradiance,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight ) {
            // Disable influence of indirect light (it is handled in the RE_Direct_Physical function)
    }

    void RE_IndirectSpecular_Physical( const in vec3 radiance,
        const in vec3 irradiance,
        const in vec3 clearcoatRadiance,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight) {
            // Disable specular reflection of light.
    }

    #define RE_Direct               RE_Direct_Physical
    #define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical
    #define RE_IndirectSpecular     RE_IndirectSpecular_Physical
`;

// src/materials/MapMeshMaterials.ts
var emptyTexture = new THREE19.Texture();
function cameraToWorldDistance(distance, visibilityRange) {
  return distance * visibilityRange.maximum;
}
function linkMixinWithMaterial(mixin, material) {
  if (material.defines === void 0) {
    material.defines = {};
  }
  mixin.shaderDefines = material.defines;
  if (mixin.shaderUniforms === void 0) {
    mixin.shaderUniforms = {};
  }
}
function linkMixinWithShader(mixin, shader) {
  Object.assign(shader.uniforms, mixin.shaderUniforms);
  mixin.shaderUniforms = shader.uniforms;
}
function hasExtrusionFeature(material) {
  return "extrusionRatio" in material;
}
var DisplacementFeature;
((DisplacementFeature3) => {
  function isEnabled(displacementMaterial) {
    return displacementMaterial.displacementMap !== null;
  }
  DisplacementFeature3.isEnabled = isEnabled;
  function updateDisplacementFeature(displacementMaterial) {
    assert(displacementMaterial.shaderDefines !== void 0);
    assert(displacementMaterial.shaderUniforms !== void 0);
    const useDisplacementMap = isEnabled(displacementMaterial);
    const needsUpdate = setShaderDefine(displacementMaterial.shaderDefines, "USE_DISPLACEMENTMAP", useDisplacementMap);
    displacementMaterial.needsUpdate = needsUpdate;
    if (useDisplacementMap) {
      const texture = displacementMaterial.displacementMap;
      texture.needsUpdate = true;
      displacementMaterial.shaderUniforms.displacementMap.value = texture;
    } else if (needsUpdate) {
      displacementMaterial.shaderUniforms.displacementMap.value = emptyTexture;
    }
  }
  DisplacementFeature3.updateDisplacementFeature = updateDisplacementFeature;
  function onBeforeCompile(displacementMaterial, shader) {
    if (!isEnabled(displacementMaterial)) {
      return;
    }
    assert(displacementMaterial.shaderUniforms !== void 0);
    linkMixinWithShader(displacementMaterial, shader);
    shader.vertexShader = shader.vertexShader.replace("#include <skinbase_vertex>", `#include <skinbase_vertex>
#ifndef USE_ENVMAP
    vec3 objectNormal = vec3( normal );
#endif`);
    shader.vertexShader = insertShaderInclude(shader.vertexShader, "uv2_pars_vertex", "displacementmap_pars_vertex");
    shader.vertexShader = insertShaderInclude(shader.vertexShader, "skinning_vertex", "displacementmap_vertex", true);
  }
  DisplacementFeature3.onBeforeCompile = onBeforeCompile;
})(DisplacementFeature || (DisplacementFeature = {}));
var DisplacementFeatureMixin = class {
  needsUpdate;
  uniformsNeedUpdate;
  defines;
  shaderDefines;
  shaderUniforms;
  onBeforeCompile;
  m_displacementMap = null;
  get displacementMap() {
    return this.m_displacementMap;
  }
  set displacementMap(map) {
    this.setDisplacementMap(map);
  }
  getDisplacementMap() {
    return this.m_displacementMap;
  }
  setDisplacementMap(map) {
    if (map !== this.m_displacementMap) {
      this.m_displacementMap = map;
      DisplacementFeature.updateDisplacementFeature(this);
    }
  }
  addDisplacementProperties() {
    Object.defineProperty(this, "displacementMap", {
      get: () => {
        return this.getDisplacementMap();
      },
      set: (val) => {
        this.setDisplacementMap(val);
      }
    });
  }
  applyDisplacementParameters(params) {
    linkMixinWithMaterial(this, this);
    assert(this.shaderDefines !== void 0);
    assert(this.shaderUniforms !== void 0);
    const uniforms = this.shaderUniforms;
    uniforms.displacementMap = new THREE19.Uniform(emptyTexture);
    uniforms.displacementScale = new THREE19.Uniform(1);
    uniforms.displacementBias = new THREE19.Uniform(0);
    if (params !== void 0) {
      if (params.displacementMap !== void 0) {
        this.setDisplacementMap(params.displacementMap);
      }
    }
    this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader) => {
      DisplacementFeature.onBeforeCompile(this, shader);
    });
    this.needsUpdate = DisplacementFeature.isEnabled(this);
  }
  copyDisplacementParameters(source) {
    this.setDisplacementMap(source.displacementMap);
    return this;
  }
};
var FadingFeature;
((FadingFeature2) => {
  FadingFeature2.DEFAULT_FADE_NEAR = -1;
  FadingFeature2.DEFAULT_FADE_FAR = -1;
  function isEnabled(fadingMaterial) {
    return fadingMaterial.fadeNear !== void 0 && fadingMaterial.fadeFar !== void 0 && fadingMaterial.fadeFar > 0;
  }
  FadingFeature2.isEnabled = isEnabled;
  function isDefined(fadingMaterial) {
    return fadingMaterial.fadeNear !== void 0 && fadingMaterial.fadeFar !== void 0;
  }
  FadingFeature2.isDefined = isDefined;
  function patchGlobalShaderChunks() {
    if (THREE19.ShaderChunk.fading_pars_vertex === void 0) {
      Object.assign(THREE19.ShaderChunk, FadingChunks_default);
    }
  }
  FadingFeature2.patchGlobalShaderChunks = patchGlobalShaderChunks;
  function updateFadingFeature(fadingMaterial) {
    assert(fadingMaterial.shaderDefines !== void 0);
    assert(fadingMaterial.shaderUniforms !== void 0);
    const useFading = isEnabled(fadingMaterial);
    const needsUpdate = setShaderDefine(fadingMaterial.shaderDefines, "FADING_MATERIAL", useFading);
    fadingMaterial.needsUpdate = needsUpdate;
    assert(fadingMaterial.shaderUniforms.fadeNear !== void 0 && fadingMaterial.shaderUniforms.fadeFar !== void 0);
    if (useFading) {
      fadingMaterial.shaderUniforms.fadeNear.value = fadingMaterial.fadeNear;
      fadingMaterial.shaderUniforms.fadeFar.value = fadingMaterial.fadeFar;
      if (needsUpdate) {
        enableBlending(fadingMaterial);
      }
    } else if (needsUpdate) {
      fadingMaterial.shaderUniforms.fadeNear.value = FadingFeature2.DEFAULT_FADE_NEAR;
      fadingMaterial.shaderUniforms.fadeFar.value = FadingFeature2.DEFAULT_FADE_FAR;
      disableBlending(fadingMaterial);
    }
  }
  FadingFeature2.updateFadingFeature = updateFadingFeature;
  function onBeforeCompile(fadingMaterial, shader) {
    if (!isEnabled(fadingMaterial)) {
      return;
    }
    assert(fadingMaterial.shaderUniforms !== void 0);
    linkMixinWithShader(fadingMaterial, shader);
    shader.vertexShader = insertShaderInclude(shader.vertexShader, "fog_pars_vertex", "fading_pars_vertex");
    shader.vertexShader = insertShaderInclude(shader.vertexShader, "fog_vertex", "fading_vertex", true);
    shader.fragmentShader = insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "fading_pars_fragment");
    shader.fragmentShader = insertShaderInclude(shader.fragmentShader, "fog_fragment", "fading_fragment", true);
  }
  FadingFeature2.onBeforeCompile = onBeforeCompile;
  function addRenderHelper(object, viewRanges, fadeNear, fadeFar, updateUniforms, additionalCallback) {
    object.onBeforeRender = chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
      const fadingMaterial = material;
      fadingMaterial.fadeNear = fadeNear === void 0 || fadeNear === FadingFeature2.DEFAULT_FADE_NEAR ? FadingFeature2.DEFAULT_FADE_NEAR : cameraToWorldDistance(fadeNear, viewRanges);
      fadingMaterial.fadeFar = fadeFar === void 0 || fadeFar === FadingFeature2.DEFAULT_FADE_FAR ? FadingFeature2.DEFAULT_FADE_FAR : cameraToWorldDistance(fadeFar, viewRanges);
      if (additionalCallback !== void 0) {
        additionalCallback(renderer, material);
      }
    });
  }
  FadingFeature2.addRenderHelper = addRenderHelper;
})(FadingFeature || (FadingFeature = {}));
var FadingFeatureMixin = class {
  needsUpdate;
  uniformsNeedUpdate;
  defines;
  shaderDefines;
  shaderUniforms;
  onBeforeCompile;
  m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;
  m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;
  getFadeNear() {
    return this.m_fadeNear;
  }
  setFadeNear(value2) {
    const needsUpdate = value2 !== this.m_fadeNear;
    if (needsUpdate) {
      this.m_fadeNear = value2;
      FadingFeature.updateFadingFeature(this);
    }
  }
  getFadeFar() {
    return this.m_fadeFar;
  }
  setFadeFar(value2) {
    const needsUpdate = value2 !== this.m_fadeFar;
    if (needsUpdate) {
      this.m_fadeFar = value2;
      FadingFeature.updateFadingFeature(this);
    }
  }
  addFadingProperties() {
    Object.defineProperty(this, "fadeNear", {
      get: () => {
        return this.getFadeNear();
      },
      set: (val) => {
        this.setFadeNear(val);
      }
    });
    Object.defineProperty(this, "fadeFar", {
      get: () => {
        return this.getFadeFar();
      },
      set: (val) => {
        this.setFadeFar(val);
      }
    });
  }
  applyFadingParameters(params) {
    linkMixinWithMaterial(this, this);
    assert(this.shaderDefines !== void 0);
    assert(this.shaderUniforms !== void 0);
    this.shaderUniforms.fadeNear = new THREE19.Uniform(FadingFeature.DEFAULT_FADE_NEAR);
    this.shaderUniforms.fadeFar = new THREE19.Uniform(FadingFeature.DEFAULT_FADE_FAR);
    if (params !== void 0) {
      if (params.fadeNear !== void 0) {
        this.setFadeNear(params.fadeNear);
      }
      if (params.fadeFar !== void 0) {
        this.setFadeFar(params.fadeFar);
      }
    }
    this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader) => {
      FadingFeature.onBeforeCompile(this, shader);
    });
    this.needsUpdate = FadingFeature.isEnabled(this);
  }
  copyFadingParameters(source) {
    this.setFadeNear(source.fadeNear === void 0 ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);
    this.setFadeFar(source.fadeFar === void 0 ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);
    return this;
  }
};
var ExtrusionFeature;
((ExtrusionFeature4) => {
  function isEnabled(extrusionMaterial) {
    return extrusionMaterial.extrusionRatio !== void 0 && extrusionMaterial.extrusionRatio >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
  }
  ExtrusionFeature4.isEnabled = isEnabled;
  function patchGlobalShaderChunks() {
    if (THREE19.ShaderChunk.extrusion_pars_vertex === void 0) {
      Object.assign(THREE19.ShaderChunk, ExtrusionChunks_default);
    }
  }
  ExtrusionFeature4.patchGlobalShaderChunks = patchGlobalShaderChunks;
  function updateExtrusionFeature(extrusionMaterial) {
    assert(extrusionMaterial.shaderDefines !== void 0);
    assert(extrusionMaterial.shaderUniforms !== void 0);
    const useExtrusion = isEnabled(extrusionMaterial);
    const needsUpdate = setShaderDefine(extrusionMaterial.shaderDefines, "EXTRUSION_MATERIAL", useExtrusion);
    extrusionMaterial.needsUpdate = needsUpdate;
    if (useExtrusion) {
      extrusionMaterial.shaderUniforms.extrusionRatio.value = extrusionMaterial.extrusionRatio;
    } else if (needsUpdate) {
      extrusionMaterial.shaderUniforms.extrusionRatio.value = ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
  }
  ExtrusionFeature4.updateExtrusionFeature = updateExtrusionFeature;
  function onBeforeCompile(extrusionMaterial, shader) {
    if (!isEnabled(extrusionMaterial)) {
      return;
    }
    assert(extrusionMaterial.shaderUniforms !== void 0);
    linkMixinWithShader(extrusionMaterial, shader);
    shader.vertexShader = insertShaderInclude(shader.vertexShader, "common", "extrusion_pars_vertex");
    shader.vertexShader = insertShaderInclude(shader.vertexShader, "begin_vertex", "extrusion_vertex", true);
    shader.fragmentShader = insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "extrusion_pars_fragment");
    shader.fragmentShader = shader.fragmentShader.replace("#include <normal_fragment_begin>", "#include <extrusion_normal_fragment_begin>");
    shader.fragmentShader = insertShaderInclude(shader.fragmentShader, "fog_fragment", "extrusion_fragment", true);
  }
  ExtrusionFeature4.onBeforeCompile = onBeforeCompile;
})(ExtrusionFeature || (ExtrusionFeature = {}));
var ExtrusionFeatureMixin = class {
  needsUpdate;
  uniformsNeedUpdate;
  defines;
  shaderDefines;
  shaderUniforms;
  onBeforeCompile;
  m_extrusion = ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
  getExtrusionRatio() {
    return this.m_extrusion;
  }
  setExtrusionRatio(value2) {
    const needsUpdate = value2 !== this.m_extrusion;
    if (needsUpdate) {
      this.m_extrusion = value2;
      ExtrusionFeature.updateExtrusionFeature(this);
    }
  }
  addExtrusionProperties() {
    Object.defineProperty(this, "extrusionRatio", {
      get: () => {
        return this.getExtrusionRatio();
      },
      set: (val) => {
        this.setExtrusionRatio(val);
      }
    });
  }
  applyExtrusionParameters(params) {
    linkMixinWithMaterial(this, this);
    assert(this.shaderDefines !== void 0);
    assert(this.shaderUniforms !== void 0);
    if (params && params.zFightingWorkaround === true) {
      this.shaderDefines.ZFIGHTING_WORKAROUND = "";
    }
    this.shaderUniforms.extrusionRatio = new THREE19.Uniform(ExtrusionFeatureDefs.DEFAULT_RATIO_MAX);
    if (params !== void 0) {
      if (params.extrusionRatio !== void 0) {
        this.setExtrusionRatio(params.extrusionRatio);
      }
    }
    this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader) => {
      ExtrusionFeature.onBeforeCompile(this, shader);
    });
    this.needsUpdate = ExtrusionFeature.isEnabled(this);
  }
  copyExtrusionParameters(source) {
    if (source.extrusionRatio !== void 0) {
      this.setExtrusionRatio(source.extrusionRatio);
    }
    return this;
  }
};
var MapMeshBasicMaterial = class extends THREE19.MeshBasicMaterial {
  constructor(params) {
    super(params);
    FadingFeature.patchGlobalShaderChunks();
    this.addFadingProperties();
    this.applyFadingParameters(params);
    ExtrusionFeature.patchGlobalShaderChunks();
    this.addExtrusionProperties();
    this.applyExtrusionParameters({ ...params, zFightingWorkaround: true });
    this.addDisplacementProperties();
    this.applyDisplacementParameters(params);
  }
  clone() {
    return new MapMeshBasicMaterial().copy(this);
  }
  copy(source) {
    super.copy(source);
    this.copyFadingParameters(source);
    this.copyExtrusionParameters(source);
    this.copyDisplacementParameters(source);
    return this;
  }
  get fadeNear() {
    return FadingFeature.DEFAULT_FADE_NEAR;
  }
  set fadeNear(value2) {
  }
  get fadeFar() {
    return FadingFeature.DEFAULT_FADE_FAR;
  }
  set fadeFar(value2) {
  }
  get extrusionRatio() {
    return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
  }
  set extrusionRatio(value2) {
  }
  get displacementMap() {
    return null;
  }
  set displacementMap(value2) {
  }
  setDisplacementMap(value2) {
  }
  addFadingProperties() {
  }
  applyFadingParameters(params) {
  }
  copyFadingParameters(source) {
  }
  addExtrusionProperties() {
  }
  applyExtrusionParameters(params) {
  }
  copyExtrusionParameters(source) {
  }
  addDisplacementProperties() {
  }
  applyDisplacementParameters(params) {
  }
  copyDisplacementParameters(source) {
  }
};
var MapMeshDepthMaterial = class extends THREE19.MeshDepthMaterial {
  constructor(params) {
    super(params);
    ExtrusionFeature.patchGlobalShaderChunks();
    this.addExtrusionProperties();
    this.applyExtrusionParameters({ ...params, zFightingWorkaround: false });
  }
  get extrusionRatio() {
    return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
  }
  set extrusionRatio(value2) {
  }
  addExtrusionProperties() {
  }
  applyExtrusionParameters(params) {
  }
  copyExtrusionParameters(source) {
  }
};
var MapMeshStandardMaterial = class extends THREE19.MeshStandardMaterial {
  uniformsNeedUpdate;
  constructor(params) {
    super(params);
    FadingFeature.patchGlobalShaderChunks();
    this.addFadingProperties();
    this.applyFadingParameters(params);
    ExtrusionFeature.patchGlobalShaderChunks();
    this.addExtrusionProperties();
    this.applyExtrusionParameters({ ...params, zFightingWorkaround: true });
    if ((params == null ? void 0 : params.removeDiffuseLight) === true) {
      this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shaderParameters) => {
        const shader = shaderParameters;
        shader.fragmentShader = THREE19.ShaderChunk.meshphysical_frag.replace("#include <lights_physical_pars_fragment>", simpleLightingShadowChunk);
      });
    }
  }
  clone() {
    return new MapMeshStandardMaterial().copy(this);
  }
  copy(source) {
    super.copy(source);
    this.copyFadingParameters(source);
    this.copyExtrusionParameters(source);
    return this;
  }
  get fadeNear() {
    return FadingFeature.DEFAULT_FADE_NEAR;
  }
  set fadeNear(value2) {
  }
  get fadeFar() {
    return FadingFeature.DEFAULT_FADE_FAR;
  }
  set fadeFar(value2) {
  }
  get extrusionRatio() {
    return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
  }
  set extrusionRatio(value2) {
  }
  get removeDiffuseLight() {
    return false;
  }
  set removeDiffuseLight(val) {
  }
  addFadingProperties() {
  }
  applyFadingParameters(params) {
  }
  copyFadingParameters(source) {
  }
  addExtrusionProperties() {
  }
  applyExtrusionParameters(params) {
  }
  copyExtrusionParameters(source) {
  }
};
applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);
applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);
applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);
applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);
applyMixinsWithoutProperties(MapMeshDepthMaterial, [ExtrusionFeatureMixin]);
applyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);

// src/materials/EdgeMaterial.ts
var vertexSource = `
#define EDGE_DEPTH_OFFSET 0.0001

#ifdef USE_COLOR
attribute vec4 color;
#else
uniform vec3 color;
#endif

// SHADER_NAME may be defined by THREE.JS own shaders in which case these attributes & uniforms are
// already defined
#ifndef SHADER_NAME
attribute vec3 position;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
#endif

uniform vec3 edgeColor;
uniform float edgeColorMix;

#ifdef USE_DISPLACEMENTMAP
attribute vec3 normal;
attribute vec2 uv;
uniform sampler2D displacementMap;
#endif

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_vertex>
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

void main() {

    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);

    vec3 transformed = vec3( position );

    #ifdef USE_EXTRUSION
    #include <extrusion_vertex>
    #endif

    #ifdef USE_DISPLACEMENTMAP
    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );

    gl_Position = projectionMatrix * mvPosition;
    // After projection gl_Position contains clip space coordinates of each vertex
    // before perspective division (1 / w), thus only vertexes with -w < z < w should
    // be displayed and offset. We offset only those edges which z coordinate in NDC
    // space is between: -inf < z < 1
    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;
    gl_Position.z -= depthOffset;

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif
}`;
var fragmentSource = `
precision highp float;
precision highp int;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

void main() {
    float alphaValue = 1.0;
    gl_FragColor = vec4(vColor, alphaValue);

    #ifdef USE_EXTRUSION
    #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
var _EdgeMaterial = class extends RawShaderMaterial2 {
  constructor(params) {
    let shaderParams;
    if (params) {
      const defines = {};
      const hasExtrusion = params.extrusionRatio !== void 0 && params.extrusionRatio >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN && params.extrusionRatio < ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
      if (params.displacementMap) {
        setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
      }
      if (hasExtrusion) {
        setShaderDefine(defines, "USE_EXTRUSION", true);
      }
      if (params.vertexColors === true) {
        setShaderDefine(defines, "USE_COLOR", true);
      }
      shaderParams = {
        name: "EdgeMaterial",
        vertexShader: vertexSource,
        fragmentShader: fragmentSource,
        uniforms: {
          color: new THREE20.Uniform(new THREE20.Color(_EdgeMaterial.DEFAULT_COLOR)),
          edgeColor: new THREE20.Uniform(new THREE20.Color(_EdgeMaterial.DEFAULT_COLOR)),
          edgeColorMix: new THREE20.Uniform(_EdgeMaterial.DEFAULT_COLOR_MIX),
          fadeNear: new THREE20.Uniform(FadingFeature.DEFAULT_FADE_NEAR),
          fadeFar: new THREE20.Uniform(FadingFeature.DEFAULT_FADE_FAR),
          extrusionRatio: new THREE20.Uniform(ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),
          displacementMap: new THREE20.Uniform(params.displacementMap ?? new THREE20.Texture())
        },
        depthWrite: false,
        defines,
        rendererCapabilities: params.rendererCapabilities
      };
    }
    super(shaderParams);
    enforceBlending(this);
    FadingFeature.patchGlobalShaderChunks();
    ExtrusionFeature.patchGlobalShaderChunks();
    if (params !== void 0) {
      if (params.color !== void 0) {
        this.color.set(params.color);
      }
      if (params.colorMix !== void 0) {
        this.colorMix = params.colorMix;
      }
      if (params.fadeNear !== void 0) {
        this.fadeNear = params.fadeNear;
      }
      if (params.fadeFar !== void 0) {
        this.fadeFar = params.fadeFar;
      }
      if (params.displacementMap !== void 0) {
        this.displacementMap = params.displacementMap;
      }
      if (params.extrusionRatio !== void 0) {
        this.extrusionRatio = params.extrusionRatio;
      }
    }
  }
  get objectColor() {
    return this.uniforms.color.value;
  }
  set objectColor(value2) {
    this.uniforms.color.value.copy(value2);
  }
  get color() {
    return this.uniforms.edgeColor.value;
  }
  set color(value2) {
    this.uniforms.edgeColor.value.copy(value2);
  }
  get lineWidth() {
    return this.linewidth;
  }
  set lineWidth(value2) {
    this.linewidth = value2;
    if (this.linewidth <= 0) {
      this.visible = false;
    } else {
      this.visible = true;
    }
  }
  get colorMix() {
    return this.uniforms.edgeColorMix.value;
  }
  set colorMix(value2) {
    if (this.uniforms.edgeColorMix.value === value2) {
      return;
    }
    this.uniforms.edgeColorMix.value = value2;
  }
  get fadeNear() {
    return this.uniforms.fadeNear.value;
  }
  set fadeNear(value2) {
    this.uniforms.fadeNear.value = value2;
  }
  get fadeFar() {
    return this.uniforms.fadeFar.value;
  }
  set fadeFar(value2) {
    if (this.uniforms.fadeFar.value === value2) {
      return;
    }
    this.uniforms.fadeFar.value = value2;
    setShaderMaterialDefine(this, "USE_FADING", value2 > 0);
  }
  get extrusionRatio() {
    return this.uniforms.extrusionRatio.value;
  }
  set extrusionRatio(value2) {
    if (this.uniforms.extrusionRatio.value === value2) {
      return;
    }
    this.uniforms.extrusionRatio.value = value2;
    const useExtrusion = value2 >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
    setShaderMaterialDefine(this, "USE_EXTRUSION", useExtrusion);
  }
  get displacementMap() {
    return this.uniforms.displacementMap.value;
  }
  set displacementMap(map) {
    if (this.uniforms.displacementMap.value === map) {
      return;
    }
    this.uniforms.displacementMap.value = map;
    const useDisplacementMap = map !== null;
    if (useDisplacementMap) {
      this.uniforms.displacementMap.value.needsUpdate = true;
    }
    setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
  }
};
var EdgeMaterial = _EdgeMaterial;
__publicField(EdgeMaterial, "DEFAULT_COLOR", 0);
__publicField(EdgeMaterial, "DEFAULT_COLOR_MIX", 0);

// src/materials/GroundAtmosphereMaterial.ts
var THREE21 = __toESM(require("three"));

// src/materials/ShaderChunks/AtmosphereChunks.ts
var AtmosphereChunks_default = {
  atmosphere_vertex_utils: `

    const float RayleighScaleDepth = 0.25;

    struct AtmosphereColor
    {
        vec3 mie;
        vec3 rayleigh;
    };

    float scale(float cosAngle)
    {
        float x = 1.0 - cosAngle;
        return RayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
    }

    float getNearSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {
        // Solve simple square equation for the x0 (first point of intersection).
#if defined(IMPROVE_INTERSECT_PRECISION)
        // To improve precision instead of simple projection: b = 2.0 * dot(vPos, v3Ray),
        // we change the equation that gives better results especially around the poles.
        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);
#else
        float fB = 2.0 * dot(v3Pos, v3Ray);
#endif
        float fC = fCameraHeight2 - fOuterRadius2;
        // det = b^2 - 4*a*c, where a = 1
        float fDet = max(0.0, fB * fB - 4.0 * fC);
        // Intersection points distances are defined as follows:
        // x0 = (-b - sqrt(det)) / 2*a ^ x1 = (-b + sqrt(det)) / 2*a
        // we search for x0:
        return 0.5 * (-fB - sqrt(fDet));
    }

    float getFarSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {
        // Solve simple square equation for the x1 (second point of intersection).
#if defined(IMPROVE_INTERSECT_PRECISION)
        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);
#else
        float fB = 2.0 * dot(v3Pos, v3Ray);
#endif
        float fC = fCameraHeight2 - fOuterRadius2;
        // det = b^2 - 4*a*c, where a = 1
        float fDet = max(0.0, fB * fB - 4.0 * fC);
        // Compute second intersection distance:
        // x1 = (-b + sqrt(det)) / 2*a
        return 0.5 * (-fB + sqrt(fDet));
    }
    `,
  atmosphere_fragment_utils: `

    // Branch free RGB to HSV conversion.
    // Based on article:
    // http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
    // and optimized OpenGL SL algorithm
    // http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
    vec3 rgb2Hsv(vec3 c)
    {
        const vec4 RGB_HSV_CONV = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        // Ternary operator may be used explicitly if compiler can use fast conditional move.
        // vec4 p = c.g < c.b ? vec4(c.bg, RGB_HSV_CONV.wz) : vec4(c.gb, RGB_HSV_CONV.xy);
        vec4 p = mix(vec4(c.bg, RGB_HSV_CONV.wz), vec4(c.gb, RGB_HSV_CONV.xy), step(c.b, c.g));
        // vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
    }

    // Branch free HSV to RGB conversion
    vec3 hsv2Rgb(vec3 c)
    {
        const vec4 HSV_RGB_CONV = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + HSV_RGB_CONV.xyz) * 6.0 - HSV_RGB_CONV.www);
        return c.z * mix(HSV_RGB_CONV.xxx, clamp(p - HSV_RGB_CONV.xxx, 0.0, 1.0), c.y);
    }

    vec3 correctExposure(vec3 rgb, float exposure)
    {
        const vec3 fullColor = vec3(1.0);
        return fullColor - exp(-exposure * rgb);
    }

    vec3 correctColor(vec3 rgb, vec3 hsvShift)
    {
        const float e = 0.0000001;
        // Convert rgb color to hsv
        vec3 hsv = rgb2Hsv(rgb);
        // Shift hue value with angle wrapping
        hsv.x = mod(hsv.x + hsvShift.x, 1.0);
        // Shift and clamp saturation
        hsv.y = clamp(hsv.y + hsvShift.y, 0.0, 1.0);
        // Change value if it is significant (greater then epsilon)
        hsv.z = hsv.z > e ? clamp(hsv.z + hsvShift.z, 0.0, 1.0) : 0.0;
        // Convert shifted hsv back to rgb
        return hsv2Rgb(hsv);
    }
    `
};

// src/materials/GroundAtmosphereMaterial.ts
var EQUATORIAL_RADIUS = 6378137;
var GroundAtmosphereShader = {
  uniforms: {
    u_eyePositionWorld: new THREE21.Uniform(new THREE21.Vector3()),
    u_lightDirectionWorld: new THREE21.Uniform(new THREE21.Vector3(0, 1, 0)),
    u_modelViewProjection: new THREE21.Uniform(new THREE21.Matrix4()),
    u_atmosphereEnv: new THREE21.Uniform(new THREE21.Vector3(EQUATORIAL_RADIUS * 1.001, EQUATORIAL_RADIUS * 1.025, 0)),
    u_hsvCorrection: new THREE21.Uniform(new THREE21.Vector3(0, 0, 0)),
    topColor: new THREE21.Uniform(new THREE21.Color(30719)),
    bottomColor: new THREE21.Uniform(new THREE21.Color(16777215)),
    offset: new THREE21.Uniform(33),
    exponent: new THREE21.Uniform(0.6),
    fogColor: new THREE21.Uniform(new THREE21.Color(30719)),
    fogNear: new THREE21.Uniform(new THREE21.Color(30719)),
    fogFar: new THREE21.Uniform(new THREE21.Color(16777215))
  },
  vertexShader: `

    #define IMPROVE_INTERSECT_PRECISION 1
    #define IMPROVE_DOT_PRECISION 1

    precision highp float;
    precision highp int;

    attribute vec4 position;

    // Base mandatory uniforms
    uniform mat4 u_modelViewProjection;
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height
    uniform vec3 u_hsvCorrection;

    const float Pi = 3.141592653589793;
    const float Kr = 0.0025;
    const float Km = 0.0015;
    const float Kr4PI = Kr * 4.0 * Pi;
    const float Km4PI = Km * 4.0 * Pi;
    const float ESun = 25.0; // should be 15.0
    const float KmESun = Km * ESun;
    const float KrESun = Kr * ESun;
    const vec3 InvWavelength = vec3(
        1.0 / pow(0.650, 4.0), // Red
        1.0 / pow(0.570, 4.0), // Green
        1.0 / pow(0.475, 4.0)); // Blue

    const int nSamples = 2;
    const float fSamples = 2.0;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;
    varying vec3 v_vertToOrigin;

    ${AtmosphereChunks_default.atmosphere_vertex_utils}

    //
    // Computes rayleight and mia atmosphere factors for ground.
    //
    // Code based on GPU Gems article.
    //
    // Author: Sean O'Neil
    //
    // Copyright (c) 2004 Sean O'Neil
    //
    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering
    //
    // Further modifications by HERE.
    //
    AtmosphereColor computeGroundAtmosphere(vec3 v3Pos, vec3 vLightDir)
    {
        // Retrieve environment variables
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        // All that may be moved to const or define(s) at further optimizations:
        float fScale = 1.0 / (fOuterRadius - fInnerRadius);
        float fScaleOverScaleDepth = fScale / RayleighScaleDepth;
        float fCameraHeight2 = fCameraHeight * fCameraHeight;
        float fOuterRadius2 = fOuterRadius * fOuterRadius;

        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
        vec3 v3Ray = v3Pos - u_eyePositionWorld;
        float fFar = length(v3Ray);
        v3Ray /= fFar;

#if !defined(IMPROVE_DOT_PRECISION)
        vec3 v3Dir = normalize(v3Pos);
#endif

#ifdef CAMERA_IN_SPACE

        // Calculate first point of camera ray and sphere intersection.
        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);
        // Make far relative to first atmosphere intersection, setting it to
        // the length of ray passed through atmosphere
        fFar -= fNear;

        // Compute the ray's starting position within the atmosphere, then
        // calculate its scattering offset
        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;
        float fDepth = exp((fInnerRadius - fOuterRadius) / RayleighScaleDepth);

#else // CAMERA_IN_ATMOSPHERE

        // The ray starts already in atmosphere
        vec3 v3Start = u_eyePositionWorld;
        // Virtually fNear is just at eye position, so ray passing through atmosphere does not shorten
        // fFar -= 0.0;
        float fDepth = exp((fInnerRadius - fCameraHeight) / RayleighScaleDepth);
#endif

#if defined(IMPROVE_DOT_PRECISION)
        float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);
#else
        float fCameraAngle = dot(-v3Ray, v3Dir);
#endif
        float fCameraScale = scale(fCameraAngle);

#ifdef DYNAMIC_LIGHT
        // When we want the atmosphere to be uniform over the globe so it is set to 1.0.
        #if defined(IMPROVE_DOT_PRECISION)
            // The light angle for given light source may be calculated as:
            // angle = dot(vLightDir, v3Dir) / length(v3Dir);
            // where v3Dir holds normalized vertex position, but for precision issues we v3Pos (un-normalized)
            float fLightAngle = dot(vLightDir, v3Pos) / length(v3Pos);
        #else
            float fLightAngle = dot(vLightDir, v3Dir);
        #endif
#else
        float fLightAngle = 1.0;
#endif
        float fLightScale = scale(fLightAngle);

        float fCameraOffset = fDepth * fCameraScale;
        float fTemp = (fLightScale + fCameraScale);

        // Initialize the scattering loop variables
        float fSampleLength = fFar / fSamples;
        float fScaledLength = fSampleLength * fScale;
        vec3 v3SampleRay = v3Ray * fSampleLength;
        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

        // Now loop through the sample rays
        vec3 v3BaseColor = vec3(0.0);
        vec3 v3Attenuate = vec3(0.0);
        for(int i = 0; i < nSamples; i++)
        {
            float fHeight = length(v3SamplePoint);
            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
            float fScatter = fDepth * fTemp - fCameraOffset;
            // Compute color factors
            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));
            v3BaseColor += v3Attenuate * (fDepth * fScaledLength);
            // Move to the next point
            v3SamplePoint += v3SampleRay;
        }

        AtmosphereColor color;
        color.mie = v3BaseColor * (InvWavelength * KrESun + KmESun);
        // Calculate the attenuation factor for the ground
        color.rayleigh = v3Attenuate;

        return color;
    }

    void main(void)
    {
        #ifdef DYNAMIC_LIGHT
            vec3 vLightDir = u_lightDirectionWorld;
        #else
            vec3 vLightDir = u_eyePositionWorld;
        #endif
        vLightDir = normalize(vLightDir);

        AtmosphereColor atmColor = computeGroundAtmosphere(position.xyz, vLightDir);
        v_mieColor = atmColor.mie;
        v_rayleighColor = atmColor.rayleigh;
        v_vertToCamera = u_eyePositionWorld - position.xyz;
        v_vertToOrigin = normalize(position.xyz);

        gl_Position = u_modelViewProjection * position;
    }
    `,
  fragmentShader: `

    // Exposure correction gives more subtle gradients on the ground.
    #define CORRECT_EXPOSURE 1
    #define FADE_DEPTH 1
    #define NIGHT_LOCAL 1

    precision highp float;
    precision highp int;

    #ifdef CORRECT_COLOR
    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness
    #endif

    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    const float g = -0.95;
    const float g2 = g * g;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;
    varying vec3 v_vertToOrigin;

    ${AtmosphereChunks_default.atmosphere_fragment_utils}

    void main(void)
    {
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        #ifdef DYNAMIC_LIGHT
            vec3 vLightDir = u_lightDirectionWorld;
        #else
            vec3 vLightDir = u_eyePositionWorld;
        #endif
        vLightDir = normalize(vLightDir);

        // GPU gems mix of ground solution, with custom alpha settings
        vec3 cRgb = v_mieColor + 0.25 * v_rayleighColor;

        // Not needed for HDR frame buffer
    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)
        // Interesting results with exposure factor: 2.0, 3.5, 4.0
        cRgb = correctExposure(cRgb, 3.0);
    #endif

    #ifdef CORRECT_COLOR
        cRgb = correctColor(cRgb, u_hsvCorrection);
    #endif

        // Base atmosphere opacity
        float fAtmosphereAlpha = 1.0;

        // Factor based on the distance of camera atmosphere and ground, results are:
        // 0.0 = camera on the ground surface,
        // 1.0 = at the outer edge of the atmosphere.
        float fDepthFactor = clamp((fCameraHeight - fInnerRadius) /
            (fOuterRadius - fInnerRadius), 0.0, 1.0);
    #ifdef FADE_DEPTH
        // Fade alpha based on the distance of camera between atmosphere layers
        #ifdef FADE_DEPTH_LINEAR
            fAtmosphereAlpha *= fDepthFactor;
        #else
            fAtmosphereAlpha *= pow(fDepthFactor, 1.5);
        #endif
    #endif

#if defined(FADE_NIGHT) || defined(DARKEN_NIGHT)
    #ifdef DYNAMIC_LIGHT
        // Adjust factor based on time of day, results are:
        // 0.0 = night,
        // 1.0 = day.
        #ifdef NIGHT_GLOBAL
            // Global night fade based on camera and light orientation
            float fNightFactor = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);
            fNightFactor = pow(fNightFactor, 0.5);
        #else // NIGHT_LOCAL
            float fNightFactor =
                clamp(dot(v_vertToOrigin, vLightDir) / length(v_vertToOrigin), 0.0, 1.0);
            fNightFactor = pow(fNightFactor, 0.8);
        #endif
    #else
        float fNightFactor = 1.0;
    #endif
#endif

    #ifdef FADE_NIGHT
        // Adjust alpha for night side of the globe
        fAtmosphereAlpha *= fNightFactor;
    #endif

    #ifdef DARKEN_NIGHT
        // Change the brightness depending on night / day side.
        // NOTE: Darkening should be rather applied in HSV space, without loss on saturation,
        // but it is much more GPU consuming.
        const float minBrightness = 0.5;
        float fDarkenFactor = clamp(fNightFactor, minBrightness, 1.0);
        cRgb *= fDarkenFactor;
    #endif

    #ifdef EXPOSURE_DEPTH
        // Control exposure depending from ground distance
        float exposureBoost = 3.0 - fDepthFactor;
        cRgb = correctExposure(cRgb, exposureBoost);
    #endif

        // Experimental fading out of focus point - similar to fresnel effect in top view.
        // This fade is handy to better expose cartographic/map features in screen center.
        float fFocusFactor = 1.0 - clamp(dot(normalize(v_vertToCamera), v_vertToOrigin), 0.0, 1.0) + 0.1;
        fFocusFactor = pow(fFocusFactor, 2.5);
        fAtmosphereAlpha *= fFocusFactor;

        // Integrate all features
        gl_FragColor = vec4(cRgb, fAtmosphereAlpha);
    }
    `
};
var GroundAtmosphereMaterial = class extends RawShaderMaterial2 {
  constructor(params) {
    let shaderParams;
    if (params) {
      const defines = {};
      defines.CAMERA_IN_SPACE = "";
      shaderParams = {
        name: "GroundAtmosphereMaterial",
        vertexShader: GroundAtmosphereShader.vertexShader,
        fragmentShader: GroundAtmosphereShader.fragmentShader,
        uniforms: GroundAtmosphereShader.uniforms,
        transparent: true,
        depthTest: false,
        depthWrite: false,
        side: THREE21.FrontSide,
        blending: THREE21.NormalBlending,
        fog: false,
        rendererCapabilities: params.rendererCapabilities
      };
    }
    super(shaderParams);
  }
  setDynamicLighting(enableLighting) {
    setShaderMaterialDefine(this, "DYNAMIC_LIGHT", enableLighting);
  }
  set outerRadius(radius) {
    this.uniforms.u_atmosphereEnv.value.y = radius;
  }
  get outerRadius() {
    return this.uniforms.u_atmosphereEnv.value.y;
  }
  set innerRadius(radius) {
    this.uniforms.u_atmosphereEnv.value.x = radius;
  }
  get innerRadius() {
    return this.uniforms.u_atmosphereEnv.value.x;
  }
  updateUniforms(shaderMaterial, object, camera, lightDirection) {
    const cameraInfo = this.getCameraInfo(object, camera);
    if (shaderMaterial !== void 0 && shaderMaterial.isMaterial) {
      if (shaderMaterial.uniforms && shaderMaterial.uniforms.u_atmosphereEnv && shaderMaterial.uniforms.u_hsvCorrection && shaderMaterial.uniforms.u_eyePositionWorld && shaderMaterial.uniforms.u_modelViewProjection && shaderMaterial.uniforms.u_lightDirectionWorld) {
        const eyePos = cameraInfo.eyePos;
        const mvp = cameraInfo.modelViewProjection;
        const cameraHeight = cameraInfo.eyeHeight;
        shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);
        shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);
        shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;
        shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();
        const cameraInSpace = cameraHeight > this.outerRadius;
        const needsUpdate0 = setShaderDefine(shaderMaterial.defines, "CAMERA_IN_SPACE", cameraInSpace);
        const needsUpdate1 = setShaderDefine(shaderMaterial.defines, "CAMERA_IN_ATMOSPHERE", !cameraInSpace);
        shaderMaterial.needsUpdate = shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;
      } else {
        throw Error("Atmosphere material has missing uniforms");
      }
    } else {
      throw Error("Wrong object used, only Material objects are supported");
    }
  }
  getCameraInfo(object, camera, reverse = false) {
    if (reverse) {
      const modelMatrix = new THREE21.Matrix4().identity();
      const viewMatrix = new THREE21.Matrix4().copy(object.matrixWorld).invert().transpose();
      const projectionMatrix = camera.projectionMatrix;
      const mvpMatrix = new THREE21.Matrix4();
      mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
      mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
      const eyePos = new THREE21.Vector3();
      object.getWorldPosition(eyePos);
      const objectPos = new THREE21.Vector3();
      camera.getWorldPosition(objectPos);
      const eyeHeight = objectPos.distanceTo(eyePos);
      return {
        modelViewProjection: mvpMatrix,
        eyePos,
        eyeHeight
      };
    } else {
      const modelMatrix = object.matrixWorld;
      const viewMatrix = camera.matrixWorldInverse;
      const projectionMatrix = camera.projectionMatrix;
      const mvpMatrix = new THREE21.Matrix4();
      mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
      mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
      const eyePos = new THREE21.Vector3();
      camera.getWorldPosition(eyePos);
      const objectPos = new THREE21.Vector3();
      object.getWorldPosition(objectPos);
      const eyeHeight = objectPos.distanceTo(eyePos);
      eyePos.sub(objectPos);
      return {
        modelViewProjection: mvpMatrix,
        eyePos,
        eyeHeight
      };
    }
  }
};

// src/materials/HighPrecisionLineMaterial.ts
var THREE22 = __toESM(require("three"));

// src/materials/ShaderChunks/LinesChunks.ts
var LinesChunks_default = {
  extrude_line_vert_func: `
vec3 extrudeLine(
        in vec3 vertexPosition,
        in float linePosition,
        in float extrusionWidth,
        in vec4 bitangent,
        in vec3 tangent,
        in float tanHalfAngle,
        inout vec2 uv
    ) {
    vec3 result = vertexPosition;
    // Retrieve the angle between this segment and the previous one (stored in the bitangent w
    // component).
    float angle = bitangent.w;
    // Extrude according to the angle between segments to properly render narrow joints...
    if (angle != 0.0) {
        result += uv.y * extrusionWidth * bitangent.xyz / cos(angle / 2.0);
        uv.x = linePosition + uv.x * extrusionWidth * uv.y * tanHalfAngle;
    }
    // ... or extrude in a simple manner for segments that keep the same direction.
    else {
        result += uv.y * extrusionWidth * bitangent.xyz + uv.x * extrusionWidth * tangent;
        uv.x = linePosition + uv.x * extrusionWidth;
    }
    uv.y *= extrusionWidth;
    return result;
}
`,
  round_edges_and_add_caps: `
#define CAPS_NONE ${0 /* CAPS_NONE */}
#define CAPS_SQUARE ${1 /* CAPS_SQUARE */}
#define CAPS_ROUND ${2 /* CAPS_ROUND */}
#define CAPS_TRIANGLE_IN ${3 /* CAPS_TRIANGLE_IN */}
#define CAPS_TRIANGLE_OUT ${4 /* CAPS_TRIANGLE_OUT */}

float roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {
    // Compute the line's width to length ratio.
    float widthRatio = range.y / range.x;

    // Compute the inner segment distance (same for all cap mode).
    float dist = abs(coords.y);
    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);
    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);
    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));
    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));

    #if CAPS_MODE != CAPS_ROUND
    // Compute the caps mask.
    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);
    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);
    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);
    float capMask = capRangeMask * max(beginCapMask, endCapMask);

    // Compute the outer segment distance (specific for each cap mode).
    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;
    #if CAPS_MODE == CAPS_NONE
    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);
    #elif CAPS_MODE == CAPS_SQUARE
    dist = mix(dist, max(abs(coords.y), capDist), capMask);
    #elif CAPS_MODE == CAPS_TRIANGLE_OUT
    dist = mix(dist, abs(coords.y) + capDist, capMask);
    #elif CAPS_MODE == CAPS_TRIANGLE_IN
    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);
    #endif
    #endif // CAPS_MODE != CAPS_ROUND

    return dist;
}
`,
  tile_clip_func: `
void tileClip(vec2 tilePos, vec2 tileSize) {
    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))
        discard;
    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))
        discard;
}
`,
  high_precision_vert_func: `
vec3 subtractDblEyePos( const in vec3 pos ) {
    vec3 t1 = positionLow - u_eyepos_lowpart;
    vec3 e = t1 - positionLow;
    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;
    vec3 high_delta = t1 + t2;
    vec3 low_delta = t2 - (high_delta - t1);
    return (high_delta + low_delta);
}
`
};

// src/materials/HighPrecisionLineMaterial.ts
var vertexSource2 = `
#ifdef USE_COLOR
attribute vec4 color;
varying vec3 vColor;
#endif

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 position;        // high part
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);
}`;
var fragmentSource2 = `
precision highp float;
precision highp int;

uniform vec3 diffuseColor;
uniform float opacity;

#ifdef USE_COLOR
varying vec3 color;
#endif

void main() {
    #ifdef USE_COLOR
    gl_FragColor = vec4( diffuseColor * vColor, opacity );
    #else
    gl_FragColor = vec4( diffuseColor, opacity );
    #endif
}`;
var _HighPrecisionLineMaterial = class extends RawShaderMaterial2 {
  isHighPrecisionLineMaterial;
  constructor(params) {
    Object.assign(THREE22.ShaderChunk, LinesChunks_default);
    const shaderParams = params ? {
      name: "HighPrecisionLineMaterial",
      vertexShader: vertexSource2,
      fragmentShader: fragmentSource2,
      uniforms: {
        diffuseColor: new THREE22.Uniform(new THREE22.Color(_HighPrecisionLineMaterial.DEFAULT_COLOR)),
        opacity: new THREE22.Uniform(_HighPrecisionLineMaterial.DEFAULT_OPACITY),
        u_mvp: new THREE22.Uniform(new THREE22.Matrix4()),
        u_eyepos: new THREE22.Uniform(new THREE22.Vector3()),
        u_eyepos_lowpart: new THREE22.Uniform(new THREE22.Vector3())
      },
      rendererCapabilities: params.rendererCapabilities
    } : void 0;
    Object.assign(shaderParams, params);
    super(shaderParams);
    this.type = "HighPrecisionLineMaterial";
    this.isHighPrecisionLineMaterial = true;
    if (params) {
      if (params.color !== void 0) {
        this.color.set(params.color);
      }
      if (params.opacity !== void 0) {
        this.opacity = params.opacity;
      }
    }
    this.updateTransparencyFeature();
  }
  get color() {
    return this.uniforms.diffuseColor.value;
  }
  set color(value2) {
    this.uniforms.diffuseColor.value.copy(value2);
  }
  updateTransparencyFeature() {
    this.transparent = this.opacity < 1 ? true : false;
  }
};
var HighPrecisionLineMaterial = _HighPrecisionLineMaterial;
__publicField(HighPrecisionLineMaterial, "DEFAULT_COLOR", 80);
__publicField(HighPrecisionLineMaterial, "DEFAULT_OPACITY", 1);
function isHighPrecisionLineMaterial(material) {
  return material !== void 0 && material.isHighPrecisionLineMaterial === true;
}

// src/materials/HighPrecisionPointMaterial.ts
var THREE23 = __toESM(require("three"));
var vertexSource3 = `
#ifdef USE_COLOR
varying vec3 vColor;
#endif

uniform float size;

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);

    // ignore sizeAttenuation for now!
    gl_PointSize = size;
}`;
var _HighPrecisionPointMaterial = class extends THREE23.PointsMaterial {
  isHighPrecisionPointMaterial;
  uniforms;
  vertexShader;
  fragmentShader;
  constructor(params) {
    Object.assign(THREE23.ShaderChunk, LinesChunks_default);
    const shaderParams = params;
    super(shaderParams);
    this.type = "HighPrecisionPointMaterial";
    this.vertexShader = vertexSource3;
    this.fragmentShader = THREE23.ShaderChunk.points_frag;
    this.fog = false;
    this.uniforms = {
      diffuseColor: new THREE23.Uniform(new THREE23.Color(_HighPrecisionPointMaterial.DEFAULT_COLOR)),
      opacity: new THREE23.Uniform(_HighPrecisionPointMaterial.DEFAULT_OPACITY),
      size: new THREE23.Uniform(_HighPrecisionPointMaterial.DEFAULT_SIZE),
      scale: new THREE23.Uniform(_HighPrecisionPointMaterial.DEFAULT_SCALE),
      map: new THREE23.Uniform(new THREE23.Texture()),
      uvTransform: new THREE23.Uniform(new THREE23.Matrix3()),
      u_mvp: new THREE23.Uniform(new THREE23.Matrix4()),
      u_eyepos: new THREE23.Uniform(new THREE23.Vector3()),
      u_eyepos_lowpart: new THREE23.Uniform(new THREE23.Vector3())
    };
    this.isHighPrecisionPointMaterial = true;
    if (params !== void 0) {
      if (params.color !== void 0) {
        this.color.set(params.color);
      }
      if (params.opacity !== void 0) {
        this.opacity = params.opacity;
      }
      if (params.size !== void 0) {
        this.size = params.size;
      }
      if (params.scale !== void 0) {
        this.scale = params.scale;
      }
      if (params.uvTransform !== void 0) {
        this.uvTransform = params.uvTransform;
      }
      if (params.map !== void 0) {
        this.map = params.map;
      }
    }
  }
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value2) {
    this.uniforms.scale.value = value2;
  }
  get uvTransform() {
    return this.uniforms.uvTransform.value;
  }
  set uvTransform(value2) {
    this.uniforms.uvTransform.value = value2;
  }
};
var HighPrecisionPointMaterial = _HighPrecisionPointMaterial;
__publicField(HighPrecisionPointMaterial, "DEFAULT_COLOR", 80);
__publicField(HighPrecisionPointMaterial, "DEFAULT_OPACITY", 1);
__publicField(HighPrecisionPointMaterial, "DEFAULT_SIZE", 1);
__publicField(HighPrecisionPointMaterial, "DEFAULT_SCALE", 1);
function isHighPrecisionPointMaterial(material) {
  return material !== void 0 && material.isHighPrecisionPointMaterial === true;
}

// src/materials/IconMaterial.ts
var THREE24 = __toESM(require("three"));
var vertexSource4 = `
attribute vec4 position;
attribute vec4 color;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec4 vColor;
varying vec2 vUv;

void main() {
    vUv = uv;
    vColor = color;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
}`;
var fragmentSource3 = `
precision highp float;
precision highp int;

uniform sampler2D map;

varying vec4 vColor;
varying vec2 vUv;

void main() {

    vec4 color = texture2D(map, vUv.xy);
    color *= vColor;
    if (color.a < 0.05) {
        discard;
    }
    gl_FragColor = color;
}`;
var IconMaterial = class extends RawShaderMaterial2 {
  constructor(params) {
    const shaderParams = params ? {
      name: "IconMaterial",
      vertexShader: vertexSource4,
      fragmentShader: fragmentSource3,
      uniforms: {
        map: new THREE24.Uniform(params.map)
      },
      depthTest: false,
      depthWrite: false,
      transparent: true,
      vertexColors: true,
      premultipliedAlpha: true,
      rendererCapabilities: params.rendererCapabilities
    } : void 0;
    super(shaderParams);
  }
  get map() {
    return this.uniforms.map.value;
  }
};

// src/materials/LuminosityHighPassShader.ts
var THREE25 = __toESM(require("three"));
var LuminosityHighPassShader = {
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new THREE25.Color(0) },
    defaultOpacity: { value: 0 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec3 defaultColor;
    uniform float defaultOpacity;
    uniform float luminosityThreshold;
    uniform float smoothWidth;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        vec3 luma = vec3( 0.299, 0.587, 0.114 );
        float v = dot( texel.xyz, luma );
        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );
        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );
        gl_FragColor = mix( outputColor, texel, alpha );
    }`
};

// src/materials/MSAAMaterial.ts
var THREE26 = __toESM(require("three"));
var MSAAMaterial = class extends THREE26.ShaderMaterial {
  constructor(uniforms) {
    super({
      uniforms,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      premultipliedAlpha: true,
      transparent: true,
      blending: THREE26.AdditiveBlending,
      depthTest: false,
      depthWrite: false
    });
  }
};

// src/materials/SepiaShader.ts
var SepiaShader = {
  uniforms: {
    tDiffuse: { value: null },
    amount: { value: 1 }
  },
  vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
  fragmentShader: `
        uniform float amount;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D( tDiffuse, vUv );
            vec3 c = color.rgb;
            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );
            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );
            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );
            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );
        }`
};

// src/materials/SkyAtmosphereMaterial.ts
var THREE27 = __toESM(require("three"));
var EQUATORIAL_RADIUS2 = 6378137;
var SkyAtmosphereShader = {
  uniforms: {
    u_eyePositionWorld: new THREE27.Uniform(new THREE27.Vector3()),
    u_lightDirectionWorld: new THREE27.Uniform(new THREE27.Vector3(0, 1, 0)),
    u_modelViewProjection: new THREE27.Uniform(new THREE27.Matrix4()),
    u_atmosphereEnv: new THREE27.Uniform(new THREE27.Vector3(EQUATORIAL_RADIUS2, EQUATORIAL_RADIUS2 * 1.025, 0)),
    u_hsvCorrection: new THREE27.Uniform(new THREE27.Vector3(0, 0, 0)),
    topColor: new THREE27.Uniform(new THREE27.Color(30719)),
    bottomColor: new THREE27.Uniform(new THREE27.Color(16777215)),
    offset: new THREE27.Uniform(33),
    exponent: new THREE27.Uniform(0.6),
    fogColor: new THREE27.Uniform(new THREE27.Color(30719)),
    fogNear: new THREE27.Uniform(new THREE27.Color(30719)),
    fogFar: new THREE27.Uniform(new THREE27.Color(16777215))
  },
  vertexShader: `
    precision highp float;
    precision highp int;

    attribute vec4 position;

    uniform mat4 u_modelViewProjection;
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height
    uniform vec3 u_hsvCorrection;

    const float Pi = 3.141592653589793;
    const float Kr = 0.0025;
    const float Kr4PI = Kr * 4.0 * Pi;
    const float Km = 0.0015;
    const float Km4PI = Km * 4.0 * Pi;
    const float ESun = 15.0; // should be 15.0
    const float KmESun = Km * ESun;
    const float KrESun = Kr * ESun;
    const vec3 InvWavelength = vec3(
        5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)
        9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)
        19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)

    const int nSamples = 2;
    const float fSamples = 2.0;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;

    ${AtmosphereChunks_default.atmosphere_vertex_utils}

    //
    // Computes rayleight and mia atmosphere factors for sky.
    //
    // Code based on GPU Gems article.
    //
    // Author: Sean O'Neil
    //
    // Copyright (c) 2004 Sean O'Neil
    //
    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering
    //
    // Further modifications by HERE
    //
    AtmosphereColor computeSkyAtmosphere(vec3 v3Pos, vec3 vLightDir)
    {
        // Unpack attributes
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        // All that may be const or define(s) at further optimization:
        float fScale = 1.0 / (fOuterRadius - fInnerRadius);
        float fScaleOverScaleDepth = (fScale / RayleighScaleDepth);
        float fCameraHeight2 = fCameraHeight * fCameraHeight;
        float fOuterRadius2 = fOuterRadius * fOuterRadius;

        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
        vec3 v3Ray = v3Pos - u_eyePositionWorld;
        float fFar = length(v3Ray);
        v3Ray /= fFar;

    #ifdef CAMERA_IN_SPACE

        // Calculate the closest intersection of the ray with the outer
        // atmosphere, this is the first point of the ray passing through the atmosphere dome.
        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);
        // Make far relative to first atmosphere intersection
        fFar -= fNear;

        // Compute the ray's starting position within the atmosphere, then
        // calculate its scattering offset
        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;

        float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;
        float fStartDepth = exp(-1.0 / RayleighScaleDepth );
        float fStartOffset = fStartDepth * scale(fStartAngle);

    #else // CAMERA_IN_ATMOSPHERE

        // The ray starts already in atmosphere
        vec3 v3Start = u_eyePositionWorld;
        float height = length(v3Start);
        float depth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));
        float fStartAngle = dot(v3Ray, v3Start) / height;
        float fStartOffset = depth * scale(fStartAngle);

    #endif

        // Initialize the scattering loop variables
        float fSampleLength = fFar / fSamples;
        float fScaledLength = fSampleLength * fScale;
        vec3 v3SampleRay = v3Ray * fSampleLength;
        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

        // Now loop through the sample rays
        vec3 v3BaseColor = vec3(0.0);
        vec3 v3Attenuate = vec3(0.0);
        for(int i=0; i < nSamples; i++)
        {
            float height = length(v3SamplePoint);
            float depth = exp(fScaleOverScaleDepth * (fInnerRadius - height));
            float fLightAngle = dot(vLightDir, v3SamplePoint) / height;
            float fCameraAngle = dot(v3Ray, v3SamplePoint) / height;
            float fScatter = (fStartOffset + depth * (scale(fLightAngle) - scale(fCameraAngle)));
            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));
            v3BaseColor += v3Attenuate * (depth * fScaledLength);
            v3SamplePoint += v3SampleRay;
        }

        // Scale the Mie and Rayleigh colors and set up output of the function
        AtmosphereColor color;
        color.mie = v3BaseColor * KmESun;
        color.rayleigh = v3BaseColor * (InvWavelength * KrESun);
        return color;
    }

    void main(void)
    {
        #ifdef DYNAMIC_LIGHT
            vec3 vLightDir = u_lightDirectionWorld;
        #else
            vec3 vLightDir = u_eyePositionWorld;
        #endif
        vLightDir = normalize(vLightDir);

        AtmosphereColor atmColor = computeSkyAtmosphere(position.xyz, vLightDir);
        v_mieColor = atmColor.mie;
        v_rayleighColor = atmColor.rayleigh;
        v_vertToCamera = u_eyePositionWorld - position.xyz;

        gl_Position = u_modelViewProjection * position;
    }
    `,
  fragmentShader: `
    // Because of harsh light distribution the exposure correction is always enabled for the sky.
    #define CORRECT_EXPOSURE 1

    precision highp float;
    precision highp int;

    #ifdef CORRECT_COLOR
    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness
    #endif

    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    const float g = -0.95;
    const float g2 = g * g;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;

    ${AtmosphereChunks_default.atmosphere_fragment_utils}

    void main(void)
    {
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        #ifdef DYNAMIC_LIGHT
            vec3 vLightDir = u_lightDirectionWorld;
            // Alter alpha based on time of day (0.0 = night , 1.0 = day)
            float fNightAlpha = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);
        #else
            vec3 vLightDir = u_eyePositionWorld;
            float fNightAlpha = 1.0;
        #endif
        vLightDir = normalize(vLightDir);

        // NOTE:
        // For better precision normalization may be added on fragment (for mobile devices)
        // while in vertex shader may be left un-normalized
        // dot(vLightDir, normalize(v_vertToCamera)) / length(v_vertToCamera);
        float fCosAngle = dot(vLightDir, v_vertToCamera) / length(v_vertToCamera);
        float fRayleighPhase = 0.75 * (1.0 + fCosAngle * fCosAngle);
        float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCosAngle * fCosAngle) / pow(1.0 + g2 - 2.0 * g * fCosAngle, 1.5);

        vec3 cRgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;

        // Sky produces very harsh lighting effect so exposure correction is always enabled.
    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)
        // Exposure factor may be exposed to uniform variable.
        cRgb = correctExposure(cRgb, 2.0);
    #endif

    #ifdef CORRECT_COLOR
        cRgb = correctColor(cRgb, u_hsvCorrection);
    #endif

        // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)
        float fAtmosphereAlpha = clamp((fOuterRadius - fCameraHeight) /
            (fOuterRadius - fInnerRadius), 0.0, 1.0);
        fAtmosphereAlpha *= pow(fNightAlpha, 0.5);

        gl_FragColor = vec4(cRgb, mix(cRgb.b, 1.0, fAtmosphereAlpha));
    }
    `
};
var SkyAtmosphereMaterial = class extends RawShaderMaterial2 {
  constructor(params) {
    let shaderParams;
    if (params) {
      const defines = {};
      defines.CAMERA_IN_SPACE = "";
      shaderParams = {
        name: "SkyAtmosphereMaterial",
        vertexShader: SkyAtmosphereShader.vertexShader,
        fragmentShader: SkyAtmosphereShader.fragmentShader,
        uniforms: SkyAtmosphereShader.uniforms,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        side: THREE27.BackSide,
        blending: THREE27.NormalBlending,
        fog: false,
        rendererCapabilities: params.rendererCapabilities
      };
    }
    super(shaderParams);
  }
  setDynamicLighting(enableLighting) {
    setShaderMaterialDefine(this, "DYNAMIC_LIGHT", enableLighting);
  }
  set outerRadius(radius) {
    this.uniforms.u_atmosphereEnv.value.y = radius;
  }
  get outerRadius() {
    return this.uniforms.u_atmosphereEnv.value.y;
  }
  set innerRadius(radius) {
    this.uniforms.u_atmosphereEnv.value.x = radius;
  }
  get innerRadius() {
    return this.uniforms.u_atmosphereEnv.value.x;
  }
  updateUniforms(shaderMaterial, object, camera, lightDirection) {
    const cameraInfo = this.getCameraInfo(object, camera);
    if (shaderMaterial !== void 0 && shaderMaterial.isMaterial) {
      if (shaderMaterial.uniforms && shaderMaterial.uniforms.u_atmosphereEnv && shaderMaterial.uniforms.u_hsvCorrection && shaderMaterial.uniforms.u_eyePositionWorld && shaderMaterial.uniforms.u_modelViewProjection && shaderMaterial.uniforms.u_lightDirectionWorld) {
        const eyePos = cameraInfo.eyePos;
        const mvp = cameraInfo.modelViewProjection;
        const cameraHeight = cameraInfo.eyeHeight;
        shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);
        shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);
        shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;
        shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();
        const cameraInSpace = cameraHeight > this.outerRadius;
        const needsUpdate0 = setShaderDefine(shaderMaterial.defines, "CAMERA_IN_SPACE", cameraInSpace);
        const needsUpdate1 = setShaderDefine(shaderMaterial.defines, "CAMERA_IN_ATMOSPHERE", !cameraInSpace);
        shaderMaterial.needsUpdate = shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;
      } else {
        throw Error("Atmosphere material has missing uniforms");
      }
    } else {
      throw Error("Wrong object used, only Material objects are supported");
    }
  }
  getCameraInfo(object, camera, reverse = false) {
    if (reverse) {
      const modelMatrix = new THREE27.Matrix4().identity();
      const viewMatrix = new THREE27.Matrix4().copy(object.matrixWorld).invert().transpose();
      const projectionMatrix = camera.projectionMatrix;
      const mvpMatrix = new THREE27.Matrix4();
      mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
      mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
      const eyePos = new THREE27.Vector3();
      object.getWorldPosition(eyePos);
      const objectPos = new THREE27.Vector3();
      camera.getWorldPosition(objectPos);
      const eyeHeight = objectPos.distanceTo(eyePos);
      return {
        modelViewProjection: mvpMatrix,
        eyePos,
        eyeHeight
      };
    } else {
      const modelMatrix = object.matrixWorld;
      const viewMatrix = camera.matrixWorldInverse;
      const projectionMatrix = camera.projectionMatrix;
      const mvpMatrix = new THREE27.Matrix4();
      mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
      mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
      const eyePos = new THREE27.Vector3();
      camera.getWorldPosition(eyePos);
      const objectPos = new THREE27.Vector3();
      object.getWorldPosition(objectPos);
      const eyeHeight = objectPos.distanceTo(eyePos);
      eyePos.sub(objectPos);
      return {
        modelViewProjection: mvpMatrix,
        eyePos,
        eyeHeight
      };
    }
  }
};

// src/materials/SolidLineMaterial.ts
var THREE28 = __toESM(require("three"));
var LineCapsDefinesMapping = {
  None: 0 /* CAPS_NONE */,
  Square: 1 /* CAPS_SQUARE */,
  Round: 2 /* CAPS_ROUND */,
  TriangleIn: 3 /* CAPS_TRIANGLE_IN */,
  TriangleOut: 4 /* CAPS_TRIANGLE_OUT */
};
var DefinesLineCapsMapping = Object.keys(LineCapsDefinesMapping).reduce((r, lineCapsName) => {
  const defineKey = lineCapsName;
  const defineValue = LineCapsDefinesMapping[defineKey];
  r[defineValue] = defineKey;
  return r;
}, {});
var LineDashesDefinesMapping = {
  Square: 0 /* DASHES_SQUARE */,
  Round: 1 /* DASHES_ROUND */,
  Diamond: 2 /* DASHES_DIAMOND */
};
var DefinesLineDashesMapping = Object.keys(LineDashesDefinesMapping).reduce((r, lineDashesName) => {
  const defineKey = lineDashesName;
  const defineValue = LineDashesDefinesMapping[defineKey];
  r[defineValue] = defineKey;
  return r;
}, {});
var tmpColor2 = new THREE28.Color();
var vertexSource5 = `
#define SEGMENT_OFFSET 0.1

attribute vec3 extrusionCoord;
attribute vec3 position;
attribute vec4 biTangent;
attribute vec3 tangent;
attribute vec2 uv;
attribute vec3 normal;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float extrusionWidth;
uniform float outlineWidth;
uniform float offset;
uniform vec2 drawRange;

#ifdef USE_DISPLACEMENTMAP
uniform sampler2D displacementMap;
#endif

#ifdef USE_TILE_CLIP
varying vec3 vPosition;
#endif
varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
attribute vec3 color;
varying vec3 vColor;
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

#include <fog_pars_vertex>

#include <extrude_line_vert_func>

void main() {
    // Calculate the segment.
    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;
    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;

    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.
    float linePos = mix(segment.x, segment.y, segmentPos);
    vec2 extrusionDir = sign(extrusionCoord.xy);
    // Precompute to avoid computing multiple times
    float tanHalfAngle = tan(biTangent.w / 2.0);
    float extrusionFactor = extrusionDir.y * tanHalfAngle;

    // Calculate the extruded vertex position (and scale the extrusion direction).
    vec3 pos = extrudeLine(
        position, linePos, extrusionWidth + outlineWidth, biTangent, tangent, tanHalfAngle,
        extrusionDir);

    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).
    vRange = vec3(extrusionCoord.z, extrusionWidth, extrusionFactor);
    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);

    // Adjust the segment to fit the drawRange.
    float capDist = (extrusionWidth + outlineWidth) / extrusionCoord.z;
    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {
        vCoords.zw += 1.0;
    }
    if (vCoords.z < drawRange.x) {
        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);
    }
    if (vCoords.w > drawRange.y) {
        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);
    }

    // Transform position.
    #ifdef USE_DISPLACEMENTMAP
    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    // Shift the line based on the offset, where the bitangent is the cross product of the average
    // of the two direction vectors (the previous and next segment directions) and the normal of
    // the line (facing into the sky). The w component is the angle between the two segments.
    // Note, we need to take the angle into consideration, so we use trigonometry to calculate how
    // much we need to extend the offset. Note, orthough this looks complicated we are doing this
    // in the vertex shader, so it should not cause a performance issue.
    pos += biTangent.xyz * offset * sqrt(1.0 + pow(abs(tanHalfAngle), 2.0));

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    // Pass extruded position to fragment shader.
    #ifdef USE_TILE_CLIP
    vPosition = pos;
    #endif

    #ifdef USE_COLOR
    // Pass vertex color to fragment shader.
    vColor = color;
    #endif

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif

    #include <fog_vertex>
}`;
var fragmentSource4 = `
precision highp float;
precision highp int;

uniform vec3 diffuseColor;
uniform vec3 outlineColor;
uniform float opacity;
uniform float extrusionWidth;
uniform float outlineWidth;
uniform vec2 tileSize;
uniform vec2 drawRange;

#ifdef USE_DASHED_LINE
uniform float dashSize;
uniform float gapSize;
uniform vec3 dashColor;

#define DASHES_SQUARE ${0 /* DASHES_SQUARE */}
#define DASHES_ROUND ${1 /* DASHES_ROUND */}
#define DASHES_DIAMOND ${2 /* DASHES_DIAMOND */}
#endif

#ifdef USE_TILE_CLIP
varying vec3 vPosition;
#endif

varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
varying vec3 vColor;
#endif

#include <round_edges_and_add_caps>
#include <tile_clip_func>

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

#include <fog_pars_fragment>

void main() {
    float alpha = opacity;
    vec3 outputDiffuse = diffuseColor;

    #ifdef USE_TILE_CLIP
    tileClip(vPosition.xy, tileSize);
    #endif

    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).
    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);
    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).
    float distToEdge = distToCenter - (extrusionWidth + outlineWidth) / extrusionWidth;

    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope
    // of distToChange increases (i.e. the line is further away).
    float width = fwidth(distToEdge);

    float s = opacity < 0.98
        ? clamp((distToEdge + width) / (2.0 * width), 0.0, 1.0) // prefer a boxstep
        : smoothstep(-width, width, distToEdge);

    if (opacity < 0.98 && 1.0 - s < opacity) {
        // drop the fragment when the line is using opacity.
        discard;
    }

    alpha *= 1.0 - s;

    #ifdef USE_DASHED_LINE
    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).
    float d = dashSize / vRange.x;
    float g = gapSize / vRange.x;
    float distToDashOrigin = mod(vCoords.x, d + g) / d;

    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the
    // dashBlendFactor similarly on how we did it for the line opacity.
    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);
    #if DASHES_MODE == DASHES_ROUND
    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));
    #elif DASHES_MODE == DASHES_DIAMOND
    distToDashEdge -= distToCenter * 0.5;
    #endif
    float dashWidth = fwidth(distToDashEdge);
    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);

    #ifdef USE_DASH_COLOR
    outputDiffuse = mix(diffuseColor, dashColor, dashBlendFactor);
    #endif
    #endif

    #ifdef USE_OUTLINE
    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and
    // compute the outlineBlendFactor (used to mix line and outline colors).
    float distToOutline = distToCenter - 1.0;
    float outlineWidth = fwidth(distToOutline);
    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);

    // Mix the colors using the different computed factors.
    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);
    outputDiffuse = mix(
      mix(
        mix(outlineColor, diffuseColor, colorBlendFactor),
        outputDiffuse,
        dashBlendFactor
      ),
      outlineColor,
      outlineBlendFactor
    );
    #else
    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);
    #endif
    #endif

    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    // Multiply the alpha by the dashBlendFactor.
    #if defined(USE_OUTLINE)
    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);
    #else
    alpha *= 1.0 - dashBlendFactor;
    #endif
    #endif

    #ifdef USE_COLOR
    gl_FragColor = vec4( outputDiffuse * vColor, alpha );
    #else
    gl_FragColor = vec4( outputDiffuse, alpha );
    #endif

    #include <fog_fragment>

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif


}`;
var _SolidLineMaterial = class extends RawShaderMaterial2 {
  constructor(params) {
    Object.assign(THREE28.ShaderChunk, LinesChunks_default);
    FadingFeature.patchGlobalShaderChunks();
    const defines = {
      CAPS_MODE: 2 /* CAPS_ROUND */,
      DASHES_MODE: 0 /* DASHES_SQUARE */
    };
    let fogParam = true;
    let opacityParam = 1;
    let displacementMap;
    let shaderParams;
    if (params) {
      fogParam = params.fog === true;
      if (fogParam) {
        setShaderDefine(defines, "USE_FOG", true);
      }
      opacityParam = params.opacity !== void 0 ? params.opacity : opacityParam;
      displacementMap = params.displacementMap;
      if (displacementMap !== void 0) {
        setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
      }
      const hasOutline = params.outlineWidth !== void 0 && params.outlineWidth > 0;
      if (hasOutline) {
        setShaderDefine(defines, "USE_OUTLINE", true);
      }
      shaderParams = {
        name: "SolidLineMaterial",
        vertexShader: vertexSource5,
        fragmentShader: fragmentSource4,
        uniforms: THREE28.UniformsUtils.merge([
          {
            diffuseColor: new THREE28.Uniform(new THREE28.Color(_SolidLineMaterial.DEFAULT_COLOR)),
            dashColor: new THREE28.Uniform(new THREE28.Color(_SolidLineMaterial.DEFAULT_COLOR)),
            outlineColor: new THREE28.Uniform(new THREE28.Color(_SolidLineMaterial.DEFAULT_COLOR)),
            extrusionWidth: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_WIDTH),
            outlineWidth: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),
            offset: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_OFFSET),
            opacity: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_OPACITY),
            tileSize: new THREE28.Uniform(new THREE28.Vector2()),
            fadeNear: new THREE28.Uniform(FadingFeature.DEFAULT_FADE_NEAR),
            fadeFar: new THREE28.Uniform(FadingFeature.DEFAULT_FADE_FAR),
            displacementMap: new THREE28.Uniform(displacementMap !== void 0 ? displacementMap : new THREE28.Texture()),
            drawRange: new THREE28.Uniform(new THREE28.Vector2(_SolidLineMaterial.DEFAULT_DRAW_RANGE_START, _SolidLineMaterial.DEFAULT_DRAW_RANGE_END)),
            dashSize: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_DASH_SIZE),
            gapSize: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_GAP_SIZE)
          },
          THREE28.UniformsLib.fog
        ]),
        defines,
        opacity: opacityParam,
        rendererCapabilities: params.rendererCapabilities
      };
    }
    super(shaderParams);
    this.fog = fogParam;
    this.setOpacity(opacityParam);
    this.stencilFunc = THREE28.NotEqualStencilFunc;
    this.stencilZPass = THREE28.ReplaceStencilOp;
    this.stencilRef = 1;
    this.stencilWrite = false;
    enforceBlending(this);
    this.extensions.derivatives = true;
    if (params) {
      if (params.color !== void 0) {
        tmpColor2.set(params.color);
        this.color = tmpColor2;
      }
      if (params.outlineColor !== void 0) {
        tmpColor2.set(params.outlineColor);
        this.outlineColor = tmpColor2;
      }
      if (params.lineWidth !== void 0) {
        this.lineWidth = params.lineWidth;
      }
      if (params.outlineWidth !== void 0) {
        this.outlineWidth = params.outlineWidth;
      }
      if (params.opacity !== void 0) {
        this.setOpacity(params.opacity);
      }
      if (params.depthTest !== void 0) {
        this.depthTest = params.depthTest;
      }
      if (params.depthWrite !== void 0) {
        this.depthWrite = params.depthWrite;
      }
      if (params.fadeNear !== void 0) {
        this.fadeNear = params.fadeNear;
      }
      if (params.fadeFar !== void 0) {
        this.fadeFar = params.fadeFar;
      }
      if (params.displacementMap !== void 0) {
        this.displacementMap = params.displacementMap;
      }
      if (params.caps !== void 0) {
        this.caps = params.caps;
      }
      if (params.drawRangeStart !== void 0) {
        this.drawRangeStart = params.drawRangeStart;
      }
      if (params.drawRangeEnd !== void 0) {
        this.drawRangeEnd = params.drawRangeEnd;
      }
      if (params.dashes !== void 0) {
        this.dashes = params.dashes;
      }
      if (params.dashColor !== void 0) {
        tmpColor2.set(params.dashColor);
        this.dashColor = tmpColor2;
      }
      if (params.dashSize !== void 0) {
        this.dashSize = params.dashSize;
      }
      if (params.gapSize !== void 0) {
        this.gapSize = params.gapSize;
      }
      if (params.fog !== void 0) {
        this.fog = params.fog;
        this.invalidateFog();
      }
      this.offset = params.offset ?? 0;
    }
  }
  set offset(offset) {
    this.uniforms.offset.value = offset;
  }
  get offset() {
    return this.uniforms.offset.value;
  }
  set outline(enable) {
    setShaderMaterialDefine(this, "USE_OUTLINE", enable);
  }
  get outline() {
    return getShaderMaterialDefine(this, "USE_OUTLINE") === true;
  }
  setOpacity(opacity) {
    super.setOpacity(opacity);
    if (opacity !== void 0) {
      this.stencilWrite = opacity < 0.98;
    }
  }
  get color() {
    return this.uniforms.diffuseColor.value;
  }
  set color(value2) {
    this.uniforms.diffuseColor.value.copy(value2);
  }
  get outlineColor() {
    return this.uniforms.outlineColor.value;
  }
  set outlineColor(value2) {
    this.uniforms.outlineColor.value.copy(value2);
  }
  get dashColor() {
    return this.uniforms.dashColor.value;
  }
  set dashColor(value2) {
    this.uniforms.dashColor.value.copy(value2);
    setShaderMaterialDefine(this, "USE_DASH_COLOR", true);
  }
  get lineWidth() {
    return this.uniforms.extrusionWidth.value * 2;
  }
  set lineWidth(value2) {
    this.uniforms.extrusionWidth.value = value2 / 2;
  }
  get outlineWidth() {
    return this.uniforms.outlineWidth.value;
  }
  set outlineWidth(value2) {
    this.uniforms.outlineWidth.value = value2;
    this.outline = value2 > 0;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(value2) {
    this.uniforms.dashSize.value = value2;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(value2) {
    var _a, _b;
    this.uniforms.gapSize.value = value2;
    setShaderMaterialDefine(this, "USE_DASHED_LINE", value2 > 0);
    if (((_b = (_a = this.uniforms) == null ? void 0 : _a.gapSize) == null ? void 0 : _b.value) === 0) {
      this.stencilWrite = this.opacity < 0.98;
    }
  }
  get caps() {
    let result = "Round";
    const capsMode = getShaderMaterialDefine(this, "CAPS_MODE");
    if (typeof capsMode === "number" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {
      result = DefinesLineCapsMapping[capsMode];
    }
    return result;
  }
  set caps(value2) {
    if (LineCapsDefinesMapping.hasOwnProperty(value2)) {
      setShaderMaterialDefine(this, "CAPS_MODE", LineCapsDefinesMapping[value2]);
    }
  }
  get dashes() {
    let result = "Square";
    const dashesMode = getShaderMaterialDefine(this, "DASHES_MODE");
    if (typeof dashesMode === "number" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {
      result = DefinesLineDashesMapping[dashesMode];
    }
    return result;
  }
  set dashes(value2) {
    if (LineDashesDefinesMapping.hasOwnProperty(value2)) {
      setShaderMaterialDefine(this, "DASHES_MODE", LineDashesDefinesMapping[value2]);
    }
  }
  get fadeNear() {
    return this.uniforms.fadeNear.value;
  }
  set fadeNear(value2) {
    this.uniforms.fadeNear.value = value2;
  }
  get fadeFar() {
    return this.uniforms.fadeFar.value;
  }
  set fadeFar(value2) {
    this.uniforms.fadeFar.value = value2;
    setShaderMaterialDefine(this, "USE_FADING", value2 > 0);
  }
  get displacementMap() {
    return this.uniforms.displacementMap.value;
  }
  set displacementMap(map) {
    if (this.uniforms.displacementMap.value === map) {
      return;
    }
    this.uniforms.displacementMap.value = map;
    const useDisplacementMap = map !== null;
    if (useDisplacementMap) {
      this.uniforms.displacementMap.value.needsUpdate = true;
    }
    setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
  }
  get drawRangeStart() {
    return this.uniforms.drawRange.value.x;
  }
  set drawRangeStart(value2) {
    this.uniforms.drawRange.value.x = value2;
  }
  get drawRangeEnd() {
    return this.uniforms.drawRange.value.y;
  }
  set drawRangeEnd(value2) {
    this.uniforms.drawRange.value.y = value2;
  }
  set clipTileSize(tileSize) {
    this.uniforms.tileSize.value.copy(tileSize);
    const useTileClip = tileSize.x > 0 && tileSize.y > 0;
    setShaderMaterialDefine(this, "USE_TILE_CLIP", useTileClip);
  }
  get clipTileSize() {
    return this.uniforms.tileSize.value;
  }
  copy(other) {
    super.copy(other);
    this.invalidateFog();
    this.setOpacity(other.opacity);
    return this;
  }
};
var SolidLineMaterial = _SolidLineMaterial;
__publicField(SolidLineMaterial, "DEFAULT_COLOR", 16711680);
__publicField(SolidLineMaterial, "DEFAULT_WIDTH", 1);
__publicField(SolidLineMaterial, "DEFAULT_OUTLINE_WIDTH", 0);
__publicField(SolidLineMaterial, "DEFAULT_OPACITY", 1);
__publicField(SolidLineMaterial, "DEFAULT_DRAW_RANGE_START", 0);
__publicField(SolidLineMaterial, "DEFAULT_DRAW_RANGE_END", 1);
__publicField(SolidLineMaterial, "DEFAULT_DASH_SIZE", 1);
__publicField(SolidLineMaterial, "DEFAULT_GAP_SIZE", 1);
__publicField(SolidLineMaterial, "DEFAULT_OFFSET", 0);

// src/materials/VignetteShader.ts
var VignetteShader = {
  uniforms: {
    tDiffuse: { value: null },
    offset: { value: 1 },
    darkness: { value: 1 }
  },
  vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
  fragmentShader: `
        uniform float offset;
        uniform float darkness;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D( tDiffuse, vUv );
            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );
        }`
};

// src/mapview/AnimatedExtrusionHandler.ts
var AnimatedExtrusionState = /* @__PURE__ */ ((AnimatedExtrusionState2) => {
  AnimatedExtrusionState2[AnimatedExtrusionState2["None"] = 0] = "None";
  AnimatedExtrusionState2[AnimatedExtrusionState2["Started"] = 1] = "Started";
  AnimatedExtrusionState2[AnimatedExtrusionState2["Finished"] = 2] = "Finished";
  return AnimatedExtrusionState2;
})(AnimatedExtrusionState || {});
var DEFAULT_EXTRUSION_DURATION = 750;
var DEFAULT_MIN_ZOOM_LEVEL = 1;
var AnimatedExtrusionHandler = class {
  constructor(m_mapView) {
    this.m_mapView = m_mapView;
  }
  enabled = true;
  duration = DEFAULT_EXTRUSION_DURATION;
  m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
  m_forceEnabled = false;
  m_dataSourceMap = /* @__PURE__ */ new Map();
  m_state = 0 /* None */;
  m_startTime = -1;
  get forceEnabled() {
    return this.m_forceEnabled;
  }
  set forceEnabled(force) {
    this.m_forceEnabled = force;
    this.duration = DEFAULT_EXTRUSION_DURATION;
  }
  get minZoomLevel() {
    return this.m_minZoomLevel;
  }
  setAnimationProperties(technique, env) {
    if (!isExtrudedPolygonTechnique(technique)) {
      return false;
    }
    if (technique.hasOwnProperty("minZoomLevel")) {
      this.m_minZoomLevel = technique.minZoomLevel;
    }
    if (this.forceEnabled) {
      return this.enabled;
    }
    if (technique.animateExtrusionDuration !== void 0) {
      this.duration = technique.animateExtrusionDuration;
    }
    const animateExtrusionValue = getPropertyValue(technique.animateExtrusion, env);
    if (animateExtrusionValue === null) {
      return this.enabled;
    }
    return typeof animateExtrusionValue === "boolean" ? animateExtrusionValue : typeof animateExtrusionValue === "number" ? animateExtrusionValue !== 0 : false;
  }
  update(zoomLevel) {
    const extrusionVisible = this.m_dataSourceMap.size > 0 && zoomLevel >= this.m_minZoomLevel;
    if (this.m_state === 0 /* None */ && extrusionVisible) {
      this.m_state = 1 /* Started */;
    } else if (this.m_state !== 0 /* None */ && !extrusionVisible) {
      this.resetAnimation(true);
    }
    this.animateExtrusion();
  }
  add(tile, materials) {
    tile.addDisposeCallback(this.removeTile.bind(this));
    let animated = false;
    if (this.m_state !== 0 /* None */) {
      animated = this.skipAnimation(tile);
      if (animated) {
        this.setTileExtrusionRatio(materials, 1);
      } else if (this.m_state === 2 /* Finished */) {
        this.resetAnimation(false);
      }
    }
    this.getOrCreateTileMap(tile.dataSource).set(tile.tileKey.mortonCode(), {
      materials,
      animated
    });
  }
  get isAnimating() {
    return this.m_state !== 2 /* Finished */ && this.m_state !== 0 /* None */;
  }
  getTileMap(dataSource, create = false) {
    return this.m_dataSourceMap.get(dataSource);
  }
  getOrCreateTileMap(dataSource) {
    let tileMap = this.m_dataSourceMap.get(dataSource);
    if (!tileMap) {
      tileMap = /* @__PURE__ */ new Map();
      this.m_dataSourceMap.set(dataSource, tileMap);
    }
    return tileMap;
  }
  skipAnimation(tile) {
    return this.wasAnyAncestorAnimated(tile) || this.wasAnyDescendantAnimated(tile);
  }
  wasAnyAncestorAnimated(tile) {
    var _a;
    const minLevel = tile.dataSource.getDataZoomLevel(this.m_minZoomLevel);
    const distanceToMinLevel = Math.max(0, tile.tileKey.level - minLevel);
    const levelsUp = Math.min(distanceToMinLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceUp);
    const tileMap = this.getTileMap(tile.dataSource);
    if (!tileMap) {
      return false;
    }
    let lastTileKey = tile.tileKey;
    for (let deltaUp = 1; deltaUp <= levelsUp; ++deltaUp) {
      lastTileKey = lastTileKey.parent();
      if (((_a = tileMap.get(lastTileKey.mortonCode())) == null ? void 0 : _a.animated) ?? false) {
        return true;
      }
    }
    return false;
  }
  wasAnyDescendantAnimated(tile) {
    var _a;
    const distanceToMaxLevel = tile.dataSource.maxDataLevel - tile.tileKey.level;
    const levelsDown = Math.min(distanceToMaxLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceDown);
    const tileMap = this.getTileMap(tile.dataSource);
    if (!tileMap) {
      return false;
    }
    const tilingScheme = tile.dataSource.getTilingScheme();
    let nextTileKeys = [tile.tileKey];
    let childTileKeys = [];
    for (let deltaDown = 1; deltaDown <= levelsDown; ++deltaDown) {
      childTileKeys.length = 0;
      for (const tileKey of nextTileKeys) {
        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
          if (((_a = tileMap.get(childTileKey.mortonCode())) == null ? void 0 : _a.animated) ?? false) {
            return true;
          }
          childTileKeys.push(childTileKey);
        }
      }
      ;
      [nextTileKeys, childTileKeys] = [childTileKeys, nextTileKeys];
    }
    return false;
  }
  removeTile(tile) {
    const tileMap = this.getTileMap(tile.dataSource);
    if (!tileMap) {
      return;
    }
    tileMap.delete(tile.tileKey.mortonCode());
    if (tileMap.size === 0) {
      this.m_dataSourceMap.delete(tile.dataSource);
    }
  }
  animateExtrusion() {
    if (this.m_state !== 1 /* Started */) {
      return;
    }
    const currentTime = Date.now();
    if (this.m_startTime < 0) {
      this.m_startTime = currentTime;
    }
    const duration = this.duration;
    const timeProgress = Math.min(currentTime - this.m_startTime, duration);
    const extrusionRatio = MathUtils6.easeInOutCubic(ExtrusionFeatureDefs.DEFAULT_RATIO_MIN, ExtrusionFeatureDefs.DEFAULT_RATIO_MAX, timeProgress / duration);
    this.setExtrusionRatio(extrusionRatio);
    if (timeProgress >= duration) {
      this.m_state = 2 /* Finished */;
    }
    this.m_mapView.update();
  }
  resetAnimation(resetTiles) {
    this.m_state = 0 /* None */;
    this.m_startTime = -1;
    if (resetTiles) {
      this.m_dataSourceMap.forEach((tileMap) => {
        tileMap.forEach((state) => {
          state.animated = false;
        });
      });
    }
  }
  setExtrusionRatio(value2) {
    this.m_dataSourceMap.forEach((tileMap) => {
      tileMap.forEach((state) => {
        if (!state.animated) {
          this.setTileExtrusionRatio(state.materials, value2);
          if (value2 >= 1) {
            state.animated = true;
          }
        }
      });
    });
  }
  setTileExtrusionRatio(materials, value2) {
    materials.forEach((material) => {
      material.extrusionRatio = value2;
    });
  }
};

// src/mapview/ITileLoader.ts
var TileLoaderState = /* @__PURE__ */ ((TileLoaderState2) => {
  TileLoaderState2[TileLoaderState2["Initialized"] = 0] = "Initialized";
  TileLoaderState2[TileLoaderState2["Loading"] = 1] = "Loading";
  TileLoaderState2[TileLoaderState2["Loaded"] = 2] = "Loaded";
  TileLoaderState2[TileLoaderState2["Decoding"] = 3] = "Decoding";
  TileLoaderState2[TileLoaderState2["Ready"] = 4] = "Ready";
  TileLoaderState2[TileLoaderState2["Canceled"] = 5] = "Canceled";
  TileLoaderState2[TileLoaderState2["Failed"] = 6] = "Failed";
  return TileLoaderState2;
})(TileLoaderState || {});

// src/mapview/BaseTileLoader.ts
var logger2 = LoggerManager.instance.create("BaseTileLoader");
var BaseTileLoader = class {
  constructor(dataSource, tileKey) {
    this.dataSource = dataSource;
    this.tileKey = tileKey;
  }
  state = 0 /* Initialized */;
  error;
  m_priority = 0;
  loadAbortController = new AbortController();
  donePromise;
  resolveDonePromise;
  rejectedDonePromise;
  get priority() {
    return this.m_priority;
  }
  set priority(value2) {
    this.m_priority = value2;
  }
  loadAndDecode() {
    switch (this.state) {
      case 1 /* Loading */:
      case 2 /* Loaded */:
      case 3 /* Decoding */:
        return this.donePromise;
      case 4 /* Ready */:
      case 6 /* Failed */:
      case 0 /* Initialized */:
      case 5 /* Canceled */:
        this.load();
        return this.donePromise;
    }
  }
  waitSettled() {
    if (!this.donePromise) {
      return Promise.resolve(this.state);
    }
    return this.donePromise;
  }
  cancel() {
    if (this.state === 1 /* Loading */) {
      this.loadAbortController.abort();
      this.loadAbortController = new AbortController();
    }
    this.cancelImpl();
    this.onDone(5 /* Canceled */);
  }
  get isFinished() {
    return this.state === 4 /* Ready */ || this.state === 5 /* Canceled */ || this.state === 6 /* Failed */;
  }
  cancelImpl() {
  }
  load() {
    this.loadImpl(this.loadAbortController.signal, this.onDone.bind(this), this.onError.bind(this));
    if (this.donePromise === void 0) {
      this.donePromise = new Promise((resolve, reject) => {
        this.resolveDonePromise = resolve;
        this.rejectedDonePromise = reject;
      });
    }
    this.state = 1 /* Loading */;
  }
  onDone(doneState) {
    if (this.resolveDonePromise && doneState === 4 /* Ready */) {
      this.resolveDonePromise(doneState);
    } else if (this.rejectedDonePromise) {
      this.rejectedDonePromise(doneState);
    }
    this.resolveDonePromise = void 0;
    this.rejectedDonePromise = void 0;
    this.donePromise = void 0;
    this.state = doneState;
  }
  onError(error) {
    if (this.state === 5 /* Canceled */) {
      return;
    }
    const dataSource = this.dataSource;
    logger2.error(`[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`, error);
    this.error = error;
    this.onDone(6 /* Failed */);
  }
};

// src/mapview/PlaneViewBounds.ts
var import_three14 = require("three");

// src/mapview/Utils.ts
var THREE97 = __toESM(require("three"));

// src/mapview/CameraUtils.ts
var THREE30 = __toESM(require("three"));

// src/mapview/FovCalculation.ts
var THREE29 = __toESM(require("three"));
var DEFAULT_FOV_CALCULATION = {
  type: "dynamic",
  fov: 40
};
var MIN_FOV_DEG = 10;
var MAX_FOV_DEG = 140;
var MIN_FOV_RAD = THREE29.MathUtils.degToRad(MIN_FOV_DEG);
var MAX_FOV_RAD = THREE29.MathUtils.degToRad(MAX_FOV_DEG);

// src/mapview/CameraUtils.ts
function isCenteredProjection(principalPoint) {
  return principalPoint.x === 0 && principalPoint.y === 0;
}
function computePosSideFov(focalLength, ppOffset, viewportSide) {
  assert(focalLength > 0, "Focal length must be larger than 0");
  return Math.atan((1 - ppOffset) * viewportSide * 0.5 / focalLength);
}
function computeFov(focalLength, ppOffset, viewportSide) {
  assert(focalLength > 0, "Focal length must be larger than 0");
  return ppOffset === 0 ? 2 * Math.atan(0.5 * viewportSide / focalLength) : computePosSideFov(focalLength, ppOffset, viewportSide) + computePosSideFov(focalLength, -ppOffset, viewportSide);
}
function getFovs(camera) {
  return camera.userData.fovs;
}
function setCameraParams(camera, ppalPoint, focalLength, viewportHeight, verticalFov) {
  const viewportWidth = viewportHeight * camera.aspect;
  let hFov = computeFov(focalLength, ppalPoint.x, viewportWidth);
  if (hFov < MIN_FOV_RAD || hFov > MAX_FOV_RAD) {
    hFov = THREE30.MathUtils.clamp(hFov, MIN_FOV_RAD, MAX_FOV_RAD);
    const focalLength2 = computeFocalLengthFromFov(hFov, viewportWidth, ppalPoint.x);
    verticalFov = computeFov(focalLength2, ppalPoint.y, viewportHeight);
  }
  camera.fov = THREE30.MathUtils.radToDeg(verticalFov);
  if (isCenteredProjection(ppalPoint)) {
    delete camera.userData.fovs;
  } else {
    const width = viewportHeight * camera.aspect;
    camera.userData.fovs = {
      top: computePosSideFov(focalLength, ppalPoint.y, viewportHeight),
      right: computePosSideFov(focalLength, ppalPoint.x, width),
      horizontal: hFov
    };
  }
  camera.userData.focalLength = focalLength;
}
function computeFocalLengthFromFov(fov, viewportSide, ppOffset) {
  const halfSide = viewportSide / 2;
  const ppCentered = ppOffset === 0;
  if (ppCentered) {
    return halfSide / Math.tan(fov / 2);
  }
  const eps = 1e-6;
  const ppOffsetSq = ppOffset ** 2;
  if (Math.abs(fov - Math.PI / 2) < eps) {
    return halfSide * Math.sqrt(1 - ppOffsetSq);
  }
  const tanFov = Math.tan(fov);
  const sign = Math.sign(tanFov);
  const sqrt = Math.sqrt(1 + tanFov ** 2 * (1 - ppOffsetSq));
  const f = halfSide * (1 + sign * sqrt) / tanFov;
  assert(f >= 0, "Focal length must be larger than 0");
  return f;
}
var CameraUtils;
((CameraUtils2) => {
  function getFocalLength(camera) {
    var _a;
    return (_a = camera.userData) == null ? void 0 : _a.focalLength;
  }
  CameraUtils2.getFocalLength = getFocalLength;
  function setFocalLength(camera, focalLength, viewportHeight) {
    const ppalPoint = getPrincipalPoint(camera);
    const vFov = computeFov(focalLength, ppalPoint.y, viewportHeight);
    if (vFov < MIN_FOV_RAD || vFov > MAX_FOV_RAD) {
      setVerticalFov(camera, vFov, viewportHeight);
    } else {
      setCameraParams(camera, ppalPoint, focalLength, viewportHeight, vFov);
    }
    return getFocalLength(camera);
  }
  CameraUtils2.setFocalLength = setFocalLength;
  function getVerticalFov(camera) {
    return THREE30.MathUtils.degToRad(camera.fov);
  }
  CameraUtils2.getVerticalFov = getVerticalFov;
  function setVerticalFov(camera, verticalFov, viewportHeight) {
    verticalFov = THREE30.MathUtils.clamp(verticalFov, MIN_FOV_RAD, MAX_FOV_RAD);
    const ppalPoint = getPrincipalPoint(camera);
    const focalLength = computeFocalLengthFromFov(verticalFov, viewportHeight, ppalPoint.y);
    setCameraParams(camera, ppalPoint, focalLength, viewportHeight, verticalFov);
    return getVerticalFov(camera);
  }
  CameraUtils2.setVerticalFov = setVerticalFov;
  function convertWorldToScreenSize(focalLength, distance, worldSize) {
    return focalLength * worldSize / distance;
  }
  CameraUtils2.convertWorldToScreenSize = convertWorldToScreenSize;
  function convertScreenToWorldSize(focalLength, distance, screenSize) {
    return distance * screenSize / focalLength;
  }
  CameraUtils2.convertScreenToWorldSize = convertScreenToWorldSize;
  function getPrincipalPoint(camera, result = new THREE30.Vector2()) {
    result.x = -camera.projectionMatrix.elements[8];
    result.y = -camera.projectionMatrix.elements[9];
    return result;
  }
  CameraUtils2.getPrincipalPoint = getPrincipalPoint;
  function setPrincipalPoint(camera, ndcCoords) {
    const height = 1;
    const width = camera.aspect;
    const maxNdcCoord = 1 - 1e-6;
    camera.setViewOffset(width, height, -THREE30.MathUtils.clamp(ndcCoords.x, -maxNdcCoord, maxNdcCoord) * width / 2, THREE30.MathUtils.clamp(ndcCoords.y, -maxNdcCoord, maxNdcCoord) * height / 2, width, height);
  }
  CameraUtils2.setPrincipalPoint = setPrincipalPoint;
  function getHorizontalFov(camera) {
    var _a;
    return ((_a = getFovs(camera)) == null ? void 0 : _a.horizontal) ?? 2 * Math.atan(Math.tan(THREE30.MathUtils.degToRad(camera.fov) / 2) * camera.aspect);
  }
  CameraUtils2.getHorizontalFov = getHorizontalFov;
  function getTopFov(camera) {
    var _a;
    return ((_a = getFovs(camera)) == null ? void 0 : _a.top) ?? THREE30.MathUtils.degToRad(camera.fov / 2);
  }
  CameraUtils2.getTopFov = getTopFov;
  function getBottomFov(camera) {
    return THREE30.MathUtils.degToRad(camera.fov) - getTopFov(camera);
  }
  CameraUtils2.getBottomFov = getBottomFov;
  function getRightFov(camera) {
    var _a;
    return ((_a = getFovs(camera)) == null ? void 0 : _a.right) ?? getHorizontalFov(camera) / 2;
  }
  CameraUtils2.getRightFov = getRightFov;
  function getLeftFov(camera) {
    var _a;
    return ((_a = getFovs(camera)) == null ? void 0 : _a.right) !== void 0 ? getHorizontalFov(camera) - getRightFov(camera) : getHorizontalFov(camera) / 2;
  }
  CameraUtils2.getLeftFov = getLeftFov;
})(CameraUtils || (CameraUtils = {}));

// src/mapview/geometry/Object3DUtils.ts
var THREE96 = __toESM(require("three"));

// src/mapview/Tile.ts
var THREE95 = __toESM(require("three"));

// src/mapview/geometry/LodMesh.ts
var THREE31 = __toESM(require("three"));
var LodMesh = class extends THREE31.Mesh {
  m_geometries;
  constructor(geometries, material) {
    super(void 0, material);
    this.geometries = geometries;
  }
  set geometries(geometries) {
    if (this.m_geometries !== geometries) {
      this.disposeGeometries();
    }
    this.m_geometries = geometries;
    if (this.geometries && this.m_geometries.length > 0) {
      this.geometry = this.m_geometries[0];
    }
  }
  get geometries() {
    return this.m_geometries;
  }
  setLevelOfDetail(level) {
    if (!this.m_geometries || this.m_geometries.length === 0) {
      return;
    }
    level = THREE31.MathUtils.clamp(level, 0, this.m_geometries.length - 1);
    this.geometry = this.m_geometries[level];
  }
  disposeGeometries() {
    if (this.m_geometries) {
      for (const geometry of this.m_geometries) {
        geometry.dispose();
      }
    }
    this.geometry.dispose();
  }
};

// src/mapview/MapView.ts
var THREE91 = __toESM(require("three"));

// src/map-controls/MapControls.ts
var THREE32 = __toESM(require("three"));

// src/map-controls/Utils.ts
var import_three4 = require("three");

// src/map-controls/MapControls.ts
var DEFAULT_MAX_TILT_ANGLE = THREE32.MathUtils.degToRad(89);

// src/map-controls/MapAnimations.ts
var THREE33 = __toESM(require("three"));
var TWEEN = __toESM(require("@tweenjs/tween.js"));

// src/map-controls/CameraKeyTrackAnimation.ts
var THREE34 = __toESM(require("three"));
var logger3 = LoggerManager.instance.create("CameraKeyTrackAnimation");
var MIN_DISTANCE = 0;
var ControlPoint = class {
  timestamp = 0;
  target;
  name;
  tilt;
  heading;
  distance;
  constructor(options) {
    this.timestamp = options.timestamp;
    this.target = options.target ? GeoCoordinates.fromObject(options.target) : new GeoCoordinates(0, 0);
    this.tilt = options.tilt ?? 0;
    this.heading = options.heading ?? 0;
    this.distance = options.distance ?? MIN_DISTANCE;
    this.name = options.name ?? Date.now().toString();
  }
};
var AnimationDummy = class extends THREE34.Object3D {
  distance = 0;
  constructor(name2) {
    super();
    this.name = name2;
  }
};
var CameraKeyTrackAnimation = class {
  constructor(m_mapView, m_options) {
    this.m_mapView = m_mapView;
    this.m_options = m_options;
    const interpolation = this.m_options.interpolation !== void 0 ? this.m_options.interpolation : THREE34.InterpolateSmooth;
    this.m_options.loop = this.m_options.loop ?? THREE34.LoopOnce;
    this.m_options.repetitions = this.m_options.repetitions ?? 1;
    this.m_options.rotateOnlyClockwise = this.m_options.rotateOnlyClockwise ?? true;
    this.m_name = (this.m_options.name ?? "CameraKeyTrackAnimation") + Date.now();
    const timestamps = this.m_options.controlPoints.map((point) => {
      return point.timestamp;
    });
    const posValues = [];
    const rotValues = [];
    this.m_options.controlPoints.map((point) => {
      const worldPos = this.m_mapView.projection.projectPoint(point.target);
      posValues.push(worldPos.x);
      posValues.push(worldPos.y);
      posValues.push(worldPos.z);
      const rot = new THREE34.Quaternion();
      rot.setFromAxisAngle(this.m_azimuthAxis, THREE34.MathUtils.degToRad(point.heading));
      rot.multiply(new THREE34.Quaternion().setFromAxisAngle(this.m_altitudeAxis, THREE34.MathUtils.degToRad(point.tilt)));
      rotValues.push(rot.x);
      rotValues.push(rot.y);
      rotValues.push(rot.z);
      rotValues.push(rot.w);
    });
    const lookAtTrack = new THREE34.VectorKeyframeTrack(".position", timestamps, posValues, interpolation);
    const rotationTrack = new THREE34.QuaternionKeyframeTrack(".quaternion", timestamps, rotValues, interpolation);
    const distanceTrack = new THREE34.NumberKeyframeTrack(".distance", timestamps, this.m_options.controlPoints.map((point) => {
      return point.distance;
    }), interpolation);
    this.m_animationClip = new THREE34.AnimationClip("cameraflyoveranimation", -1, [
      lookAtTrack,
      rotationTrack,
      distanceTrack
    ]);
    if (!this.m_animationClip.validate()) {
      logger3.error("Review the entered controlpoints for: ", this.m_name, ", The Animation was provided with invalid track data");
    }
    this.m_animationClip.resetDuration();
    this.m_animationClip.trim();
    this.m_animationMixer = new THREE34.AnimationMixer(this.m_dummy);
    this.m_animationAction = this.m_animationMixer.clipAction(this.m_animationClip);
    this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
    this.m_animationAction.clampWhenFinished = true;
    this.m_animateCb = this.animate.bind(this);
    this.m_animationMixer.addEventListener("finished", this.stop.bind(this));
  }
  m_animationClip;
  m_animationMixer;
  m_animationAction;
  m_dummy = new AnimationDummy("dummy");
  m_azimuthAxis = new THREE34.Vector3(0, 0, 1);
  m_altitudeAxis = new THREE34.Vector3(1, 0, 0);
  m_running = false;
  m_onFinished;
  m_name;
  m_lastFrameTime = 0;
  m_animateCb;
  set loop(value2) {
    this.m_options.loop = value2;
    this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
  }
  set repetitions(value2) {
    this.m_options.repetitions = value2;
    this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
  }
  set rotateOnlyClockwise(value2) {
    this.m_options.rotateOnlyClockwise = value2;
  }
  start(time, onFinished) {
    if (this.m_running) {
      this.stop();
    }
    this.m_onFinished = onFinished;
    this.m_animationAction.reset().play();
    this.m_lastFrameTime = Date.now();
    this.m_mapView.addEventListener("render" /* Render */, this.m_animateCb);
    this.m_mapView.beginAnimation();
    this.m_running = true;
  }
  stop() {
    this.m_mapView.removeEventListener("render" /* Render */, this.m_animateCb);
    this.m_mapView.endAnimation();
    if (this.m_onFinished !== void 0) {
      window.setTimeout(this.m_onFinished, 0);
    }
    this.m_running = false;
  }
  isRunning() {
    return this.m_running;
  }
  updateCameraFromDummy() {
    let tilt = THREE34.MathUtils.radToDeg(this.m_azimuthAxis.clone().applyQuaternion(this.m_dummy.quaternion).angleTo(this.m_azimuthAxis));
    tilt = THREE34.MathUtils.clamp(tilt, 0, MapViewUtils.MAX_TILT_DEG);
    const vec0 = this.m_altitudeAxis.clone().applyQuaternion(this.m_dummy.quaternion);
    let angle = vec0.angleTo(this.m_altitudeAxis);
    if (this.m_options.rotateOnlyClockwise) {
      const direction = this.m_azimuthAxis.dot(vec0.normalize().cross(this.m_altitudeAxis));
      if (direction >= 0) {
        angle = 2 * Math.PI - angle;
      }
    }
    const heading = THREE34.MathUtils.radToDeg(angle);
    const target = this.m_mapView.projection.unprojectPoint(this.m_dummy.position);
    const distance = Math.max(MIN_DISTANCE, this.m_dummy.distance);
    if (isNaN(tilt) || isNaN(heading) || isNaN(distance) || !target.isValid()) {
      logger3.error("Cannot update due to invalid data", tilt, heading, distance, target);
    }
    this.m_mapView.lookAt({ target, distance, tilt, heading });
  }
  animate(event) {
    const deltaTime = (Date.now() - this.m_lastFrameTime) / 1e3;
    this.m_animationMixer.update(deltaTime);
    this.m_lastFrameTime = Date.now();
    this.updateCameraFromDummy();
  }
};

// src/map-controls/CameraAnimationBuilder.ts
var THREE35 = __toESM(require("three"));
var CameraAnimationBuilder = class {
  static getLookAtFromView(mapView) {
    return {
      target: mapView.target,
      heading: mapView.heading,
      tilt: mapView.tilt,
      distance: mapView.targetDistance
    };
  }
  static appendControlPoint(options, point, appendTime) {
    appendTime = appendTime ?? 10;
    if (options.controlPoints.length > 0 && (point.timestamp === void 0 || point.timestamp <= options.controlPoints[options.controlPoints.length - 1].timestamp)) {
      point.timestamp = options.controlPoints[options.controlPoints.length - 1].timestamp + appendTime;
    }
    options.controlPoints.push(point);
  }
  static prependControlPoint(options, point, prependTime) {
    prependTime = prependTime !== void 0 ? prependTime : 10;
    for (const controlPoint of options.controlPoints) {
      controlPoint.timestamp += prependTime;
    }
    point.timestamp = 0;
    options.controlPoints.unshift(point);
  }
  static createBowFlyToOptions(mapView, startControlPoint, targetControlPoint, altitude, duration = 10) {
    const controlPoints = [startControlPoint];
    const startWorldTarget = new THREE35.Vector3();
    mapView.projection.projectPoint(startControlPoint.target, startWorldTarget);
    let maxAltitude = altitude ?? 2 * startWorldTarget.distanceTo(mapView.projection.projectPoint(targetControlPoint.target));
    maxAltitude = Math.max(startControlPoint.distance + targetControlPoint.distance, maxAltitude);
    const midCoord0 = GeoCoordinates.lerp(startControlPoint.target, targetControlPoint.target, 0.25);
    const midPoint0 = new ControlPoint({
      target: midCoord0,
      distance: maxAltitude,
      timestamp: duration / 3,
      tilt: MathUtils3.interpolateAnglesDeg(startControlPoint.tilt, targetControlPoint.tilt, 0.25),
      heading: MathUtils3.interpolateAnglesDeg(startControlPoint.heading, targetControlPoint.heading, 0.25)
    });
    controlPoints.push(midPoint0);
    const midCoord1 = GeoCoordinates.lerp(startControlPoint.target, targetControlPoint.target, 0.75);
    const midPoint1 = new ControlPoint({
      target: midCoord1,
      distance: maxAltitude,
      timestamp: duration / 3 * 2,
      tilt: MathUtils3.interpolateAnglesDeg(startControlPoint.tilt, targetControlPoint.tilt, 0.75),
      heading: MathUtils3.interpolateAnglesDeg(startControlPoint.heading, targetControlPoint.heading, 0.75)
    });
    controlPoints.push(midPoint1);
    targetControlPoint.timestamp = duration;
    controlPoints.push(targetControlPoint);
    return { controlPoints };
  }
  static createOrbitOptions(startControlPoint, duration = 10) {
    const amountOfKeys = 4;
    const controlPoints = [startControlPoint];
    const steps = amountOfKeys - 1;
    const headingStep = 360 / steps;
    const timeStep = duration / steps;
    for (let n = 1; n < amountOfKeys; n++) {
      const prev = controlPoints[n - 1];
      controlPoints.push({
        ...prev,
        heading: prev.heading - headingStep,
        timestamp: prev.timestamp + timeStep
      });
    }
    return { controlPoints };
  }
};

// src/ecs/Utils.js
function queryKey(Components) {
  var ids = [];
  for (var n = 0; n < Components.length; n++) {
    var T = Components[n];
    if (!componentRegistered(T)) {
      throw new Error(`Tried to create a query with an unregistered component`);
    }
    if (typeof T === "object") {
      var operator = T.operator === "not" ? "!" : T.operator;
      ids.push(operator + T.Component._typeId);
    } else {
      ids.push(T._typeId);
    }
  }
  return ids.sort().join("-");
}
var hasWindow = typeof window !== "undefined";
var now = hasWindow && typeof window.performance !== "undefined" ? performance.now.bind(performance) : Date.now.bind(Date);
function componentRegistered(T) {
  return typeof T === "object" && T.Component._typeId !== void 0 || T.isComponent && T._typeId !== void 0;
}

// src/ecs/EventDispatcher.js
var EventDispatcher2 = class {
  constructor() {
    this._listeners = {};
    this.stats = {
      fired: 0,
      handled: 0
    };
  }
  addEventListener(eventName, listener) {
    let listeners = this._listeners;
    if (listeners[eventName] === void 0) {
      listeners[eventName] = [];
    }
    if (listeners[eventName].indexOf(listener) === -1) {
      listeners[eventName].push(listener);
    }
  }
  hasEventListener(eventName, listener) {
    return this._listeners[eventName] !== void 0 && this._listeners[eventName].indexOf(listener) !== -1;
  }
  removeEventListener(eventName, listener) {
    var listenerArray = this._listeners[eventName];
    if (listenerArray !== void 0) {
      var index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(eventName, entity, component) {
    this.stats.fired++;
    var listenerArray = this._listeners[eventName];
    if (listenerArray !== void 0) {
      var array = listenerArray.slice(0);
      for (var i = 0; i < array.length; i++) {
        array[i].call(this, entity, component);
      }
    }
  }
  resetCounters() {
    this.stats.fired = this.stats.handled = 0;
  }
};

// src/ecs/Query.js
var Query = class {
  constructor(Components, manager) {
    this.Components = [];
    this.NotComponents = [];
    Components.forEach((component) => {
      if (typeof component === "object") {
        this.NotComponents.push(component.Component);
      } else {
        this.Components.push(component);
      }
    });
    if (this.Components.length === 0) {
      throw new Error("Can't create a query without components");
    }
    this.entities = [];
    this.eventDispatcher = new EventDispatcher2();
    this.reactive = false;
    this.key = queryKey(Components);
    for (var i = 0; i < manager._entities.length; i++) {
      var entity = manager._entities[i];
      if (this.match(entity)) {
        entity.queries.push(this);
        this.entities.push(entity);
      }
    }
  }
  addEntity(entity) {
    entity.queries.push(this);
    this.entities.push(entity);
    this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_ADDED, entity);
  }
  removeEntity(entity) {
    let index = this.entities.indexOf(entity);
    if (~index) {
      this.entities.splice(index, 1);
      index = entity.queries.indexOf(this);
      entity.queries.splice(index, 1);
      this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_REMOVED, entity);
    }
  }
  match(entity) {
    return entity.hasAllComponents(this.Components) && !entity.hasAnyComponents(this.NotComponents);
  }
  toJSON() {
    return {
      key: this.key,
      reactive: this.reactive,
      components: {
        included: this.Components.map((C) => C.name),
        not: this.NotComponents.map((C) => C.name)
      },
      numEntities: this.entities.length
    };
  }
  stats() {
    return {
      numComponents: this.Components.length,
      numEntities: this.entities.length
    };
  }
};
Query.prototype.ENTITY_ADDED = "Query#ENTITY_ADDED";
Query.prototype.ENTITY_REMOVED = "Query#ENTITY_REMOVED";
Query.prototype.COMPONENT_CHANGED = "Query#COMPONENT_CHANGED";

// src/ecs/Component.js
var Component = class {
  constructor(props) {
    if (props !== false) {
      const schema = this.constructor.schema;
      for (const key in schema) {
        if (props && props.hasOwnProperty(key)) {
          this[key] = props[key];
        } else {
          const schemaProp = schema[key];
          if (schemaProp.hasOwnProperty("default")) {
            this[key] = schemaProp.type.clone(schemaProp.default);
          } else {
            const type = schemaProp.type;
            this[key] = type.clone(type.default);
          }
        }
      }
      if (process.env.NODE_ENV !== "production" && props !== void 0) {
        this.checkUndefinedAttributes(props);
      }
    }
    this._pool = null;
  }
  copy(source) {
    const schema = this.constructor.schema;
    for (const key in schema) {
      const prop = schema[key];
      if (source.hasOwnProperty(key)) {
        this[key] = prop.type.copy(source[key], this[key]);
      }
    }
    if (process.env.NODE_ENV !== "production") {
      this.checkUndefinedAttributes(source);
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  reset() {
    const schema = this.constructor.schema;
    for (const key in schema) {
      const schemaProp = schema[key];
      if (schemaProp.hasOwnProperty("default")) {
        this[key] = schemaProp.type.copy(schemaProp.default, this[key]);
      } else {
        const type = schemaProp.type;
        this[key] = type.copy(type.default, this[key]);
      }
    }
  }
  dispose() {
    if (this._pool) {
      this._pool.release(this);
    }
  }
  getName() {
    return this.constructor.getName();
  }
  checkUndefinedAttributes(src) {
    const schema = this.constructor.schema;
    Object.keys(src).forEach((srcKey) => {
      if (!schema.hasOwnProperty(srcKey)) {
        console.warn(`Trying to set attribute '${srcKey}' not defined in the '${this.constructor.name}' schema. Please fix the schema, the attribute value won't be set`);
      }
    });
  }
};
Component.schema = {};
Component.isComponent = true;
Component.getName = function() {
  return this.displayName || this.name;
};

// src/ecs/SystemStateComponent.js
var SystemStateComponent = class extends Component {
};
SystemStateComponent.isSystemStateComponent = true;

// src/ecs/System.js
var System = class {
  canExecute() {
    if (this._mandatoryQueries.length === 0)
      return true;
    for (let i = 0; i < this._mandatoryQueries.length; i++) {
      var query = this._mandatoryQueries[i];
      if (query.entities.length === 0) {
        return false;
      }
    }
    return true;
  }
  getName() {
    return this.constructor.getName();
  }
  constructor(world, attributes) {
    this.world = world;
    this.enabled = true;
    this._queries = {};
    this.queries = {};
    this.priority = 0;
    this.executeTime = 0;
    if (attributes && attributes.priority) {
      this.priority = attributes.priority;
    }
    this._mandatoryQueries = [];
    this.initialized = true;
    if (this.constructor.queries) {
      for (var queryName in this.constructor.queries) {
        var queryConfig = this.constructor.queries[queryName];
        var Components = queryConfig.components;
        if (!Components || Components.length === 0) {
          throw new Error("'components' attribute can't be empty in a query");
        }
        let unregisteredComponents = Components.filter((Component2) => !componentRegistered(Component2));
        if (unregisteredComponents.length > 0) {
          throw new Error(`Tried to create a query '${this.constructor.name}.${queryName}' with unregistered components: [${unregisteredComponents.map((c) => c.getName()).join(", ")}]`);
        }
        var query = this.world.entityManager.queryComponents(Components);
        this._queries[queryName] = query;
        if (queryConfig.mandatory === true) {
          this._mandatoryQueries.push(query);
        }
        this.queries[queryName] = {
          results: query.entities
        };
        var validEvents = ["added", "removed", "changed"];
        const eventMapping = {
          added: Query.prototype.ENTITY_ADDED,
          removed: Query.prototype.ENTITY_REMOVED,
          changed: Query.prototype.COMPONENT_CHANGED
        };
        if (queryConfig.listen) {
          validEvents.forEach((eventName) => {
            if (!this.execute) {
              console.warn(`System '${this.getName()}' has defined listen events (${validEvents.join(", ")}) for query '${queryName}' but it does not implement the 'execute' method.`);
            }
            if (queryConfig.listen[eventName]) {
              let event = queryConfig.listen[eventName];
              if (eventName === "changed") {
                query.reactive = true;
                if (event === true) {
                  let eventList = this.queries[queryName][eventName] = [];
                  query.eventDispatcher.addEventListener(Query.prototype.COMPONENT_CHANGED, (entity) => {
                    if (eventList.indexOf(entity) === -1) {
                      eventList.push(entity);
                    }
                  });
                } else if (Array.isArray(event)) {
                  let eventList = this.queries[queryName][eventName] = [];
                  query.eventDispatcher.addEventListener(Query.prototype.COMPONENT_CHANGED, (entity, changedComponent) => {
                    if (event.indexOf(changedComponent.constructor) !== -1 && eventList.indexOf(entity) === -1) {
                      eventList.push(entity);
                    }
                  });
                } else {
                }
              } else {
                let eventList = this.queries[queryName][eventName] = [];
                query.eventDispatcher.addEventListener(eventMapping[eventName], (entity) => {
                  if (eventList.indexOf(entity) === -1)
                    eventList.push(entity);
                });
              }
            }
          });
        }
      }
    }
  }
  stop() {
    this.executeTime = 0;
    this.enabled = false;
  }
  play() {
    this.enabled = true;
  }
  clearEvents() {
    for (let queryName in this.queries) {
      var query = this.queries[queryName];
      if (query.added) {
        query.added.length = 0;
      }
      if (query.removed) {
        query.removed.length = 0;
      }
      if (query.changed) {
        if (Array.isArray(query.changed)) {
          query.changed.length = 0;
        } else {
          for (let name2 in query.changed) {
            query.changed[name2].length = 0;
          }
        }
      }
    }
  }
  toJSON() {
    var json = {
      name: this.getName(),
      enabled: this.enabled,
      executeTime: this.executeTime,
      priority: this.priority,
      queries: {}
    };
    if (this.constructor.queries) {
      var queries = this.constructor.queries;
      for (let queryName in queries) {
        let query = this.queries[queryName];
        let queryDefinition = queries[queryName];
        let jsonQuery = json.queries[queryName] = {
          key: this._queries[queryName].key
        };
        jsonQuery.mandatory = queryDefinition.mandatory === true;
        jsonQuery.reactive = queryDefinition.listen && (queryDefinition.listen.added === true || queryDefinition.listen.removed === true || queryDefinition.listen.changed === true || Array.isArray(queryDefinition.listen.changed));
        if (jsonQuery.reactive) {
          jsonQuery.listen = {};
          const methods = ["added", "removed", "changed"];
          methods.forEach((method) => {
            if (query[method]) {
              jsonQuery.listen[method] = {
                entities: query[method].length
              };
            }
          });
        }
      }
    }
    return json;
  }
};
System.isSystem = true;
System.getName = function() {
  return this.displayName || this.name;
};

// src/ecs/TagComponent.js
var TagComponent = class extends Component {
  constructor() {
    super(false);
  }
};
TagComponent.isTagComponent = true;

// src/ecs/Types.js
var copyValue = (src) => src;
var cloneValue = (src) => src;
var copyArray = (src, dest) => {
  if (!src) {
    return src;
  }
  if (!dest) {
    return src.slice();
  }
  dest.length = 0;
  for (let i = 0; i < src.length; i++) {
    dest.push(src[i]);
  }
  return dest;
};
var cloneArray = (src) => src && src.slice();
var copyJSON = (src) => JSON.parse(JSON.stringify(src));
var cloneJSON = (src) => JSON.parse(JSON.stringify(src));
function createType(typeDefinition) {
  var mandatoryProperties = ["name", "default", "copy", "clone"];
  var undefinedProperties = mandatoryProperties.filter((p) => {
    return !typeDefinition.hasOwnProperty(p);
  });
  if (undefinedProperties.length > 0) {
    throw new Error(`createType expects a type definition with the following properties: ${undefinedProperties.join(", ")}`);
  }
  typeDefinition.isType = true;
  return typeDefinition;
}
var Types = {
  Number: createType({
    name: "Number",
    default: 0,
    copy: copyValue,
    clone: cloneValue
  }),
  Boolean: createType({
    name: "Boolean",
    default: false,
    copy: copyValue,
    clone: cloneValue
  }),
  String: createType({
    name: "String",
    default: "",
    copy: copyValue,
    clone: cloneValue
  }),
  Array: createType({
    name: "Array",
    default: [],
    copy: copyArray,
    clone: cloneArray
  }),
  Ref: createType({
    name: "Ref",
    default: void 0,
    copy: copyValue,
    clone: cloneValue
  }),
  JSON: createType({
    name: "JSON",
    default: null,
    copy: copyJSON,
    clone: cloneJSON
  })
};

// src/ecs/RemoteDevTools/utils.js
function generateId(length) {
  var result = "";
  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
function injectScript(src, onLoad) {
  var script2 = document.createElement("script");
  script2.src = src;
  script2.onload = onLoad;
  (document.head || document.documentElement).appendChild(script2);
}

// src/ecs/RemoteDevTools/index.js
var import_react_native = require("react-native");
function hookConsoleAndErrors(connection2) {
  if (import_react_native.Platform.OS !== "web")
    return;
  var wrapFunctions = ["error", "warning", "log"];
  wrapFunctions.forEach((key) => {
    if (typeof console[key] === "function") {
      var fn = console[key].bind(console);
      console[key] = (...args) => {
        connection2.send({
          method: "console",
          type: key,
          args: JSON.stringify(args)
        });
        return fn.apply(null, args);
      };
    }
  });
  window.addEventListener("error", (error) => {
    connection2.send({
      method: "error",
      error: JSON.stringify({
        message: error.error.message,
        stack: error.error.stack
      })
    });
  });
}
function includeRemoteIdHTML(remoteId2) {
  if (import_react_native.Platform.OS !== "web")
    return;
  let infoDiv2 = document.createElement("div");
  infoDiv2.style.cssText = `
    align-items: center;
    background-color: #333;
    color: #aaa;
    display:flex;
    font-family: Arial;
    font-size: 1.1em;
    height: 40px;
    justify-content: center;
    left: 0;
    opacity: 0.9;
    position: absolute;
    right: 0;
    text-align: center;
    top: 0;
  `;
  infoDiv2.innerHTML = `Open ECSY devtools to connect to this page using the code:&nbsp;<b style="color: #fff">${remoteId2}</b>&nbsp;<button onClick="generateNewCode()">Generate new code</button>`;
  document.body.appendChild(infoDiv2);
  return infoDiv2;
}
function enableRemoteDevtools(remoteId) {
  if (import_react_native.Platform.OS !== "web")
    return;
  if (!hasWindow) {
    console.warn("Remote devtools not available outside the browser");
    return;
  }
  window.generateNewCode = () => {
    window.localStorage.clear();
    remoteId = generateId(6);
    window.localStorage.setItem("ecsyRemoteId", remoteId);
    window.location.reload(false);
  };
  remoteId = remoteId || window.localStorage.getItem("ecsyRemoteId");
  if (!remoteId) {
    remoteId = generateId(6);
    window.localStorage.setItem("ecsyRemoteId", remoteId);
  }
  let infoDiv = includeRemoteIdHTML(remoteId);
  window.__ECSY_REMOTE_DEVTOOLS_INJECTED = true;
  window.__ECSY_REMOTE_DEVTOOLS = {};
  let Version = "";
  let worldsBeforeLoading = [];
  let onWorldCreated = (e) => {
    var world = e.detail.world;
    Version = e.detail.version;
    worldsBeforeLoading.push(world);
  };
  window.addEventListener("ecsy-world-created", onWorldCreated);
  let onLoaded = () => {
    var peer = new Peer(remoteId, {
      host: "peerjs.ecsy.io",
      secure: true,
      port: 443,
      config: {
        iceServers: [
          { url: "stun:stun.l.google.com:19302" },
          { url: "stun:stun1.l.google.com:19302" },
          { url: "stun:stun2.l.google.com:19302" },
          { url: "stun:stun3.l.google.com:19302" },
          { url: "stun:stun4.l.google.com:19302" }
        ]
      },
      debug: 3
    });
    peer.on("open", () => {
      peer.on("connection", (connection) => {
        window.__ECSY_REMOTE_DEVTOOLS.connection = connection;
        connection.on("open", function() {
          infoDiv.innerHTML = "Connected";
          connection.on("data", function(data) {
            if (data.type === "init") {
              var script = document.createElement("script");
              script.setAttribute("type", "text/javascript");
              script.onload = () => {
                script.parentNode.removeChild(script);
                window.removeEventListener("ecsy-world-created", onWorldCreated);
                worldsBeforeLoading.forEach((world) => {
                  var event = new CustomEvent("ecsy-world-created", {
                    detail: { world, version: Version }
                  });
                  window.dispatchEvent(event);
                });
              };
              script.innerHTML = data.script;
              (document.head || document.documentElement).appendChild(script);
              script.onload();
              hookConsoleAndErrors(connection);
            } else if (data.type === "executeScript") {
              let value = eval(data.script);
              if (data.returnEval) {
                connection.send({
                  method: "evalReturn",
                  value
                });
              }
            }
          });
        });
      });
    });
  };
  injectScript("https://cdn.jsdelivr.net/npm/peerjs@0.3.20/dist/peer.min.js", onLoaded);
}
if (hasWindow && import_react_native.Platform.OS == "web") {
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has("enable-remote-devtools")) {
    enableRemoteDevtools();
  }
}

// src/Rotating.ts
var Rotating = class extends Component {
  speed = 1;
};
Rotating.schema = {
  speed: { default: 1, type: Types.Number }
};

// src/mapview/DataSource.ts
var THREE36 = __toESM(require("three"));
var logger4 = LoggerManager.instance.create("DataSource");
var _DataSource = class extends THREE36.EventDispatcher {
  UPDATE_EVENT = { type: "update" };
  enabled = true;
  cacheable = false;
  useGeometryLoader = false;
  name;
  addGroundPlane = false;
  minDataLevel = 1;
  maxDataLevel = 20;
  minDisplayLevel = 1;
  maxDisplayLevel = 20;
  allowOverlappingTiles = true;
  enablePicking = true;
  dataSourceOrder = 0;
  exprPool = new ExprPool();
  m_mapView;
  m_styleSetName;
  m_maxGeometryHeight = 0;
  m_minGeometryHeight = 0;
  m_storageLevelOffset = 0;
  m_featureStateMap = /* @__PURE__ */ new Map();
  languages;
  constructor(options = {}) {
    super();
    let { name: name2 } = options;
    const {
      styleSetName,
      languages,
      minZoomLevel,
      maxZoomLevel,
      minDataLevel,
      maxDataLevel,
      minDisplayLevel,
      maxDisplayLevel,
      storageLevelOffset,
      allowOverlappingTiles,
      enablePicking,
      minGeometryHeight,
      maxGeometryHeight,
      dataSourceOrder
    } = options;
    if (name2 === void 0 || name2.length === 0) {
      name2 = `anonymous-datasource#${++_DataSource.uniqueNameCounter}`;
    }
    this.name = name2;
    this.styleSetName = styleSetName;
    if (languages !== void 0) {
      this.languages = languages;
    }
    if (minDataLevel !== void 0) {
      this.minDataLevel = minDataLevel;
    }
    if (maxDataLevel !== void 0) {
      this.maxDataLevel = maxDataLevel;
    }
    if (minZoomLevel !== void 0) {
      this.minZoomLevel = minZoomLevel;
    }
    if (maxZoomLevel !== void 0) {
      this.maxZoomLevel = maxZoomLevel;
    }
    if (minDisplayLevel !== void 0) {
      this.minDisplayLevel = minDisplayLevel;
    }
    if (maxDisplayLevel !== void 0) {
      this.maxDisplayLevel = maxDisplayLevel;
    }
    if (storageLevelOffset !== void 0) {
      this.m_storageLevelOffset = storageLevelOffset;
    }
    if (allowOverlappingTiles !== void 0) {
      this.allowOverlappingTiles = allowOverlappingTiles;
    }
    if (enablePicking !== void 0) {
      this.enablePicking = enablePicking;
    }
    if (minGeometryHeight !== void 0) {
      this.minGeometryHeight = minGeometryHeight;
    }
    if (maxGeometryHeight !== void 0) {
      this.maxGeometryHeight = maxGeometryHeight;
    }
    if (dataSourceOrder) {
      this.dataSourceOrder = dataSourceOrder;
    }
  }
  getFeatureState(featureId) {
    return this.m_featureStateMap.get(featureId);
  }
  clearFeatureState() {
    this.m_featureStateMap.clear();
  }
  setFeatureState(featureId, state) {
    this.m_featureStateMap.set(featureId, state);
  }
  removeFeatureState(featureId) {
    this.m_featureStateMap.delete(featureId);
  }
  get styleSetName() {
    return this.m_styleSetName;
  }
  set styleSetName(styleSetName) {
    if (styleSetName !== this.m_styleSetName) {
      this.m_styleSetName = styleSetName;
      this.clearCache();
      this.requestUpdate();
    }
  }
  dispose() {
  }
  clearCache() {
  }
  isFullyCovering() {
    return this.addGroundPlane;
  }
  ready() {
    return true;
  }
  get mapView() {
    if (this.m_mapView === void 0) {
      throw new Error("This DataSource was not added to MapView");
    }
    return this.m_mapView;
  }
  get projection() {
    return this.mapView.projection;
  }
  async connect() {
  }
  attach(mapView) {
    this.m_mapView = mapView;
  }
  detach(mapView) {
    assert(this.m_mapView === mapView);
    this.m_mapView = void 0;
  }
  isDetached() {
    return this.m_mapView === void 0;
  }
  async setTheme(theme, languages) {
  }
  setLanguages(languages) {
    this.languages = languages;
  }
  setPoliticalView(pov) {
  }
  updateTile(tile) {
  }
  shouldPreloadTiles() {
    return false;
  }
  get minZoomLevel() {
    logger4.warn("DataSource.minZoomLevel is deprecated. Use minDataLevel and maxDataLevel instead.");
    return this.minDataLevel;
  }
  set minZoomLevel(level) {
    logger4.warn("DataSource.minZoomLevel is deprecated. Use minDataLevel and minDisplayLevel instead.");
    this.minDataLevel = level;
  }
  get maxZoomLevel() {
    logger4.warn("DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.");
    return this.maxDataLevel;
  }
  set maxZoomLevel(level) {
    logger4.warn("DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.");
    this.maxDataLevel = level;
  }
  get maxGeometryHeight() {
    return this.m_maxGeometryHeight;
  }
  set maxGeometryHeight(value2) {
    this.m_maxGeometryHeight = value2;
  }
  get minGeometryHeight() {
    return this.m_minGeometryHeight;
  }
  set minGeometryHeight(value2) {
    this.m_minGeometryHeight = value2;
  }
  get storageLevelOffset() {
    return this.m_storageLevelOffset;
  }
  set storageLevelOffset(levelOffset) {
    this.m_storageLevelOffset = levelOffset;
  }
  setEnableElevationOverlay(enable) {
  }
  getDataZoomLevel(zoomLevel) {
    return THREE36.MathUtils.clamp(zoomLevel + this.m_storageLevelOffset, this.minDataLevel, this.maxDataLevel);
  }
  isVisible(zoomLevel) {
    return zoomLevel >= this.minDisplayLevel && zoomLevel <= this.maxDisplayLevel;
  }
  canGetTile(zoomLevel, tileKey) {
    return tileKey.level <= zoomLevel;
  }
  shouldSubdivide(zoomLevel, tileKey) {
    return tileKey.level <= zoomLevel;
  }
  shouldRenderText(zoomLevel, tileKey) {
    return true;
  }
  requestUpdate() {
    this.dispatchEvent(this.UPDATE_EVENT);
  }
};
var DataSource = _DataSource;
__publicField(DataSource, "uniqueNameCounter", 0);

// src/mapview/geometry/AddGroundPlane.ts
var THREE46 = __toESM(require("three"));

// src/geometry/ClipLineString.ts
var import_three5 = require("three");
var ClipEdge = class {
  constructor(x1, y1, x2, y2, isInside) {
    this.isInside = isInside;
    this.p0 = new import_three5.Vector2(x1, y1);
    this.p1 = new import_three5.Vector2(x2, y2);
  }
  p0;
  p1;
  inside(point) {
    return this.isInside(point);
  }
  computeIntersection(a, b) {
    const result = new import_three5.Vector2();
    Math2D.intersectLines(a.x, a.y, b.x, b.y, this.p0.x, this.p0.y, this.p1.x, this.p1.y, result);
    return result;
  }
  clipLine(lineString) {
    const inputList = lineString;
    const result = [];
    lineString = [];
    result.push(lineString);
    const pushPoint = (point) => {
      if (lineString.length === 0 || !lineString[lineString.length - 1].equals(point)) {
        lineString.push(point);
      }
    };
    for (let i = 0; i < inputList.length; ++i) {
      const currentPoint = inputList[i];
      const prevPoint = i > 0 ? inputList[i - 1] : void 0;
      if (this.inside(currentPoint)) {
        if (prevPoint !== void 0 && !this.inside(prevPoint)) {
          if (lineString.length > 0) {
            lineString = [];
            result.push(lineString);
          }
          pushPoint(this.computeIntersection(prevPoint, currentPoint));
        }
        pushPoint(currentPoint);
      } else if (prevPoint !== void 0 && this.inside(prevPoint)) {
        pushPoint(this.computeIntersection(prevPoint, currentPoint));
      }
    }
    if (result[result.length - 1].length === 0) {
      result.length = result.length - 1;
    }
    return result;
  }
  clipLines(lineStrings) {
    const reuslt = [];
    lineStrings.forEach((lineString) => {
      this.clipLine(lineString).forEach((clippedLine) => {
        reuslt.push(clippedLine);
      });
    });
    return reuslt;
  }
};
var ec = EarthConstants.EQUATORIAL_CIRCUMFERENCE;
var border = 0;
var WRAP_MIDDLE_CLIP_EDGES = [
  new ClipEdge(0 - border, ec, 0 - border, 0, (p) => p.x > 0 - border),
  new ClipEdge(ec + border, 0, ec + border, ec, (p) => p.x < ec + border)
];
var WRAP_LEFT_CLIP_EDGES = [
  new ClipEdge(-ec - border, ec, -ec - border, 0, (p) => p.x > -ec - border),
  new ClipEdge(0 + border, 0, 0 + border, ec, (p) => p.x < 0 + border)
];
var WRAP_RIGHT_CLIP_EDGES = [
  new ClipEdge(ec - border, ec, ec - border, 0, (p) => p.x > ec - border),
  new ClipEdge(ec * 2 + border, 0, ec * 2 + border, ec, (p) => p.x < ec * 2 + border)
];

// src/geometry/ClipPolygon.ts
var import_three6 = require("three");
var ClippingEdge = class {
  clipPolygon(polygon, extent) {
    const inputList = polygon;
    polygon = [];
    const pushPoint = (point) => {
      const lastAddedPoint = polygon[polygon.length - 1];
      if (!(lastAddedPoint == null ? void 0 : lastAddedPoint.equals(point)) || point.isClipped === true && !(lastAddedPoint == null ? void 0 : lastAddedPoint.isClipped) || !point.isClipped && (lastAddedPoint == null ? void 0 : lastAddedPoint.isClipped) === true) {
        polygon.push(point);
      }
    };
    for (let i = 0; i < inputList.length; ++i) {
      const currentPoint = inputList[i];
      const prevPoint = inputList[(i + inputList.length - 1) % inputList.length];
      if (this.inside(currentPoint, extent)) {
        if (!this.inside(prevPoint, extent)) {
          const p = this.computeIntersection(prevPoint, currentPoint, extent);
          p.isClipped = true;
          pushPoint(p);
        }
        pushPoint(currentPoint);
      } else if (this.inside(prevPoint, extent)) {
        const p = this.computeIntersection(prevPoint, currentPoint, extent);
        p.isClipped = true;
        pushPoint(p);
      }
    }
    return polygon;
  }
};
var TopClippingEdge = class extends ClippingEdge {
  inside(point) {
    return point.y >= 0;
  }
  computeIntersection(a, b) {
    const { x: x1, y: y1 } = a;
    const { x: x2, y: y2 } = b;
    const v = new import_three6.Vector2((x1 * y2 - y1 * x2) / -(y1 - y2), 0).round();
    return v;
  }
};
var RightClippingEdge = class extends ClippingEdge {
  inside(point, extent) {
    return point.x <= extent;
  }
  computeIntersection(a, b, extent) {
    const { x: x1, y: y1 } = a;
    const { x: x2, y: y2 } = b;
    const v = new import_three6.Vector2(extent, (x1 * y2 - y1 * x2 - (y1 - y2) * -extent) / (x1 - x2)).round();
    return v;
  }
};
var BottomClipEdge = class extends ClippingEdge {
  inside(point, extent) {
    return point.y <= extent;
  }
  computeIntersection(a, b, extent) {
    const { x: x1, y: y1 } = a;
    const { x: x2, y: y2 } = b;
    const v = new import_three6.Vector2((x1 * y2 - y1 * x2 - (x1 - x2) * extent) / -(y1 - y2), extent).round();
    return v;
  }
};
var LeftClippingEdge = class extends ClippingEdge {
  inside(point) {
    return point.x >= 0;
  }
  computeIntersection(a, b) {
    const { x: x1, y: y1 } = a;
    const { x: x2, y: y2 } = b;
    const v = new import_three6.Vector2(0, (x1 * y2 - y1 * x2) / (x1 - x2)).round();
    return v;
  }
};
var clipEdges = [
  new TopClippingEdge(),
  new RightClippingEdge(),
  new BottomClipEdge(),
  new LeftClippingEdge()
];

// src/geometry/EdgeLengthGeometrySubdivisionModifier.ts
var import_three8 = require("three");

// src/geometry/SubdivisionModifier.ts
var import_three7 = require("three");
var tmpVectorA = new import_three7.Vector3();
var tmpVectorB = new import_three7.Vector3();
var tmpVectorC = new import_three7.Vector3();
var SubdivisionModifier = class {
  constructor() {
  }
  modify(geometry) {
    const positionAttr = geometry.getAttribute("position");
    const position = Array.from(positionAttr.array);
    const uvAttr = geometry.getAttribute("uv");
    const uv = uvAttr !== void 0 ? Array.from(uvAttr.array) : void 0;
    const edgeAttr = geometry.getAttribute("edge");
    const edge = edgeAttr !== void 0 ? Array.from(edgeAttr.array) : void 0;
    const wallAttr = geometry.getAttribute("wall");
    const wall = wallAttr !== void 0 ? Array.from(wallAttr.array) : void 0;
    const indexAttr = geometry.getIndex();
    const indices = Array.from(indexAttr.array);
    const cache6 = /* @__PURE__ */ new Map();
    function middleVertex(i, j) {
      const key = `${Math.min(i, j)}_${Math.max(i, j)}`;
      const h = cache6.get(key);
      if (h !== void 0) {
        return h;
      }
      tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);
      tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);
      tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
      const index = position.length / 3;
      position.push(...tmpVectorC.toArray());
      cache6.set(key, index);
      if (uv !== void 0) {
        tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);
        tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);
        tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
        uv.push(tmpVectorC.x, tmpVectorC.y);
      }
      if (edge !== void 0) {
        if (edge[i] === j) {
          edge.push(j);
          edge[i] = index;
        } else if (edge[j] === i) {
          edge.push(i);
          edge[j] = index;
        } else {
          edge.push(-1);
        }
      }
      if (wall !== void 0) {
        if (wall[i] === j) {
          wall.push(j);
          wall[i] = index;
        } else if (wall[j] === i) {
          wall.push(i);
          wall[j] = index;
        } else {
          wall.push(-1);
        }
      }
      return index;
    }
    const newIndices = [];
    while (indices.length >= 3) {
      const v0 = indices.shift();
      const v1 = indices.shift();
      const v2 = indices.shift();
      tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);
      tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);
      tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);
      const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);
      switch (edgeToSplit) {
        case 0: {
          const v3 = middleVertex(v0, v1);
          indices.push(v0, v3, v2, v3, v1, v2);
          break;
        }
        case 1: {
          const v3 = middleVertex(v1, v2);
          indices.push(v0, v1, v3, v0, v3, v2);
          break;
        }
        case 2: {
          const v3 = middleVertex(v2, v0);
          indices.push(v0, v1, v3, v3, v1, v2);
          break;
        }
        case void 0: {
          newIndices.push(v0, v1, v2);
          break;
        }
        default:
          throw new Error("failed to subdivide the given geometry");
      }
    }
    positionAttr.array = positionAttr.array instanceof Float32Array ? new Float32Array(position) : new Float64Array(position);
    positionAttr.count = position.length / positionAttr.itemSize;
    positionAttr.needsUpdate = true;
    geometry.setIndex(newIndices);
    if (uv !== void 0) {
      uvAttr.array = new Float32Array(uv);
      uvAttr.count = uv.length / uvAttr.itemSize;
      uvAttr.needsUpdate = true;
    }
    if (edge !== void 0) {
      edgeAttr.array = new Float32Array(edge);
      edgeAttr.count = edge.length / edgeAttr.itemSize;
      edgeAttr.needsUpdate = true;
    }
    return geometry;
  }
};

// src/geometry/EdgeLengthGeometrySubdivisionModifier.ts
var VERTEX_POSITION_CACHE = [new import_three8.Vector3(), new import_three8.Vector3()];
var EdgeLengthGeometrySubdivisionModifier = class extends SubdivisionModifier {
  constructor(subdivision, geoBox, subdivisionMode = 0 /* All */, projection) {
    super();
    this.subdivision = subdivision;
    this.geoBox = geoBox;
    this.subdivisionMode = subdivisionMode;
    this.projection = projection;
    assert(projection.type === 0 /* Planar */, "EdgeLengthGeometrySubdivisionModifier only supports planar projections");
    const northEast = projection.projectPoint(geoBox.northEast, VERTEX_POSITION_CACHE[0]);
    const southWest = projection.projectPoint(geoBox.southWest, VERTEX_POSITION_CACHE[1]);
    this.m_projectedBox = {
      min: {
        x: Math.min(northEast.x, southWest.x),
        y: Math.min(northEast.y, southWest.y),
        z: Math.min(northEast.z, southWest.z)
      },
      max: {
        x: Math.max(northEast.x, southWest.x),
        y: Math.max(northEast.y, southWest.y),
        z: Math.max(northEast.z, southWest.z)
      }
    };
    this.m_maxLengthX = (this.m_projectedBox.max.x - this.m_projectedBox.min.x) / subdivision;
    this.m_maxLengthY = (this.m_projectedBox.max.y - this.m_projectedBox.min.y) / subdivision;
    if (this.subdivisionMode === 0 /* All */) {
      this.m_maxLengthX *= 1.1;
      this.m_maxLengthY *= 1.1;
    }
    this.m_maxLength = Math.sqrt(this.m_maxLengthX * this.m_maxLengthX + this.m_maxLengthY * this.m_maxLengthY);
  }
  m_projectedBox;
  m_maxLength;
  m_maxLengthX;
  m_maxLengthY;
  get maxLength() {
    return this.m_maxLength;
  }
  get maxLengthX() {
    return this.m_maxLengthX;
  }
  get maxLengthY() {
    return this.m_maxLengthY;
  }
  shouldSplitTriangle(a, b, c) {
    const shouldSplitAB = this.shouldSplitEdge(a, b);
    const shouldSplitBC = this.shouldSplitEdge(b, c);
    const shouldSplitCA = this.shouldSplitEdge(c, a);
    const shouldSplit = shouldSplitAB || shouldSplitBC || shouldSplitCA;
    if (!shouldSplit) {
      return;
    }
    const ab = a.distanceTo(b);
    const bc = b.distanceTo(c);
    const ca = c.distanceTo(a);
    const maxDistance = Math.max(shouldSplitAB ? ab : 0, shouldSplitBC ? bc : 0, shouldSplitCA ? ca : 0);
    if (ab === maxDistance) {
      return 0;
    } else if (bc === maxDistance) {
      return 1;
    } else if (ca === maxDistance) {
      return 2;
    }
    throw new Error("Could not split triangle.");
  }
  shouldSplitEdge(a, b) {
    switch (this.subdivisionMode) {
      case 0 /* All */:
        return a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX || a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY || a.distanceTo(b) > this.m_maxLength;
      case 1 /* NoDiagonals */:
        return a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX || a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY;
    }
  }
};

// src/geometry/SphericalGeometrySubdivisionModifier.ts
var import_three9 = require("three");
var VERTEX_POSITION_CACHE2 = [new import_three9.Vector3(), new import_three9.Vector3(), new import_three9.Vector3()];
var SphericalGeometrySubdivisionModifier = class extends SubdivisionModifier {
  constructor(angle, projection = sphereProjection) {
    super();
    this.angle = angle;
    this.projection = projection;
  }
  shouldSplitTriangle(a, b, c) {
    const aa = sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE2[0]);
    const bb = sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE2[1]);
    const cc = sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE2[2]);
    const alpha = aa.angleTo(bb);
    const beta = bb.angleTo(cc);
    const gamma = cc.angleTo(aa);
    const m = Math.max(alpha, Math.max(beta, gamma));
    if (m < this.angle) {
      return void 0;
    }
    if (m === alpha) {
      return 0;
    } else if (m === beta) {
      return 1;
    } else if (m === gamma) {
      return 2;
    }
    throw new Error("failed to split triangle");
  }
};

// src/geometry/WrapPolygon.ts
var import_three10 = require("three");
var ClipEdge2 = class extends ClippingEdge {
  constructor(p0, p1, isInside) {
    super();
    this.isInside = isInside;
    this.p0 = new import_three10.Vector2().fromArray(p0);
    this.p1 = new import_three10.Vector2().fromArray(p1);
  }
  p0;
  p1;
  inside(point, extent) {
    return this.isInside(point);
  }
  computeIntersection(a, b, extent) {
    const result = new import_three10.Vector2();
    Math2D.intersectLines(a.x, a.y, b.x, b.y, this.p0.x, this.p0.y, this.p1.x, this.p1.y, result);
    return result;
  }
};
var ec2 = EarthConstants.EQUATORIAL_CIRCUMFERENCE;
var border2 = ec2 * 0.05;
var WRAP_MIDDLE_CLIP_EDGES2 = [
  new ClipEdge2([0 - border2, ec2], [0 - border2, 0], (p) => p.x > 0 - border2),
  new ClipEdge2([ec2 + border2, 0], [ec2 + border2, ec2], (p) => p.x < ec2 + border2)
];
var WRAP_LEFT_CLIP_EDGES2 = [
  new ClipEdge2([-ec2 - border2, ec2], [-ec2 - border2, 0], (p) => p.x > -ec2 - border2),
  new ClipEdge2([0 + border2, 0], [0 + border2, ec2], (p) => p.x < 0 + border2)
];
var WRAP_RIGHT_CLIP_EDGES2 = [
  new ClipEdge2([ec2 - border2, ec2], [ec2 - border2, 0], (p) => p.x > ec2 - border2),
  new ClipEdge2([ec2 * 2 + border2, 0], [ec2 * 2 + border2, ec2], (p) => p.x < ec2 * 2 + border2)
];

// src/mapview/geometry/ProjectTilePlaneCorners.ts
var THREE37 = __toESM(require("three"));
function projectTilePlaneCorners(tile, projection) {
  const { east, west, north, south } = tile.geoBox;
  const sw = projection.projectPoint(new GeoCoordinates(south, west), new THREE37.Vector3());
  const se = projection.projectPoint(new GeoCoordinates(south, east), new THREE37.Vector3());
  const nw = projection.projectPoint(new GeoCoordinates(north, west), new THREE37.Vector3());
  const ne = projection.projectPoint(new GeoCoordinates(north, east), new THREE37.Vector3());
  return { sw, se, nw, ne };
}

// src/mapview/MapMaterialAdapter.ts
var THREE45 = __toESM(require("three"));

// src/mapview/DecodedTileHelpers.ts
var THREE44 = __toESM(require("three"));

// src/mapview/geometry/DisplacedMesh.ts
var THREE40 = __toESM(require("three"));

// src/mapview/geometry/DisplacedBufferAttribute.ts
var THREE38 = __toESM(require("three"));

// src/mapview/geometry/VertexCache.ts
var Invalid = -1;
var VertexCache = class {
  constructor(maxVertexCount) {
    this.maxVertexCount = maxVertexCount;
    this.m_cache.length = this.maxVertexCount * 6 /* Count */;
    this.clear();
  }
  m_cache = [];
  m_vertexCount = 0;
  m_oldestIdx = 0;
  m_newestIdx = 0;
  clear() {
    this.m_cache.fill(Invalid);
    this.m_vertexCount = 0;
  }
  get(vertexId, vertex) {
    const vertexIdx = this.find(vertexId);
    if (vertexIdx === void 0) {
      return false;
    }
    this.promoteEntry(vertexIdx);
    this.getVertex(vertexIdx, vertex);
    return true;
  }
  set(vertexId, vertex) {
    let vertexIdx = Invalid;
    if (this.m_vertexCount < this.maxVertexCount) {
      vertexIdx = this.m_vertexCount * 6 /* Count */;
      this.m_vertexCount++;
    } else {
      vertexIdx = this.m_oldestIdx;
    }
    if (this.m_vertexCount === 1) {
      this.m_oldestIdx = this.m_newestIdx = vertexIdx;
    } else {
      this.promoteEntry(vertexIdx);
    }
    this.setVertex(vertexIdx, vertexId, vertex);
  }
  find(vertexId) {
    const size = this.m_cache.length;
    for (let i = 0; i < size; i += 6 /* Count */) {
      if (this.m_cache[i] === vertexId) {
        return i;
      }
    }
    return void 0;
  }
  promoteEntry(vertexIdx) {
    if (vertexIdx === this.m_newestIdx) {
      return;
    }
    const newerIdx = this.getNewerIdx(vertexIdx);
    const olderIdx = this.getOlderIdx(vertexIdx);
    if (newerIdx !== Invalid) {
      assert(this.getOlderIdx(newerIdx) === vertexIdx);
      this.setOlderIdx(newerIdx, olderIdx);
    }
    if (olderIdx !== Invalid) {
      assert(this.getNewerIdx(olderIdx) === vertexIdx);
      this.setNewerIdx(olderIdx, newerIdx);
    }
    if (vertexIdx === this.m_oldestIdx) {
      this.m_oldestIdx = newerIdx;
    }
    this.setNewerIdx(vertexIdx, Invalid);
    this.setOlderIdx(vertexIdx, this.m_newestIdx);
    assert(this.m_newestIdx !== Invalid);
    assert(this.getNewerIdx(this.m_newestIdx) === Invalid);
    this.setNewerIdx(this.m_newestIdx, vertexIdx);
    this.m_newestIdx = vertexIdx;
  }
  getOlderIdx(vertexIdx) {
    return this.m_cache[vertexIdx + 1 /* OlderIdx */];
  }
  setOlderIdx(vertexIdx, olderIdx) {
    this.m_cache[vertexIdx + 1 /* OlderIdx */] = olderIdx;
  }
  getNewerIdx(vertexIdx) {
    return this.m_cache[vertexIdx + 2 /* NewerIdx */];
  }
  setNewerIdx(vertexIdx, newerIdx) {
    this.m_cache[vertexIdx + 2 /* NewerIdx */] = newerIdx;
  }
  getVertex(vertexIdx, vertex) {
    vertex.x = this.m_cache[vertexIdx + 3 /* X */];
    vertex.y = this.m_cache[vertexIdx + 4 /* Y */];
    vertex.z = this.m_cache[vertexIdx + 5 /* Z */];
  }
  setVertex(vertexIdx, vertexId, vertex) {
    this.m_cache[vertexIdx] = vertexId;
    this.m_cache[vertexIdx + 3 /* X */] = vertex.x;
    this.m_cache[vertexIdx + 4 /* Y */] = vertex.y;
    this.m_cache[vertexIdx + 5 /* Z */] = vertex.z;
  }
};

// src/mapview/geometry/DisplacedBufferAttribute.ts
var _DisplacedBufferAttribute = class extends THREE38.BufferAttribute {
  constructor(originalAttribute, m_normals, m_uvs, displacementMap) {
    super(originalAttribute.array, originalAttribute.itemSize, originalAttribute.normalized);
    this.originalAttribute = originalAttribute;
    this.m_normals = m_normals;
    this.m_uvs = m_uvs;
    this.resetTexture(displacementMap);
  }
  m_texture;
  m_textureWidth = 0;
  m_textureHeight = 0;
  m_cache = new VertexCache(_DisplacedBufferAttribute.MAX_CACHE_SIZE);
  m_lastBufferIndex;
  m_lastPos = new THREE38.Vector3();
  m_tmpNormal = new THREE38.Vector3();
  reset(originalAttribute, normals, uvs, displacementMap) {
    this.array = originalAttribute.array;
    this.itemSize = originalAttribute.itemSize;
    this.count = this.array.length / this.itemSize;
    this.normalized = originalAttribute.normalized;
    this.originalAttribute = originalAttribute;
    this.m_normals = normals;
    this.m_uvs = uvs;
    this.m_cache.clear();
    this.m_lastBufferIndex = void 0;
    this.resetTexture(displacementMap);
  }
  getX(index) {
    return this.getDisplacedCoordinate(index).x;
  }
  getY(index) {
    return this.getDisplacedCoordinate(index).y;
  }
  getZ(index) {
    return this.getDisplacedCoordinate(index).z;
  }
  resetTexture(displacementMap) {
    this.m_texture = new Float32Array(displacementMap.image.data.buffer);
    this.m_textureWidth = displacementMap.image.width;
    this.m_textureHeight = displacementMap.image.height;
  }
  getDisplacedCoordinate(bufferIndex) {
    if (bufferIndex === this.m_lastBufferIndex) {
      return this.m_lastPos;
    }
    this.m_lastBufferIndex = bufferIndex;
    if (this.m_cache.get(bufferIndex, this.m_lastPos)) {
      return this.m_lastPos;
    }
    this.displacePosition(bufferIndex);
    this.m_cache.set(bufferIndex, this.m_lastPos);
    return this.m_lastPos;
  }
  displacePosition(bufferIndex) {
    this.m_lastPos.fromBufferAttribute(this.originalAttribute, bufferIndex);
    const normals = this.m_normals;
    this.m_tmpNormal.fromBufferAttribute(normals, bufferIndex);
    const uvs = this.m_uvs;
    const u = THREE38.MathUtils.clamp(uvs.getX(bufferIndex), 0, 1);
    const v = THREE38.MathUtils.clamp(uvs.getY(bufferIndex), 0, 1);
    const displacement = sampleBilinear(this.m_texture, this.m_textureWidth, this.m_textureHeight, u, v);
    this.m_lastPos.add(this.m_tmpNormal.multiplyScalar(displacement));
  }
};
var DisplacedBufferAttribute = _DisplacedBufferAttribute;
__publicField(DisplacedBufferAttribute, "MAX_CACHE_SIZE", 6);

// src/mapview/geometry/DisplacedBufferGeometry.ts
var THREE39 = __toESM(require("three"));
var tmpV12 = new THREE39.Vector3();
var tmpV2 = new THREE39.Vector3();
var tmpBox = new THREE39.Box3();
function displaceBox(box, displacementRange, displacementDir) {
  tmpBox.copy(box);
  const tmpNormalMin = tmpV12.copy(displacementDir);
  const tmpNormalMax = tmpV2.copy(tmpNormalMin);
  box.translate(tmpNormalMin.multiplyScalar(displacementRange.min)).union(tmpBox.translate(tmpNormalMax.multiplyScalar(displacementRange.max)));
  return box;
}
var DisplacedBufferGeometry = class extends THREE39.BufferGeometry {
  constructor(originalGeometry, displacementMap, displacementRange, displacedPositions) {
    super();
    this.originalGeometry = originalGeometry;
    this.displacementRange = displacementRange;
    if (!displacedPositions) {
      this.m_displacedPositions = new DisplacedBufferAttribute(originalGeometry.attributes.position, originalGeometry.attributes.normal, originalGeometry.attributes.uv, displacementMap);
    } else {
      this.m_displacedPositions = displacedPositions;
    }
    this.resetAttributes();
  }
  m_displacedPositions;
  m_originalBoundingBox = new THREE39.Box3();
  reset(geometry, displacementMap, displacementRange) {
    this.originalGeometry = geometry;
    const positions = geometry.attributes.position;
    const normals = geometry.attributes.normal;
    const uvs = geometry.attributes.uv;
    this.m_displacedPositions.reset(positions, normals, uvs, displacementMap);
    const displacementRangeChanged = this.displacementRange.min !== displacementRange.min || this.displacementRange.max !== displacementRange.max;
    this.displacementRange = displacementRange;
    this.resetAttributes();
    this.resetBoundingVolumes(displacementRangeChanged);
  }
  computeBoundingBox() {
    if (this.originalGeometry.boundingBox === null) {
      this.originalGeometry.computeBoundingBox();
    }
    const origBBox = this.m_originalBoundingBox.copy(this.originalGeometry.boundingBox);
    if (this.boundingBox === null) {
      this.boundingBox = origBBox.clone();
    } else {
      this.boundingBox.copy(origBBox);
    }
    displaceBox(this.boundingBox, this.displacementRange, tmpV12.fromBufferAttribute(this.attributes.normal, 0));
  }
  computeBoundingSphere() {
    if (this.boundingBox === null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere === null) {
      this.boundingSphere = new THREE39.Sphere();
    }
    this.boundingBox.getBoundingSphere(this.boundingSphere);
  }
  needsBoundingBoxUpdate(displacementRangeChanged) {
    return displacementRangeChanged || this.boundingBox !== null && (!this.originalGeometry.boundingBox || !this.m_originalBoundingBox.equals(this.originalGeometry.boundingBox));
  }
  resetBoundingVolumes(displacementRangeChanged) {
    if (this.needsBoundingBoxUpdate(displacementRangeChanged)) {
      this.computeBoundingBox();
      if (this.boundingSphere) {
        this.computeBoundingSphere();
      }
    }
  }
  resetAttributes() {
    this.index = this.originalGeometry.index;
    this.groups = this.originalGeometry.groups;
    this.drawRange = this.originalGeometry.drawRange;
    this.attributes = { ...this.originalGeometry.attributes };
    this.attributes.position = this.m_displacedPositions;
  }
};

// src/mapview/geometry/DisplacedMesh.ts
function isDisplacementMaterial(material) {
  const isDisplacementFeature = hasDisplacementFeature(material);
  assert(isDisplacementFeature, "Material does not support displacement maps.");
  return isDisplacementFeature;
}
function isDataTextureMap(map) {
  if (!map) {
    return false;
  }
  const isDataTexture = map instanceof THREE40.DataTexture;
  assert(isDataTexture, "Material does not support displacement maps.");
  return isDataTexture;
}
var _DisplacedMesh = class extends THREE40.Mesh {
  constructor(geometry, material, m_getDisplacementRange, m_raycastStrategy) {
    super(geometry, material);
    this.m_getDisplacementRange = m_getDisplacementRange;
    this.m_raycastStrategy = m_raycastStrategy;
  }
  static getDisplacedPositionAttribute(geometry, displacementMap) {
    if (!_DisplacedMesh.displacedPositions) {
      _DisplacedMesh.displacedPositions = new DisplacedBufferAttribute(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);
    } else {
      _DisplacedMesh.displacedPositions.reset(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);
    }
    return _DisplacedMesh.displacedPositions;
  }
  displacedGeometry;
  raycast(raycaster, intersects) {
    const firstMaterial = this.firstMaterial;
    if (!isDisplacementMaterial(firstMaterial) || !isDataTextureMap(firstMaterial.displacementMap)) {
      super.raycast(raycaster, intersects);
      return;
    }
    const displacementMap = firstMaterial.displacementMap;
    const displacementRange = { ...this.m_getDisplacementRange() };
    assert(this.geometry instanceof THREE40.BufferGeometry, "Unsupported geometry type.");
    const geometry = this.geometry;
    if (this.displacedGeometry) {
      this.displacedGeometry.reset(geometry, displacementMap, displacementRange);
    } else {
      this.displacedGeometry = new DisplacedBufferGeometry(geometry, displacementMap, displacementRange, _DisplacedMesh.getDisplacedPositionAttribute(geometry, displacementMap));
    }
    this.geometry = this.displacedGeometry;
    if (this.m_raycastStrategy) {
      this.m_raycastStrategy(this, raycaster, intersects);
    } else {
      super.raycast(raycaster, intersects);
    }
    super.geometry = this.displacedGeometry.originalGeometry;
  }
  get firstMaterial() {
    return Array.isArray(this.material) ? this.material[0] : this.material;
  }
};
var DisplacedMesh = _DisplacedMesh;
__publicField(DisplacedMesh, "displacedPositions");

// src/mapview/geometry/SolidLineMesh.ts
var THREE41 = __toESM(require("three"));
var tmpSphere = new THREE41.Sphere();
var tmpInverseMatrix = new THREE41.Matrix4();
var tmpRay = new THREE41.Ray();
var tmpLine1 = new THREE41.Line3();
var tmpBox2 = new THREE41.Box3();
var tmpOBB = new OrientedBox3();
var tmpPlane = new THREE41.Plane();
var tmpV13 = new THREE41.Vector3();
var tmpV22 = new THREE41.Vector3();
var tmpV3 = new THREE41.Vector3();
var tmpV4 = new THREE41.Vector3();
var SEGMENT_STRIDE = 6;
var VERTEX_STRIDE = 2;
function isSolidLineMaterial(material) {
  return Array.isArray(material) ? material.every((mat) => mat instanceof SolidLineMaterial) : material instanceof SolidLineMaterial;
}
function getAttributeInfo(attribute) {
  const isBufferAttribute = attribute.isBufferAttribute === true;
  const data2 = isBufferAttribute ? attribute : attribute.data;
  return {
    data: data2,
    version: data2.version
  };
}
function attributeChanged(attribute, attrInfo) {
  const isBufferAttribute = attribute.isBufferAttribute === true;
  const data2 = isBufferAttribute ? attribute : attribute.data;
  return attrInfo === void 0 || attrInfo.data !== data2 || attribute.isBufferAttribute && attrInfo.version !== data2.version;
}
function computeFeatureBoundingSphere(geometry, featureBeginIndex, featureEndIndex) {
  let displacementRange;
  if (geometry instanceof DisplacedBufferGeometry) {
    displacementRange = geometry.displacementRange;
    geometry = geometry.originalGeometry;
  }
  const attributes = geometry.attributes;
  const pos = attributes.position;
  const indices = geometry.index.array;
  const sphere = new THREE41.Sphere();
  const bbox = tmpBox2.makeEmpty();
  const vertex = tmpV13;
  for (let i = featureBeginIndex; i < featureEndIndex; i += SEGMENT_STRIDE) {
    bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i]));
    bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i + VERTEX_STRIDE]));
  }
  if (displacementRange) {
    const normal = tmpV22;
    normal.fromBufferAttribute(geometry.attributes.normal, 0);
    return displaceBox(bbox, displacementRange, normal).getBoundingSphere(sphere);
  }
  return bbox.getBoundingSphere(sphere);
}
function intersectExtrudedLine(ray, line, vExtrusion, normal, hWidth) {
  const obb = tmpOBB;
  line.getCenter(obb.position);
  line.delta(obb.xAxis).normalize();
  obb.yAxis.copy(vExtrusion);
  obb.zAxis.copy(normal);
  obb.extents.set(line.distance() / 2, hWidth, hWidth);
  if (obb.contains(ray.origin)) {
    return 0;
  }
  return obb.intersectsRay(ray) ?? Infinity;
}
function intersectClosestEndCap(ray, line, hWidth) {
  const sphere = new THREE41.Sphere(line.start, hWidth);
  const startCapT = sphere.containsPoint(ray.origin) ? 0 : ray.intersectSphere(sphere, tmpV4) ? tmpV4.sub(ray.origin).length() : Infinity;
  sphere.center.copy(line.end);
  const endCapT = sphere.containsPoint(ray.origin) ? 0 : ray.intersectSphere(sphere, tmpV4) ? tmpV4.sub(ray.origin).length() : Infinity;
  return Math.min(startCapT, endCapT);
}
function intersectLine(ray, line, vExtrusion, hWidth, hWidthSq, plane, interPlane, outInterLine) {
  if (interPlane.equals(ray.origin) && ray.direction.dot(plane.normal) === 0) {
    const extrLineT = intersectExtrudedLine(ray, line, vExtrusion, plane.normal, hWidth);
    const endCapT = intersectClosestEndCap(ray, line, hWidth);
    const minT = Math.min(extrLineT, endCapT);
    if (minT === Infinity) {
      return false;
    }
    ray.at(minT, outInterLine);
    return true;
  }
  const distSq = interPlane.distanceToSquared(line.closestPointToPoint(interPlane, true, tmpV4));
  if (distSq > hWidthSq) {
    return false;
  }
  outInterLine.copy(interPlane);
  return true;
}
function intersectFeature(mesh, raycaster, localRay, halfWidth, lHalfWidth, lHalfWidthSq, beginIdx, endIdx, bSphere, intersections) {
  const vExt = tmpV13;
  const plane = tmpPlane;
  const interPlane = tmpV22;
  const line = tmpLine1;
  const geometry = mesh.geometry;
  const attributes = geometry.attributes;
  const position = attributes.position;
  const bitangent = attributes.biTangent;
  const indices = geometry.index.array;
  tmpSphere.copy(bSphere);
  tmpSphere.applyMatrix4(mesh.matrixWorld);
  tmpSphere.radius += halfWidth;
  if (!raycaster.ray.intersectsSphere(tmpSphere)) {
    return;
  }
  for (let i = beginIdx; i < endIdx; i += SEGMENT_STRIDE) {
    const a = indices[i];
    const b = indices[i + VERTEX_STRIDE];
    line.start.fromBufferAttribute(position, a);
    line.end.fromBufferAttribute(position, b);
    vExt.set(bitangent.getX(a), bitangent.getY(a), bitangent.getZ(a)).normalize();
    plane.setFromCoplanarPoints(line.start, tmpV3.copy(line.start).add(vExt), line.end);
    if (plane.normal.manhattanLength() === 0) {
      continue;
    }
    if (!localRay.intersectPlane(plane, interPlane)) {
      continue;
    }
    const interLine = tmpV3;
    if (!intersectLine(localRay, line, vExt, lHalfWidth, lHalfWidthSq, plane, interPlane, interLine)) {
      continue;
    }
    const interLineWorld = interLine.applyMatrix4(mesh.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(interLineWorld);
    if (distance < raycaster.near || distance > raycaster.far) {
      continue;
    }
    intersections.push({
      distance,
      point: interLineWorld.clone(),
      index: i,
      object: mesh
    });
  }
}
var singleFeatureStart = [0];
var MAX_SCALE_RATIO_DIFF = 0.01;
function intersectGroup(mesh, material, raycaster, localRay, firstFeatureIdx, groupEndIdx, intersections) {
  const bVolumes = mesh.userData.feature.boundingVolumes;
  assert(mesh.geometry instanceof THREE41.BufferGeometry, "Unsupported geometry type.");
  const geometry = mesh.geometry;
  assert(isSolidLineMaterial(material), "Unsupported material type");
  const solidLineMaterial = material;
  const halfWidth = (solidLineMaterial.lineWidth + solidLineMaterial.outlineWidth) / 2;
  assert(Math.abs(1 - mesh.scale.x / mesh.scale.y) < MAX_SCALE_RATIO_DIFF);
  assert(Math.abs(1 - mesh.scale.x / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);
  assert(Math.abs(1 - mesh.scale.y / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);
  const localHalfWidth = halfWidth / ((mesh.scale.x + mesh.scale.y + mesh.scale.z) / 3);
  const localHalfWidthSq = localHalfWidth * localHalfWidth;
  const featureStarts = mesh.userData.feature.starts ?? singleFeatureStart;
  let featureIdx = firstFeatureIdx;
  let beginIdx = featureStarts[featureIdx];
  const lastFeatureIdx = featureStarts.length - 1;
  while (beginIdx < groupEndIdx) {
    const bVolumeIdx = featureIdx;
    const endIdx = featureIdx < lastFeatureIdx ? featureStarts[++featureIdx] : groupEndIdx;
    if (bVolumeIdx >= bVolumes.length) {
      bVolumes.push(computeFeatureBoundingSphere(geometry, beginIdx, endIdx));
    }
    intersectFeature(mesh, raycaster, localRay, halfWidth, localHalfWidth, localHalfWidthSq, beginIdx, endIdx, bVolumes[bVolumeIdx], intersections);
    beginIdx = endIdx;
  }
  return featureIdx;
}
var SolidLineMesh = class extends THREE41.Mesh {
  static raycast(mesh, raycaster, intersections) {
    assert(mesh.geometry instanceof THREE41.BufferGeometry, "Unsupported geometry type");
    const geometry = mesh.geometry;
    assert(geometry.index !== null, "Geometry does not have indices");
    const matrixWorld = mesh.matrixWorld;
    tmpInverseMatrix.copy(matrixWorld).invert();
    const localRay = tmpRay.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    if (mesh.userData.feature === void 0) {
      mesh.userData.feature = {};
    }
    const positionAttribute = geometry.attributes["position"];
    const attributeInfo = mesh.userData.feature.attributeInfo;
    if (attributeInfo === void 0 || mesh.userData.feature.boundingVolumes === void 0 || attributeChanged(positionAttribute, attributeInfo)) {
      mesh.userData.feature.boundingVolumes = [];
      mesh.userData.feature.attributeInfo = getAttributeInfo(positionAttribute);
    }
    const indices = geometry.index.array;
    if (Array.isArray(mesh.material)) {
      let nextFeatureIdx = 0;
      for (const group of geometry.groups) {
        const material = mesh.material[group.materialIndex];
        const groupEndIdx = group.start + group.count;
        nextFeatureIdx = intersectGroup(mesh, material, raycaster, localRay, nextFeatureIdx, groupEndIdx, intersections);
      }
    } else {
      intersectGroup(mesh, mesh.material, raycaster, localRay, 0, indices.length, intersections);
    }
  }
  constructor(geometry, material) {
    super(geometry, material);
  }
  raycast(raycaster, intersects) {
    SolidLineMesh.raycast(this, raycaster, intersects);
  }
};

// src/mapview/MapViewPoints.ts
var THREE42 = __toESM(require("three"));
var MapViewPoints = class extends THREE42.Points {
  enableRayTesting = true;
  raycast(raycaster, intersects) {
    if (!this.enableRayTesting) {
      return;
    }
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const ndc = raycaster.ray.origin.clone().add(raycaster.ray.direction).project(raycaster.camera);
    const mouseCoords = ndcToScreen(ndc, raycaster);
    const testPoint = (point2, index2) => {
      const pointInfo = getPointInfo(point2, matrixWorld, raycaster);
      if (pointInfo.pointIsOnScreen) {
        this.testPoint(point2, pointInfo.absoluteScreenPosition, mouseCoords, index2, pointInfo.distance, intersects);
      }
    };
    const point = new THREE42.Vector3();
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positions = attributes.position.array;
    if (index !== null) {
      const indices = index.array;
      for (let i = 0, il = indices.length; i < il; i++) {
        testPoint(point.fromArray(positions, indices[i] * 3), i);
      }
    } else {
      for (let i = 0, l = positions.length / 3; i < l; i++) {
        testPoint(point.fromArray(positions, i * 3), i);
      }
    }
  }
};
function ndcToScreen(ndc, raycaster) {
  return new THREE42.Vector2(ndc.x + 1, 1 - ndc.y).divideScalar(2).multiply(raycaster.canvasSize).ceil();
}
function getPointInfo(point, matrixWorld, raycaster) {
  const worldPosition = point.clone().applyMatrix4(matrixWorld);
  const distance = worldPosition.distanceTo(raycaster.ray.origin);
  const ndc = worldPosition.project(raycaster.camera);
  const pointIsOnScreen = ndc.x < 1 && ndc.x > -1 && ndc.y < 1 && ndc.y > -1;
  if (pointIsOnScreen) {
    const absoluteScreenPosition = ndcToScreen(ndc, raycaster);
    return {
      absoluteScreenPosition,
      pointIsOnScreen,
      distance
    };
  }
  return {
    pointIsOnScreen
  };
}
var Circles = class extends MapViewPoints {
  testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
    const dx = screenPosition.x - pickCoordinates.x;
    const dy = screenPosition.y - pickCoordinates.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const radius = this.material.size / 2;
    if (dist <= radius) {
      intersects.push({
        point,
        distance,
        index,
        object: this
      });
    }
  }
};
var Squares = class extends MapViewPoints {
  testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
    const dx = screenPosition.x - pickCoordinates.x;
    const dy = screenPosition.y - pickCoordinates.y;
    const halfSize = this.material.size / 2;
    if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {
      intersects.push({
        point,
        distance,
        index,
        object: this
      });
    }
  }
};

// src/mapview/ThemeHelpers.ts
var THREE43 = __toESM(require("three"));
function toPixelFormat(format) {
  switch (format) {
    case "Alpha":
      return THREE43.AlphaFormat;
    case "RGB":
      return THREE43.RGBFormat;
    case "RGBA":
      return THREE43.RGBAFormat;
    case "Luminance":
      return THREE43.LuminanceFormat;
    case "LuminanceAlpha":
      return THREE43.LuminanceAlphaFormat;
    case "Depth":
      return THREE43.DepthFormat;
    case "DepthStencil":
      return THREE43.DepthStencilFormat;
    case "Red":
      return THREE43.RedFormat;
    default:
      throw new Error(`invalid pixel format: ${format}`);
  }
}
function toTextureDataType(dataType) {
  switch (dataType) {
    case "UnsignedByte":
      return THREE43.UnsignedByteType;
    case "Byte":
      return THREE43.ByteType;
    case "Short":
      return THREE43.ShortType;
    case "UnsignedShort":
      return THREE43.UnsignedShortType;
    case "Int":
      return THREE43.IntType;
    case "UnsignedInt":
      return THREE43.UnsignedIntType;
    case "Float":
      return THREE43.FloatType;
    case "HalfFloat":
      return THREE43.HalfFloatType;
    default:
      throw new Error(`invalid texture data type: ${dataType}`);
  }
}
function toWrappingMode(mode) {
  switch (mode) {
    case "clamp":
      return THREE43.ClampToEdgeWrapping;
    case "repeat":
      return THREE43.RepeatWrapping;
    case "mirror":
      return THREE43.MirroredRepeatWrapping;
    default:
      throw new Error(`invalid wrapping mode: ${mode}`);
  }
}
function toTextureFilter(filter) {
  switch (filter) {
    case "nearest":
      return THREE43.NearestFilter;
    case "nearestMipMapNearest":
      return THREE43.NearestMipMapNearestFilter;
    case "nearestMipMapLinear":
      return THREE43.NearestMipMapLinearFilter;
    case "linear":
      return THREE43.LinearFilter;
    case "linearMipMapNearest":
      return THREE43.LinearMipMapNearestFilter;
    case "linearMipMapLinear":
      return THREE43.LinearMipMapLinearFilter;
    default:
      throw new Error(`invalid texture filter: ${filter}`);
  }
}
function createLight(lightDescription) {
  switch (lightDescription.type) {
    case "ambient": {
      const light = new THREE43.AmbientLight(lightDescription.color, lightDescription.intensity);
      light.name = lightDescription.name;
      return light;
    }
    case "directional": {
      const light = new THREE43.DirectionalLight(lightDescription.color, lightDescription.intensity);
      light.name = lightDescription.name;
      if (lightDescription.castShadow !== void 0) {
        light.castShadow = lightDescription.castShadow;
      }
      if (light.castShadow) {
        light.shadow.bias = 1e-5;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
      }
      light.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);
      light.position.normalize();
      return light;
    }
  }
}

// src/mapview/DecodedTileHelpers.ts
var logger5 = LoggerManager.instance.create("DecodedTileHelpers");
function createTextureFromURL(url, onLoad, onError, isObjectURL) {
  const texture = new THREE44.TextureLoader().load(url, onLoad, void 0, onError);
  if (isObjectURL) {
    texture.addEventListener("dispose", () => {
      URL.revokeObjectURL(url);
    });
  }
}
function createTextureFromRawImage(textureBuffer, onLoad, onError) {
  const properties = textureBuffer.dataTextureProperties;
  if (properties) {
    const textureDataType = properties.type ? toTextureDataType(properties.type) : void 0;
    const buffer = getTextureBuffer(textureBuffer.buffer, textureDataType);
    const texture = new THREE44.DataTexture(buffer, properties.width, properties.height, properties.format ? toPixelFormat(properties.format) : void 0, textureDataType);
    onLoad(texture);
  } else {
    onError("no data texture properties provided.");
  }
}
function initTextureProperties(texture, properties) {
  if (!properties) {
    return;
  }
  if (properties.wrapS !== void 0) {
    texture.wrapS = toWrappingMode(properties.wrapS);
  }
  if (properties.wrapT !== void 0) {
    texture.wrapT = toWrappingMode(properties.wrapT);
  }
  if (properties.magFilter !== void 0) {
    texture.magFilter = toTextureFilter(properties.magFilter);
  }
  if (properties.minFilter !== void 0) {
    texture.minFilter = toTextureFilter(properties.minFilter);
  }
  if (properties.flipY !== void 0) {
    texture.flipY = properties.flipY;
  }
  if (properties.repeatU !== void 0) {
    texture.repeat.x = properties.repeatU;
  }
  if (properties.repeatV !== void 0) {
    texture.repeat.y = properties.repeatV;
  }
}
function createTexture(material, texturePropertyName, options) {
  const technique = options.technique;
  let textureProperty = technique[texturePropertyName];
  if (textureProperty === void 0) {
    return void 0;
  }
  const texturePromise = new Promise((resolve, reject) => {
    const onLoad = (texture) => {
      const properties = technique[texturePropertyName + "Properties"];
      initTextureProperties(texture, properties);
      material[texturePropertyName] = texture;
      material.needsUpdate = true;
      resolve(texture);
    };
    const onError = (error) => {
      logger5.error("#createMaterial: Failed to load texture: ", error);
      reject(error);
    };
    if (Expr3.isExpr(textureProperty)) {
      textureProperty = getPropertyValue(textureProperty, options.env);
      if (!textureProperty) {
        onLoad(new THREE44.Texture());
        return;
      }
    }
    if (typeof textureProperty === "string") {
      createTextureFromURL(textureProperty, onLoad, onError, false);
    } else if (isTextureBuffer(textureProperty)) {
      if (textureProperty.type === "image/raw") {
        createTextureFromRawImage(textureProperty, onLoad, onError);
      } else {
        const textureBlob = new Blob([textureProperty.buffer], {
          type: textureProperty.type
        });
        createTextureFromURL(URL.createObjectURL(textureBlob), onLoad, onError, true);
      }
    } else if (typeof textureProperty === "object" && (textureProperty.nodeName === "IMG" || textureProperty.nodeName === "CANVAS")) {
      onLoad(new THREE44.CanvasTexture(textureProperty));
    }
  });
  return texturePromise;
}
function createMaterial(rendererCapabilities, options, onTextureCreated) {
  const technique = options.technique;
  const Constructor = getMaterialConstructor(technique, options.shadowsEnabled === true);
  const settings = {};
  if (Constructor === void 0) {
    return void 0;
  }
  if (Constructor.prototype instanceof RawShaderMaterial2) {
    settings.rendererCapabilities = rendererCapabilities;
    if (Constructor !== HighPrecisionLineMaterial) {
      settings.fog = options.fog;
    }
  }
  if (options.shadowsEnabled === true && technique.name === "fill") {
    settings.removeDiffuseLight = true;
  }
  const material = new Constructor(settings);
  if (technique.id !== void 0) {
    material.name = technique.id;
  }
  if (isExtrudedPolygonTechnique(technique)) {
    ;
    material.flatShading = true;
  }
  material.depthTest = isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;
  if (supportsTextures(technique)) {
    TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName) => {
      const texturePromise = createTexture(material, texturePropertyName, options);
      if (texturePromise) {
        onTextureCreated == null ? void 0 : onTextureCreated(texturePromise);
      }
    });
  }
  if (isShaderTechnique(technique)) {
    applyShaderTechniqueToMaterial(technique, material);
  } else {
    MapMaterialAdapter.create(material, getMainMaterialStyledProps(technique));
  }
  return material;
}
function getBufferAttribute(attribute) {
  switch (attribute.type) {
    case "float":
      return new THREE44.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);
    case "uint8":
      return new THREE44.BufferAttribute(new Uint8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
    case "uint16":
      return new THREE44.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
    case "uint32":
      return new THREE44.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
    case "int8":
      return new THREE44.BufferAttribute(new Int8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
    case "int16":
      return new THREE44.BufferAttribute(new Int16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
    case "int32":
      return new THREE44.BufferAttribute(new Int32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
    default:
      throw new Error(`unsupported buffer of type ${attribute.type}`);
  }
}
function usesObject3D(technique) {
  const name2 = technique.name;
  return name2 !== void 0 && name2 !== "text" && name2 !== "labeled-icon" && name2 !== "line-marker" && name2 !== "label-rejection-line";
}
function buildObject(technique, geometry, material, tile, elevationEnabled) {
  assert(technique.name !== void 0);
  switch (technique.name) {
    case "extruded-line":
    case "standard":
    case "extruded-polygon":
    case "fill":
      return elevationEnabled ? new DisplacedMesh(geometry, material, () => ({
        min: tile.elevationRange.minElevation,
        max: tile.elevationRange.maxElevation
      })) : new THREE44.Mesh(geometry, material);
    case "terrain":
      return new THREE44.Mesh(geometry, material);
    case "dashed-line":
    case "solid-line":
      return elevationEnabled ? new DisplacedMesh(geometry, material, () => ({
        min: tile.elevationRange.minElevation,
        max: tile.elevationRange.maxElevation
      }), SolidLineMesh.raycast) : new SolidLineMesh(geometry, material);
    case "circles":
      return new Circles(geometry, material);
    case "squares":
      return new Squares(geometry, material);
    case "line":
      return new THREE44.LineSegments(geometry, material);
    case "segments":
      return new THREE44.LineSegments(geometry, material);
    case "shader": {
      assert(isShaderTechnique(technique), "Invalid technique");
      switch (technique.primitive) {
        case "line":
          return new THREE44.Line(geometry, material);
        case "segments":
          return new THREE44.LineSegments(geometry, material);
        case "point":
          return new THREE44.Points(geometry, material);
        case "mesh":
          return new THREE44.Mesh(geometry, material);
      }
    }
  }
  assert(false, "Invalid technique");
  return new THREE44.Object3D();
}
var BASE_TECHNIQUE_NON_MATERIAL_PROPS = ["name", "id", "renderOrder", "transient"];
function getMaterialConstructor(technique, shadowsEnabled) {
  if (technique.name === void 0) {
    return void 0;
  }
  switch (technique.name) {
    case "extruded-line":
      if (!isExtrudedLineTechnique(technique)) {
        throw new Error("Invalid extruded-line technique");
      }
      return technique.shading === "standard" ? MapMeshStandardMaterial : MapMeshBasicMaterial;
    case "standard":
    case "terrain":
    case "extruded-polygon":
      return MapMeshStandardMaterial;
    case "dashed-line":
    case "solid-line":
      return SolidLineMaterial;
    case "fill":
      return shadowsEnabled ? MapMeshStandardMaterial : MapMeshBasicMaterial;
    case "squares":
      return THREE44.PointsMaterial;
    case "circles":
      return CirclePointsMaterial;
    case "line":
    case "segments":
      return THREE44.LineBasicMaterial;
    case "shader":
      return THREE44.ShaderMaterial;
    case "text":
    case "labeled-icon":
    case "line-marker":
    case "label-rejection-line":
      return void 0;
  }
}
function getMainMaterialStyledProps(technique) {
  const automaticAttributes = getTechniqueAutomaticAttrs(technique);
  switch (technique.name) {
    case "dashed-line":
    case "solid-line": {
      const baseProps = pick(technique, automaticAttributes);
      baseProps.lineWidth = buildMetricValueEvaluator(technique.lineWidth ?? 0, technique.metricUnit);
      baseProps.outlineWidth = buildMetricValueEvaluator(technique.outlineWidth, technique.metricUnit);
      baseProps.dashSize = buildMetricValueEvaluator(technique.dashSize, technique.metricUnit);
      baseProps.gapSize = buildMetricValueEvaluator(technique.gapSize, technique.metricUnit);
      baseProps.offset = buildMetricValueEvaluator(technique.offset, technique.metricUnit);
      return baseProps;
    }
    case "fill":
      return pick(technique, automaticAttributes);
    case "standard":
    case "terrain":
    case "extruded-polygon": {
      const baseProps = pick(technique, automaticAttributes);
      if (technique.vertexColors !== true) {
        baseProps.color = technique.color;
      }
      return baseProps;
    }
    case "circles":
    case "squares":
      return pick(technique, automaticAttributes);
    case "extruded-line":
      return pick(technique, [
        "color",
        "wireframe",
        "transparent",
        "opacity",
        "polygonOffset",
        "polygonOffsetFactor",
        "polygonOffsetUnits",
        ...automaticAttributes
      ]);
    case "line":
    case "segments":
      return pick(technique, automaticAttributes);
    default:
      return {};
  }
}
function buildMetricValueEvaluator(value2, metricUnit) {
  if (value2 === void 0 || value2 === null) {
    return value2;
  }
  if (typeof value2 === "string") {
    if (value2.endsWith("px")) {
      metricUnit = "Pixel";
      value2 = Number.parseFloat(value2);
    } else if (value2.endsWith("m")) {
      value2 = Number.parseFloat(value2);
    }
  }
  if (metricUnit === "Pixel") {
    return (context2) => {
      const pixelToWorld = context2.env.lookup("$pixelToMeters") ?? 1;
      const evaluated = getPropertyValue(value2, context2.env);
      return pixelToWorld * evaluated;
    };
  } else {
    return value2;
  }
}
function evaluateBaseColorProperty(technique, env) {
  const baseColorProp = getBaseColorProp(technique);
  if (baseColorProp !== void 0) {
    return evaluateColorProperty(baseColorProp, env);
  }
  return void 0;
}
function applyShaderTechniqueToMaterial(technique, material) {
  if (technique.transparent) {
    enableBlending(material);
  } else {
    disableBlending(material);
  }
  const params = technique.params;
  const baseColorPropName = getBaseColorPropName(technique);
  const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;
  const props = Object.getOwnPropertyNames(params).filter((propertyName) => {
    if (baseColorPropName === propertyName || hasBaseColor && TRANSPARENCY_PROPERTY_KEYS.includes(propertyName)) {
      return false;
    }
    const prop = propertyName;
    if (prop === "name") {
      return false;
    }
    return true;
  });
  props.forEach((propertyName) => {
    applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);
  });
  if (hasBaseColor) {
    const propColor = baseColorPropName;
    applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);
  }
}
function applyTechniquePropertyToMaterial(material, propertyName, techniqueAttrValue, env) {
  const m = material;
  if (m[propertyName] instanceof THREE44.Color) {
    applySecondaryColorToMaterial(material[propertyName], techniqueAttrValue, env);
  } else {
    const value2 = evaluateProperty(techniqueAttrValue, env);
    if (value2 !== null) {
      m[propertyName] = value2;
    }
  }
}
function applySecondaryColorToMaterial(materialColor, techniqueColor, env) {
  let value2 = evaluateColorProperty(techniqueColor, env);
  if (value2 === void 0) {
    return;
  }
  if (ColorUtils.hasAlphaInHex(value2)) {
    logger5.warn("Used RGBA value for technique color without transparency support!");
    value2 = ColorUtils.removeAlphaFromHex(value2);
  }
  materialColor.setHex(value2);
}
function applyBaseColorToMaterial(material, materialColor, technique, techniqueColor, env) {
  const colorValue = evaluateColorProperty(techniqueColor, env);
  if (colorValue === void 0) {
    return;
  }
  const { r, g, b, a } = ColorUtils.getRgbaFromHex(colorValue);
  const tech = technique;
  let opacity = a;
  if (tech.opacity !== void 0) {
    opacity *= evaluateProperty(tech.opacity, env);
  }
  opacity = THREE44.MathUtils.clamp(opacity, 0, 1);
  if (material instanceof RawShaderMaterial2) {
    material.setOpacity(opacity);
  } else {
    material.opacity = opacity;
  }
  materialColor.setRGB(r, g, b);
  const opaque = opacity >= 1;
  if (!opaque) {
    enableBlending(material);
  } else {
    disableBlending(material);
  }
}
function evaluateProperty(value2, env) {
  if (env !== void 0 && Expr3.isExpr(value2)) {
    value2 = getPropertyValue(value2, env);
  }
  return value2;
}
function evaluateColorProperty(value2, env) {
  value2 = evaluateProperty(value2, env);
  if (value2 === void 0 || value2 === null) {
    return void 0;
  }
  if (typeof value2 === "number") {
    return value2;
  }
  if (typeof value2 === "string") {
    const parsed = parseStringEncodedColor(value2);
    if (parsed !== void 0) {
      return parsed;
    }
  }
  logger5.error(`Unsupported color format: '${value2}'`);
  return void 0;
}
function getBaseColorProp(technique) {
  const baseColorPropName = getBaseColorPropName(technique);
  if (baseColorPropName !== void 0) {
    if (!isShaderTechnique(technique)) {
      const propColor = baseColorPropName;
      return technique[propColor];
    } else {
      const params = technique.params;
      const propColor = baseColorPropName;
      return params[propColor];
    }
  }
  return void 0;
}
function getBaseColorPropName(technique) {
  var _a;
  return (_a = getTechniqueDescriptor(technique)) == null ? void 0 : _a.attrTransparencyColor;
}
function getTextureBuffer(buffer, textureDataType) {
  if (textureDataType === void 0) {
    return new Uint8Array(buffer);
  }
  switch (textureDataType) {
    case THREE44.UnsignedByteType:
      return new Uint8Array(buffer);
    case THREE44.ByteType:
      return new Int8Array(buffer);
    case THREE44.ShortType:
      return new Int16Array(buffer);
    case THREE44.UnsignedShortType:
      return new Uint16Array(buffer);
    case THREE44.IntType:
      return new Int32Array(buffer);
    case THREE44.UnsignedIntType:
      return new Uint32Array(buffer);
    case THREE44.FloatType:
      return new Float32Array(buffer);
    case THREE44.HalfFloatType:
      return new Uint16Array(buffer);
  }
  throw new Error("Unsupported texture data type");
}

// src/mapview/MapMaterialAdapter.ts
function isTextureProperty(propertyName) {
  return TEXTURE_PROPERTY_KEYS.includes(propertyName);
}
var MapMaterialAdapter = class {
  static get(material) {
    var _a;
    const mapAdapter = (_a = material.userData) == null ? void 0 : _a.mapAdapter;
    if (mapAdapter instanceof MapMaterialAdapter) {
      return mapAdapter;
    } else if (mapAdapter !== void 0) {
      return void 0;
    } else {
      return void 0;
    }
  }
  static install(objData) {
    if (!objData.material.userData) {
      objData.material.userData = {};
    }
    return objData.material.userData.mapAdapter = objData;
  }
  static create(material, styledProperties) {
    return MapMaterialAdapter.install(new MapMaterialAdapter(material, styledProperties));
  }
  static ensureUpdated(material, context2) {
    var _a;
    return ((_a = MapMaterialAdapter.get(material)) == null ? void 0 : _a.ensureUpdated(context2)) ?? false;
  }
  material;
  styledProperties;
  currentStyledProperties;
  m_lastUpdateFrameNumber = -1;
  m_dynamicProperties;
  tmpColor = new THREE45.Color();
  constructor(material, styledProperties) {
    this.material = material;
    this.styledProperties = styledProperties;
    this.currentStyledProperties = {};
    this.m_dynamicProperties = [];
    for (const propName in styledProperties) {
      if (!styledProperties.hasOwnProperty(propName)) {
        continue;
      }
      const propDefinition = styledProperties[propName];
      if (Expr3.isExpr(propDefinition) || typeof propDefinition === "function") {
        this.m_dynamicProperties.push([propName, propDefinition]);
      } else {
        this.currentStyledProperties[propName] = propDefinition;
      }
    }
    this.setupStaticProperties();
  }
  toJSON() {
    return { styledProperties: this.styledProperties };
  }
  ensureUpdated(context2) {
    if (this.m_lastUpdateFrameNumber === context2.frameNumber) {
      return false;
    }
    this.m_lastUpdateFrameNumber = context2.frameNumber;
    return this.updateDynamicProperties(context2);
  }
  setupStaticProperties() {
    let updateBaseColor = false;
    for (const propName in this.styledProperties) {
      if (!this.styledProperties.hasOwnProperty(propName)) {
        continue;
      }
      const currentValue = this.currentStyledProperties[propName];
      if (currentValue === void 0 || currentValue === null) {
        continue;
      }
      if (propName === "color" || propName === "opacity") {
        updateBaseColor = true;
      } else if (!isTextureProperty(propName)) {
        this.applyMaterialGenericProp(propName, currentValue);
      }
    }
    if (updateBaseColor) {
      const color = this.currentStyledProperties.color ?? 16711680;
      const opacity = this.currentStyledProperties.opacity ?? 1;
      this.applyMaterialBaseColor(color, opacity);
    }
  }
  updateDynamicProperties(context2) {
    let somethingChanged = false;
    if (this.m_dynamicProperties.length > 0) {
      let updateBaseColor = false;
      for (const [propName, propDefinition] of this.m_dynamicProperties) {
        const newValue = Expr3.isExpr(propDefinition) ? getPropertyValue(propDefinition, context2.env) : propDefinition(context2);
        if (newValue === this.currentStyledProperties[propName]) {
          continue;
        }
        this.currentStyledProperties[propName] = newValue;
        if (propName === "color" || propName === "opacity") {
          updateBaseColor = true;
        } else if (isTextureProperty(propName)) {
          this.applyMaterialTextureProp(propName, newValue);
          somethingChanged = true;
        } else {
          this.applyMaterialGenericProp(propName, newValue);
          somethingChanged = true;
        }
      }
      if (updateBaseColor) {
        const color = this.currentStyledProperties.color ?? 16711680;
        const opacity = this.currentStyledProperties.opacity ?? 1;
        this.applyMaterialBaseColor(color, opacity);
        somethingChanged = true;
      }
    }
    return somethingChanged;
  }
  applyMaterialTextureProp(propName, value2) {
    const m = this.material;
    if (!m[propName] || value2 === null) {
      return;
    }
    const oldTexture = m[propName];
    let newTexture;
    if (typeof value2 === "string") {
      newTexture = new THREE45.TextureLoader().load(value2, (texture) => {
        m[propName] = texture;
      });
    } else if (typeof value2 === "object") {
      const element = value2;
      const isImage = element.nodeName === "IMG";
      const isCanvas = element.nodeName === "CANVAS";
      if (isImage || isCanvas) {
        newTexture = new THREE45.CanvasTexture(element);
        if (isImage && !element.complete) {
          const onLoad = () => {
            m[propName] = newTexture;
            element.removeEventListener("load", onLoad);
          };
          element.addEventListener("load", onLoad);
        } else {
          m[propName] = newTexture;
        }
      }
    }
    if (newTexture) {
      newTexture.wrapS = oldTexture.wrapS;
      newTexture.wrapT = oldTexture.wrapT;
      newTexture.magFilter = oldTexture.magFilter;
      newTexture.minFilter = oldTexture.minFilter;
      newTexture.flipY = oldTexture.flipY;
      newTexture.repeat = oldTexture.repeat;
    }
  }
  applyMaterialGenericProp(propName, value2) {
    const m = this.material;
    if (m[propName] instanceof THREE45.Color) {
      let colorValue = value2;
      if (typeof colorValue !== "number") {
        const parsed = evaluateColorProperty(colorValue);
        if (parsed === void 0) {
          return;
        }
        colorValue = parsed;
      }
      const rgbValue = ColorUtils.removeAlphaFromHex(colorValue);
      this.tmpColor.set(rgbValue);
      value2 = this.tmpColor;
    }
    m[propName] = value2;
  }
  applyMaterialBaseColor(color, opacity) {
    if (typeof color !== "number") {
      const parsed = evaluateColorProperty(color);
      if (parsed === void 0) {
        return;
      }
      color = parsed;
    }
    const { r, g, b, a } = ColorUtils.getRgbaFromHex(color ?? 16711680);
    const actualOpacity = a * THREE45.MathUtils.clamp(opacity ?? 1, 0, 1);
    if (this.material instanceof RawShaderMaterial2) {
      this.material.setOpacity(actualOpacity);
    } else {
      this.material.opacity = actualOpacity;
    }
    ;
    this.material.color.setRGB(r, g, b);
    const opaque = actualOpacity >= 1;
    if (!opaque) {
      enableBlending(this.material);
    } else {
      disableBlending(this.material);
    }
  }
};

// src/mapview/MapObjectAdapter.ts
var MapObjectAdapter = class {
  static get(object) {
    var _a;
    return ((_a = object.userData) == null ? void 0 : _a.mapAdapter) instanceof MapObjectAdapter ? object.userData.mapAdapter : void 0;
  }
  static install(objData) {
    if (!objData.object.userData) {
      objData.object.userData = {};
    }
    return objData.object.userData.mapAdapter = objData;
  }
  static create(object, params) {
    return MapObjectAdapter.install(new MapObjectAdapter(object, params));
  }
  static ensureUpdated(object, context2) {
    var _a;
    return ((_a = MapObjectAdapter.get(object)) == null ? void 0 : _a.ensureUpdated(context2)) ?? false;
  }
  object;
  technique;
  kind;
  dataSource;
  level;
  m_pickability;
  m_lastUpdateFrameNumber = -1;
  m_notCompletlyTransparent = true;
  constructor(object, params) {
    this.object = object;
    this.technique = params.technique;
    this.kind = params.kind;
    this.dataSource = params.dataSource;
    this.m_pickability = params.pickability ?? "only-visible" /* onlyVisible */;
    this.m_notCompletlyTransparent = this.getObjectMaterials().some((material) => material.opacity > 0);
    this.level = params.level;
  }
  toJSON() {
    return { kind: this.kind, technique: this.technique };
  }
  ensureUpdated(context2) {
    if (this.m_lastUpdateFrameNumber === context2.frameNumber) {
      return false;
    }
    this.m_lastUpdateFrameNumber = context2.frameNumber;
    return this.updateMaterials(context2);
  }
  isVisible() {
    return this.object.visible && this.m_notCompletlyTransparent;
  }
  isPickable() {
    return this.pickability === "only-visible" /* onlyVisible */ && this.isVisible() || this.m_pickability === "all" /* all */;
  }
  get pickability() {
    return this.m_pickability;
  }
  updateMaterials(context2) {
    let somethingChanged = false;
    const materials = this.getObjectMaterials();
    for (const material of materials) {
      const changed = MapMaterialAdapter.ensureUpdated(material, context2);
      somethingChanged = somethingChanged || changed;
    }
    if (somethingChanged) {
      this.m_notCompletlyTransparent = materials.some((material) => material.opacity > 0);
    }
    return somethingChanged;
  }
  getObjectMaterials() {
    const object = this.object;
    return Array.isArray(object.material) ? object.material : object.material !== void 0 ? [object.material] : [];
  }
};

// src/mapview/geometry/RegisterTileObject.ts
function registerTileObject(tile, object, geometryKind, mapAdapterParams) {
  const kind = geometryKind instanceof Set ? Array.from(geometryKind.values()) : Array.isArray(geometryKind) ? geometryKind : [geometryKind];
  MapObjectAdapter.create(object, {
    dataSource: tile.dataSource,
    kind,
    level: tile.tileKey.level,
    ...mapAdapterParams
  });
  if (object.userData === void 0) {
    object.userData = {};
  }
  const userData = object.userData;
  userData.tileKey = tile.tileKey;
  userData.dataSource = tile.dataSource.name;
  userData.kind = kind;
  tile.resetVisibilityCounter();
}

// src/mapview/geometry/AddGroundPlane.ts
var tmpV = new THREE46.Vector3();
function addGroundPlane(tile, renderOrder, materialOrColor = tile.mapView.clearColor, opacity = 1, createTexCoords = false, receiveShadow = tile.mapView.shadowsEnabled, createMultiLod = tile.mapView.enableMixedLod !== false) {
  const mesh = createGroundPlane(tile, createTexCoords, receiveShadow, materialOrColor, createMultiLod, opacity);
  mesh.receiveShadow = receiveShadow;
  mesh.renderOrder = renderOrder;
  registerTileObject(tile, mesh, GeometryKind.Background, {
    pickability: "transient" /* transient */
  });
  tile.objects.push(mesh);
  return mesh;
}
function createGroundPlane(tile, createTexCoords, receiveShadow, materialOrColor, createMultiLod, opacity) {
  const { dataSource, projection } = tile;
  const sourceProjection = dataSource.getTilingScheme().projection;
  const shouldSubdivide = projection.type === 1 /* Spherical */;
  const useLocalTargetCoords = !shouldSubdivide;
  const material = typeof materialOrColor === "number" ? createGroundPlaneMaterial(new THREE46.Color(materialOrColor), receiveShadow, projection.type === 1 /* Spherical */, opacity) : materialOrColor;
  const geometry = createGroundPlaneGeometry(tile, useLocalTargetCoords, createTexCoords, receiveShadow);
  if (!shouldSubdivide) {
    return new THREE46.Mesh(geometry, material);
  }
  const geometries = [];
  const sphericalModifier = new SphericalGeometrySubdivisionModifier(THREE46.MathUtils.degToRad(10), sourceProjection);
  if (!createMultiLod) {
    sphericalModifier.modify(geometry);
    toLocalTargetCoords(geometry, sourceProjection, tile);
    return new THREE46.Mesh(geometry, material);
  }
  for (let zoomLevelOffset = 0; zoomLevelOffset < 4; ++zoomLevelOffset) {
    const subdivision = Math.pow(2, zoomLevelOffset);
    const zoomLevelGeometry = geometry.clone();
    if (subdivision > 1) {
      const edgeModifier = new EdgeLengthGeometrySubdivisionModifier(subdivision, tile.geoBox, 0 /* All */, sourceProjection);
      edgeModifier.modify(zoomLevelGeometry);
    }
    sphericalModifier.modify(zoomLevelGeometry);
    toLocalTargetCoords(zoomLevelGeometry, sourceProjection, tile);
    geometries.push(zoomLevelGeometry);
  }
  return new LodMesh(geometries, material);
}
function toLocalTargetCoords(geom, srcProjection, tile) {
  const attr = geom.getAttribute("position");
  const oldArray = attr.array;
  const newArray = new Float32Array(oldArray.length);
  for (let i = 0; i < attr.array.length; i += 1) {
    tmpV.fromBufferAttribute(attr, i);
    tile.projection.reprojectPoint(srcProjection, tmpV, tmpV).sub(tile.center);
    tmpV.toArray(newArray, i * 3);
  }
  attr.array = newArray;
  attr.needsUpdate = true;
}
function createGroundPlaneGeometry(tile, useLocalTargetCoords, createTexCoords, receiveShadow) {
  const { dataSource, projection } = tile;
  const sourceProjection = dataSource.getTilingScheme().projection;
  const tmpV6 = new THREE46.Vector3();
  const geometry = new THREE46.BufferGeometry();
  const tileCorners = projectTilePlaneCorners(tile, sourceProjection);
  const cornersArray = [tileCorners.sw, tileCorners.se, tileCorners.nw, tileCorners.ne];
  if (useLocalTargetCoords) {
    for (const corner of cornersArray) {
      projection.reprojectPoint(sourceProjection, corner, corner).sub(tile.center);
    }
  }
  const bufferArray = useLocalTargetCoords ? new Float32Array(12) : new Float64Array(12);
  const posAttr = new THREE46.BufferAttribute(bufferArray, 3).copyVector3sArray(cornersArray);
  geometry.setAttribute("position", posAttr);
  if (receiveShadow) {
    sourceProjection.surfaceNormal(tileCorners.sw, tmpV6).negate();
    const normAttr = new THREE46.BufferAttribute(new Float32Array(12), 3).copyVector3sArray(Array(4).fill(tmpV6));
    geometry.setAttribute("normal", normAttr);
  }
  geometry.setIndex(new THREE46.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));
  if (createTexCoords) {
    const uvAttr = new THREE46.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);
    geometry.setAttribute("uv", uvAttr);
  }
  return geometry;
}
function createGroundPlaneMaterial(color, receiveShadow, depthWrite, opacity) {
  if (receiveShadow) {
    return new MapMeshStandardMaterial({
      color,
      visible: true,
      depthWrite,
      removeDiffuseLight: true,
      opacity
    });
  } else {
    return new MapMeshBasicMaterial({
      color,
      visible: true,
      depthWrite,
      opacity
    });
  }
}

// src/mapview/BackgroundDataSource.ts
var _BackgroundDataSource = class extends DataSource {
  m_tilingScheme = _BackgroundDataSource.DEFAULT_TILING_SCHEME;
  constructor() {
    super({ name: "background" });
    this.cacheable = true;
    this.addGroundPlane = true;
    this.enablePicking = false;
  }
  updateStorageLevelOffset() {
    let storageLevelOffset;
    this.mapView.dataSources.forEach((ds) => {
      if (ds === this) {
        return;
      }
      const tilingScheme = ds.getTilingScheme();
      if (tilingScheme === this.m_tilingScheme) {
        storageLevelOffset = storageLevelOffset === void 0 ? ds.storageLevelOffset : Math.max(storageLevelOffset, ds.storageLevelOffset);
      }
    });
    if (storageLevelOffset === void 0) {
      storageLevelOffset = 0;
    }
    if (storageLevelOffset !== this.storageLevelOffset) {
      this.storageLevelOffset = storageLevelOffset;
      this.mapView.clearTileCache(this.name);
    }
  }
  async setTheme(theme, languages) {
    this.mapView.clearTileCache(this.name);
  }
  setTilingScheme(tilingScheme) {
    const newScheme = tilingScheme ?? _BackgroundDataSource.DEFAULT_TILING_SCHEME;
    if (newScheme === this.m_tilingScheme) {
      return;
    }
    this.m_tilingScheme = newScheme;
    this.updateStorageLevelOffset();
    this.mapView.clearTileCache(this.name);
  }
  getTilingScheme() {
    return this.m_tilingScheme;
  }
  getTile(tileKey) {
    const tile = new Tile(this, tileKey);
    tile.forceHasGeometry(true);
    addGroundPlane(tile, _BackgroundDataSource.GROUND_RENDER_ORDER);
    return tile;
  }
};
var BackgroundDataSource = _BackgroundDataSource;
__publicField(BackgroundDataSource, "GROUND_RENDER_ORDER", Number.MIN_SAFE_INTEGER);
__publicField(BackgroundDataSource, "DEFAULT_TILING_SCHEME", webMercatorTilingScheme);

// src/mapview/CameraMovementDetector.ts
var import_three11 = require("three");
var DEFAULT_THROTTLING_TIMEOUT = 300;
var CameraMovementDetector = class {
  constructor(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {
    this.m_throttlingTimeout = m_throttlingTimeout;
    this.m_movementStartedFunc = m_movementStartedFunc;
    this.m_movementFinishedFunc = m_movementFinishedFunc;
    if (this.m_throttlingTimeout === void 0) {
      this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;
    }
  }
  m_lastAttitude;
  m_lastCameraPos = new import_three11.Vector3();
  m_newCameraPos = new import_three11.Vector3();
  m_cameraMovedLastFrame;
  m_throttlingTimerId = void 0;
  m_movementDetectorDeadline = 0;
  checkCameraMoved(mapView, now2) {
    const newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);
    const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
    if (this.m_lastAttitude === void 0) {
      this.m_lastCameraPos.copy(newCameraPos);
      this.m_lastAttitude = newAttitude;
      return false;
    }
    const cameraMoved = !this.m_lastCameraPos.equals(newCameraPos) || newAttitude.yaw !== this.m_lastAttitude.yaw || newAttitude.pitch !== this.m_lastAttitude.pitch || newAttitude.roll !== this.m_lastAttitude.roll;
    if (cameraMoved) {
      this.m_lastCameraPos.copy(newCameraPos);
      this.m_lastAttitude = newAttitude;
    }
    if (cameraMoved !== this.m_cameraMovedLastFrame) {
      if (cameraMoved) {
        this.movementStarted();
      }
      this.m_cameraMovedLastFrame = cameraMoved;
    }
    if (cameraMoved) {
      this.m_movementDetectorDeadline = now2 + this.m_throttlingTimeout;
      this.startMovementFinishedTimer(now2);
    }
    return this.m_cameraMovedLastFrame;
  }
  clear(mapView) {
    const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
    this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);
    const newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);
    this.m_lastAttitude = newAttitude;
  }
  forceMoved() {
    this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);
  }
  get cameraIsMoving() {
    return this.m_throttlingTimerId !== void 0;
  }
  dispose() {
    this.removeMovementFinishedTimer();
    this.m_movementStartedFunc = void 0;
    this.m_movementFinishedFunc = void 0;
  }
  get cameraMovedLastFrame() {
    return this.m_cameraMovedLastFrame === true;
  }
  movementStarted() {
    if (this.m_movementStartedFunc !== void 0) {
      this.m_movementStartedFunc();
    }
  }
  movementFinished() {
    this.removeMovementFinishedTimer();
    if (this.m_movementFinishedFunc !== void 0) {
      this.m_movementFinishedFunc();
    }
  }
  startMovementFinishedTimer(now2) {
    if (this.m_throttlingTimerId === void 0) {
      const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now2);
      this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);
    }
  }
  onDeadlineTimer = () => {
    this.m_throttlingTimerId = void 0;
    const now2 = performance.now();
    if (now2 >= this.m_movementDetectorDeadline) {
      this.movementFinished();
    } else {
      this.startMovementFinishedTimer(now2);
    }
  };
  removeMovementFinishedTimer() {
    if (this.m_throttlingTimerId !== void 0) {
      clearTimeout(this.m_throttlingTimerId);
      this.m_throttlingTimerId = void 0;
    }
  }
};

// src/mapview/ClipPlanesEvaluator.ts
var THREE47 = __toESM(require("three"));
var epsilon = 1e-6;
var SphericalProj;
((SphericalProj2) => {
  const tmpVectors = [
    new THREE47.Vector3(),
    new THREE47.Vector3()
  ];
  const raycaster = new THREE47.Raycaster();
  const sphere = new THREE47.Sphere(new THREE47.Vector3(), EarthConstants.EQUATORIAL_RADIUS);
  function getHorizonDistance(d, r) {
    return d - r < epsilon ? 0 : Math.sqrt(d * d - r * r);
  }
  function getFarDistanceFromElevatedHorizon(camera, d, minR, maxR) {
    const t = getHorizonDistance(d, minR);
    const te = getHorizonDistance(maxR, minR);
    const normalToTanAngle = Math.asin(minR / d);
    const fwdToTanAngle = Math.abs(normalToTanAngle - SphericalProj2.getNormalToFwdAngle(camera));
    const far = Math.cos(fwdToTanAngle) * (t + te);
    return far;
  }
  SphericalProj2.getFarDistanceFromElevatedHorizon = getFarDistanceFromElevatedHorizon;
  function getProjNearPlaneTanDistance(camera, bottomFov, R) {
    const fwdDir = camera.getWorldDirection(tmpVectors[0]);
    const camToTanVec = tmpVectors[1].copy(fwdDir).multiplyScalar(-R).sub(camera.position);
    const near = camToTanVec.dot(fwdDir);
    const cosTanDirToFwdDir = near / camToTanVec.length();
    return cosTanDirToFwdDir > Math.cos(bottomFov) ? near : void 0;
  }
  SphericalProj2.getProjNearPlaneTanDistance = getProjNearPlaneTanDistance;
  function getProjSphereIntersectionDistance(camera, ndcDir, R) {
    raycaster.setFromCamera(ndcDir, camera);
    sphere.radius = R;
    const intersection = raycaster.ray.intersectSphere(sphere, tmpVectors[0]);
    return intersection !== null ? intersection.sub(camera.position).dot(camera.getWorldDirection(tmpVectors[1])) : void 0;
  }
  SphericalProj2.getProjSphereIntersectionDistance = getProjSphereIntersectionDistance;
  function getNormalToFwdAngle(camera) {
    const camToOriginDir = tmpVectors[0].copy(camera.position).negate().normalize();
    const cosAngle = camToOriginDir.dot(camera.getWorldDirection(tmpVectors[1]));
    return Math.acos(THREE47.MathUtils.clamp(cosAngle, -1, 1));
  }
  SphericalProj2.getNormalToFwdAngle = getNormalToFwdAngle;
})(SphericalProj || (SphericalProj = {}));
var ElevationBasedClipPlanesEvaluator = class {
  m_maxElevation;
  m_minElevation;
  constructor(maxElevation, minElevation) {
    assert(maxElevation >= minElevation);
    this.m_minElevation = minElevation;
    this.m_maxElevation = maxElevation;
  }
  set maxElevation(elevation) {
    this.m_maxElevation = elevation;
    this.m_minElevation = Math.min(elevation, this.m_minElevation);
  }
  get maxElevation() {
    return this.m_maxElevation;
  }
  set minElevation(elevation) {
    this.m_minElevation = elevation;
    this.m_maxElevation = Math.max(elevation, this.m_maxElevation);
  }
  get minElevation() {
    return this.m_minElevation;
  }
};
var TopViewClipPlanesEvaluator = class extends ElevationBasedClipPlanesEvaluator {
  constructor(maxElevation = EarthConstants.MAX_BUILDING_HEIGHT, minElevation = 0, nearMin = 1, nearFarMarginRatio = 0.05, farMaxRatio = 6) {
    super(maxElevation, minElevation);
    this.nearMin = nearMin;
    this.nearFarMarginRatio = nearFarMarginRatio;
    this.farMaxRatio = farMaxRatio;
    assert(nearMin > 0);
    assert(nearFarMarginRatio >= 0);
    assert(farMaxRatio > 1);
    const nearFarMargin = nearFarMarginRatio * nearMin;
    this.m_minimumViewRange = {
      near: nearMin,
      far: nearMin + nearFarMargin,
      minimum: this.nearMin,
      maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)
    };
  }
  m_tmpVectors = [
    new THREE47.Vector3(),
    new THREE47.Vector3(),
    new THREE47.Vector3()
  ];
  m_tmpQuaternion = new THREE47.Quaternion();
  m_minimumViewRange;
  evaluateClipPlanes(camera, projection, elevationProvider) {
    assert(camera instanceof THREE47.PerspectiveCamera, "Unsupported camera type.");
    const persCamera = camera;
    if (projection.type === 1 /* Spherical */) {
      return this.evaluateDistanceSphericalProj(persCamera, projection, elevationProvider);
    } else if (projection.type === 0 /* Planar */) {
      return this.evaluateDistancePlanarProj(persCamera, projection, elevationProvider);
    }
    assert(false, "Unsupported projection type");
    return { ...this.minimumViewRange };
  }
  get minimumViewRange() {
    return this.m_minimumViewRange;
  }
  evaluateDistancePlanarProj(camera, projection, elevationProvider) {
    assert(projection.type !== 1 /* Spherical */);
    let nearPlane = this.nearMin;
    let farPlane = this.nearMin * this.farMaxRatio;
    const groundDistance = projection.groundDistance(camera.position);
    const farMax = groundDistance * this.farMaxRatio;
    nearPlane = groundDistance - this.maxElevation;
    farPlane = groundDistance - this.minElevation;
    nearPlane = Math.max(nearPlane, this.nearMin);
    farPlane = Math.min(farPlane, farMax);
    const nearFarMargin = this.nearFarMarginRatio * (nearPlane + farPlane) / 2;
    nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
    farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
    const viewRanges = {
      near: nearPlane,
      far: farPlane,
      minimum: this.nearMin,
      maximum: Math.max(farMax, farPlane)
    };
    return viewRanges;
  }
  evaluateDistanceSphericalProj(camera, projection, elevationProvider) {
    assert(projection.type === 1 /* Spherical */);
    const cameraAltitude = projection.groundDistance(camera.position);
    let nearPlane = cameraAltitude - this.maxElevation;
    const r = EarthConstants.EQUATORIAL_RADIUS;
    const d = Math.max(epsilon, camera.position.length());
    const alpha = Math.asin(r / d);
    let halfFovAngle = THREE47.MathUtils.degToRad(camera.fov / 2);
    if (camera.aspect > 1) {
      halfFovAngle = MapViewUtils.calculateHorizontalFovByVerticalFov(halfFovAngle * 2, camera.aspect);
    }
    const maxR = r + this.maxElevation;
    const farTangent = SphericalProj.getFarDistanceFromElevatedHorizon(camera, d, r, maxR);
    let farPlane = halfFovAngle > alpha ? farTangent : this.getFovBasedFarPlane(camera, d, r, 2 * halfFovAngle, projection);
    const farMin = cameraAltitude - this.minElevation;
    const farMax = cameraAltitude * this.farMaxRatio;
    nearPlane = Math.max(nearPlane, this.nearMin);
    farPlane = Math.max(farPlane, farMin);
    const nearFarMargin = this.nearFarMarginRatio * (nearPlane + farPlane) / 2;
    nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
    farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
    const viewRanges = {
      near: nearPlane,
      far: farPlane,
      minimum: this.nearMin,
      maximum: farMax
    };
    return viewRanges;
  }
  getFovBasedFarPlane(camera, d, r, fovAngle, projection) {
    const dVec = camera.position;
    camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
    this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);
    const cameraFwdVec = this.m_tmpVectors[2];
    const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);
    const cta = dVec.dot(tVec);
    if (cta < 0) {
      const groundDistance = projection.groundDistance(camera.position);
      return groundDistance * this.farMaxRatio;
    }
    const a2 = dVec.dot(dVec) - cta * cta;
    const r2 = r * r;
    assert(a2 <= r2, "Please use this evaluator only for top view camera poses.");
    const tota = Math.sqrt(r2 - a2);
    return cta - tota;
  }
};
var TiltViewClipPlanesEvaluator = class extends TopViewClipPlanesEvaluator {
  m_tmpV2 = new THREE47.Vector2();
  evaluateDistancePlanarProj(camera, projection, elevationProvider) {
    assert(projection.type !== 1 /* Spherical */);
    const viewRanges = { ...this.minimumViewRange };
    const halfPiLimit = Math.PI / 2 - epsilon;
    const z = projection.groundDistance(camera.position);
    const cameraTilt = MapViewUtils.extractCameraTilt(camera, projection);
    const topFov = CameraUtils.getTopFov(camera);
    const bottomFov = CameraUtils.getBottomFov(camera);
    const topAngle = THREE47.MathUtils.clamp(cameraTilt + topFov, -halfPiLimit, halfPiLimit);
    const bottomAngle = THREE47.MathUtils.clamp(cameraTilt - bottomFov, -halfPiLimit, halfPiLimit);
    const topDist = Math.max(0, (z - this.minElevation) / Math.cos(topAngle));
    const bottomDist = Math.max(0, (z - this.maxElevation) / Math.cos(bottomAngle));
    viewRanges.near = bottomDist * Math.cos(bottomFov);
    viewRanges.far = topDist * Math.cos(topFov);
    return this.applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider);
  }
  evaluateDistanceSphericalProj(camera, projection, elevationProvider) {
    assert(projection.type === 1 /* Spherical */);
    const viewRanges = { ...this.minimumViewRange };
    viewRanges.near = this.computeNearDistSphericalProj(camera, projection);
    viewRanges.far = this.computeFarDistSphericalProj(camera, projection);
    return this.applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider);
  }
  computeNearDistSphericalProj(camera, projection) {
    assert(projection.type === 1 /* Spherical */);
    const defaultNear = projection.groundDistance(camera.position) - this.maxElevation;
    const cameraBelowMaxElevation = defaultNear <= 0;
    if (cameraBelowMaxElevation) {
      return 0;
    }
    const maxR = EarthConstants.EQUATORIAL_RADIUS + this.maxElevation;
    const bottomFov = CameraUtils.getBottomFov(camera);
    const nearPlaneTanDist = SphericalProj.getProjNearPlaneTanDistance(camera, bottomFov, maxR);
    if (nearPlaneTanDist !== void 0) {
      return nearPlaneTanDist;
    }
    CameraUtils.getPrincipalPoint(camera, this.m_tmpV2);
    const checkTopIntersection = this.m_tmpV2.y > 0;
    const bottomDist = SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.setComponent(1, -1), maxR);
    const topDist = checkTopIntersection ? SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.setComponent(1, 1), maxR) : Infinity;
    const near = Math.min(bottomDist ?? Infinity, topDist ?? Infinity);
    assert(near !== Infinity, "No reference point for near distance found");
    return near ?? defaultNear;
  }
  computeFarDistSphericalProj(camera, projection) {
    assert(projection.type === 1 /* Spherical */);
    const r = EarthConstants.EQUATORIAL_RADIUS;
    const minR = r + this.minElevation;
    const maxR = r + this.maxElevation;
    const d = camera.position.length();
    CameraUtils.getPrincipalPoint(camera, this.m_tmpV2);
    const isRightIntersectionFarther = this.m_tmpV2.x <= 0;
    const ndcX = isRightIntersectionFarther ? 1 : -1;
    const checkBottomIntersection = this.m_tmpV2.y > 0;
    const topDist = SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.set(ndcX, 1), minR);
    const bottomDist = checkBottomIntersection ? SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.set(ndcX, -1), minR) : 0;
    const largestDist = Math.max(topDist ?? Infinity, bottomDist ?? Infinity);
    if (largestDist !== Infinity) {
      return largestDist;
    }
    return SphericalProj.getFarDistanceFromElevatedHorizon(camera, d, r, maxR);
  }
  applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider) {
    const { distance } = MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider);
    const farMin = projection.groundDistance(camera.position) - this.minElevation;
    const farMax = distance * this.farMaxRatio;
    viewRanges.near = Math.max(viewRanges.near, this.nearMin);
    viewRanges.far = THREE47.MathUtils.clamp(viewRanges.far, farMin, farMax);
    const nearFarMargin = this.nearFarMarginRatio * (viewRanges.near + viewRanges.far) / 2;
    viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);
    viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);
    viewRanges.minimum = this.nearMin;
    viewRanges.maximum = farMax;
    return viewRanges;
  }
};
var createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();

// src/mapview/composing/MapRenderingManager.ts
var THREE53 = __toESM(require("three"));

// src/mapview/composing/LowResRenderPass.ts
var THREE49 = __toESM(require("three"));

// src/mapview/composing/Pass.ts
var THREE48 = __toESM(require("three"));
var Pass = class {
  enabled = false;
  renderToScreen = false;
  setSize(width, height) {
  }
  render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
  }
};
var RenderPass = class extends Pass {
  constructor() {
    super();
  }
  render(renderer, scene, camera, writeBuffer, readBuffer) {
    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
    renderer.render(scene, camera);
  }
};
var ShaderPass = class extends Pass {
  constructor(shader, textureID = "tDiffuse") {
    super();
    this.textureID = textureID;
    if (shader instanceof THREE48.ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else {
      this.uniforms = THREE48.UniformsUtils.clone(shader.uniforms);
      this.material = new THREE48.ShaderMaterial({
        defines: { ...shader.defines },
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  uniforms;
  material;
  fsQuad;
  render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
    this.fsQuad.render(renderer);
  }
};
var FullScreenQuad = class {
  m_mesh;
  m_camera;
  constructor(material) {
    this.m_camera = new THREE48.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const geometry = new THREE48.PlaneBufferGeometry(2, 2);
    this.m_mesh = new THREE48.Mesh(geometry, material);
  }
  get material() {
    return this.m_mesh.material;
  }
  set material(value2) {
    this.m_mesh.material = value2;
  }
  render(renderer) {
    renderer.render(this.m_mesh, this.m_camera);
  }
};

// src/mapview/composing/LowResRenderPass.ts
var LowResRenderPass = class extends Pass {
  constructor(lowResPixelRatio) {
    super();
    this.lowResPixelRatio = lowResPixelRatio;
    this.m_quad.frustumCulled = false;
    this.m_quadScene.add(this.m_quad);
    this.m_pixelRatio = lowResPixelRatio;
  }
  m_renderTarget = null;
  m_localCamera = new THREE49.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  m_quadScene = new THREE49.Scene();
  m_quadUniforms = CopyShader.uniforms;
  m_quadMaterial = new CopyMaterial(this.m_quadUniforms);
  m_quad = new THREE49.Mesh(new THREE49.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
  m_pixelRatio;
  m_savedWidth = 0;
  m_savedHeight = 0;
  dispose() {
    this.m_quadMaterial.dispose();
    this.m_quad.geometry.dispose();
    if (this.m_renderTarget !== null) {
      this.m_renderTarget.dispose();
      this.m_renderTarget = null;
    }
  }
  set pixelRatio(ratio) {
    this.m_pixelRatio = ratio;
    if (this.m_renderTarget && this.pixelRatio !== void 0) {
      this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));
    }
  }
  get pixelRatio() {
    return this.m_pixelRatio;
  }
  render(renderer, scene, camera, writeBuffer, readBuffer) {
    if (!this.enabled || this.pixelRatio === void 0) {
      return;
    }
    if (this.m_renderTarget === null) {
      this.m_savedWidth = readBuffer.width;
      this.m_savedHeight = readBuffer.height;
      this.m_renderTarget = new THREE49.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {
        minFilter: THREE49.LinearFilter,
        magFilter: THREE49.LinearFilter,
        format: THREE49.RGBAFormat,
        depthBuffer: true,
        stencilBuffer: true
      });
      this.m_renderTarget.texture.name = "LowResRenderPass.sample";
    }
    this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
    this.m_quadUniforms.opacity.value = 1;
    const oldRenderTarget = renderer.getRenderTarget();
    renderer.setRenderTarget(this.m_renderTarget);
    renderer.clear();
    renderer.render(scene, camera);
    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
    renderer.clear();
    renderer.render(this.m_quadScene, this.m_localCamera);
    renderer.setRenderTarget(oldRenderTarget);
  }
  setSize(width, height) {
    this.m_savedWidth = width;
    this.m_savedHeight = height;
    if (this.m_renderTarget && this.pixelRatio !== void 0) {
      this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));
    }
  }
};

// src/mapview/composing/MSAARenderPass.ts
var THREE50 = __toESM(require("three"));
var MSAASampling = /* @__PURE__ */ ((MSAASampling2) => {
  MSAASampling2[MSAASampling2["Level_0"] = 0] = "Level_0";
  MSAASampling2[MSAASampling2["Level_1"] = 1] = "Level_1";
  MSAASampling2[MSAASampling2["Level_2"] = 2] = "Level_2";
  MSAASampling2[MSAASampling2["Level_3"] = 3] = "Level_3";
  MSAASampling2[MSAASampling2["Level_4"] = 4] = "Level_4";
  MSAASampling2[MSAASampling2["Level_5"] = 5] = "Level_5";
  return MSAASampling2;
})(MSAASampling || {});
var _MSAARenderPass = class extends Pass {
  samplingLevel = 1 /* Level_1 */;
  m_renderTarget = null;
  m_localCamera = new THREE50.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  m_quadScene = new THREE50.Scene();
  m_quadUniforms = CopyShader.uniforms;
  m_quadMaterial = new MSAAMaterial(this.m_quadUniforms);
  m_quad = new THREE50.Mesh(new THREE50.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
  m_tmpColor = new THREE50.Color();
  constructor() {
    super();
    this.m_quad.frustumCulled = false;
    this.m_quadScene.add(this.m_quad);
  }
  dispose() {
    if (this.m_renderTarget !== null) {
      this.m_renderTarget.dispose();
      this.m_renderTarget = null;
    }
  }
  render(renderer, scene, camera, writeBuffer, readBuffer) {
    if (!this.enabled) {
      return;
    }
    if (this.m_renderTarget === null) {
      this.m_renderTarget = new THREE50.WebGLRenderTarget(readBuffer.width, readBuffer.height, {
        minFilter: THREE50.LinearFilter,
        magFilter: THREE50.LinearFilter,
        format: THREE50.RGBAFormat
      });
      this.m_renderTarget.texture.name = "MSAARenderPass.sample";
    }
    this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
    const offsets = _MSAARenderPass.OffsetVectors[this.samplingLevel];
    const rendererClearColor = renderer.getClearColor(this.m_tmpColor);
    const oldClearColor = rendererClearColor !== void 0 ? rendererClearColor.getHex() : 0;
    const oldView = {
      enabled: camera.view !== null && camera.view.enabled,
      fullWidth: readBuffer.width,
      fullHeight: readBuffer.height,
      x: 0,
      y: 0,
      width: readBuffer.width,
      height: readBuffer.height
    };
    if (oldView.enabled && camera.view !== null) {
      oldView.fullWidth = camera.view.fullWidth;
      oldView.fullHeight = camera.view.fullHeight;
      oldView.x = camera.view.offsetX;
      oldView.y = camera.view.offsetY;
      oldView.width = camera.view.width;
      oldView.height = camera.view.height;
    }
    const oldRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < offsets.length; i++) {
      const offset = offsets[i];
      camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);
      const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;
      const sampleWeight = 1 / offsets.length + uniformCenteredDistribution / 32;
      this.m_quadUniforms.opacity.value = sampleWeight;
      renderer.setRenderTarget(this.m_renderTarget);
      renderer.clear();
      renderer.render(scene, camera);
      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
      if (i === 0) {
        renderer.setClearColor(0);
        renderer.clear();
      }
      renderer.render(this.m_quadScene, this.m_localCamera);
      if (i === 0 && rendererClearColor !== void 0) {
        renderer.setClearColor(oldClearColor);
      }
    }
    renderer.setRenderTarget(oldRenderTarget);
    if (camera.view !== null) {
      camera.view.enabled = oldView.enabled;
      camera.view.offsetX = oldView.x;
      camera.view.offsetY = oldView.y;
    }
  }
  setSize(width, height) {
    if (this.m_renderTarget) {
      this.m_renderTarget.setSize(width, height);
    }
  }
};
var MSAARenderPass = _MSAARenderPass;
__publicField(MSAARenderPass, "OffsetVectors", [
  [[0, 0]],
  [
    [4, 4],
    [-4, -4]
  ],
  [
    [-2, -6],
    [6, -2],
    [-6, 2],
    [2, 6]
  ],
  [
    [1, -3],
    [-1, 3],
    [5, 1],
    [-3, -5],
    [-5, 5],
    [-7, -1],
    [3, 7],
    [7, -7]
  ],
  [
    [1, 1],
    [-1, -3],
    [-3, 2],
    [4, -1],
    [-5, -2],
    [2, 5],
    [5, 3],
    [3, -5],
    [-2, 6],
    [0, -7],
    [-4, -6],
    [-6, 4],
    [-8, 0],
    [7, -4],
    [6, 7],
    [-7, -8]
  ],
  [
    [-4, -7],
    [-7, -5],
    [-3, -5],
    [-5, -4],
    [-1, -4],
    [-2, -2],
    [-6, -1],
    [-4, 0],
    [-7, 1],
    [-1, 2],
    [-6, 3],
    [-3, 3],
    [-7, 6],
    [-3, 6],
    [-5, 7],
    [-1, 7],
    [5, -7],
    [1, -6],
    [6, -5],
    [4, -4],
    [2, -3],
    [7, -2],
    [1, -1],
    [4, -1],
    [2, 1],
    [6, 2],
    [0, 4],
    [4, 4],
    [2, 5],
    [7, 5],
    [5, 6],
    [3, 7]
  ]
]);

// src/mapview/composing/Outline.ts
var THREE51 = __toESM(require("three"));
var vertexShaderChunk = `
#ifdef USE_EXTRUSION
  #ifndef HAS_EXTRUSION_PARS_VERTEX
    #include <extrusion_pars_vertex>
  #endif
#endif

#ifdef USE_FADING
  #include <fading_pars_vertex>
#endif

uniform float outlineThickness;

vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {
    float thickness = outlineThickness;
    const float ratio = 1.0;
    vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );
    vec4 norm = normalize( pos - pos2 );
    return pos + norm * thickness * pos.w * ratio;
}`;
var vertexShaderChunk2 = `
#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )
    #ifndef USE_ENVMAP
        vec3 objectNormal = normalize( normal );
    #endif
#endif

#ifdef FLIP_SIDED
    objectNormal = -objectNormal;
#endif

#ifdef DECLARE_TRANSFORMED
    vec3 transformed = vec3( position );
#endif

#ifdef USE_EXTRUSION
 #ifndef HAS_EXTRUSION_VERTEX
  #include <extrusion_vertex>
 #endif
#endif

#ifdef USE_FADING
  #include <fading_vertex>
#endif

#ifdef USE_EXTRUSION
  gl_Position = calculateOutline( projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 ),
      objectNormal, vec4( transformed, 1.0 ) );
#else
  gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );
#endif

#include <fog_vertex>`;
var fragmentShader2 = `
#include <common>
#include <fog_pars_fragment>

#ifdef USE_EXTRUSION
  #include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
  #include <fading_pars_fragment>
#endif

uniform vec3 outlineColor;
uniform float outlineAlpha;

void main() {

    gl_FragColor = vec4( outlineColor, outlineAlpha );

    #include <fog_fragment>

    #ifdef USE_EXTRUSION
      #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
      #include <fading_fragment>
    #endif
}`;
var OutlineEffect = class {
  constructor(m_renderer) {
    this.m_renderer = m_renderer;
    this.autoClear = m_renderer.autoClear;
    this.domElement = m_renderer.domElement;
    this.shadowMap = m_renderer.shadowMap;
  }
  enabled = true;
  autoClear;
  domElement;
  shadowMap;
  m_defaultThickness = 0.02;
  m_defaultColor = new THREE51.Color(0, 0, 0);
  m_defaultAlpha = 1;
  m_defaultKeepAlive = false;
  m_ghostExtrudedPolygons = false;
  m_cache = {};
  m_removeThresholdCount = 60;
  m_originalMaterials = {};
  m_originalOnBeforeRenders = {};
  m_shaderIDs = {
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "phong",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical"
  };
  m_uniformsChunk = {
    outlineThickness: { value: this.m_defaultThickness },
    outlineColor: { value: this.m_defaultColor },
    outlineAlpha: { value: this.m_defaultAlpha }
  };
  set thickness(thickness) {
    this.m_defaultThickness = thickness;
    this.m_uniformsChunk.outlineThickness.value = thickness;
    this.m_cache = {};
  }
  set color(color) {
    this.m_defaultColor.set(color);
    this.m_cache = {};
  }
  set ghostExtrudedPolygons(ghost) {
    this.m_ghostExtrudedPolygons = ghost;
  }
  clear(color, depth, stencil) {
    this.m_renderer.clear(color, depth, stencil);
  }
  getPixelRatio() {
    return this.m_renderer.getPixelRatio();
  }
  setPixelRatio(value2) {
    this.m_renderer.setPixelRatio(value2);
  }
  getSize(target) {
    return this.m_renderer.getSize(target);
  }
  setSize(width, height, updateStyle) {
    this.m_renderer.setSize(width, height, updateStyle);
  }
  setViewport(x, y, width, height) {
    this.m_renderer.setViewport(x, y, width, height);
  }
  setScissor(x, y, width, height) {
    this.m_renderer.setScissor(x, y, width, height);
  }
  setScissorTest(boolean) {
    this.m_renderer.setScissorTest(boolean);
  }
  setRenderTarget(renderTarget) {
    this.m_renderer.setRenderTarget(renderTarget);
  }
  render(scene, camera) {
    if (this.m_ghostExtrudedPolygons) {
      if (!this.enabled) {
        this.m_renderer.render(scene, camera);
        return;
      }
      const currentAutoClear = this.m_renderer.autoClear;
      this.m_renderer.autoClear = this.autoClear;
      this.m_renderer.render(scene, camera);
      this.m_renderer.autoClear = currentAutoClear;
    }
    this.renderOutline(scene, camera);
  }
  renderOutline(scene, camera) {
    const currentAutoClear = this.m_renderer.autoClear;
    const currentSceneAutoUpdate = scene.autoUpdate;
    const currentSceneBackground = scene.background;
    const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;
    scene.autoUpdate = false;
    scene.background = null;
    this.m_renderer.autoClear = false;
    this.m_renderer.shadowMap.enabled = false;
    scene.traverse(this.setOutlineMaterial.bind(this));
    this.m_renderer.render(scene, camera);
    scene.traverse(this.restoreOriginalMaterial.bind(this));
    this.cleanupCache();
    scene.autoUpdate = currentSceneAutoUpdate;
    scene.background = currentSceneBackground;
    this.m_renderer.autoClear = currentAutoClear;
    this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;
  }
  createInvisibleMaterial() {
    return new THREE51.ShaderMaterial({ name: "invisible", visible: false });
  }
  createMaterial(originalMaterial) {
    if (originalMaterial instanceof EdgeMaterial || originalMaterial.isDepthPrepassMaterial === true) {
      return this.createInvisibleMaterial();
    }
    const shaderID = this.m_shaderIDs[originalMaterial.type];
    let originalVertexShader;
    let originalUniforms = originalMaterial.shaderUniforms !== void 0 ? originalMaterial.shaderUniforms : originalMaterial.uniforms;
    if (shaderID !== void 0) {
      const shader = THREE51.ShaderLib[shaderID];
      originalUniforms = shader.uniforms;
      originalVertexShader = shader.vertexShader;
    } else if (originalMaterial.isRawShaderMaterial === true) {
      originalVertexShader = originalMaterial.vertexShader;
      if (!/attribute\s+vec3\s+position\s*;/.test(originalVertexShader) || !/attribute\s+vec3\s+normal\s*;/.test(originalVertexShader)) {
        return this.createInvisibleMaterial();
      }
    } else if (originalMaterial.isShaderMaterial === true) {
      originalVertexShader = originalMaterial.vertexShader;
    } else {
      return this.createInvisibleMaterial();
    }
    const isExtrusionMaterial = originalMaterial.shaderUniforms !== void 0 && originalMaterial.shaderUniforms.extrusionRatio !== void 0;
    const isFadingMaterial = FadingFeature.isDefined(originalMaterial);
    const uniforms = {
      ...originalUniforms,
      ...this.m_uniformsChunk
    };
    const vertexShader2 = originalVertexShader.replace(/void\s+main\s*\(\s*\)/, vertexShaderChunk + "\nvoid main()").replace(/\}\s*$/, vertexShaderChunk2 + "\n}").replace(/#include\s+<[\w_]*light[\w_]*>/g, "");
    const defines = {};
    if (!/vec3\s+transformed\s*=/.test(originalVertexShader) && !/#include\s+<begin_vertex>/.test(originalVertexShader)) {
      ;
      defines.DECLARE_TRANSFORMED = true;
    }
    if (isExtrusionMaterial) {
      uniforms.extrusionRatio = {
        value: ExtrusionFeatureDefs.DEFAULT_RATIO_MIN
      };
      defines.USE_EXTRUSION = 1;
    }
    if (isFadingMaterial) {
      uniforms.fadeNear = {
        value: originalUniforms.fadeNear !== void 0 ? originalUniforms.fadeNear.value : FadingFeature.DEFAULT_FADE_NEAR
      };
      uniforms.fadeFar = {
        value: originalUniforms.fadeFar !== void 0 ? originalUniforms.fadeFar.value : FadingFeature.DEFAULT_FADE_FAR
      };
      defines.USE_FADING = 1;
    }
    const outlineMaterial = new THREE51.ShaderMaterial({
      defines,
      uniforms,
      vertexShader: vertexShader2,
      fragmentShader: fragmentShader2,
      side: THREE51.BackSide,
      morphTargets: false,
      morphNormals: false,
      fog: false,
      blending: THREE51.CustomBlending,
      blendSrc: THREE51.SrcAlphaFactor,
      blendDst: THREE51.OneMinusSrcAlphaFactor,
      blendSrcAlpha: THREE51.OneFactor,
      blendDstAlpha: THREE51.OneMinusSrcAlphaFactor,
      transparent: true,
      polygonOffset: true,
      polygonOffsetFactor: 10,
      polygonOffsetUnits: 30
    });
    return outlineMaterial;
  }
  getOutlineMaterialFromCache(originalMaterial) {
    let data2 = this.m_cache[originalMaterial.uuid];
    if (data2 === void 0) {
      data2 = {
        material: this.createMaterial(originalMaterial),
        used: true,
        keepAlive: this.m_defaultKeepAlive,
        count: 0
      };
      this.m_cache[originalMaterial.uuid] = data2;
    }
    data2.used = true;
    return data2.material;
  }
  getOutlineMaterial(originalMaterial) {
    const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);
    this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;
    this.updateOutlineMaterial(outlineMaterial, originalMaterial);
    return outlineMaterial;
  }
  setOutlineMaterial(object) {
    if (object.material === void 0) {
      return;
    }
    if (Array.isArray(object.material)) {
      for (let i = 0, il = object.material.length; i < il; i++) {
        ;
        object.material[i] = this.getOutlineMaterial(object.material[i]);
      }
    } else {
      ;
      object.material = this.getOutlineMaterial(object.material);
    }
    this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
    object.onBeforeRender = chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));
  }
  restoreOriginalMaterial(object) {
    if (object.material === void 0) {
      return;
    }
    if (Array.isArray(object.material)) {
      for (let i = 0, il = object.material.length; i < il; i++) {
        ;
        object.material[i] = this.m_originalMaterials[object.material[i].uuid];
      }
    } else {
      ;
      object.material = this.m_originalMaterials[object.material.uuid];
    }
    object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];
  }
  onBeforeRender(renderer, scene, camera, geometry, material, group) {
    const originalMaterial = this.m_originalMaterials[material.uuid];
    if (originalMaterial === void 0) {
      return;
    }
    this.updateUniforms(material, originalMaterial);
  }
  updateUniforms(material, originalMaterial) {
    var _a;
    const outlineParameters = originalMaterial.userData.outlineParameters;
    const outlineUniforms = material.uniforms;
    outlineUniforms.outlineAlpha.value = originalMaterial.opacity;
    const originalUniforms = originalMaterial.shaderUniforms !== void 0 ? originalMaterial.shaderUniforms : originalMaterial.uniforms;
    if (outlineParameters !== void 0) {
      if (outlineParameters.thickness !== void 0) {
        outlineUniforms.outlineThickness.value = outlineParameters.thickness;
      }
      if (outlineParameters.color !== void 0) {
        outlineUniforms.outlineColor.value.fromArray(outlineParameters.color);
      }
      if (outlineParameters.alpha !== void 0) {
        outlineUniforms.outlineAlpha.value = outlineParameters.alpha;
      }
    }
    if (originalUniforms !== void 0 && originalUniforms.extrusionRatio !== void 0) {
      const value2 = originalMaterial.shaderUniforms.extrusionRatio.value;
      material.extrusionRatio = value2;
      material.uniforms.extrusionRatio.value = value2 !== void 0 ? value2 : ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
    }
    if (((_a = material.defines) == null ? void 0 : _a.USE_FADING) !== void 0 && originalUniforms.fadeNear !== void 0 && originalUniforms.fadeFar !== void 0 && originalUniforms.fadeFar.value >= 0) {
      outlineUniforms.fadeNear.value = originalUniforms.fadeNear.value;
      outlineUniforms.fadeFar.value = originalUniforms.fadeFar.value;
    }
  }
  updateOutlineMaterial(material, originalMaterial) {
    if (material.name === "invisible") {
      return;
    }
    const outlineParameters = originalMaterial.userData.outlineParameters;
    material.skinning = originalMaterial.skinning;
    material.morphTargets = originalMaterial.morphTargets;
    material.morphNormals = originalMaterial.morphNormals;
    material.fog = originalMaterial.fog;
    if (outlineParameters !== void 0) {
      material.visible = originalMaterial.visible === false ? false : outlineParameters.visible !== void 0 ? outlineParameters.visible : true;
      if (outlineParameters.keepAlive !== void 0) {
        this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
      }
    } else {
      material.visible = originalMaterial.visible;
    }
    if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {
      material.visible = false;
    }
  }
  cleanupCache() {
    let keys;
    keys = Object.keys(this.m_originalMaterials);
    for (let i = 0, il = keys.length; i < il; i++) {
      this.m_originalMaterials[keys[i]] = void 0;
    }
    keys = Object.keys(this.m_originalOnBeforeRenders);
    for (let i = 0, il = keys.length; i < il; i++) {
      this.m_originalOnBeforeRenders[keys[i]] = void 0;
    }
    keys = Object.keys(this.m_cache);
    for (const key of keys) {
      if (this.m_cache[key].used === false) {
        this.m_cache[key].count++;
        if (this.m_cache[key].keepAlive === false && this.m_cache[key].count > this.m_removeThresholdCount) {
          delete this.m_cache[key];
        }
      } else {
        this.m_cache[key].used = false;
        this.m_cache[key].count = 0;
      }
    }
  }
};

// src/mapview/composing/UnrealBloomPass.ts
var THREE52 = __toESM(require("three"));
var BlurDirectionX = new THREE52.Vector2(1, 0);
var BlurDirectionY = new THREE52.Vector2(0, 1);
var BloomPass = class extends Pass {
  strength;
  radius;
  threshold;
  resolution = new THREE52.Vector2(256, 256);
  m_renderTargetsHorizontal = [];
  m_renderTargetsVertical = [];
  m_nMips = 5;
  m_highPassUniforms;
  m_materialHighPassFilter;
  m_separableBlurMaterials = [];
  m_materialCopy;
  m_copyUniforms;
  m_compositeMaterial;
  m_camera = new THREE52.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  m_scene = new THREE52.Scene();
  m_basic = new THREE52.MeshBasicMaterial();
  m_quad = new THREE52.Mesh(new THREE52.PlaneBufferGeometry(2, 2));
  m_bloomTintColors = [
    new THREE52.Vector3(1, 1, 1),
    new THREE52.Vector3(1, 1, 1),
    new THREE52.Vector3(1, 1, 1),
    new THREE52.Vector3(1, 1, 1),
    new THREE52.Vector3(1, 1, 1)
  ];
  m_renderTargetBright;
  constructor(resolution, strength, radius, threshold) {
    super();
    this.strength = strength;
    this.radius = radius;
    this.threshold = threshold;
    this.resolution = resolution;
    this.m_quad.frustumCulled = false;
    this.m_scene.add(this.m_quad);
    const pars = {
      minFilter: THREE52.LinearFilter,
      magFilter: THREE52.LinearFilter,
      format: THREE52.RGBAFormat
    };
    let resx = Math.round(this.resolution.x / 2);
    let resy = Math.round(this.resolution.y / 2);
    this.m_renderTargetBright = new THREE52.WebGLRenderTarget(resx, resy, pars);
    this.m_renderTargetBright.texture.name = "UnrealBloomPass.bright";
    this.m_renderTargetBright.texture.generateMipmaps = false;
    for (let i = 0; i < this.m_nMips; i++) {
      const renderTargetHorizonal = new THREE52.WebGLRenderTarget(resx, resy, pars);
      renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
      renderTargetHorizonal.texture.generateMipmaps = false;
      this.m_renderTargetsHorizontal.push(renderTargetHorizonal);
      const renderTargetVertical = new THREE52.WebGLRenderTarget(resx, resy, pars);
      renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
      renderTargetVertical.texture.generateMipmaps = false;
      this.m_renderTargetsVertical.push(renderTargetVertical);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    this.m_highPassUniforms = THREE52.UniformsUtils.clone(LuminosityHighPassShader.uniforms);
    this.m_highPassUniforms["luminosityThreshold"].value = threshold;
    this.m_highPassUniforms["smoothWidth"].value = 0.01;
    this.m_materialHighPassFilter = new THREE52.ShaderMaterial({
      uniforms: this.m_highPassUniforms,
      vertexShader: LuminosityHighPassShader.vertexShader,
      fragmentShader: LuminosityHighPassShader.fragmentShader,
      defines: {}
    });
    const kernelSizeArray = [3, 5, 7, 9, 11];
    resx = Math.round(this.resolution.x / 2);
    resy = Math.round(this.resolution.y / 2);
    for (let i = 0; i < this.m_nMips; i++) {
      this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
      this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE52.Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);
    this.m_compositeMaterial.uniforms["blurTexture1"].value = this.m_renderTargetsVertical[0].texture;
    this.m_compositeMaterial.uniforms["blurTexture2"].value = this.m_renderTargetsVertical[1].texture;
    this.m_compositeMaterial.uniforms["blurTexture3"].value = this.m_renderTargetsVertical[2].texture;
    this.m_compositeMaterial.uniforms["blurTexture4"].value = this.m_renderTargetsVertical[3].texture;
    this.m_compositeMaterial.uniforms["blurTexture5"].value = this.m_renderTargetsVertical[4].texture;
    this.m_compositeMaterial.uniforms["bloomStrength"].value = strength;
    this.m_compositeMaterial.uniforms["bloomRadius"].value = 0.1;
    this.m_compositeMaterial.needsUpdate = true;
    const bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
    this.m_compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
    this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
    this.m_copyUniforms = THREE52.UniformsUtils.clone(CopyShader.uniforms);
    this.m_copyUniforms["opacity"].value = 1;
    this.m_materialCopy = new THREE52.ShaderMaterial({
      uniforms: this.m_copyUniforms,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      blending: THREE52.AdditiveBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
  }
  dispose() {
    for (const rt of this.m_renderTargetsHorizontal) {
      rt.dispose();
    }
    for (const rt of this.m_renderTargetsVertical) {
      rt.dispose();
    }
    this.m_renderTargetBright.dispose();
  }
  setSize(width, height) {
    let resx = Math.round(width / 2);
    let resy = Math.round(height / 2);
    this.m_renderTargetBright.setSize(resx, resy);
    for (let i = 0; i < this.m_nMips; i++) {
      this.m_renderTargetsHorizontal[i].setSize(resx, resy);
      this.m_renderTargetsVertical[i].setSize(resx, resy);
      this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE52.Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
  }
  render(renderer, scene, camera, writeBuffer, readBuffer) {
    if (this.renderToScreen) {
      this.m_quad.material = this.m_basic;
      this.m_basic.map = readBuffer.texture;
      renderer.setRenderTarget(null);
      renderer.clear();
      renderer.render(this.m_scene, this.m_camera);
    }
    this.m_highPassUniforms["tDiffuse"].value = readBuffer.texture;
    this.m_highPassUniforms["luminosityThreshold"].value = this.threshold;
    this.m_quad.material = this.m_materialHighPassFilter;
    renderer.setRenderTarget(this.m_renderTargetBright);
    renderer.clear();
    renderer.render(this.m_scene, this.m_camera);
    let inputRenderTarget = this.m_renderTargetBright;
    for (let i = 0; i < this.m_nMips; i++) {
      this.m_quad.material = this.m_separableBlurMaterials[i];
      this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = inputRenderTarget.texture;
      this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionX;
      renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);
      renderer.clear();
      renderer.render(this.m_scene, this.m_camera);
      this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = this.m_renderTargetsHorizontal[i].texture;
      this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionY;
      renderer.setRenderTarget(this.m_renderTargetsVertical[i]);
      renderer.clear();
      renderer.render(this.m_scene, this.m_camera);
      inputRenderTarget = this.m_renderTargetsVertical[i];
    }
    this.m_quad.material = this.m_compositeMaterial;
    this.m_compositeMaterial.uniforms["bloomStrength"].value = this.strength;
    this.m_compositeMaterial.uniforms["bloomRadius"].value = this.radius;
    this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
    renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);
    renderer.clear();
    renderer.render(this.m_scene, this.m_camera);
    this.m_quad.material = this.m_materialCopy;
    this.m_copyUniforms["tDiffuse"].value = this.m_renderTargetsHorizontal[0].texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      renderer.render(this.m_scene, this.m_camera);
    } else {
      renderer.setRenderTarget(readBuffer);
      renderer.render(this.m_scene, this.m_camera);
    }
  }
  getSeperableBlurMaterial(kernelRadius) {
    return new THREE52.ShaderMaterial({
      defines: {
        KERNEL_RADIUS: kernelRadius,
        SIGMA: kernelRadius
      },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new THREE52.Vector2(0.5, 0.5) },
        direction: { value: new THREE52.Vector2(0.5, 0.5) }
      },
      vertexShader: `varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }`,
      fragmentShader: `#include <common>
            varying vec2 vUv;
            uniform sampler2D colorTexture;
            uniform vec2 texSize;
            uniform vec2 direction;

            float gaussianPdf(in float x, in float sigma) {
                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
            }
            void main() {
                vec2 invSize = 1.0 / texSize;
                float fSigma = float(SIGMA);
                float weightSum = gaussianPdf(0.0, fSigma);
                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
                    float x = float(i);
                    float w = gaussianPdf(x, fSigma);
                    vec2 uvOffset = direction * invSize * x;
                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
                    diffuseSum += (sample1 + sample2) * w;
                    weightSum += 2.0 * w;
                }
                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
            }`
    });
  }
  getCompositeMaterial(nMips) {
    return new THREE52.ShaderMaterial({
      defines: {
        NUM_MIPS: nMips
      },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        dirtTexture: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
      fragmentShader: `varying vec2 vUv;
                uniform sampler2D blurTexture1;
                uniform sampler2D blurTexture2;
                uniform sampler2D blurTexture3;
                uniform sampler2D blurTexture4;
                uniform sampler2D blurTexture5;
                uniform sampler2D dirtTexture;
                uniform float bloomStrength;
                uniform float bloomRadius;
                uniform float bloomFactors[NUM_MIPS];
                uniform vec3 bloomTintColors[NUM_MIPS];

                float lerpBloomFactor(const in float factor) {
                    float mirrorFactor = 1.2 - factor;
                    return mix(factor, mirrorFactor, bloomRadius);
                }

                void main() {
                    gl_FragColor = bloomStrength * (
lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                }`
    });
  }
};

// src/mapview/composing/MapRenderingManager.ts
var DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = 1 /* Level_1 */;
var DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = 4 /* Level_4 */;
var MapRenderingManager = class {
  bloom = {
    enabled: false,
    strength: 1.5,
    radius: 0.4,
    threshold: 0.85
  };
  outline = {
    enabled: false,
    thickness: 5e-3,
    color: "#000000",
    ghostExtrudedPolygons: false,
    needsUpdate: false
  };
  vignette = {
    enabled: false,
    offset: 1,
    darkness: 1
  };
  sepia = {
    enabled: false,
    amount: 0.5
  };
  m_width = 1;
  m_height = 1;
  m_outlineEffect;
  m_msaaPass;
  m_renderPass = new RenderPass();
  m_target1 = new THREE53.WebGLRenderTarget(1, 1);
  m_target2 = new THREE53.WebGLRenderTarget(1, 1);
  m_bloomPass;
  m_sepiaPass = new ShaderPass(SepiaShader);
  m_vignettePass = new ShaderPass(VignetteShader);
  m_readBuffer;
  m_dynamicMsaaSamplingLevel;
  m_staticMsaaSamplingLevel;
  m_lowResPass;
  constructor(width, height, lowResPixelRatio, antialiasSettings = {
    msaaEnabled: false
  }) {
    this.m_readBuffer = new THREE53.WebGLRenderTarget(width, height);
    this.m_msaaPass = new MSAARenderPass();
    this.m_msaaPass.enabled = antialiasSettings !== void 0 ? antialiasSettings.msaaEnabled === true : false;
    this.m_dynamicMsaaSamplingLevel = antialiasSettings.dynamicMsaaSamplingLevel === void 0 ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL : antialiasSettings.dynamicMsaaSamplingLevel;
    this.m_staticMsaaSamplingLevel = antialiasSettings.staticMsaaSamplingLevel === void 0 ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL : antialiasSettings.staticMsaaSamplingLevel;
    this.m_lowResPass = new LowResRenderPass(lowResPixelRatio);
    this.m_lowResPass.enabled = lowResPixelRatio !== void 0;
  }
  updateOutline(options) {
    this.outline.color = options.color;
    this.outline.thickness = options.thickness;
    this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;
    this.outline.needsUpdate = true;
  }
  render(renderer, scene, camera, isStaticFrame) {
    const target = null;
    if (!isStaticFrame && this.m_lowResPass.pixelRatio !== void 0) {
      this.m_lowResPass.renderToScreen = true;
      this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);
      return;
    }
    const usePostEffects = this.bloom.enabled || this.outline.enabled || this.vignette.enabled || this.sepia.enabled;
    let activeTarget = null;
    if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
      renderer.setRenderTarget(this.m_target1);
      renderer.clearDepth();
    }
    if (this.m_msaaPass.enabled) {
      this.m_msaaPass.samplingLevel = isStaticFrame ? this.m_staticMsaaSamplingLevel : this.m_dynamicMsaaSamplingLevel;
      this.m_msaaPass.renderToScreen = !usePostEffects;
      this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);
    } else {
      if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
        activeTarget = this.m_target1;
        this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);
      } else if (!this.outline.enabled || this.outline.enabled && !this.bloom.enabled) {
        renderer.render(scene, camera);
      }
    }
    if (this.outline.enabled) {
      if (this.m_outlineEffect === void 0) {
        this.m_outlineEffect = new OutlineEffect(renderer);
      }
      if (this.outline.needsUpdate) {
        this.m_outlineEffect.color = this.outline.color;
        this.m_outlineEffect.thickness = this.outline.thickness;
        this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;
        this.outline.needsUpdate = false;
      }
      const nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;
      if (nextEffectEnabled) {
        activeTarget = this.m_target1;
      }
      renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);
      this.m_outlineEffect.render(scene, camera);
    }
    if (this.bloom.enabled) {
      if (this.m_bloomPass === void 0) {
        this.m_bloomPass = new BloomPass(new THREE53.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);
      }
      const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;
      this.m_bloomPass.renderToScreen = !nextEffectEnabled;
      this.m_bloomPass.radius = this.bloom.radius;
      this.m_bloomPass.strength = this.bloom.strength;
      this.m_bloomPass.threshold = this.bloom.threshold;
      this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);
    } else if (this.m_bloomPass !== void 0) {
      this.m_bloomPass.dispose();
      this.m_bloomPass = void 0;
    }
    if (this.vignette.enabled) {
      const oldTarget = activeTarget;
      const nextEffectEnabled = this.sepia.enabled;
      this.m_vignettePass.uniforms.offset.value = this.vignette.offset;
      this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;
      this.m_vignettePass.renderToScreen = !nextEffectEnabled;
      if (nextEffectEnabled) {
        activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;
      }
      this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);
    }
    if (this.sepia.enabled) {
      this.m_sepiaPass.renderToScreen = true;
      this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;
      this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);
    }
  }
  setSize(width, height) {
    this.m_readBuffer.setSize(width, height);
    this.m_msaaPass.setSize(width, height);
    if (this.m_bloomPass !== void 0) {
      this.m_bloomPass.setSize(width, height);
    }
    this.m_lowResPass.setSize(width, height);
    this.m_target1.setSize(width, height);
    this.m_target2.setSize(width, height);
    this.m_width = width;
    this.m_height = height;
  }
  get lowResPixelRatio() {
    return this.m_lowResPass.pixelRatio;
  }
  set lowResPixelRatio(pixelRatio) {
    this.m_lowResPass.pixelRatio = pixelRatio;
    this.m_lowResPass.enabled = pixelRatio !== void 0;
  }
  set dynamicMsaaSamplingLevel(samplingLevel) {
    this.m_dynamicMsaaSamplingLevel = samplingLevel;
  }
  get dynamicMsaaSamplingLevel() {
    return this.m_dynamicMsaaSamplingLevel;
  }
  set msaaEnabled(value2) {
    this.m_msaaPass.enabled = value2;
  }
  get msaaEnabled() {
    return this.m_msaaPass.enabled;
  }
  set staticMsaaSamplingLevel(samplingLevel) {
    this.m_staticMsaaSamplingLevel = samplingLevel;
  }
  get staticMsaaSamplingLevel() {
    return this.m_staticMsaaSamplingLevel;
  }
};

// src/mapview/ConcurrentWorkerSet.ts
var THREE54 = __toESM(require("three"));

// src/mapview/workers/WorkerBootstrapDefs.ts
function isWorkerBootstrapRequest(message) {
  return message && message.type === "worker-bootstrap-request" && Array.isArray(message.dependencies);
}

// src/mapview/workers/WorkerLoader.ts
var logger6 = LoggerManager.instance.create("WorkerLoader");
var _WorkerLoader = class {
  static startWorker(scriptUrl, timeout = 1e4) {
    if (scriptUrl.startsWith("blob:")) {
      return this.startWorkerImmediately(scriptUrl, timeout);
    }
    if (this.directlyFallbackToBlobBasedLoading) {
      return this.startWorkerBlob(scriptUrl, timeout);
    }
    return this.startWorkerImmediately(scriptUrl, timeout).catch((error) => {
      if (typeof window !== "undefined") {
        const pageUrl = window.location.href;
        const fullScriptUrl = new URL(scriptUrl, pageUrl).href;
        if (getUrlOrigin(fullScriptUrl) === getUrlOrigin(pageUrl)) {
          throw error;
        }
        logger6.log("#startWorker: cross-origin worker construction failed, trying load with blob");
        this.directlyFallbackToBlobBasedLoading = true;
        return _WorkerLoader.startWorkerBlob(scriptUrl, timeout);
      } else {
        throw error;
      }
    });
  }
  static startWorkerImmediately(scriptUrl, timeout) {
    try {
      const worker = new Worker(scriptUrl);
      return this.waitWorkerInitialized(worker, timeout);
    } catch (error) {
      return Promise.reject(error);
    }
  }
  static startWorkerBlob(scriptUrl, timeout) {
    return this.fetchScriptSourceToBlobUrl(scriptUrl).then((blobUrl) => {
      return this.startWorkerImmediately(blobUrl, timeout);
    });
  }
  static fetchScriptSourceToBlobUrl(scriptUrl) {
    let loadingPromise = this.sourceLoaderCache.get(scriptUrl);
    if (loadingPromise !== void 0) {
      return loadingPromise;
    }
    loadingPromise = fetch(scriptUrl).then((response) => response.text()).catch((error) => {
      throw new Error(`WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`);
    }).then((scriptSource) => {
      this.sourceLoaderCache.delete(scriptUrl);
      const blob = new Blob([scriptSource], {
        type: "application/javascript"
      });
      return URL.createObjectURL(blob);
    });
    this.sourceLoaderCache.set(scriptUrl, loadingPromise);
    return loadingPromise;
  }
  static waitWorkerInitialized(worker, timeout) {
    return new Promise((resolve, reject) => {
      const firstMessageCallback = (event) => {
        const message = event.data;
        if (isWorkerBootstrapRequest(message)) {
          const dependencies = message.dependencies;
          const resolvedDependencies = [];
          for (const dependency of dependencies) {
            const resolved = this.dependencyUrlMapping[dependency];
            if (!resolved) {
              cleanup();
              reject(new Error(`#waitWorkerInitialized: Unable to resolve '${dependency}' as needed by worker script.`));
              return;
            }
            resolvedDependencies.push(resolved);
          }
          const response = {
            type: "worker-bootstrap-response",
            resolvedDependencies
          };
          worker.postMessage(response);
          return;
        }
        cleanup();
        resolve(worker);
        setTimeout(() => {
          worker.dispatchEvent(event);
        }, 0);
      };
      const errorCallback = (error) => {
        cleanup();
        let message = "Error during worker initialization";
        if (error.message) {
          message = message + `: ${error.message}`;
        }
        if (typeof error.filename === "string" && typeof error.lineno === "number") {
          message = message + ` in ${error.filename}:${error.lineno}`;
        }
        reject(new Error(message));
      };
      const cleanup = () => {
        clearTimeout(timerId);
        worker.removeEventListener("message", firstMessageCallback);
        worker.removeEventListener("error", errorCallback);
      };
      worker.addEventListener("error", errorCallback);
      worker.addEventListener("message", firstMessageCallback);
      const timerId = setTimeout(() => {
        cleanup();
        reject(new Error("Timeout exceeded when waiting for first message from worker."));
      }, timeout);
    });
  }
};
var WorkerLoader = _WorkerLoader;
__publicField(WorkerLoader, "directlyFallbackToBlobBasedLoading", false);
__publicField(WorkerLoader, "sourceLoaderCache", /* @__PURE__ */ new Map());
__publicField(WorkerLoader, "dependencyUrlMapping", {});

// src/mapview/ConcurrentWorkerSet.ts
var logger7 = LoggerManager.instance.create("ConcurrentWorkerSet");
function isLoggingMessage(message) {
  return message && typeof message.level === "number" && message.type === WORKERCHANNEL_MSG_TYPE;
}
var DEFAULT_WORKER_COUNT = 2;
var DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 1e4;
var ConcurrentWorkerSet = class {
  constructor(m_options) {
    this.m_options = m_options;
    this.start();
  }
  m_workerChannelLogger = LoggerManager.instance.create("WorkerChannel");
  m_eventListeners = /* @__PURE__ */ new Map();
  m_workers = new Array();
  m_availableWorkers = new Array();
  m_workerPromises = new Array();
  m_workerCount;
  m_readyPromises = /* @__PURE__ */ new Map();
  m_requests = /* @__PURE__ */ new Map();
  m_workerRequestQueue = [];
  m_nextMessageId = 0;
  m_stopped = true;
  m_referenceCount = 0;
  addReference() {
    this.m_referenceCount += 1;
    if (this.m_referenceCount === 1 && this.m_stopped) {
      this.start();
    }
  }
  removeReference() {
    this.m_referenceCount -= 1;
    if (this.m_referenceCount === 0) {
      this.destroy();
    }
  }
  start(options) {
    if (options !== void 0) {
      this.m_options = options;
    }
    if (!this.m_stopped) {
      throw new Error("ConcurrentWorker set already started");
    }
    this.m_workerCount = getOptionValue(this.m_options.workerCount, typeof navigator !== "undefined" && navigator.hardwareConcurrency !== void 0 ? THREE54.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 2) : void 0, DEFAULT_WORKER_COUNT);
    const timeout = getOptionValue(this.m_options.workerConnectionTimeout, DEFAULT_WORKER_INITIALIZATION_TIMEOUT);
    for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {
      const workerPromise = WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then((worker) => {
        const listener = (evt) => {
          this.onWorkerMessage(workerId, evt);
        };
        worker.addEventListener("message", listener);
        this.m_workers.push(worker);
        this.m_availableWorkers.push(worker);
        return {
          worker,
          listener
        };
      });
      this.m_workerPromises.push(workerPromise);
    }
    this.m_stopped = false;
  }
  get workerCount() {
    return this.m_workerCount;
  }
  async stop() {
    this.m_stopped = true;
    await this.waitForAllResponses().then(() => {
      this.terminateWorkers();
    });
  }
  destroy() {
    this.m_stopped = true;
    this.m_requests.forEach((entry) => {
      entry.resolver(new Error("worker destroyed"));
    });
    this.m_requests.clear();
    this.m_workerRequestQueue = [];
    this.terminateWorkers();
    this.m_eventListeners.clear();
  }
  get terminated() {
    return this.m_workers.length === 0;
  }
  async connect(serviceId) {
    this.ensureStarted();
    await Promise.all(this.m_workerPromises);
    return await this.getReadyPromise(serviceId).promise;
  }
  addEventListener(serviceId, callback) {
    this.m_eventListeners.set(serviceId, callback);
  }
  removeEventListener(serviceId) {
    this.m_eventListeners.delete(serviceId);
  }
  invokeRequest(serviceId, request, transferList, requestController) {
    this.ensureStarted();
    const messageId = this.m_nextMessageId++;
    let resolver;
    const promise = new Promise((resolve, reject) => {
      resolver = (error, response) => {
        this.m_requests.delete(messageId);
        if (error !== void 0) {
          reject(error);
        } else {
          resolve(response);
        }
      };
    });
    this.m_requests.set(messageId, {
      promise,
      resolver
    });
    const message = {
      service: serviceId,
      type: WorkerServiceProtocol.ServiceMessageName.Request,
      messageId,
      request
    };
    this.postRequestMessage(message, transferList, requestController);
    return promise;
  }
  broadcastRequest(serviceId, request, transferList) {
    const promises = [];
    for (const worker of this.m_workers) {
      const messageId = this.m_nextMessageId++;
      let resolver;
      const promise = new Promise((resolve, reject) => {
        resolver = (error, response) => {
          this.m_requests.delete(messageId);
          if (error !== void 0) {
            reject(error);
          } else {
            resolve(response);
          }
        };
      });
      promises.push(promise);
      this.m_requests.set(messageId, {
        promise,
        resolver
      });
      const message = {
        service: serviceId,
        type: WorkerServiceProtocol.ServiceMessageName.Request,
        messageId,
        request
      };
      if (transferList !== void 0) {
        worker.postMessage(message, transferList);
      } else {
        worker.postMessage(message);
      }
    }
    return Promise.all(promises);
  }
  broadcastMessage(message, buffers) {
    this.ensureStarted();
    if (buffers !== void 0) {
      this.m_workers.forEach((worker) => worker.postMessage(message, buffers));
    } else {
      this.m_workers.forEach((worker) => worker.postMessage(message));
    }
  }
  get requestQueueSize() {
    return this.m_workerRequestQueue.length;
  }
  get numWorkers() {
    return this.m_workers.length;
  }
  get numIdleWorkers() {
    return this.m_availableWorkers.length;
  }
  eventHandler(event) {
    if (typeof event.data.type !== "string") {
      return;
    }
    this.dispatchEvent(event.data.type, event);
  }
  onWorkerMessage = (workerId, event) => {
    if (WorkerServiceProtocol.isResponseMessage(event.data)) {
      const response = event.data;
      if (response.messageId === null) {
        logger7.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);
        return;
      }
      const entry = this.m_requests.get(response.messageId);
      if (entry === void 0) {
        logger7.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`);
        return;
      }
      if (workerId >= 0 && workerId < this.m_workers.length) {
        const worker = this.m_workers[workerId];
        this.m_availableWorkers.push(worker);
        this.checkWorkerRequestQueue();
      } else {
        logger7.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);
      }
      if (response.errorMessage !== void 0) {
        const error = new Error(response.errorMessage);
        if (response.errorStack !== void 0) {
          error.stack = response.errorStack;
        }
        entry.resolver(error);
      } else {
        entry.resolver(void 0, response.response);
      }
    } else if (WorkerServiceProtocol.isInitializedMessage(event.data)) {
      const readyPromise = this.getReadyPromise(event.data.service);
      if (++readyPromise.count === this.m_workerPromises.length) {
        readyPromise.resolve();
      }
    } else if (isLoggingMessage(event.data)) {
      switch (event.data.level) {
        case 0 /* Trace */:
          this.m_workerChannelLogger.trace(...event.data.message);
          break;
        case 1 /* Debug */:
          this.m_workerChannelLogger.debug(...event.data.message);
          break;
        case 2 /* Log */:
          this.m_workerChannelLogger.log(...event.data.message);
          break;
        case 3 /* Info */:
          this.m_workerChannelLogger.info(...event.data.message);
          break;
        case 4 /* Warn */:
          this.m_workerChannelLogger.warn(...event.data.message);
          break;
        case 5 /* Error */:
          this.m_workerChannelLogger.error(...event.data.message);
          break;
      }
    } else {
      this.eventHandler(event);
    }
  };
  postRequestMessage(message, buffers, requestController) {
    this.ensureStarted();
    if (this.m_workers.length === 0) {
      throw new Error("ConcurrentWorkerSet#postMessage: no workers started");
    }
    if (requestController !== void 0 && requestController.signal.aborted) {
      const entry = this.m_requests.get(message.messageId);
      if (entry === void 0) {
        logger7.error(`[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`);
        return;
      }
      const err = new Error("Aborted");
      err.name = "AbortError";
      entry.resolver(err, void 0);
      return;
    }
    if (this.m_availableWorkers.length > 0) {
      const worker = this.m_availableWorkers.pop();
      if (buffers !== void 0) {
        worker.postMessage(message, buffers);
      } else {
        worker.postMessage(message);
      }
    } else {
      if (requestController === void 0) {
        requestController = new RequestController(0);
      }
      if (requestController.priority === 0) {
        requestController.priority = -this.m_nextMessageId;
      }
      this.m_workerRequestQueue.unshift({
        message,
        buffers,
        requestController
      });
    }
  }
  ensureStarted() {
    if (this.m_stopped) {
      throw new Error("ConcurrentWorkerSet stopped");
    }
  }
  async waitForAllResponses() {
    const promises = new Array();
    this.m_requests.forEach((entry) => {
      promises.push(entry.promise);
    });
    await Promise.all(promises);
  }
  dispatchEvent(id, message) {
    const callback = this.m_eventListeners.get(id);
    if (callback === void 0) {
      return;
    }
    callback(message);
  }
  terminateWorkers() {
    this.m_workerPromises.forEach((workerPromise) => {
      workerPromise.then((workerEntry) => {
        if (workerEntry === void 0) {
          return;
        }
        workerEntry.worker.removeEventListener("message", workerEntry.listener);
        workerEntry.worker.terminate();
      });
    });
    this.m_workers = [];
    this.m_workerPromises = [];
    this.m_availableWorkers = [];
    this.m_readyPromises.clear();
  }
  getReadyPromise(id) {
    const readyPromise = this.m_readyPromises.get(id);
    if (readyPromise !== void 0) {
      return readyPromise;
    }
    const newPromise = {
      count: 0,
      promise: void 0,
      resolve: () => {
      },
      reject: (error) => {
        newPromise.error = error;
      },
      error: void 0
    };
    newPromise.promise = new Promise((resolve, reject) => {
      const that = newPromise;
      if (that.error !== void 0) {
        reject(that.error);
      } else if (that.count === this.m_workerPromises.length) {
        resolve();
      }
      that.resolve = resolve;
      that.reject = reject;
    });
    this.m_readyPromises.set(id, newPromise);
    return newPromise;
  }
  checkWorkerRequestQueue() {
    if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {
      return;
    }
    this.m_workerRequestQueue.sort((a, b) => {
      return a.requestController.priority - b.requestController.priority;
    });
    while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {
      const request = this.m_workerRequestQueue.pop();
      this.postRequestMessage(request.message, request.buffers, request.requestController);
    }
  }
};

// src/mapview/WorkerBasedDecoder.ts
var nextUniqueServiceId = 0;
var WorkerBasedDecoder = class {
  constructor(workerSet, decoderServiceType) {
    this.workerSet = workerSet;
    this.decoderServiceType = decoderServiceType;
    this.workerSet.addReference();
    this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;
  }
  serviceId;
  m_serviceCreated = false;
  dispose() {
    if (this.m_serviceCreated) {
      this.workerSet.broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
        type: WorkerServiceProtocol.Requests.DestroyService,
        targetServiceId: this.serviceId
      }).catch(() => {
      });
    }
    this.workerSet.removeReference();
  }
  async connect() {
    await this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
    if (!this.m_serviceCreated) {
      await this.workerSet.broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
        type: WorkerServiceProtocol.Requests.CreateService,
        targetServiceType: this.decoderServiceType,
        targetServiceId: this.serviceId
      });
      this.m_serviceCreated = true;
    }
  }
  decodeTile(data2, tileKey, projection, requestController) {
    const tileKeyCode = tileKey.mortonCode();
    const message = {
      type: WorkerDecoderProtocol.Requests.DecodeTileRequest,
      tileKey: tileKeyCode,
      data: data2,
      projection: getProjectionName(projection)
    };
    const transferList = data2 instanceof ArrayBuffer ? [data2] : void 0;
    return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
  }
  getTileInfo(data2, tileKey, projection, requestController) {
    const tileKeyCode = tileKey.mortonCode();
    const message = {
      type: WorkerDecoderProtocol.Requests.TileInfoRequest,
      tileKey: tileKeyCode,
      data: data2,
      projection: getProjectionName(projection)
    };
    const transferList = data2 instanceof ArrayBuffer ? [data2] : void 0;
    return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
  }
  configure(options, customOptions) {
    const message = {
      service: this.serviceId,
      type: WorkerDecoderProtocol.DecoderMessageName.Configuration,
      ...options,
      options: customOptions
    };
    this.workerSet.broadcastMessage(message);
  }
  get workerCount() {
    return this.workerSet.workerCount;
  }
};

// src/mapview/ConcurrentDecoderFacade.ts
var _ConcurrentDecoderFacade = class {
  static getTileDecoder(decoderServiceType, scriptUrl, workerCount, workerConnectionTimeout) {
    const workerSet = this.getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout);
    return new WorkerBasedDecoder(workerSet, decoderServiceType);
  }
  static getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout) {
    if (scriptUrl === void 0) {
      scriptUrl = this.defaultScriptUrl;
    }
    let workerSet = this.workerSets[scriptUrl];
    if (workerSet === void 0) {
      const workerConnectionTimeoutInMs = workerConnectionTimeout !== void 0 ? workerConnectionTimeout * 1e3 : void 0;
      workerSet = new ConcurrentWorkerSet({
        scriptUrl,
        workerCount: workerCount ?? this.defaultWorkerCount,
        workerConnectionTimeout: workerConnectionTimeoutInMs
      });
      this.workerSets[scriptUrl] = workerSet;
    }
    return workerSet;
  }
  static destroyWorkerSet(scriptUrl) {
    const workerSet = this.workerSets[scriptUrl];
    if (workerSet !== void 0) {
      workerSet.destroy();
      delete this.workerSets[scriptUrl];
    }
  }
  static destroy() {
    Object.keys(this.workerSets).forEach((name2) => {
      this.workerSets[name2].destroy();
    });
    this.workerSets = {};
  }
  static destroyIfTerminated() {
    let allWorkerSetsTerminated = true;
    Object.keys(this.workerSets).forEach((name2) => {
      if (!this.workerSets[name2].terminated) {
        allWorkerSetsTerminated = false;
      }
    });
    if (allWorkerSetsTerminated) {
      _ConcurrentDecoderFacade.destroy();
    }
  }
};
var ConcurrentDecoderFacade = _ConcurrentDecoderFacade;
__publicField(ConcurrentDecoderFacade, "defaultScriptUrl", "./decoder.bundle.js");
__publicField(ConcurrentDecoderFacade, "defaultWorkerCount");
__publicField(ConcurrentDecoderFacade, "workerSets", {});

// src/mapview/copyrights/CopyrightInfo.ts
var CopyrightInfo;
((CopyrightInfo2) => {
  function mergeArrays(a, b) {
    const result = [];
    for (const source of [a, b]) {
      if (source === void 0) {
        continue;
      }
      for (const sourceInfo of source) {
        const existingInfo = result.find((findItem) => findItem.id === sourceInfo.id || findItem.label !== void 0 && findItem.label === sourceInfo.label);
        if (existingInfo === void 0) {
          result.push({ ...sourceInfo });
        } else {
          existingInfo.year = MathUtils6.max2(sourceInfo.year, existingInfo.year);
          existingInfo.label = getOptionValue(sourceInfo.label, existingInfo.label);
          existingInfo.link = getOptionValue(sourceInfo.link, existingInfo.link);
        }
      }
    }
    return result;
  }
  CopyrightInfo2.mergeArrays = mergeArrays;
  function formatAsHtml(copyrightInfo) {
    if (copyrightInfo.length === 0) {
      return "";
    }
    const filtered = copyrightInfo.filter((entry) => entry.label !== "");
    if (filtered.length === 0) {
      return "";
    }
    return "\xA9 " + filtered.map((entry) => {
      const label = entry.label ?? entry.id;
      const text = entry.year !== void 0 ? `${entry.year} ${label}` : label;
      const link = entry.link;
      return link ? `<a href="${link}" target="_blank" rel="noreferrer noopener">${text}</a>` : `${text}`;
    }).join(", ");
  }
  CopyrightInfo2.formatAsHtml = formatAsHtml;
})(CopyrightInfo || (CopyrightInfo = {}));

// src/mapview/EventDispatcher.ts
var EventDispatcher = class {
  m_listeners = /* @__PURE__ */ new Map();
  dispose() {
    this.removeAllEventListeners();
  }
  hasEventListener(type, listener) {
    const listeners = this.m_listeners.get(type);
    if (listeners === void 0) {
      return false;
    }
    return listener !== void 0 ? listeners.includes(listener) : true;
  }
  addEventListener(type, listener) {
    let listeners = this.m_listeners.get(type);
    if (listeners === void 0) {
      listeners = [];
      this.m_listeners.set(type, listeners);
    }
    if (!listeners.includes(listener)) {
      listeners.push(listener);
    }
  }
  removeEventListener(type, listener) {
    const listeners = this.m_listeners.get(type);
    if (listeners === void 0) {
      return;
    }
    if (listener === void 0) {
      this.m_listeners.delete(type);
    } else {
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          this.m_listeners.delete(type);
        }
      }
    }
  }
  removeAllEventListeners() {
    const events = Array.from(this.m_listeners.keys());
    for (const event of events) {
      this.removeEventListener(event);
    }
  }
  get eventTypes() {
    return Array.from(this.m_listeners.keys());
  }
  listeners(type) {
    return this.m_listeners.get(type);
  }
  dispatchEvent(event) {
    const listeners = this.m_listeners.get(event.type);
    if (listeners !== void 0) {
      event.target = this;
      const array = listeners.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
};

// src/mapview/FrustumIntersection.ts
var THREE56 = __toESM(require("three"));

// src/mapview/ElevationRangeSource.ts
var CalculationStatus = /* @__PURE__ */ ((CalculationStatus2) => {
  CalculationStatus2[CalculationStatus2["PendingApproximate"] = 0] = "PendingApproximate";
  CalculationStatus2[CalculationStatus2["FinalPrecise"] = 1] = "FinalPrecise";
  return CalculationStatus2;
})(CalculationStatus || {});

// src/mapview/MapTileCuller.ts
var THREE55 = __toESM(require("three"));
var MapTileCuller = class {
  constructor(m_camera) {
    this.m_camera = m_camera;
  }
  m_globalFrustumMin = new THREE55.Vector3();
  m_globalFrustumMax = new THREE55.Vector3();
  m_frustumCorners = [
    new THREE55.Vector3(),
    new THREE55.Vector3(),
    new THREE55.Vector3(),
    new THREE55.Vector3(),
    new THREE55.Vector3(),
    new THREE55.Vector3(),
    new THREE55.Vector3(),
    new THREE55.Vector3()
  ];
  setup() {
    const frustumCorners = this.getFrustumCorners();
    const matrix = this.m_camera.matrixWorld;
    this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (const frustumCorner of frustumCorners) {
      frustumCorner.applyMatrix4(matrix);
      this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);
      this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);
      this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);
      this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);
      this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);
      this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);
    }
  }
  frustumIntersectsTileBox(tileBounds) {
    const globalFrustumMin = this.m_globalFrustumMin;
    const globalFrustumMax = this.m_globalFrustumMax;
    if (globalFrustumMax.x < tileBounds.min.x || globalFrustumMax.y < tileBounds.min.y || globalFrustumMax.z < tileBounds.min.z || globalFrustumMin.x > tileBounds.max.x || globalFrustumMin.y > tileBounds.max.y || globalFrustumMin.z > tileBounds.max.z) {
      return false;
    }
    return true;
  }
  getFrustumCorners() {
    const frustumCorners = this.m_frustumCorners;
    const invProjMatrix = this.m_camera.projectionMatrixInverse;
    let cornerIndex = 0;
    function addPoint(x, y, z) {
      frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);
    }
    const w = 1;
    const h = 1;
    const n = -1;
    const f = 1;
    addPoint(-w, -h, n);
    addPoint(w, -h, n);
    addPoint(-w, h, n);
    addPoint(w, h, n);
    addPoint(-w, -h, f);
    addPoint(w, -h, f);
    addPoint(-w, h, f);
    addPoint(w, h, f);
    return frustumCorners;
  }
};

// src/mapview/FrustumIntersection.ts
var tmpVectors3 = [new THREE56.Vector3(), new THREE56.Vector3()];
var tmpVector4 = new THREE56.Vector4();
var TileKeyEntry = class {
  constructor(tileKey, area, offset = 0, elevationRange, distance = 0) {
    this.tileKey = tileKey;
    this.area = area;
    this.offset = offset;
    this.elevationRange = elevationRange;
    this.distance = distance;
  }
};
function getGeoBox(tilingScheme, childTileKey, offset) {
  const geoBox = tilingScheme.getGeoBox(childTileKey);
  const longitudeOffset = 360 * offset;
  geoBox.northEast.longitude += longitudeOffset;
  geoBox.southWest.longitude += longitudeOffset;
  return geoBox;
}
var FrustumIntersection = class {
  constructor(m_camera, mapView, m_extendedFrustumCulling, m_tileWrappingEnabled, m_enableMixedLod, m_tilePixelSize = 256) {
    this.m_camera = m_camera;
    this.mapView = mapView;
    this.m_extendedFrustumCulling = m_extendedFrustumCulling;
    this.m_tileWrappingEnabled = m_tileWrappingEnabled;
    this.m_enableMixedLod = m_enableMixedLod;
    this.m_tilePixelSize = m_tilePixelSize;
    this.m_mapTileCuller = new MapTileCuller(m_camera);
  }
  m_frustum = new THREE56.Frustum();
  m_viewProjectionMatrix = new THREE56.Matrix4();
  m_mapTileCuller;
  m_rootTileKeys = [];
  m_tileKeyEntries = /* @__PURE__ */ new Map();
  get camera() {
    return this.m_camera;
  }
  get projection() {
    return this.mapView.projection;
  }
  updateFrustum(projectionMatrixOverride) {
    this.m_viewProjectionMatrix.multiplyMatrices(projectionMatrixOverride !== void 0 ? projectionMatrixOverride : this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);
    this.m_frustum.setFromProjectionMatrix(this.m_viewProjectionMatrix);
    if (this.m_extendedFrustumCulling) {
      this.m_mapTileCuller.setup();
    }
    this.computeRequiredInitialRootTileKeys(this.m_camera.position);
  }
  compute(tilingScheme, elevationRangeSource, zoomLevels, dataSources) {
    this.m_tileKeyEntries.clear();
    assert(this.mapView.viewportHeight !== 0);
    const targetTileArea = Math.pow(this.m_tilePixelSize / this.mapView.viewportHeight, 2);
    const useElevationRangeSource = elevationRangeSource !== void 0 && elevationRangeSource.getTilingScheme() === tilingScheme;
    const obbIntersections = this.mapView.projection.type === 1 /* Spherical */ || useElevationRangeSource;
    const uniqueZoomLevels = new Set(zoomLevels);
    let minGeometryHeight = 0;
    let maxGeometryHeight = 0;
    dataSources.forEach((dataSource) => {
      minGeometryHeight = Math.min(minGeometryHeight, dataSource.minGeometryHeight);
      maxGeometryHeight = Math.max(maxGeometryHeight, dataSource.maxGeometryHeight);
    });
    const cache6 = {
      calculationFinal: true,
      tileBounds: obbIntersections ? new OrientedBox3() : new THREE56.Box3()
    };
    for (const zoomLevel of uniqueZoomLevels) {
      this.m_tileKeyEntries.set(zoomLevel, /* @__PURE__ */ new Map());
    }
    for (const tileEntry of this.m_rootTileKeys) {
      const tileKey = tileEntry.tileKey;
      const offset = tileEntry.offset;
      const tileKeyEntry = this.getTileKeyEntry(tileKey, offset, tilingScheme, cache6, minGeometryHeight, maxGeometryHeight, useElevationRangeSource ? elevationRangeSource : void 0);
      if (tileKeyEntry !== void 0) {
        for (const zoomLevel of uniqueZoomLevels) {
          const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
          tileKeyEntries.set(TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset), tileKeyEntry);
        }
      }
    }
    const workList = [...this.m_rootTileKeys.values()];
    while (workList.length > 0) {
      const tileEntry = workList.pop();
      if (tileEntry === void 0) {
        break;
      }
      const tileKey = tileEntry.tileKey;
      const offset = tileEntry.offset;
      const subdivide = dataSources.some((ds, i) => ds.shouldSubdivide(zoomLevels[i], tileKey));
      if (!subdivide) {
        continue;
      }
      if (this.m_enableMixedLod && tileEntry.area < targetTileArea) {
        continue;
      }
      const tileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset);
      for (const zoomLevel of uniqueZoomLevels) {
        if (tileKey.level >= zoomLevel) {
          continue;
        }
        const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
        tileKeyEntries.delete(tileKeyAndOffset);
      }
      for (const subTileKey of tilingScheme.getSubTileKeys(tileKey)) {
        const subTileEntry = this.getTileKeyEntry(subTileKey, offset, tilingScheme, cache6, minGeometryHeight, maxGeometryHeight, useElevationRangeSource ? elevationRangeSource : void 0);
        if (subTileEntry !== void 0) {
          for (const zoomLevel of uniqueZoomLevels) {
            if (subTileEntry.tileKey.level > zoomLevel) {
              continue;
            }
            const subTileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset(subTileKey, offset);
            this.m_tileKeyEntries.get(zoomLevel).set(subTileKeyAndOffset, subTileEntry);
          }
          workList.push(subTileEntry);
        }
      }
    }
    return {
      tileKeyEntries: this.m_tileKeyEntries,
      calculationFinal: cache6.calculationFinal
    };
  }
  getTileKeyEntry(tileKey, offset, tilingScheme, cache6, minGeometryHeight, maxGeometryHeight, elevationRangeSource) {
    const geoBox = getGeoBox(tilingScheme, tileKey, offset);
    if (elevationRangeSource !== void 0) {
      const range = elevationRangeSource.getElevationRange(tileKey);
      geoBox.southWest.altitude = range.minElevation;
      geoBox.northEast.altitude = range.maxElevation;
      cache6.calculationFinal = cache6.calculationFinal && range.calculationStatus === 1 /* FinalPrecise */;
    }
    geoBox.southWest.altitude = (geoBox.southWest.altitude ?? 0) + minGeometryHeight;
    geoBox.northEast.altitude = (geoBox.northEast.altitude ?? 0) + maxGeometryHeight;
    this.mapView.projection.projectBox(geoBox, cache6.tileBounds);
    const { area, distance } = this.computeTileAreaAndDistance(cache6.tileBounds);
    if (area > 0) {
      return new TileKeyEntry(tileKey, area, offset, {
        minElevation: geoBox.southWest.altitude,
        maxElevation: geoBox.northEast.altitude
      }, distance);
    }
    return void 0;
  }
  computeTileAreaAndDistance(tileBounds) {
    if (tileBounds instanceof THREE56.Box3) {
      if (this.m_extendedFrustumCulling && !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds) || !this.m_frustum.intersectsBox(tileBounds)) {
        return {
          area: 0,
          distance: Infinity
        };
      }
    } else if (!tileBounds.intersects(this.m_frustum)) {
      return {
        area: 0,
        distance: Infinity
      };
    }
    const center = tileBounds.getCenter(tmpVectors3[0]);
    const projectedPoint = tmpVector4.set(center.x, center.y, center.z, 1).applyMatrix4(this.m_viewProjectionMatrix);
    const size = tileBounds.getSize(tmpVectors3[1]);
    const objectSize = 0.5 * size.length() / projectedPoint.w;
    return {
      area: objectSize * objectSize,
      distance: projectedPoint.z <= -projectedPoint.w ? -1 : projectedPoint.z >= projectedPoint.w ? 1 : projectedPoint.z / projectedPoint.w
    };
  }
  computeRequiredInitialRootTileKeys(worldCenter) {
    this.m_rootTileKeys = [];
    const rootTileKey = TileKey.fromRowColumnLevel(0, 0, 0);
    const tileWrappingEnabled = this.mapView.projection.type === 0 /* Planar */;
    if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {
      this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0));
      return;
    }
    const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);
    const startOffset = Math.round(worldGeoPoint.longitude / 360);
    const camera = this.m_camera;
    const cameraPitch = MapViewUtils.extractAttitude(this.mapView, camera).pitch;
    const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
    const totalAngleRad = THREE56.MathUtils.degToRad(camera.fov * aspect / 2) + cameraPitch;
    const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;
    const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;
    const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;
    const worldLeftPoint = new THREE56.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);
    const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);
    const offsetRange = THREE56.MathUtils.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, 7);
    for (let offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++) {
      this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset));
    }
  }
};

// src/mapview/geometry/TileGeometryManager.ts
var TileGeometryManager = class {
  constructor(mapView) {
    this.mapView = mapView;
  }
  get enabledGeometryKinds() {
    return this.enabledKinds;
  }
  set enabledGeometryKinds(kinds) {
    this.enabledKinds = kinds;
  }
  get disabledGeometryKinds() {
    return this.disabledKinds;
  }
  set disabledGeometryKinds(kinds) {
    this.disabledKinds = kinds;
  }
  get hiddenGeometryKinds() {
    return this.hiddenKinds;
  }
  set hiddenGeometryKinds(kinds) {
    this.hiddenKinds = kinds;
    this.incrementVisibilityCounter();
  }
  enableFilterByKind = true;
  get visibilityCounter() {
    return this.m_visibilityCounter;
  }
  enabledKinds = new GeometryKindSet();
  disabledKinds = new GeometryKindSet();
  hiddenKinds = new GeometryKindSet();
  m_tileUpdateCallback;
  m_visibilityCounter = 1;
  updateTiles(tiles) {
    let prio = 0;
    for (const tile of tiles) {
      const tilePriority = prio++;
      const updateDone = tile.updateGeometry(tilePriority, this.enableFilterByKind ? this.enabledGeometryKinds : void 0, this.enableFilterByKind ? this.disabledGeometryKinds : void 0);
      if (updateDone && this.m_tileUpdateCallback) {
        this.m_tileUpdateCallback(tile);
      }
    }
    if (this.updateTileObjectVisibility(tiles)) {
      this.mapView.update();
    }
  }
  clear() {
    this.enabledKinds.clear();
    this.disabledKinds.clear();
    this.hiddenKinds.clear();
  }
  enableKind(kind, addOrRemoveToEnabledSet = true) {
    this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);
  }
  disableKind(kind, addOrRemoveToDisabledSet = true) {
    this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);
  }
  hideKind(kind, addOrRemoveToHiddenSet = true) {
    let visibilityHasChanged = false;
    if (Array.isArray(kind) || kind instanceof Set) {
      for (const oneKind of kind) {
        const visibilityChange = this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);
        visibilityHasChanged = visibilityHasChanged || visibilityChange;
      }
    } else {
      visibilityHasChanged = this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);
    }
    if (visibilityHasChanged) {
      this.incrementVisibilityCounter();
    }
  }
  getAvailableKinds(tiles) {
    const visibleKinds = new GeometryKindSet();
    for (const tile of tiles) {
      const tileKinds = tile.loadedGeometryKinds;
      if (tileKinds !== void 0) {
        for (const kind of tileKinds) {
          visibleKinds.add(kind);
        }
      }
    }
    return visibleKinds;
  }
  updateTileObjectVisibility(tiles) {
    let needUpdate = false;
    for (const tile of tiles) {
      if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {
        continue;
      }
      tile.visibilityCounter = this.visibilityCounter;
      for (const object of tile.objects) {
        const objectAdapter = MapObjectAdapter.get(object);
        const geometryKind = objectAdapter == null ? void 0 : objectAdapter.kind;
        if (geometryKind !== void 0) {
          const nowVisible = !geometryKind.some((kind) => this.hiddenKinds.has(kind));
          needUpdate = needUpdate || object.visible !== nowVisible;
          object.visible = nowVisible;
        }
      }
    }
    return needUpdate;
  }
  setTileUpdateCallback(callback) {
    this.m_tileUpdateCallback = callback;
  }
  incrementVisibilityCounter() {
    return ++this.m_visibilityCounter;
  }
  enableDisableKinds(set, kind, addToSet) {
    if (Array.isArray(kind)) {
      for (const oneKind of kind) {
        this.addRemove(set, oneKind, addToSet);
      }
    } else if (kind instanceof Set) {
      const kindSet = kind;
      for (const oneKind of kindSet) {
        this.addRemove(set, oneKind, addToSet);
      }
    } else if (kind !== void 0) {
      this.addRemove(set, kind, addToSet);
    }
  }
  addRemove(kindsSet, kind, addToSet) {
    if (addToSet) {
      if (!kindsSet.has(kind)) {
        kindsSet.add(kind);
        return true;
      }
    } else {
      if (kindsSet.has(kind)) {
        kindsSet.delete(kind);
        return true;
      }
    }
    return false;
  }
};

// src/mapview/image/Image.ts
var THREE58 = __toESM(require("three"));

// src/mapview/image/MipMapGenerator.ts
var THREE57 = __toESM(require("three"));
var isNode = true;
var MipMapGenerator = class {
  static getPaddedSize(width, height) {
    return {
      width: THREE57.MathUtils.ceilPowerOfTwo(width),
      height: THREE57.MathUtils.ceilPowerOfTwo(height)
    };
  }
  m_paddingCanvas;
  m_paddingContext;
  m_resizeCanvas;
  m_resizeContext;
  constructor() {
    if (!isNode) {
      this.m_paddingCanvas = document.createElement("canvas");
      this.m_paddingContext = this.m_paddingCanvas.getContext("2d");
      this.m_resizeCanvas = document.createElement("canvas");
      this.m_resizeContext = this.m_resizeCanvas.getContext("2d");
    }
  }
  generateTextureAtlasMipMap(image) {
    if (isNode) {
      throw new Error("MipMapGenerator only works in browser.");
    }
    if (image.image === void 0) {
      throw new Error("Can not generate mip maps. Image data not loaded!");
    }
    const imageData = image.image;
    const mipMaps = [];
    const { width: paddedWidth, height: paddedHeight } = MipMapGenerator.getPaddedSize(imageData.width, imageData.height);
    this.copyImageWithPadding(imageData, paddedWidth, paddedHeight);
    mipMaps.push(this.m_paddingContext.getImageData(0, 0, paddedWidth, paddedHeight));
    let width = paddedWidth * 0.5;
    let height = paddedHeight * 0.5;
    while (width >= 1 || height >= 1) {
      const mipMapLevel = mipMaps.length;
      const previousImage = mipMaps[mipMapLevel - 1];
      mipMaps.push(this.resizeImage(previousImage, Math.max(width, 1), Math.max(height, 1)));
      width *= 0.5;
      height *= 0.5;
    }
    return mipMaps;
  }
  copyImageWithPadding(image, width, height) {
    this.m_paddingCanvas.width = width;
    this.m_paddingCanvas.height = height;
    this.m_paddingContext.clearRect(0, 0, width, height);
    if (image instanceof ImageData) {
      this.m_paddingContext.putImageData(image, 0, 0);
    } else {
      this.m_paddingContext.drawImage(image, 0, 0);
    }
    if (image.width !== width) {
      this.m_paddingContext.drawImage(this.m_paddingCanvas, image.width - 1, 0, 1, image.height, image.width, 0, width - image.width, image.height);
    }
    if (image.height !== height) {
      this.m_paddingContext.drawImage(this.m_paddingCanvas, 0, image.height - 1, width, 1, 0, image.height, width, height - image.height);
    }
    return this.m_paddingCanvas;
  }
  resizeImage(image, width, height) {
    const paddedImage = this.copyImageWithPadding(image, image.width, image.height);
    this.m_resizeCanvas.width = width;
    this.m_resizeCanvas.height = height;
    this.m_resizeContext.clearRect(0, 0, width, height);
    this.m_resizeContext.drawImage(paddedImage, 0, 0, width, height);
    return this.m_resizeContext.getImageData(0, 0, width, height);
  }
};

// src/mapview/image/Image.ts
var logger8 = LoggerManager.instance.create("loadImage");
var mipMapGenerator = new MipMapGenerator();
var ImageItem = class {
  constructor(url, image) {
    this.url = url;
    this.image = image;
  }
  mipMaps;
  cancelled;
  loadingPromise;
  get loaded() {
    return this.image !== void 0 && this.mipMaps !== void 0;
  }
  get loading() {
    return this.loadingPromise !== void 0;
  }
  loadImage() {
    if (this.loaded) {
      return Promise.resolve(this);
    }
    if (this.loading) {
      return this.loadingPromise;
    }
    this.loadingPromise = new Promise((resolve, reject) => {
      if (this.image) {
        const image = this.image;
        if (image instanceof HTMLImageElement && !image.complete) {
          image.addEventListener("load", this.finalizeImage.bind(this, image, resolve));
          image.addEventListener("error", reject);
        } else {
          this.finalizeImage(this.image, resolve);
        }
        return;
      }
      logger8.debug(`Loading image: ${this.url}`);
      if (this.cancelled === true) {
        logger8.debug(`Cancelled loading image: ${this.url}`);
        resolve(void 0);
      } else {
        new THREE58.ImageLoader().load(this.url, (image) => {
          if (this.cancelled === true) {
            logger8.debug(`Cancelled loading image: ${this.url}`);
            resolve(void 0);
            return;
          }
          this.finalizeImage(image, resolve);
        }, void 0, (errorEvent) => {
          logger8.error(`... loading image failed: ${this.url} : ${errorEvent}`);
          this.loadingPromise = void 0;
          reject(`... loading image failed: ${this.url} : ${errorEvent}`);
        });
      }
    });
    return this.loadingPromise;
  }
  finalizeImage(image, resolve) {
    this.image = image;
    this.mipMaps = mipMapGenerator.generateTextureAtlasMipMap(this);
    this.loadingPromise = void 0;
    resolve(this);
  }
};

// src/mapview/image/ImageCache.ts
var _ImageCache = class {
  static get instance() {
    if (_ImageCache.m_instance === void 0) {
      _ImageCache.m_instance = new _ImageCache();
    }
    return _ImageCache.m_instance;
  }
  static dispose() {
    _ImageCache.m_instance = void 0;
  }
  m_images = /* @__PURE__ */ new Map();
  registerImage(owner, url, image) {
    let imageCacheItem = this.findImageCacheItem(url);
    if (imageCacheItem) {
      if (owner !== void 0 && !imageCacheItem.owners.includes(owner)) {
        imageCacheItem.owners.push(owner);
      }
      return imageCacheItem.imageItem;
    }
    imageCacheItem = {
      imageItem: new ImageItem(url, image),
      owners: [owner]
    };
    this.m_images.set(url, imageCacheItem);
    return imageCacheItem.imageItem;
  }
  removeImage(url, owner) {
    const cacheItem = this.m_images.get(url);
    if (cacheItem !== void 0) {
      this.unlinkCacheItem(cacheItem, owner);
      return true;
    }
    return false;
  }
  findImage(url) {
    const cacheItem = this.m_images.get(url);
    if (cacheItem !== void 0) {
      return cacheItem.imageItem;
    }
    return void 0;
  }
  clear(owner) {
    this.m_images.forEach((cacheItem) => {
      this.unlinkCacheItem(cacheItem, owner);
    });
  }
  get size() {
    return this.m_images.size;
  }
  findImageCacheItem(url) {
    return this.m_images.get(url);
  }
  cancelLoading(imageItem) {
    if (imageItem.loading) {
      imageItem.cancelled = true;
    }
  }
  unlinkCacheItem(cacheItem, owner) {
    const ownerIndex = cacheItem.owners.indexOf(owner);
    if (ownerIndex >= 0) {
      cacheItem.owners.splice(ownerIndex, 1);
    }
    if (cacheItem.owners.length === 0) {
      this.m_images.delete(cacheItem.imageItem.url);
      this.cancelLoading(cacheItem.imageItem);
    }
  }
};
var ImageCache = _ImageCache;
__publicField(ImageCache, "m_instance");

// src/mapview/image/MapViewImageCache.ts
var MapViewImageCache = class {
  m_name2Url = /* @__PURE__ */ new Map();
  m_urlNameCount = /* @__PURE__ */ new Map();
  addImage(name2, urlOrImage, startLoading = true) {
    if (typeof urlOrImage === "string") {
      const url = urlOrImage;
      const imageItem = this.registerImage(name2, url);
      return startLoading ? imageItem.loadImage() : imageItem;
    }
    const image = urlOrImage;
    return this.registerImage(name2, void 0, image);
  }
  removeImage(name2) {
    const url = this.m_name2Url.get(name2);
    if (url !== void 0) {
      this.m_name2Url.delete(name2);
      let nameCount = 1;
      if (name2 !== url) {
        const result = this.m_urlNameCount.get(url);
        assert(result !== void 0);
        nameCount = result;
        assert(nameCount > 0);
      }
      if (nameCount > 1) {
        this.m_urlNameCount.set(url, nameCount - 1);
      } else {
        this.m_urlNameCount.delete(url);
        ImageCache.instance.removeImage(url, this);
      }
      return true;
    }
    return false;
  }
  findImageByName(name2) {
    const url = this.m_name2Url.get(name2);
    if (url === void 0) {
      return void 0;
    }
    return ImageCache.instance.findImage(url);
  }
  clear() {
    ImageCache.instance.clear(this);
    this.m_name2Url.clear();
    this.m_urlNameCount.clear();
  }
  registerImage(name2, url, image) {
    if (this.hasName(name2)) {
      throw new Error("duplicate name in cache");
    }
    if (url === void 0) {
      assert(image !== void 0);
      url = name2;
    }
    if (url !== name2) {
      const nameCount = this.m_urlNameCount.get(url) ?? 0;
      this.m_urlNameCount.set(url, nameCount + 1);
    }
    this.m_name2Url.set(name2, url);
    return ImageCache.instance.registerImage(this, url, image);
  }
  hasName(name2) {
    return this.m_name2Url.get(name2) !== void 0;
  }
};

// src/mapview/MapAnchors.ts
var THREE59 = __toESM(require("three"));
var MapAnchors = class {
  m_anchors = [];
  m_priorities = [];
  get children() {
    return this.m_anchors;
  }
  add(mapAnchor) {
    this.m_anchors.push(mapAnchor);
  }
  remove(mapAnchor) {
    const index = this.m_anchors.findIndex((element) => element === mapAnchor);
    if (index > -1) {
      this.m_anchors.splice(index, 1);
    }
  }
  clear() {
    this.m_anchors.length = 0;
  }
  setPriorities(priorities) {
    this.m_priorities = priorities;
  }
  update(projection, cameraPosition, rootNode, overlayRootNode) {
    const worldPosition = new THREE59.Vector3();
    this.m_anchors.forEach((mapAnchor) => {
      var _a;
      if (mapAnchor.styleSet !== void 0) {
        const priority = (_a = this.m_priorities) == null ? void 0 : _a.findIndex((entry) => entry.group === mapAnchor.styleSet && entry.category === mapAnchor.category);
        if (priority !== void 0 && priority !== -1) {
          mapAnchor.renderOrder = (priority + 1) * 10;
        }
      }
      const anchor = mapAnchor.geoPosition !== void 0 ? mapAnchor.geoPosition : mapAnchor.anchor;
      if (anchor !== void 0) {
        if (isVector3Like(anchor)) {
          worldPosition.set(anchor.x, anchor.y, anchor.z);
        } else if (isGeoCoordinatesLike(anchor)) {
          projection.projectPoint(anchor, worldPosition);
        }
        mapAnchor.position.copy(worldPosition).sub(cameraPosition);
      }
      if (mapAnchor.overlay === true) {
        overlayRootNode.add(mapAnchor);
      } else {
        rootNode.add(mapAnchor);
      }
    });
  }
};

// src/mapview/MapViewEnvironment.ts
var THREE61 = __toESM(require("three"));

// src/mapview/MapViewFog.ts
var THREE60 = __toESM(require("three"));
var MapViewFog = class {
  constructor(m_scene) {
    this.m_scene = m_scene;
  }
  m_enabled = true;
  m_fog = new THREE60.Fog(0);
  m_fogIsDefined = false;
  m_cachedFog;
  set enabled(enableFog) {
    this.m_enabled = enableFog;
    if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {
      this.add();
    } else if (!enableFog && this.m_scene.fog !== null) {
      this.remove();
    }
  }
  get enabled() {
    return this.m_enabled;
  }
  reset(fog) {
    this.m_cachedFog = fog;
    if (fog !== void 0 && fog.color !== void 0 && fog.startRatio !== void 0) {
      this.m_fogIsDefined = true;
      this.m_fog.color.set(fog.color);
      if (this.m_enabled && this.m_scene.fog === null) {
        this.add();
      }
    } else {
      this.m_fogIsDefined = false;
      if (this.m_scene.fog !== null) {
        this.remove();
      }
    }
  }
  update(mapView, viewDistance) {
    if (this.m_scene.fog !== null && this.m_cachedFog !== void 0 && this.m_cachedFog && this.m_cachedFog.startRatio !== void 0 && (mapView.camera.far !== void 0 || viewDistance !== void 0)) {
      const viewRange = viewDistance !== void 0 ? viewDistance : mapView.camera.far;
      const horizontalDensity = 1;
      const verticalDensity = 0;
      const startRatio = this.m_cachedFog.startRatio;
      const endRatio = 1;
      assert(startRatio <= endRatio);
      const t = Math.abs(Math.cos(mapView.tilt));
      const density = MathUtils6.smoothStep(horizontalDensity, verticalDensity, t);
      this.m_fog.near = THREE60.MathUtils.lerp(viewRange * startRatio, viewRange, 1 - density);
      this.m_fog.far = THREE60.MathUtils.lerp(viewRange * endRatio, viewRange, density);
      this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);
      this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);
    }
  }
  add() {
    this.m_scene.fog = this.m_fog;
    this.setFogInRawShaderMaterials(true);
  }
  remove() {
    this.m_scene.fog = null;
    this.setFogInRawShaderMaterials(false);
  }
  setFogInRawShaderMaterials(enableFog) {
    this.m_scene.traverse((object) => {
      if (object instanceof THREE60.Mesh) {
        const material = object.material;
        if (material instanceof THREE60.Material && !(material instanceof HighPrecisionLineMaterial) && material.fog !== enableFog) {
          material.fog = enableFog;
          if (material instanceof RawShaderMaterial2) {
            material.invalidateFog();
          }
        }
      }
    });
  }
};

// src/mapview/SkyCubemapTexture.ts
var import_three12 = require("three");
var logger9 = LoggerManager.instance.create("SkyCubemapTexture");
var SKY_CUBEMAP_FACE_COUNT = 6;
var SkyCubemapFaceId = /* @__PURE__ */ ((SkyCubemapFaceId2) => {
  SkyCubemapFaceId2[SkyCubemapFaceId2["positiveX"] = 0] = "positiveX";
  SkyCubemapFaceId2[SkyCubemapFaceId2["negativeX"] = 1] = "negativeX";
  SkyCubemapFaceId2[SkyCubemapFaceId2["positiveY"] = 2] = "positiveY";
  SkyCubemapFaceId2[SkyCubemapFaceId2["negativeY"] = 3] = "negativeY";
  SkyCubemapFaceId2[SkyCubemapFaceId2["positiveZ"] = 4] = "positiveZ";
  SkyCubemapFaceId2[SkyCubemapFaceId2["negativeZ"] = 5] = "negativeZ";
  return SkyCubemapFaceId2;
})(SkyCubemapFaceId || {});
var SkyCubemapTexture = class {
  m_skybox;
  constructor(sky) {
    const faces = this.createCubemapFaceArray(sky);
    this.m_skybox = faces !== void 0 ? new import_three12.CubeTextureLoader().load(faces) : new import_three12.CubeTexture();
  }
  dispose() {
    this.m_skybox.dispose();
  }
  get texture() {
    return this.m_skybox;
  }
  updateTexture(sky) {
    const faces = this.createCubemapFaceArray(sky);
    if (faces === void 0) {
      return;
    }
    this.m_skybox = new import_three12.CubeTextureLoader().load(faces);
  }
  createCubemapFaceArray(sky) {
    const faces = [
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0
    ];
    for (let i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i) {
      const face = sky[SkyCubemapFaceId[i]];
      if (face === void 0) {
        logger9.error(`Face "${SkyCubemapFaceId[i]}" was not defined.`);
        return;
      }
      faces[i] = face;
    }
    return faces;
  }
};

// src/mapview/SkyGradientTexture.ts
var import_three13 = require("three");
var DEFAULT_TEXTURE_SIZE = 512;
var DEFAULT_MONOMIAL_POWER = 1;
var cameraDir = [
  new import_three13.Vector3(1, 0, 0),
  new import_three13.Vector3(-1, 0, 0),
  new import_three13.Vector3(0, -1, 0),
  new import_three13.Vector3(0, 1, 0),
  new import_three13.Vector3(0, 0, 1),
  new import_three13.Vector3(0, 0, -1)
];
var cameraRight = [
  new import_three13.Vector3(0, 0, -1),
  new import_three13.Vector3(0, 0, 1),
  new import_three13.Vector3(1, 0, 0),
  new import_three13.Vector3(1, 0, 0),
  new import_three13.Vector3(1, 0, 0),
  new import_three13.Vector3(-1, 0, 0)
];
var cameraUp = [
  new import_three13.Vector3(0, 1, 0),
  new import_three13.Vector3(0, 1, 0),
  new import_three13.Vector3(0, 0, 1),
  new import_three13.Vector3(0, 0, -1),
  new import_three13.Vector3(0, 1, 0),
  new import_three13.Vector3(0, 1, 0)
];
var SkyGradientTexture = class {
  constructor(sky, m_projectionType, m_height = DEFAULT_TEXTURE_SIZE) {
    this.m_projectionType = m_projectionType;
    this.m_height = m_height;
    const topColor = new import_three13.Color(sky.topColor);
    const bottomColor = new import_three13.Color(sky.bottomColor);
    const groundColor = new import_three13.Color(sky.groundColor);
    this.m_width = this.m_projectionType === 0 /* Planar */ ? 1 : this.m_height;
    this.m_faceCount = this.m_projectionType === 0 /* Planar */ ? 1 : 6;
    this.m_faces = [];
    for (let i = 0; i < this.m_faceCount; ++i) {
      const data2 = new Uint8Array(3 * this.m_width * this.m_height);
      this.fillTextureData(data2, i, topColor, bottomColor, groundColor, sky.monomialPower);
      const texture = new import_three13.DataTexture(data2, this.m_width, this.m_height, import_three13.RGBFormat);
      texture.needsUpdate = true;
      texture.unpackAlignment = 1;
      this.m_faces.push(texture);
    }
    if (this.m_projectionType === 1 /* Spherical */) {
      this.m_skybox = new import_three13.CubeTexture(this.m_faces);
      this.m_skybox.needsUpdate = true;
    } else {
      this.m_farClipPlaneDividedVertically = new import_three13.Line3();
      this.m_groundPlane = new import_three13.Plane(new import_three13.Vector3(0, 0, 1));
      this.m_bottomMidFarPoint = new import_three13.Vector3();
      this.m_topMidFarPoint = new import_three13.Vector3();
      this.m_horizonPosition = new import_three13.Vector3();
      this.m_farClipPlaneCorners = [new import_three13.Vector3(), new import_three13.Vector3(), new import_three13.Vector3(), new import_three13.Vector3()];
    }
  }
  m_width;
  m_faceCount;
  m_faces;
  m_skybox;
  m_farClipPlaneDividedVertically;
  m_groundPlane;
  m_bottomMidFarPoint;
  m_topMidFarPoint;
  m_horizonPosition;
  m_farClipPlaneCorners;
  dispose() {
    for (let i = 0; i < this.m_faceCount; ++i) {
      this.m_faces[i].dispose();
    }
    if (this.m_projectionType === 1 /* Spherical */) {
      this.m_skybox.dispose();
    }
  }
  get texture() {
    return this.m_projectionType === 0 /* Planar */ ? this.m_faces[0] : this.m_skybox;
  }
  update(camera) {
    if (this.m_projectionType === 0 /* Planar */) {
      this.setHorizonPosition(camera);
      this.updateTexturePosition();
    }
  }
  updateTexture(sky) {
    for (let i = 0; i < this.m_faceCount; ++i) {
      this.fillTextureData(this.m_faces[i].image.data, i, new import_three13.Color(sky.topColor), new import_three13.Color(sky.bottomColor), new import_three13.Color(sky.groundColor), sky.monomialPower);
      this.m_faces[i].needsUpdate = true;
    }
    if (this.m_projectionType === 1 /* Spherical */) {
      this.m_skybox.needsUpdate = true;
    }
  }
  fillTextureData(data2, faceIdx, topColor, bottomColor, groundColor, monomialPower) {
    const color = new import_three13.Color();
    const dir = new import_three13.Vector3();
    const right = new import_three13.Vector3();
    const up = new import_three13.Vector3();
    const upDir = new import_three13.Vector3(0, 0, 1);
    for (let i = 0; i < this.m_height; ++i) {
      for (let j = 0; j < this.m_width; ++j) {
        if (this.m_projectionType === 1 /* Spherical */) {
          const offsetX = right.copy(cameraRight[faceIdx]).multiplyScalar((j + 0.5) / this.m_width * 2 - 1);
          const offsetY = up.copy(cameraUp[faceIdx]).multiplyScalar((i + 0.5) / this.m_height * 2 - 1);
          dir.copy(cameraDir[faceIdx]).add(offsetX).add(offsetY).normalize();
          const t = Math.max(upDir.dot(dir), 0);
          color.copy(groundColor).lerp(bottomColor, Math.min(t * 100, 1)).lerp(topColor, t ** getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER)).multiplyScalar(255);
        } else {
          const t = i / this.m_height;
          if (i === 0) {
            color.copy(groundColor).multiplyScalar(255);
          } else {
            color.copy(bottomColor).lerp(topColor, t ** getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER)).multiplyScalar(255);
          }
        }
        data2[i * this.m_width * 3 + j * 3] = color.r;
        data2[i * this.m_width * 3 + j * 3 + 1] = color.g;
        data2[i * this.m_width * 3 + j * 3 + 2] = color.b;
      }
    }
  }
  setHorizonPosition(camera) {
    this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);
    this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);
    this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);
    this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);
    this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0]).add(this.m_farClipPlaneCorners[1]).multiplyScalar(0.5);
    this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2]).add(this.m_farClipPlaneCorners[3]).multiplyScalar(0.5);
    this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);
    const hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);
    if (!hasIntersection) {
      this.m_horizonPosition.set(0, 0, 0);
    }
  }
  updateTexturePosition() {
    const coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);
    const frustumHeight = this.m_farClipPlaneDividedVertically.distance();
    const skyRatio = coveredBySky / frustumHeight;
    const ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;
    this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);
  }
};

// src/mapview/SkyBackground.ts
var SkyBackground = class {
  constructor(m_sky, m_projectionType, camera) {
    this.m_sky = m_sky;
    this.m_projectionType = m_projectionType;
    switch (this.m_sky.type) {
      case "gradient":
        this.m_skyTexture = new SkyGradientTexture(this.m_sky, this.m_projectionType);
        this.updateCamera(camera);
        break;
      case "cubemap": {
        this.m_skyTexture = new SkyCubemapTexture(this.m_sky);
        break;
      }
    }
  }
  m_skyTexture;
  dispose() {
    this.m_skyTexture.dispose();
  }
  get texture() {
    return this.m_skyTexture.texture;
  }
  updateCamera(camera) {
    if (this.m_sky.type === "gradient") {
      ;
      this.m_skyTexture.update(camera);
    }
  }
  updateTexture(params, projectionType) {
    const isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;
    switch (params.type) {
      case "gradient":
        if (isSameSkyType) {
          ;
          this.m_skyTexture.updateTexture(params);
        } else {
          this.m_skyTexture = new SkyGradientTexture(params, projectionType);
        }
        break;
      case "cubemap": {
        if (isSameSkyType) {
          ;
          this.m_skyTexture.updateTexture(params);
        } else {
          this.m_skyTexture = new SkyCubemapTexture(params);
        }
        break;
      }
    }
    this.m_projectionType = projectionType;
    this.m_sky = params;
  }
};

// src/mapview/MapViewEnvironment.ts
var logger10 = LoggerManager.instance.create("MapViewEnvironment");
var DEFAULT_CLEAR_COLOR = 16777215;
var cache = {
  vector3: [new THREE61.Vector3(), new THREE61.Vector3(), new THREE61.Vector3()],
  frustumPoints: [
    new THREE61.Vector3(),
    new THREE61.Vector3(),
    new THREE61.Vector3(),
    new THREE61.Vector3(),
    new THREE61.Vector3(),
    new THREE61.Vector3(),
    new THREE61.Vector3(),
    new THREE61.Vector3()
  ]
};
var MapViewEnvironment = class {
  constructor(m_mapView, options) {
    this.m_mapView = m_mapView;
    this.m_fog = new MapViewFog(this.m_mapView.scene);
    if (options.addBackgroundDatasource !== false) {
      this.m_backgroundDataSource = new BackgroundDataSource();
      this.m_mapView.addDataSource(this.m_backgroundDataSource);
    }
    if (options.backgroundTilingScheme !== void 0 && this.m_backgroundDataSource !== void 0) {
      this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);
    }
    this.updateClearColor();
  }
  m_fog;
  m_skyBackground;
  m_createdLights;
  m_overlayCreatedLights;
  m_backgroundDataSource;
  get lights() {
    return this.m_createdLights ?? [];
  }
  get fog() {
    return this.m_fog;
  }
  updateBackgroundDataSource() {
    if (this.m_backgroundDataSource) {
      this.m_backgroundDataSource.updateStorageLevelOffset();
    }
  }
  clearBackgroundDataSource() {
    if (this.m_backgroundDataSource !== void 0) {
      this.m_mapView.clearTileCache(this.m_backgroundDataSource.name);
    }
  }
  update() {
    this.m_fog.update(this.m_mapView, this.m_mapView.viewRanges.maximum);
    if (this.m_skyBackground !== void 0 && this.m_mapView.projection.type === 0 /* Planar */) {
      this.m_skyBackground.updateCamera(this.m_mapView.camera);
    }
    this.updateLights();
  }
  updateClearColor(clearColor, clearAlpha) {
    if (clearColor !== void 0) {
      this.m_mapView.renderer.setClearColor(new THREE61.Color(clearColor), clearAlpha);
    } else {
      this.m_mapView.renderer.setClearColor(DEFAULT_CLEAR_COLOR, clearAlpha);
    }
  }
  updateSkyBackground(sky, clearColor) {
    if (this.m_skyBackground instanceof SkyBackground && sky !== void 0) {
      this.updateSkyBackgroundColors(sky, clearColor);
    } else if (this.m_skyBackground === void 0 && sky !== void 0) {
      this.addNewSkyBackground(sky, clearColor);
      return;
    } else if (this.m_skyBackground instanceof SkyBackground && sky === void 0) {
      this.removeSkyBackGround();
    }
  }
  updateLighting(lights) {
    var _a;
    if (this.m_createdLights) {
      this.m_createdLights.forEach((light) => {
        this.m_mapView.scene.remove(light);
      });
    }
    (_a = this.m_overlayCreatedLights) == null ? void 0 : _a.forEach((light) => {
      this.m_mapView.overlayScene.remove(light);
      if (light instanceof THREE61.DirectionalLight) {
        this.m_mapView.overlayScene.remove(light.target);
      }
    });
    if (lights !== void 0) {
      this.m_createdLights = [];
      this.m_overlayCreatedLights = [];
      lights.forEach((lightDescription) => {
        const light = createLight(lightDescription);
        if (!light) {
          logger10.warn(`MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);
          return;
        }
        this.m_mapView.scene.add(light);
        if (light.isDirectionalLight) {
          const directionalLight = light;
          this.m_mapView.scene.add(directionalLight.target);
        }
        this.m_createdLights.push(light);
        const clonedLight = light.clone();
        this.m_mapView.overlayScene.add(clonedLight);
        if (clonedLight instanceof THREE61.DirectionalLight) {
          this.m_mapView.overlayScene.add(clonedLight.target.clone());
        }
      });
    }
  }
  updateLights() {
    if (!this.m_mapView.shadowsEnabled || this.m_mapView.projection.type === 1 /* Spherical */ || this.m_createdLights === void 0 || this.m_createdLights.length === 0) {
      return;
    }
    const points = [
      { x: -1, y: -1, z: -1 },
      { x: 1, y: -1, z: -1 },
      { x: -1, y: 1, z: -1 },
      { x: 1, y: 1, z: -1 },
      { x: -1, y: -1, z: 1 },
      { x: 1, y: -1, z: 1 },
      { x: -1, y: 1, z: 1 },
      { x: 1, y: 1, z: 1 }
    ];
    const transformedPoints = points.map((p, i) => this.m_mapView.ndcToView(p, cache.frustumPoints[i]));
    this.m_createdLights.forEach((element) => {
      const directionalLight = element;
      if (directionalLight.isDirectionalLight === true) {
        const lightDirection = cache.vector3[0];
        lightDirection.copy(directionalLight.target.position);
        lightDirection.sub(directionalLight.position);
        lightDirection.normalize();
        const normal = cache.vector3[1];
        if (this.m_mapView.projection.type === 0 /* Planar */) {
          normal.set(0, 0, -1);
        } else {
        }
        const tilt = this.m_mapView.tilt;
        const cameraHeight = this.m_mapView.targetDistance * Math.cos(THREE61.MathUtils.degToRad(tilt));
        const lightPosHyp = cameraHeight / normal.dot(lightDirection);
        directionalLight.target.position.copy(this.m_mapView.worldTarget).sub(this.m_mapView.camera.position);
        directionalLight.position.copy(this.m_mapView.worldTarget);
        directionalLight.position.addScaledVector(lightDirection, -lightPosHyp);
        directionalLight.position.sub(this.m_mapView.camera.position);
        directionalLight.updateMatrixWorld();
        directionalLight.shadow.updateMatrices(directionalLight);
        const camera = directionalLight.shadow.camera;
        const pointsInLightSpace = transformedPoints.map((p) => this.viewToLightSpace(p.clone(), camera));
        const box = new THREE61.Box3();
        pointsInLightSpace.forEach((point) => {
          box.expandByPoint(point);
        });
        camera.left = box.min.x;
        camera.right = box.max.x;
        camera.top = box.max.y;
        camera.bottom = box.min.y;
        camera.near = -box.max.z * 0.95;
        camera.far = -box.min.z;
        camera.updateProjectionMatrix();
      }
    });
  }
  addNewSkyBackground(sky, clearColor) {
    if (sky.type === "gradient" && sky.groundColor === void 0) {
      sky.groundColor = getOptionValue(clearColor, "#000000");
    }
    this.m_skyBackground = new SkyBackground(sky, this.m_mapView.projection.type, this.m_mapView.camera);
    this.m_mapView.scene.background = this.m_skyBackground.texture;
  }
  removeSkyBackGround() {
    this.m_mapView.scene.background = null;
    if (this.m_skyBackground !== void 0) {
      this.m_skyBackground.dispose();
      this.m_skyBackground = void 0;
    }
  }
  updateSkyBackgroundColors(sky, clearColor) {
    var _a;
    if (sky.type === "gradient" && sky.groundColor === void 0) {
      sky.groundColor = getOptionValue(clearColor, "#000000");
    }
    if (this.m_skyBackground !== void 0) {
      this.m_skyBackground.updateTexture(sky, this.m_mapView.projection.type);
      this.m_mapView.scene.background = (_a = this.m_skyBackground) == null ? void 0 : _a.texture;
    }
  }
  viewToLightSpace(viewPos, camera) {
    return viewPos.applyMatrix4(camera.matrixWorldInverse);
  }
};

// src/mapview/MapViewTaskScheduler.ts
var THREE62 = __toESM(require("three"));

// src/mapview/Statistics.ts
var logger11 = LoggerManager.instance.create("Statistics");
var RingBuffer = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.buffer = new Array(capacity);
    this.capacity = capacity;
    this.head = this.tail = this.size = 0;
  }
  buffer;
  size;
  head;
  tail;
  clear() {
    this.head = this.tail = this.size = 0;
  }
  enqOne(data2) {
    let next = this.head + 1;
    if (next >= this.capacity) {
      next = 0;
    }
    if (this.size < this.capacity) {
      this.size++;
    }
    this.buffer[this.head] = data2;
    this.head = next;
    if (this.size === this.capacity) {
      this.tail = this.head;
    }
  }
  enq(...data2) {
    for (const v of data2) {
      this.enqOne(v);
    }
  }
  deq() {
    if (this.size === 0) {
      throw new Error("Ringbuffer underrun");
    }
    const data2 = this.buffer[this.tail];
    let next = this.tail + 1;
    if (next >= this.capacity) {
      next = 0;
    }
    if (this.size > 0) {
      this.size--;
    }
    this.tail = next;
    return data2;
  }
  get top() {
    if (this.size === 0) {
      throw new Error("Ringbuffer underrun");
    }
    return this.buffer[this.tail];
  }
  get bottom() {
    if (this.size === 0) {
      throw new Error("Ringbuffer underrun");
    }
    let previous = this.head - 1;
    if (previous < 0) {
      previous = this.capacity - 1;
    }
    return this.buffer[previous];
  }
  iterator() {
    return new RingBuffer.Iterator(this);
  }
  asArray() {
    const array = new Array();
    for (let i = 0; i < this.size; i++) {
      array.push(this.buffer[(this.tail + i) % this.capacity]);
    }
    return array;
  }
};
((RingBuffer2) => {
  class Iterator {
    constructor(m_buffer, m_index = 0) {
      this.m_buffer = m_buffer;
      this.m_index = m_index;
    }
    get value() {
      return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];
    }
    next() {
      this.m_index++;
      return this.m_index < this.m_buffer.size;
    }
  }
  RingBuffer2.Iterator = Iterator;
})(RingBuffer || (RingBuffer = {}));
var SimpleTimer = class {
  constructor(statistics, name2) {
    this.statistics = statistics;
    this.name = name2;
  }
  running = false;
  m_currentValue;
  get value() {
    return this.m_currentValue;
  }
  setValue(val) {
    this.m_currentValue = val;
  }
  reset() {
    this.m_currentValue = void 0;
  }
  start() {
    if (!this.statistics.enabled) {
      return -1;
    }
    if (this.running) {
      throw new Error("Timer '" + this.name + "' is already running");
    }
    this.running = true;
    return this.m_currentValue = PerformanceTimer.now();
  }
  stop() {
    if (!this.statistics.enabled) {
      return -1;
    }
    if (!this.running) {
      throw new Error("Timer '" + this.name + "' has not been started");
    } else {
      const t = PerformanceTimer.now() - (this.m_currentValue ?? 0);
      this.m_currentValue = t;
      this.setValue(t);
      this.running = false;
      return t;
    }
  }
  now() {
    if (!this.statistics.enabled) {
      return -1;
    }
    if (!this.running) {
      throw new Error("Timer '" + this.name + "' has not been started");
    } else {
      const t = PerformanceTimer.now() - (this.m_currentValue ?? 0);
      return t;
    }
  }
};
var SampledTimer = class extends SimpleTimer {
  constructor(statistics, name2) {
    super(statistics, name2);
    this.statistics = statistics;
    this.name = name2;
  }
  numResets = 0;
  maxNumSamples = 1e3;
  samples = new RingBuffer(this.maxNumSamples);
  reset() {
    super.reset();
    this.getStats();
    this.samples.clear();
    this.numResets++;
  }
  setValue(val) {
    super.setValue(val);
    if (val !== void 0) {
      this.samples.enqOne(val);
    }
  }
  getStats() {
    return computeArrayStats(this.samples.asArray());
  }
};
function computeArrayStats(samples) {
  if (samples.length === 0) {
    return void 0;
  }
  samples.sort((a, b) => {
    return a - b;
  });
  const min = samples[0];
  const max = samples[samples.length - 1];
  let median;
  let median75;
  let median90;
  let median95;
  let median97;
  let median99;
  let median999;
  if (samples.length === 1) {
    median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];
  } else if (samples.length === 2) {
    median = samples[0] * 0.5 + samples[1] * 0.5;
    median75 = median90 = median95 = median97 = median99 = median999 = samples[1];
  } else {
    const mid = Math.floor(samples.length / 2);
    median = samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];
    const mid75 = Math.round(samples.length * 0.75) - 1;
    median75 = samples[mid75];
    const mid90 = Math.round(samples.length * 0.9) - 1;
    median90 = samples[mid90];
    const mid95 = Math.round(samples.length * 0.95) - 1;
    median95 = samples[mid95];
    const mid97 = Math.round(samples.length * 0.97) - 1;
    median97 = samples[mid97];
    const mid99 = Math.round(samples.length * 0.99) - 1;
    median99 = samples[mid99];
    const mid999 = Math.round(samples.length * 0.999) - 1;
    median999 = samples[mid999];
  }
  let sum = 0;
  for (let i = 0, l = samples.length; i < l; i++) {
    sum += samples[i];
  }
  const avg = sum / samples.length;
  return {
    min,
    max,
    avg,
    median,
    median75,
    median90,
    median95,
    median97,
    median99,
    median999,
    numSamples: samples.length
  };
}
function computeArrayAverage(samples) {
  if (samples.length === 0) {
    return void 0;
  }
  let sum = 0;
  for (let i = 0, l = samples.length; i < l; i++) {
    sum += samples[i];
  }
  const avg = sum / samples.length;
  return avg;
}
var MultiStageTimer = class {
  constructor(statistics, name2, stages) {
    this.statistics = statistics;
    this.name = name2;
    this.stages = stages;
    if (stages.length < 1) {
      throw new Error("MultiStageTimer needs stages");
    }
    stages.forEach((stage) => {
      if (!statistics.hasTimer(stage)) {
        throw new Error("Unknown timer: " + stage);
      }
    });
  }
  currentStage;
  get value() {
    return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;
  }
  reset() {
    if (!this.statistics.enabled) {
      return;
    }
    this.stages.forEach((stage) => {
      this.statistics.getTimer(stage).reset();
    });
  }
  start() {
    this.stage = this.stages[0];
    return this.statistics.getTimer(this.stages[0]).value ?? -1;
  }
  stop() {
    this.stage = void 0;
    return this.value !== void 0 ? this.value : -1;
  }
  get stage() {
    return this.currentStage;
  }
  set stage(stage) {
    if (this.currentStage === stage) {
      return;
    }
    if (this.statistics.enabled && this.currentStage !== void 0) {
      this.statistics.getTimer(this.currentStage).stop();
    }
    this.currentStage = stage;
    if (this.statistics.enabled && this.currentStage !== void 0) {
      this.statistics.getTimer(this.currentStage).start();
    }
  }
};
var Statistics = class {
  constructor(name2, enabled = false) {
    this.name = name2;
    this.enabled = enabled;
    this.timers = /* @__PURE__ */ new Map();
    this.nullTimer = new SimpleTimer(this, "<null>");
  }
  timers;
  nullTimer;
  createTimer(name2, keepSamples = true) {
    const timer = keepSamples ? new SampledTimer(this, name2) : new SimpleTimer(this, name2);
    return this.addTimer(timer);
  }
  addTimer(timer) {
    if (this.timers.get(timer.name) !== void 0) {
      throw new Error("Duplicate timer name: '" + timer.name + "'");
    }
    this.timers.set(timer.name, timer);
    return timer;
  }
  getTimer(name2) {
    if (!this.enabled) {
      return this.nullTimer;
    }
    const t = this.timers.get(name2);
    return t === void 0 ? this.nullTimer : t;
  }
  hasTimer(name2) {
    const t = this.timers.get(name2);
    return t !== void 0;
  }
  reset() {
    this.timers.forEach((timer) => {
      timer.reset();
    });
  }
  log(header, footer) {
    if (header !== void 0 || this.name !== void 0) {
      logger11.log(header !== void 0 ? header : this.name);
    }
    let maxNameLength = 0;
    this.timers.forEach((timer) => {
      maxNameLength = Math.max(maxNameLength, timer.name.length);
    });
    const print = (v) => {
      return v !== void 0 ? v.toFixed(5) : "?";
    };
    this.timers.forEach((timer) => {
      let s = timer.name + ": " + " ".repeat(maxNameLength - timer.name.length);
      s += print(timer.value);
      if (timer instanceof SampledTimer) {
        const simpleStats = timer.getStats();
        if (simpleStats !== void 0) {
          s += `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, N=${print(simpleStats.numSamples)} ]`;
        }
      }
      logger11.log(s);
    });
    if (footer !== void 0) {
      logger11.log(footer);
    }
  }
};
var FrameStats = class {
  entries = /* @__PURE__ */ new Map();
  messages = void 0;
  getValue(name2) {
    return this.entries.get(name2);
  }
  setValue(name2, value2) {
    this.entries.set(name2, value2);
  }
  addValue(name2, value2) {
    const oldValue = this.entries.get(name2);
    this.entries.set(name2, value2 + (oldValue === void 0 ? 0 : oldValue));
  }
  addMessage(message) {
    if (this.messages === void 0) {
      this.messages = [];
    }
    this.messages.push(message);
  }
  reset() {
    this.entries.forEach((value2, name2) => {
      this.entries.set(name2, 0);
    });
    this.messages = void 0;
  }
};
var FrameStatsArray = class {
  constructor(capacity = 0) {
    this.capacity = capacity;
    this.messages = new RingBuffer(capacity);
  }
  frameEntries = /* @__PURE__ */ new Map();
  messages;
  get length() {
    return this.messages.size;
  }
  reset() {
    this.frameEntries.forEach((buffer, name2) => {
      buffer.clear();
    });
    this.messages.clear();
  }
  addFrame(frameStats) {
    const currentSize = this.length;
    const frameEntries = this.frameEntries;
    frameStats.entries.forEach((value2, name2) => {
      let buffer = frameEntries.get(name2);
      if (buffer === void 0) {
        buffer = new RingBuffer(this.capacity);
        for (let i = 0; i < currentSize; i++) {
          buffer.enqOne(0);
        }
        this.frameEntries.set(name2, buffer);
      }
      buffer.enqOne(value2);
    });
    this.messages.enq(frameStats.messages);
  }
  log() {
    let maxNameLength = 0;
    this.frameEntries.forEach((buffer, name2) => {
      maxNameLength = Math.max(maxNameLength, name2.length);
    });
    const print = (v) => {
      return v !== void 0 ? v.toFixed(5) : "?";
    };
    this.frameEntries.forEach((buffer, name2) => {
      let s = name2 + ": " + " ".repeat(maxNameLength - name2.length);
      const simpleStats = computeArrayStats(buffer.asArray());
      if (simpleStats !== void 0) {
        s += `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, N=${print(simpleStats.numSamples)} ]`;
      }
      logger11.log(s);
    });
  }
};
var _PerformanceStatistics = class {
  constructor(enabled = true, maxNumFrames = 1e3) {
    this.enabled = enabled;
    this.maxNumFrames = maxNumFrames;
    _PerformanceStatistics.m_instance = this;
    this.m_frameEvents = new FrameStatsArray(maxNumFrames);
  }
  get isFull() {
    return this.m_frameEvents.length >= this.maxNumFrames;
  }
  static get instance() {
    if (_PerformanceStatistics.m_instance === void 0) {
      _PerformanceStatistics.m_instance = new _PerformanceStatistics(false, 0);
    }
    return _PerformanceStatistics.m_instance;
  }
  currentFrame = new FrameStats();
  get frameEvents() {
    return this.m_frameEvents;
  }
  appResults = /* @__PURE__ */ new Map();
  configs = /* @__PURE__ */ new Map();
  m_frameEvents;
  clear() {
    this.clearFrames();
    this.configs.clear();
    this.appResults.clear();
  }
  clearFrames() {
    this.m_frameEvents.reset();
    this.currentFrame.reset();
  }
  addWebGLInfo(webGlInfo) {
    if (webGlInfo.render !== void 0) {
      this.currentFrame.setValue("gl.numCalls", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);
      this.currentFrame.setValue("gl.numPoints", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);
      this.currentFrame.setValue("gl.numLines", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);
      this.currentFrame.setValue("gl.numTriangles", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);
    }
    if (webGlInfo.memory !== void 0) {
      this.currentFrame.setValue("gl.numGeometries", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);
      this.currentFrame.setValue("gl.numTextures", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);
    }
    if (webGlInfo.programs !== void 0) {
      this.currentFrame.setValue("gl.numPrograms", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);
    }
  }
  addMemoryInfo() {
    if (window !== void 0 && window.performance !== void 0) {
      const memory = window.performance.memory;
      if (memory !== void 0) {
        this.currentFrame.setValue("memory.totalJSHeapSize", memory.totalJSHeapSize);
        this.currentFrame.setValue("memory.usedJSHeapSize", memory.usedJSHeapSize);
        this.currentFrame.setValue("memory.jsHeapSizeLimit", memory.jsHeapSizeLimit);
      }
    }
  }
  storeAndClearFrameInfo() {
    if (this.m_frameEvents.length >= this.maxNumFrames) {
      return false;
    }
    this.m_frameEvents.addFrame(this.currentFrame);
    this.currentFrame.reset();
    return true;
  }
  log(header, footer) {
    logger11.log(header !== void 0 ? header : "PerformanceStatistics");
    const appResults = this.appResults;
    appResults.forEach((value2, name2) => {
      logger11.log(name2, value2);
    });
    const configs = this.configs;
    configs.forEach((value2, name2) => {
      logger11.log(name2, value2);
    });
    this.m_frameEvents.log();
    if (footer !== void 0) {
      logger11.log(footer);
    }
  }
  getAsPlainObject(onlyLastFrame = false) {
    const appResults = {};
    const configs = {};
    const frames = {};
    const plainObject = {
      configs,
      appResults,
      frames
    };
    const appResultValues = this.appResults;
    appResultValues.forEach((value2, name2) => {
      appResults[name2] = value2;
    });
    const configValues = this.configs;
    configValues.forEach((value2, name2) => {
      configs[name2] = value2;
    });
    if (onlyLastFrame) {
      for (const [name2, buffer] of this.m_frameEvents.frameEntries) {
        frames[name2] = buffer.bottom;
      }
    } else {
      for (const [name2, buffer] of this.m_frameEvents.frameEntries) {
        frames[name2] = buffer.asArray();
      }
    }
    plainObject.messages = this.m_frameEvents.messages.asArray();
    return plainObject;
  }
  getLastFrameStatistics() {
    return this.getAsPlainObject(true);
  }
  getAsSimpleFrameStatistics(onlyLastFrame = false) {
    const configs = /* @__PURE__ */ new Map();
    const appResults = /* @__PURE__ */ new Map();
    const frames = /* @__PURE__ */ new Map();
    const simpleStatistics = {
      configs,
      appResults,
      frames,
      messages: this.m_frameEvents.messages.asArray()
    };
    const appResultValues = this.appResults;
    appResultValues.forEach((value2, name2) => {
      appResults.set(name2, value2);
    });
    const configValues = this.configs;
    configValues.forEach((value2, name2) => {
      configs.set(name2, value2);
    });
    if (onlyLastFrame) {
      for (const [name2, buffer] of this.m_frameEvents.frameEntries) {
        frames.set(name2, buffer.bottom);
      }
    } else {
      for (const [name2, buffer] of this.m_frameEvents.frameEntries) {
        frames.set(name2, buffer.asArray());
      }
    }
    return simpleStatistics;
  }
};
var PerformanceStatistics = _PerformanceStatistics;
__publicField(PerformanceStatistics, "m_instance");

// src/mapview/MapViewTaskScheduler.ts
var DEFAULT_MAX_FPS = 60;
var DEFAULT_PROCESSING_ESTIMATE_TIME = 2;
var UPDATE_EVENT = { type: "update" };
var MapViewTaskScheduler = class extends THREE62.EventDispatcher {
  constructor(m_maxFps = DEFAULT_MAX_FPS) {
    super();
    this.m_maxFps = m_maxFps;
    this.m_taskQueue = new TaskQueue({
      groups: ["fetch" /* FETCH_AND_DECODE */, "create" /* CREATE */],
      prioSortFn: (a, b) => {
        return a.getPriority() - b.getPriority();
      }
    });
    this.maxFps = m_maxFps;
  }
  m_taskQueue;
  m_throttlingEnabled = false;
  set maxFps(fps) {
    this.m_maxFps = fps <= 0 ? DEFAULT_MAX_FPS : fps;
  }
  get maxFps() {
    return this.m_maxFps;
  }
  get taskQueue() {
    return this.m_taskQueue;
  }
  get throttlingEnabled() {
    return this.m_throttlingEnabled === true;
  }
  set throttlingEnabled(enabled) {
    this.m_throttlingEnabled = enabled;
  }
  requestUpdate() {
    this.dispatchEvent(UPDATE_EVENT);
  }
  processPending(frameStartTime) {
    const stats = PerformanceStatistics.instance;
    const currentFrameEvent = stats.enabled ? stats.currentFrame : void 0;
    let startTime;
    if (stats.enabled) {
      startTime = PerformanceTimer.now();
    }
    this.m_taskQueue.update();
    let numItemsLeft = this.taskQueue.numItemsLeft();
    currentFrameEvent == null ? void 0 : currentFrameEvent.setValue("TaskScheduler.numPendingTasks", numItemsLeft);
    if (this.throttlingEnabled) {
      let availableTime = this.spaceInFrame(frameStartTime);
      availableTime = availableTime > 2 ? availableTime - 2 : availableTime;
      currentFrameEvent == null ? void 0 : currentFrameEvent.setValue("TaskScheduler.estimatedAvailableTime", availableTime);
      let counter = 0;
      while (availableTime > 0 && numItemsLeft > 0) {
        let shouldProcess2 = function(task) {
          var _a;
          availableTime -= ((_a = task.estimatedProcessTime) == null ? void 0 : _a.call(task)) ?? DEFAULT_PROCESSING_ESTIMATE_TIME;
          if (availableTime > 0 || counter === 1) {
            return true;
          }
          return false;
        };
        var shouldProcess = shouldProcess2;
        counter++;
        ;
        ["create" /* CREATE */, "fetch" /* FETCH_AND_DECODE */].forEach((tag) => {
          if (this.m_taskQueue.numItemsLeft(tag)) {
            this.m_taskQueue.processNext(tag, shouldProcess2);
          }
        });
        numItemsLeft = this.m_taskQueue.numItemsLeft();
      }
      numItemsLeft = this.m_taskQueue.numItemsLeft();
      if (numItemsLeft > 0) {
        currentFrameEvent == null ? void 0 : currentFrameEvent.setValue("TaskScheduler.pendingTasksNotYetProcessed", numItemsLeft);
        this.requestUpdate();
      }
    } else {
      this.m_taskQueue.processNext("create" /* CREATE */, void 0, this.m_taskQueue.numItemsLeft("create" /* CREATE */));
      this.m_taskQueue.processNext("fetch" /* FETCH_AND_DECODE */, void 0, this.m_taskQueue.numItemsLeft("fetch" /* FETCH_AND_DECODE */));
    }
    if (stats.enabled) {
      currentFrameEvent == null ? void 0 : currentFrameEvent.setValue("TaskScheduler.pendingTasksTime", PerformanceTimer.now() - startTime);
    }
  }
  clearQueuedTasks() {
    this.m_taskQueue.clear();
  }
  spaceInFrame(frameStartTime) {
    const passedTime = (performance || Date).now() - frameStartTime;
    return Math.max(1e3 / this.m_maxFps - passedTime, 0);
  }
};

// src/mapview/ThemeLoader.ts
var DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;
var ThemeLoader = class {
  static async load(theme, options) {
    options = options ?? {};
    if (typeof theme === "string") {
      const uriResolver = options.uriResolver;
      const themeUrl = uriResolver !== void 0 ? uriResolver.resolveUri(theme) : theme;
      const response = await fetch(themeUrl, { signal: options.signal });
      if (!response.ok) {
        throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);
      }
      theme = await response.json();
      theme.url = themeUrl;
      theme = this.resolveUrls(theme, options);
    } else if (theme.url === void 0) {
      theme.url = getAppBaseUrl();
      theme = this.resolveUrls(theme, options);
    }
    theme.styles = getStyles(theme.styles);
    if (theme === null || theme === void 0) {
      throw new Error("ThemeLoader#load: loaded resource is not valid JSON");
    }
    const resolveDefinitions = getOptionValue(options.resolveDefinitions, false);
    theme = await ThemeLoader.resolveBaseThemes(theme, options);
    if (resolveDefinitions) {
      const contextLoader = new ContextLogger(options.logger ?? console, `when processing Theme ${theme.url}:`);
      ThemeLoader.resolveThemeReferences(theme, contextLoader);
    }
    return theme;
  }
  static isThemeLoaded(theme) {
    return theme.extends === void 0 && !isStylesDictionary(theme.styles);
  }
  static async loadAsync(themeUrl) {
    return await ThemeLoader.load(themeUrl);
  }
  static resolveUrls(theme, options) {
    if (theme.url === void 0) {
      return theme;
    }
    const childUrlResolver = composeUriResolvers(options == null ? void 0 : options.uriResolver, new RelativeUriResolver(theme.url));
    const resolveIncludes = options === void 0 || !(options.resolveIncludeUris === false);
    if (theme.extends && resolveIncludes) {
      theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map((baseTheme) => {
        if (typeof baseTheme === "string") {
          return childUrlResolver.resolveUri(baseTheme);
        } else {
          if (baseTheme.url !== void 0) {
            return baseTheme;
          } else {
            baseTheme.url = theme.url;
            return this.resolveUrls(baseTheme, options);
          }
        }
      });
    }
    const resolveResources = options === void 0 || !(options.resolveResourceUris === false);
    if (resolveResources) {
      ThemeLoader.resolveResources(theme, childUrlResolver);
    }
    return theme;
  }
  static resolveThemeReferences(theme, contextLogger) {
    if (theme.styles !== void 0) {
      contextLogger.pushAttr("styles");
      theme.styles = ThemeLoader.resolveStyles(getStyles(theme.styles), theme.definitions, contextLogger);
      contextLogger.pop();
      contextLogger.pop();
    }
    return theme;
  }
  static resolveStyles(styles, definitions, contextLogger) {
    const result = [];
    for (let index = 0; index < styles.length; ++index) {
      const currentStyle = styles[index];
      contextLogger.pushIndex(index);
      const resolvedStyle = ThemeLoader.resolveStyle(currentStyle, definitions, contextLogger);
      if (resolvedStyle !== void 0) {
        result.push(resolvedStyle);
      } else {
        contextLogger.warn("invalid style, ignored");
      }
      contextLogger.pop();
    }
    return result;
  }
  static resolveStyle(style, definitions, contextLogger) {
    if (Array.isArray(style.when)) {
      contextLogger.pushAttr("when");
      const resolvedWhen = this.resolveExpressionReferences(style.when, definitions, contextLogger);
      contextLogger.pop();
      if (resolvedWhen === void 0) {
        return void 0;
      }
      style.when = resolvedWhen;
    }
    if (style.attr !== void 0) {
      const attr = style.attr;
      contextLogger.pushAttr("attr");
      for (const prop in attr) {
        if (!attr.hasOwnProperty(prop)) {
          continue;
        }
        const value2 = attr[prop];
        if (!Array.isArray(value2)) {
          continue;
        }
        contextLogger.pushAttr(prop);
        const resolvedValue = this.resolveExpressionReferences(value2, definitions, contextLogger);
        contextLogger.pop();
        if (resolvedValue !== void 0) {
          attr[prop] = resolvedValue;
        } else {
          delete attr[prop];
        }
      }
      contextLogger.pop();
    }
    return style;
  }
  static resolveExpressionReferences(value2, definitions, contextLogger) {
    let failed = false;
    function resolveInternal(node) {
      if (isJsonExprReference(node)) {
        const defName = node[1];
        const def = definitions && definitions[defName];
        if (def === void 0) {
          contextLogger.warn(`invalid reference '${defName}' - not found`);
          failed = true;
          return void 0;
        }
        if (isJsonExpr(def)) {
          return def;
        }
        return getDefinitionValue(def);
      } else if (Array.isArray(node)) {
        const result = [...node];
        for (let i = 1; i < result.length; ++i) {
          result[i] = resolveInternal(result[i]);
        }
        return result;
      } else {
        return node;
      }
    }
    const r = resolveInternal(value2);
    if (failed) {
      return void 0;
    }
    return r;
  }
  static async resolveBaseThemes(theme, options) {
    options = options ?? {};
    if (theme.extends === void 0) {
      return theme;
    }
    const maxInheritanceDepth = getOptionValue(options.maxInheritanceDepth, DEFAULT_MAX_THEME_INTHERITANCE_DEPTH);
    if (maxInheritanceDepth <= 0) {
      throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);
    }
    const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;
    delete theme.extends;
    let baseThemesMerged = {};
    for (const baseTheme of baseThemes) {
      const actualBaseTheme = await ThemeLoader.load(baseTheme, {
        ...options,
        resolveDefinitions: false,
        maxInheritanceDepth: maxInheritanceDepth - 1
      });
      baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);
    }
    return ThemeLoader.mergeThemes(theme, baseThemesMerged);
  }
  static mergeThemes(theme, baseTheme) {
    const definitions = { ...baseTheme.definitions, ...theme.definitions };
    let styles;
    const baseStyles = getStyles(baseTheme.styles);
    const themeStyles = getStyles(theme.styles);
    if (baseTheme.styles && theme.styles) {
      const newStyles = [];
      const styleIdMap = /* @__PURE__ */ new Map();
      baseStyles.forEach((style) => {
        if (typeof style.id === "string") {
          if (!styleIdMap.has(style.id)) {
            styleIdMap.set(style.id, newStyles.length);
          }
        }
        newStyles.push(style);
      });
      themeStyles.forEach((style) => {
        if (typeof style.extends === "string" && styleIdMap.has(style.extends)) {
          const baseStyleIndex = styleIdMap.get(style.extends);
          const baseStyle = newStyles[baseStyleIndex];
          newStyles[baseStyleIndex] = {
            ...baseStyle,
            ...style
          };
          newStyles[baseStyleIndex].extends = void 0;
          return;
        }
        if (typeof style.id === "string" && styleIdMap.has(style.id)) {
          const styleIndex = styleIdMap.get(style.id);
          if (newStyles[styleIndex].styleSet === style.styleSet) {
            newStyles[styleIndex] = style;
          }
          return;
        }
        newStyles.push(style);
      });
      styles = newStyles;
    } else if (baseTheme.styles) {
      styles = [...baseStyles];
    } else if (theme.styles) {
      styles = [...themeStyles];
    }
    return {
      ...baseTheme,
      ...theme,
      ...ThemeLoader.mergeImageTextures(theme, baseTheme),
      definitions,
      styles
    };
  }
  static mergeImageTextures(theme, baseTheme) {
    const images = { ...baseTheme.images, ...theme.images };
    let imageTextures = [];
    if (!baseTheme.imageTextures && theme.imageTextures) {
      imageTextures = theme.imageTextures;
    } else if (baseTheme.imageTextures && !theme.imageTextures) {
      imageTextures = baseTheme.imageTextures;
    } else if (baseTheme.imageTextures && theme.imageTextures) {
      imageTextures = theme.imageTextures.slice();
      baseTheme.imageTextures.forEach((val) => {
        if (!imageTextures.find(({ name: name2 }) => name2 === val.name)) {
          imageTextures.push(val);
        }
      });
    }
    return {
      images,
      imageTextures
    };
  }
  static resolveResources(theme, childUrlResolver) {
    if (theme.sky && theme.sky.type === "cubemap") {
      for (let i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i) {
        const faceUrl = theme.sky[SkyCubemapFaceId[i]];
        if (faceUrl !== void 0) {
          ;
          theme.sky[SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);
        }
      }
    }
    if (theme.images) {
      for (const name2 of Object.keys(theme.images)) {
        const image = theme.images[name2];
        image.url = childUrlResolver.resolveUri(image.url);
        if (image.atlas !== void 0) {
          image.atlas = childUrlResolver.resolveUri(image.atlas);
        }
      }
    }
    if (theme.fontCatalogs) {
      for (const font of theme.fontCatalogs) {
        font.url = childUrlResolver.resolveUri(font.url);
      }
    }
    if (theme.poiTables) {
      for (const poiTable of theme.poiTables) {
        poiTable.url = childUrlResolver.resolveUri(poiTable.url);
      }
    }
    if (theme.styles !== void 0) {
      for (const style of getStyles(theme.styles)) {
        if (!style.attr) {
          continue;
        }
        ;
        ["map", "normalMap", "displacementMap", "roughnessMap"].forEach((texturePropertyName) => {
          const textureProperty = style.attr[texturePropertyName];
          if (textureProperty && typeof textureProperty === "string") {
            ;
            style.attr[texturePropertyName] = childUrlResolver.resolveUri(textureProperty);
          }
        });
      }
    }
  }
};

// src/mapview/MapViewThemeManager.ts
var logger12 = LoggerManager.instance.create("MapViewThemeManager");
var MapViewThemeManager = class {
  constructor(m_mapView, m_uriResolver) {
    this.m_mapView = m_mapView;
    this.m_uriResolver = m_uriResolver;
    this.m_imageCache = new MapViewImageCache();
  }
  m_imageCache;
  m_updatePromise;
  m_abortControllers = [];
  m_theme = {};
  async setTheme(theme) {
    if (this.isUpdating()) {
      logger12.warn("Formerly set Theme is still updating, update will be canceled");
      this.cancelThemeUpdate();
    }
    this.m_updatePromise = this.loadTheme(theme).then(async (theme2) => {
      await this.updateTheme(theme2);
    });
    await this.m_updatePromise;
    this.m_updatePromise = void 0;
    return this.m_theme;
  }
  async getTheme() {
    if (this.isUpdating()) {
      await this.m_updatePromise;
    }
    return this.m_theme;
  }
  isUpdating() {
    return this.m_updatePromise !== void 0;
  }
  get theme() {
    return this.isUpdating() ? {} : this.m_theme;
  }
  async loadTheme(theme) {
    let loadedTheme = {};
    if (typeof theme === "string" || !ThemeLoader.isThemeLoaded(theme)) {
      try {
        loadedTheme = await ThemeLoader.load(theme, {
          uriResolver: this.m_uriResolver,
          signal: this.createAbortController().signal
        });
      } catch (error) {
        if (error.name === "AbortError") {
          logger12.warn(`theme loading was aborted due to: ${error}`);
        } else {
          logger12.error(`failed to load theme: ${error}`);
        }
      }
    } else {
      loadedTheme = theme;
    }
    return loadedTheme;
  }
  async updateTheme(theme) {
    const environment = this.m_mapView.sceneEnvironment;
    this.m_theme.fog = theme.fog;
    this.m_theme.sky = theme.sky;
    environment.updateSkyBackground(theme.sky);
    environment.fog.reset(theme.fog);
    this.m_theme.lights = theme.lights;
    environment.updateLighting(theme.lights);
    this.m_theme.clearColor = theme.clearColor;
    this.m_theme.clearAlpha = theme.clearAlpha;
    environment.updateClearColor(theme.clearColor, theme.clearAlpha);
    this.m_theme.images = theme.images;
    this.m_theme.imageTextures = theme.imageTextures;
    await this.updateImages(theme.images, theme.imageTextures);
    this.m_theme.poiTables = theme.poiTables;
    await this.loadPoiTables(theme.poiTables);
    this.m_theme.textStyles = theme.textStyles;
    this.m_theme.defaultTextStyle = theme.defaultTextStyle;
    this.m_theme.fontCatalogs = theme.fontCatalogs;
    await this.m_mapView.resetTextRenderer(theme.fontCatalogs, theme.textStyles, theme.defaultTextStyle);
    if (Array.isArray(theme.priorities)) {
      this.m_theme.priorities = theme.priorities;
    }
    this.m_mapView.mapAnchors.setPriorities(theme.priorities ?? []);
    if (Array.isArray(theme.labelPriorities)) {
      this.m_theme.labelPriorities = theme.labelPriorities;
    }
    if (this.m_theme.styles === void 0) {
      this.m_theme.styles = [];
    }
    this.m_theme.styles = theme.styles ?? [];
    this.m_theme.definitions = theme.definitions;
    environment.clearBackgroundDataSource();
    for (const dataSource of this.m_mapView.dataSources) {
      await dataSource.setTheme(this.m_theme);
    }
  }
  updateCache() {
    this.updateImages(this.m_theme.images, this.m_theme.imageTextures);
    this.m_mapView.sceneEnvironment.updateLighting(this.m_theme.lights);
    this.m_mapView.sceneEnvironment.updateSkyBackground(this.m_theme.sky, this.m_theme.clearColor);
  }
  get imageCache() {
    return this.m_imageCache;
  }
  dispose() {
    this.m_imageCache.clear();
  }
  async loadPoiTables(poiTables) {
    this.m_mapView.poiTableManager.clear();
    await this.m_mapView.poiTableManager.loadPoiTables(poiTables);
  }
  cancelThemeUpdate() {
    for (var i = 0; i < this.m_abortControllers.length; i++) {
      this.m_abortControllers[i].abort();
    }
    this.m_abortControllers = [];
    this.m_imageCache.clear();
    this.m_mapView.poiManager.clear();
    this.m_mapView.poiTableManager.clear();
  }
  createAbortController() {
    this.m_abortControllers.push(new AbortController());
    return this.m_abortControllers[this.m_abortControllers.length - 1];
  }
  async updateImages(images, imageTextures) {
    this.m_imageCache.clear();
    this.m_mapView.poiManager.clear();
    if (images !== void 0) {
      for (const name2 of Object.keys(images)) {
        const image = images[name2];
        this.m_imageCache.addImage(name2, image.url, image.preload === true);
        if (typeof image.atlas === "string") {
          await this.m_mapView.poiManager.addTextureAtlas(name2, image.atlas, this.createAbortController().signal);
        }
      }
    }
    if (imageTextures !== void 0) {
      imageTextures.forEach((imageTexture) => {
        this.m_mapView.poiManager.addImageTexture(imageTexture);
      });
    }
  }
};

// src/mapview/PickHandler.ts
var THREE64 = __toESM(require("three"));

// src/mapview/PickingRaycaster.ts
var THREE63 = __toESM(require("three"));
function intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers) && object.visible) {
    const mapObjectAdapter = MapObjectAdapter.get(object);
    if (!mapObjectAdapter || mapObjectAdapter.isPickable()) {
      object.raycast(raycaster, intersects);
    }
  }
  if (recursive === true) {
    for (const child of object.children) {
      intersectObject(child, raycaster, intersects, true);
    }
  }
}
var PickingRaycaster = class extends THREE63.Raycaster {
  constructor(canvasSize) {
    super();
    this.canvasSize = canvasSize;
  }
  intersectObject(object, recursive, optionalTarget) {
    const intersects = optionalTarget ?? [];
    intersectObject(object, this, intersects, recursive);
    return intersects;
  }
  intersectObjects(objects, recursive, optionalTarget) {
    const intersects = optionalTarget ?? [];
    for (const object of objects) {
      intersectObject(object, this, intersects, recursive);
    }
    return intersects;
  }
};

// src/mapview/PickListener.ts
function defaultSort(lhs, rhs) {
  const lDataSourceOrder = lhs.dataSourceOrder ?? 0;
  const rDataSourceOrder = rhs.dataSourceOrder ?? 0;
  if (lDataSourceOrder !== rDataSourceOrder) {
    return rDataSourceOrder - lDataSourceOrder;
  }
  const eps = 1e-4;
  const distanceDiff = lhs.distance - rhs.distance;
  const haveRenderOrder = lhs.renderOrder !== void 0 && rhs.renderOrder !== void 0;
  if (Math.abs(distanceDiff) > eps || !haveRenderOrder) {
    return distanceDiff;
  }
  return rhs.renderOrder - lhs.renderOrder;
}
var PickListener = class {
  constructor(m_parameters) {
    this.m_parameters = m_parameters;
  }
  m_results = [];
  m_sorted = true;
  m_finished = true;
  addResult(result) {
    const foundFeatureIdx = this.m_results.findIndex((otherResult) => {
      var _a, _b, _c, _d;
      const sameType = otherResult.type === result.type;
      const dataSource = (_b = (_a = result.intersection) == null ? void 0 : _a.object.userData) == null ? void 0 : _b.dataSource;
      const sameDataSource = dataSource && ((_d = (_c = otherResult.intersection) == null ? void 0 : _c.object.userData) == null ? void 0 : _d.dataSource) === dataSource;
      const sameId = result.featureId !== void 0 && otherResult.featureId === result.featureId;
      const noId = result.featureId === void 0 && otherResult.featureId === void 0;
      const sameUserData = result.userData && otherResult.userData === result.userData;
      return sameType && sameDataSource && (sameId || noId && sameUserData);
    });
    if (foundFeatureIdx < 0) {
      this.m_sorted = false;
      this.m_finished = false;
      this.m_results.push(result);
      return;
    }
    const oldResult = this.m_results[foundFeatureIdx];
    if (defaultSort(result, oldResult) < 0) {
      this.m_results[foundFeatureIdx] = result;
      this.m_sorted = false;
      this.m_finished = false;
    }
  }
  get done() {
    return this.maxResults ? this.m_results.length >= this.maxResults : false;
  }
  finish() {
    this.sortResults();
    if (this.maxResults && this.m_results.length > this.maxResults) {
      this.m_results.length = this.maxResults;
    }
    this.m_finished = true;
  }
  get results() {
    assert(this.m_finished, "finish() was not called before getting the results");
    return this.m_results;
  }
  get closestResult() {
    this.sortResults();
    return this.m_results.length > 0 ? this.m_results[0] : void 0;
  }
  get furthestResult() {
    this.sortResults();
    return this.m_results.length > 0 ? this.m_results[this.m_results.length - 1] : void 0;
  }
  get maxResults() {
    var _a;
    const maxCount = ((_a = this.m_parameters) == null ? void 0 : _a.maxResultCount) ?? 0;
    return maxCount > 0 ? maxCount : void 0;
  }
  sortResults() {
    if (this.m_sorted) {
      return;
    }
    const zeroDistanceGroup = [];
    const nonZeroDistanceGroup = [];
    this.m_results.sort(defaultSort).forEach((result) => (result.distance === 0 ? zeroDistanceGroup : nonZeroDistanceGroup).push(result));
    this.m_results = zeroDistanceGroup.concat(nonZeroDistanceGroup);
    this.m_sorted = true;
  }
};

// src/mapview/PickHandler.ts
var PickObjectType = /* @__PURE__ */ ((PickObjectType2) => {
  PickObjectType2[PickObjectType2["Unspecified"] = 0] = "Unspecified";
  PickObjectType2[PickObjectType2["Point"] = 1] = "Point";
  PickObjectType2[PickObjectType2["Line"] = 2] = "Line";
  PickObjectType2[PickObjectType2["Area"] = 3] = "Area";
  PickObjectType2[PickObjectType2["Text"] = 4] = "Text";
  PickObjectType2[PickObjectType2["Icon"] = 5] = "Icon";
  PickObjectType2[PickObjectType2["Object3D"] = 6] = "Object3D";
  return PickObjectType2;
})(PickObjectType || {});
var tmpV32 = new THREE64.Vector3();
var tmpOBB2 = new OrientedBox3();
function intersectDependentObjects(tile, intersects, rayCaster2, checkedDependencies, mapView) {
  for (const tileKey of tile.dependencies) {
    const mortonCode = tileKey.mortonCode();
    if (checkedDependencies.has(mortonCode)) {
      continue;
    }
    checkedDependencies.add(mortonCode);
    const otherTile = mapView.visibleTileSet.getCachedTile(tile.dataSource, tileKey, tile.offset, mapView.frameNumber);
    if (otherTile !== void 0) {
      rayCaster2.intersectObjects(otherTile.objects, true, intersects);
    }
  }
}
var PickHandler = class {
  constructor(mapView, camera, enablePickTechnique = false) {
    this.mapView = mapView;
    this.camera = camera;
    this.enablePickTechnique = enablePickTechnique;
    this.m_pickingRaycaster = new PickingRaycaster(mapView.renderer.getSize(new THREE64.Vector2()));
  }
  m_pickingRaycaster;
  intersectMapObjects(x, y, parameters) {
    const ndc = this.mapView.getNormalizedScreenCoordinates(x, y);
    const rayCaster2 = this.setupRaycaster(x, y);
    const pickListener = new PickListener(parameters);
    if (this.mapView.textElementsRenderer !== void 0) {
      const { clientWidth, clientHeight } = this.mapView.canvas;
      const screenX = ndc.x * clientWidth * 0.5;
      const screenY = ndc.y * clientHeight * 0.5;
      const scenePosition = new THREE64.Vector2(screenX, screenY);
      this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickListener);
    }
    const intersects = [];
    const intersectedTiles = this.getIntersectedTiles(rayCaster2);
    const checkedDependencies = /* @__PURE__ */ new Set();
    for (const { tile, distance } of intersectedTiles) {
      if (pickListener.done && pickListener.furthestResult.distance < distance) {
        break;
      }
      intersects.length = 0;
      rayCaster2.intersectObjects(tile.objects, true, intersects);
      intersectDependentObjects(tile, intersects, rayCaster2, checkedDependencies, this.mapView);
      for (const intersect of intersects) {
        pickListener.addResult(this.createResult(intersect, tile));
      }
    }
    intersects.length = 0;
    for (const child of this.mapView.mapAnchors.children) {
      rayCaster2.intersectObject(child, true, intersects);
      for (const intersect of intersects) {
        pickListener.addResult(this.createResult(intersect));
      }
    }
    pickListener.finish();
    return pickListener.results;
  }
  raycasterFromScreenPoint(x, y) {
    this.m_pickingRaycaster.setFromCamera(this.mapView.getNormalizedScreenCoordinates(x, y), this.camera);
    this.mapView.renderer.getSize(this.m_pickingRaycaster.canvasSize);
    return this.m_pickingRaycaster;
  }
  createResult(intersection, tile) {
    var _a, _b, _c;
    const pickResult = {
      type: 0 /* Unspecified */,
      point: intersection.point,
      distance: intersection.distance,
      dataSourceName: (_a = intersection.object.userData) == null ? void 0 : _a.dataSource,
      dataSourceOrder: (_b = tile == null ? void 0 : tile.dataSource) == null ? void 0 : _b.dataSourceOrder,
      intersection,
      tileKey: tile == null ? void 0 : tile.tileKey
    };
    if (intersection.object.userData === void 0 || intersection.object.userData.feature === void 0) {
      return pickResult;
    }
    if (this.enablePickTechnique) {
      pickResult.technique = intersection.object.userData.technique;
    }
    pickResult.renderOrder = (_c = intersection.object) == null ? void 0 : _c.renderOrder;
    const featureData = intersection.object.userData.feature;
    this.addObjInfo(featureData, intersection, pickResult);
    if (pickResult.userData) {
      const featureId = getFeatureId(pickResult.userData);
      pickResult.featureId = featureId === 0 ? void 0 : featureId;
    }
    let pickObjectType;
    switch (featureData.geometryType) {
      case 1 /* Point */:
      case 4 /* Text */:
        pickObjectType = 1 /* Point */;
        break;
      case 2 /* Line */:
      case 6 /* ExtrudedLine */:
      case 3 /* SolidLine */:
      case 5 /* TextPath */:
        pickObjectType = 2 /* Line */;
        break;
      case 7 /* Polygon */:
      case 8 /* ExtrudedPolygon */:
        pickObjectType = 3 /* Area */;
        break;
      case 9 /* Object3D */:
        pickObjectType = 6 /* Object3D */;
        break;
      default:
        pickObjectType = 0 /* Unspecified */;
    }
    pickResult.type = pickObjectType;
    return pickResult;
  }
  getIntersectedTiles(rayCaster2) {
    const tiles = new Array();
    const tileList = this.mapView.visibleTileSet.dataSourceTileList;
    tileList.forEach((dataSourceTileList) => {
      if (!dataSourceTileList.dataSource.enablePicking) {
        return;
      }
      dataSourceTileList.renderedTiles.forEach((tile) => {
        tmpOBB2.copy(tile.boundingBox);
        tmpOBB2.position.sub(this.mapView.worldCenter);
        const worldOffsetX = tile.computeWorldOffsetX();
        tmpOBB2.position.x += worldOffsetX;
        const distance = tmpOBB2.intersectsRay(rayCaster2.ray);
        if (distance !== void 0) {
          tiles.push({ tile, distance });
        }
      });
    });
    tiles.sort((lhs, rhs) => {
      return lhs.distance - rhs.distance;
    });
    return tiles;
  }
  addObjInfo(featureData, intersect, pickResult) {
    if (featureData.objInfos === void 0) {
      return;
    }
    if (pickResult.intersection.object instanceof MapViewPoints) {
      pickResult.userData = featureData.objInfos[intersect.index];
      return;
    }
    if (featureData.starts === void 0 || featureData.starts.length === 0 || typeof intersect.faceIndex !== "number" && intersect.index === void 0) {
      if (featureData.objInfos.length === 1) {
        pickResult.userData = featureData.objInfos[0];
      }
      return;
    }
    if (featureData.starts.length === 1) {
      pickResult.userData = featureData.objInfos[0];
      return;
    }
    const intersectIndex = typeof intersect.faceIndex === "number" ? intersect.faceIndex * 3 : intersect.index;
    let objInfosIndex = 0;
    for (const featureStartIndex of featureData.starts) {
      if (featureStartIndex > intersectIndex) {
        break;
      }
      objInfosIndex++;
    }
    pickResult.userData = featureData.objInfos[objInfosIndex - 1];
  }
  setupRaycaster(x, y) {
    const camera = this.mapView.camera;
    const rayCaster2 = this.raycasterFromScreenPoint(x, y);
    const furthestIntersection = this.mapView.getWorldPositionAt(x, y, true);
    const furthestDistance = camera.position.distanceTo(furthestIntersection) / this.mapView.camera.getWorldDirection(tmpV32).dot(rayCaster2.ray.direction);
    rayCaster2.params.Line.threshold = MapViewUtils.calculateWorldSizeByFocalLength(this.mapView.focalLength, furthestDistance, 1);
    return rayCaster2;
  }
};

// src/mapview/poi/PoiManager.ts
var THREE85 = __toESM(require("three"));

// src/text-canvas/rendering/FontCatalog.ts
var THREE69 = __toESM(require("three"));

// src/text-canvas/utils/UnicodeUtils.ts
var UnicodeUtils;
((UnicodeUtils2) => {
  UnicodeUtils2.whiteSpaceRanges = [
    [9, 9],
    [32, 32],
    [5760, 5760],
    [8192, 8198],
    [8200, 8202],
    [8287, 12288],
    [6158, 6158],
    [8203, 8205]
  ];
  function isWhiteSpace(codePoint) {
    for (const range of UnicodeUtils2.whiteSpaceRanges) {
      if (codePoint >= range[0] && codePoint <= range[1]) {
        return true;
      }
    }
    return false;
  }
  UnicodeUtils2.isWhiteSpace = isWhiteSpace;
  UnicodeUtils2.newLineRanges = [
    [10, 13],
    [133, 133],
    [8232, 8233]
  ];
  function isNewLine(codePoint) {
    for (const range of UnicodeUtils2.newLineRanges) {
      if (codePoint >= range[0] && codePoint <= range[1]) {
        return true;
      }
    }
    return false;
  }
  UnicodeUtils2.isNewLine = isNewLine;
  UnicodeUtils2.nonPrintableRanges = [
    [0, 31],
    [127, 159]
  ];
  function isPrintable(codePoint) {
    for (const range of UnicodeUtils2.nonPrintableRanges) {
      if (codePoint >= range[0] && codePoint <= range[1]) {
        return false;
      }
    }
    return true;
  }
  UnicodeUtils2.isPrintable = isPrintable;
  let Direction;
  ((Direction2) => {
    Direction2[Direction2["Neutral"] = 0] = "Neutral";
    Direction2[Direction2["Weak"] = 0.5] = "Weak";
    Direction2[Direction2["LTR"] = 1] = "LTR";
    Direction2[Direction2["RTL"] = -1] = "RTL";
  })(Direction = UnicodeUtils2.Direction || (UnicodeUtils2.Direction = {}));
  UnicodeUtils2.rtlBlocks = [
    "Hebrew",
    "Alphabetic Presentation Forms",
    "Arabic",
    "Arabic Supplement",
    "Arabic Extended-A",
    "Arabic Presentation Forms-A",
    "Arabic Presentation Forms-B",
    "Arabic Mathematical Alphabetic Symbols",
    "Indic Siyaq Numbers",
    "Rumi Numeral Symbols",
    "Syriac",
    "Syriac Supplement",
    "Samaritan",
    "Mandaic",
    "Thaana",
    "Mende Kikakui",
    "NKo",
    "Adlam",
    "Hanifi Rohingya"
  ];
  UnicodeUtils2.neutralBidirectionalRanges = [
    [32, 47],
    [58, 64],
    [91, 96],
    [123, 126]
  ];
  UnicodeUtils2.weakBidirectionalRanges = [
    [48, 57],
    [1632, 1641],
    [1776, 1785]
  ];
  function getDirection(codePoint, block) {
    for (const weakRange of UnicodeUtils2.weakBidirectionalRanges) {
      if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {
        return 0.5 /* Weak */;
      }
    }
    for (const neutralRange of UnicodeUtils2.neutralBidirectionalRanges) {
      if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {
        return 0 /* Neutral */;
      }
    }
    const rtl = UnicodeUtils2.rtlBlocks.find((element) => {
      return element === block;
    });
    if (rtl !== void 0) {
      return -1 /* RTL */;
    } else {
      return 1 /* LTR */;
    }
  }
  UnicodeUtils2.getDirection = getDirection;
  UnicodeUtils2.rtlMirroredCodePoints = [
    40,
    41,
    60,
    62,
    91,
    93,
    123,
    125
  ];
  function isRtlMirrored(codePoint) {
    return UnicodeUtils2.rtlMirroredCodePoints.find((element) => {
      return element === codePoint;
    }) !== void 0;
  }
  UnicodeUtils2.isRtlMirrored = isRtlMirrored;
})(UnicodeUtils || (UnicodeUtils = {}));

// src/text-canvas/rendering/GlyphData.ts
var THREE65 = __toESM(require("three"));
var GlyphData = class {
  constructor(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font, isReplacement = false) {
    this.codePoint = codePoint;
    this.block = block;
    this.width = width;
    this.height = height;
    this.advanceX = advanceX;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    this.texture = texture;
    this.font = font;
    this.isReplacement = isReplacement;
    this.character = String.fromCodePoint(codePoint);
    this.direction = UnicodeUtils.getDirection(codePoint, block);
    const left = this.offsetX;
    const right = left + this.width;
    const top = font.metrics.lineHeight - this.offsetY;
    const bottom = top - this.height;
    this.positions.push(new THREE65.Vector3(left, bottom, 1), new THREE65.Vector3(right, bottom, 1), new THREE65.Vector3(left, top, 1), new THREE65.Vector3(right, top, 1));
    this.sourceTextureCoordinates.push(new THREE65.Vector2(u0, v0), new THREE65.Vector2(u1, v0), new THREE65.Vector2(u0, v1), new THREE65.Vector2(u1, v1));
    this.dynamicTextureCoordinates.push(new THREE65.Vector2(0, 0), new THREE65.Vector2(1, 0), new THREE65.Vector2(0, 1), new THREE65.Vector2(1, 1));
  }
  character;
  direction;
  positions = [];
  sourceTextureCoordinates = [];
  dynamicTextureCoordinates = [];
  copyIndex = 0;
  isInCache = false;
  clone() {
    return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font, this.isReplacement);
  }
};

// src/text-canvas/rendering/GlyphTextureCache.ts
var THREE67 = __toESM(require("three"));

// src/text-canvas/rendering/TextMaterials.ts
var THREE66 = __toESM(require("three"));
var SdfShaderChunks = {
  sdf_attributes: `
        attribute vec4 position;
        attribute vec4 uv;
        attribute vec4 color;
        attribute vec4 bgColor;
        `,
  sdf_varying: `
        varying vec4 vColor;
        varying float vWeight;
        varying vec2 vUv;
        varying float vRotation;
        `,
  sdf_varying_computation: `
        #if BG_TEXT
        vColor = bgColor;
        vWeight = uv.w;
        #else
        vColor = color;
        vWeight = uv.z;
        #endif
        vUv = vec2(uv.xy);
        vRotation = position.w;
        `,
  sdf_frag_uniforms: `
        uniform sampler2D sdfTexture;
        uniform vec4 sdfParams;
        `,
  sdf_sampling_functions: `
        float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
        }

        float getDistance(vec2 uvOffset) {
            vec3 texSample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;
            #if MSDF
            return median(texSample.r, texSample.g, texSample.b);
            #else
            return texSample.r;
            #endif
        }

        float getOpacity(vec2 uvOffset, float weight) {
            vec2 uv = vUv + uvOffset;
            vec2 rotatedUVs = abs(vec2(
                cos(vRotation) * uv.x - sin(vRotation) * uv.y,
                sin(vRotation) * uv.x + cos(vRotation) * uv.y));

            float dx = dFdx(rotatedUVs.x) * sdfParams.x;
            float dy = dFdy(rotatedUVs.y) * sdfParams.y;
            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );

            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;
            return clamp(dist * toPixels + 0.5, 0.0, 1.0);
        }
        `
};
Object.assign(THREE66.ShaderChunk, SdfShaderChunks);
var clearVertexSource = `
    attribute vec2 position;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
var clearFragmentSource = `
    precision highp float;
    precision highp int;

    void main() {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }`;
var copyVertexSource = `
    attribute vec3 position;
    attribute vec2 uv;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    varying vec3 vUv;

    void main() {
        vUv = vec3(uv.xy, position.z);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
var copyFragmentSource = `
    precision highp float;
    precision highp int;

    uniform float pageOffset;
    uniform sampler2D page0;
    uniform sampler2D page1;
    uniform sampler2D page2;
    uniform sampler2D page3;
    uniform sampler2D page4;
    uniform sampler2D page5;
    uniform sampler2D page6;
    uniform sampler2D page7;

    varying vec3 vUv;

    void main() {
        vec4 texSample = vec4(0.0);
        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;
        else if (vUv.z < pageOffset + 1.0) texSample = texture2D(page0, vUv.xy);
        else if (vUv.z < pageOffset + 2.0) texSample = texture2D(page1, vUv.xy);
        else if (vUv.z < pageOffset + 3.0) texSample = texture2D(page2, vUv.xy);
        else if (vUv.z < pageOffset + 4.0) texSample = texture2D(page3, vUv.xy);
        else if (vUv.z < pageOffset + 5.0) texSample = texture2D(page4, vUv.xy);
        else if (vUv.z < pageOffset + 6.0) texSample = texture2D(page5, vUv.xy);
        else if (vUv.z < pageOffset + 7.0) texSample = texture2D(page6, vUv.xy);
        else texSample = texture2D(page7, vUv.xy);

        gl_FragColor = texSample;
    }`;
var sdfTextVertexSource = `
    #include <sdf_attributes>
    #include <sdf_varying>

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        #include <sdf_varying_computation>
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
    }`;
var sdfTextFragmentSource = `
    precision highp float;
    precision highp int;

    #include <sdf_varying>
    #include <sdf_frag_uniforms>
    #include <sdf_sampling_functions>

    void main() {
        vec4 color = vColor;
        color.a *= getOpacity(vec2(0.0), vWeight);
        if (color.a < 0.05) {
            discard;
        }
        gl_FragColor = color;
    }`;
var RawShaderMaterial4 = class extends THREE66.RawShaderMaterial {
  constructor(params) {
    const isWebGL2 = (params == null ? void 0 : params.rendererCapabilities.isWebGL2) === true;
    const shaderParams = params ? {
      ...params,
      glslVersion: isWebGL2 ? THREE66.GLSL3 : THREE66.GLSL1,
      vertexShader: isWebGL2 && params.vertexShader ? convertVertexShaderToWebGL2(params.vertexShader) : params.vertexShader,
      fragmentShader: isWebGL2 && params.fragmentShader ? convertFragmentShaderToWebGL2(params.fragmentShader) : params.fragmentShader
    } : void 0;
    if (shaderParams) {
      delete shaderParams.rendererCapabilities;
    }
    super(shaderParams);
  }
};
var GlyphClearMaterial = class extends RawShaderMaterial4 {
  constructor(params) {
    const shaderParams = params ? {
      name: "GlyphClearMaterial",
      vertexShader: clearVertexSource,
      fragmentShader: clearFragmentSource,
      uniforms: {},
      depthTest: false,
      depthWrite: false,
      rendererCapabilities: params.rendererCapabilities
    } : void 0;
    super(shaderParams);
  }
};
var GlyphCopyMaterial = class extends RawShaderMaterial4 {
  constructor(params) {
    const shaderParams = params ? {
      name: "GlyphCopyMaterial",
      vertexShader: copyVertexSource,
      fragmentShader: copyFragmentSource,
      uniforms: {
        pageOffset: new THREE66.Uniform(0),
        page0: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
        page1: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
        page2: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
        page3: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
        page4: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
        page5: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
        page6: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
        page7: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE)
      },
      depthTest: false,
      depthWrite: false,
      rendererCapabilities: params.rendererCapabilities
    } : void 0;
    super(shaderParams);
  }
};
var SdfTextMaterial = class extends RawShaderMaterial4 {
  constructor(params) {
    const shaderParams = params ? {
      name: "SdfTextMaterial",
      vertexShader: params.vertexSource !== void 0 ? params.vertexSource : sdfTextVertexSource,
      fragmentShader: params.fragmentSource !== void 0 ? params.fragmentSource : sdfTextFragmentSource,
      uniforms: {
        sdfTexture: new THREE66.Uniform(params.texture),
        sdfParams: new THREE66.Uniform(new THREE66.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))
      },
      defines: {
        MSDF: params.isMsdf ? 1 : 0,
        BG_TEXT: params.isBackground ? 1 : 0
      },
      depthTest: true,
      depthWrite: false,
      side: THREE66.DoubleSide,
      transparent: true,
      rendererCapabilities: params.rendererCapabilities
    } : void 0;
    super(shaderParams);
    this.extensions.derivatives = true;
  }
};

// src/text-canvas/rendering/GlyphTextureCache.ts
var MAX_NUM_COPY_PAGES = 8;
var MAX_TEXTURE_SIZE = 4096;
var GlyphTextureCache = class {
  constructor(capacity, entryWidth, entryHeight) {
    this.capacity = capacity;
    this.entryWidth = entryWidth;
    this.entryHeight = entryHeight;
    const nRows = Math.floor(Math.sqrt(capacity));
    this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;
    this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;
    this.m_textureSize = new THREE67.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);
    if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {
      console.warn("GlyphTextureCache texture size (" + this.m_textureSize.x + ", " + this.m_textureSize.y + ") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (" + MAX_TEXTURE_SIZE + ").\nThis could result in rendering errors on some devices.\nPlease consider reducing its capacity or input assets size.");
    }
    this.m_entryCache = new LRUCache(capacity);
    this.initCacheEntries();
    this.m_scene = new THREE67.Scene();
    this.m_camera = new THREE67.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);
    this.m_camera.position.z = 1;
    this.m_camera.updateMatrixWorld(false);
    this.m_rt = new THREE67.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {
      wrapS: THREE67.ClampToEdgeWrapping,
      wrapT: THREE67.ClampToEdgeWrapping,
      depthBuffer: false,
      stencilBuffer: false
    });
    this.m_copyTextureSet = /* @__PURE__ */ new Set();
    this.m_copyTransform = new THREE67.Matrix3();
    this.m_copyPositions = [];
    this.m_copyPositions.push(new THREE67.Vector2(), new THREE67.Vector2(), new THREE67.Vector2(), new THREE67.Vector2());
    this.m_copyVertexBuffer = new THREE67.InterleavedBuffer(new Float32Array(capacity * 20), 5);
    this.m_copyVertexBuffer.setUsage(THREE67.DynamicDrawUsage);
    this.m_copyPositionAttribute = new THREE67.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);
    this.m_copyUVAttribute = new THREE67.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);
    this.m_copyGeometry = new THREE67.BufferGeometry();
    this.m_copyGeometry.setAttribute("position", this.m_copyPositionAttribute);
    this.m_copyGeometry.setAttribute("uv", this.m_copyUVAttribute);
    const copyIndexBuffer = new THREE67.BufferAttribute(new Uint32Array(capacity * 6), 1);
    copyIndexBuffer.setUsage(THREE67.DynamicDrawUsage);
    this.m_copyGeometry.setIndex(copyIndexBuffer);
    this.m_copyMesh = new THREE67.Mesh(this.m_copyGeometry);
    this.m_copyMesh.frustumCulled = false;
    this.m_copyGeometryDrawCount = 0;
    this.m_clearPositionAttribute = new THREE67.BufferAttribute(new Float32Array(capacity * 8), 2);
    this.m_clearPositionAttribute.setUsage(THREE67.DynamicDrawUsage);
    this.m_clearGeometry = new THREE67.BufferGeometry();
    this.m_clearGeometry.setAttribute("position", this.m_clearPositionAttribute);
    const clearIndexBuffer = new THREE67.BufferAttribute(new Uint32Array(capacity * 6), 1);
    clearIndexBuffer.setUsage(THREE67.DynamicDrawUsage);
    this.m_clearGeometry.setIndex(clearIndexBuffer);
    this.m_clearMesh = new THREE67.Mesh(this.m_clearGeometry);
    this.m_clearMesh.frustumCulled = false;
    this.m_clearGeometryDrawCount = 0;
    this.m_scene.add(this.m_clearMesh, this.m_copyMesh);
  }
  m_cacheWidth;
  m_cacheHeight;
  m_textureSize;
  m_entryCache;
  m_scene;
  m_camera;
  m_rt;
  m_copyTextureSet;
  m_copyTransform;
  m_copyPositions;
  m_copyMaterial;
  m_copyVertexBuffer;
  m_copyPositionAttribute;
  m_copyUVAttribute;
  m_copyGeometry;
  m_copyMesh;
  m_copyGeometryDrawCount;
  m_clearMaterial;
  m_clearPositionAttribute;
  m_clearGeometry;
  m_clearMesh;
  m_clearGeometryDrawCount;
  dispose() {
    var _a, _b;
    this.m_entryCache.clear();
    this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);
    this.m_rt.dispose();
    (_a = this.m_clearMaterial) == null ? void 0 : _a.dispose();
    (_b = this.m_copyMaterial) == null ? void 0 : _b.dispose();
    this.m_copyTextureSet.clear();
    this.m_clearGeometry.dispose();
    this.m_copyGeometry.dispose();
  }
  get texture() {
    return this.m_rt.texture;
  }
  get textureSize() {
    return this.m_textureSize;
  }
  add(hash, glyph) {
    const entry = this.m_entryCache.get(hash);
    if (entry !== void 0) {
      return;
    }
    const oldestEntry = this.m_entryCache.oldest;
    if (oldestEntry === null) {
      throw new Error("GlyphTextureCache is uninitialized!");
    }
    this.clearCacheEntry(oldestEntry.value);
    this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);
  }
  has(hash) {
    return this.m_entryCache.has(hash);
  }
  get(hash) {
    return this.m_entryCache.get(hash);
  }
  clear() {
    this.m_copyGeometryDrawCount = 0;
    this.m_clearGeometryDrawCount = 0;
    this.m_entryCache.clear();
    this.m_copyTextureSet.clear();
    this.initCacheEntries();
  }
  update(renderer) {
    let oldRenderTarget = null;
    const willClearGeometry = this.m_clearGeometryDrawCount > 0;
    const willCopyGeometry = this.m_copyGeometryDrawCount > 0;
    if (willClearGeometry || willCopyGeometry) {
      oldRenderTarget = renderer.getRenderTarget();
      renderer.setRenderTarget(this.m_rt);
    }
    if (willClearGeometry) {
      if (!this.m_clearMaterial) {
        this.m_clearMaterial = new GlyphClearMaterial({
          rendererCapabilities: renderer.capabilities
        });
        this.m_clearMesh.material = this.m_clearMaterial;
      }
      if (this.m_clearGeometry.index === null) {
        throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
      }
      this.m_clearPositionAttribute.needsUpdate = true;
      this.m_clearPositionAttribute.updateRange.offset = 0;
      this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;
      this.m_clearGeometry.index.needsUpdate = true;
      this.m_clearGeometry.index.updateRange.offset = 0;
      this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;
      this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);
      this.m_clearMesh.visible = true;
      this.m_copyMesh.visible = false;
      renderer.render(this.m_scene, this.m_camera);
      this.m_clearGeometryDrawCount = 0;
      this.m_clearMesh.visible = false;
    }
    if (willCopyGeometry) {
      if (!this.m_copyMaterial) {
        this.m_copyMaterial = new GlyphCopyMaterial({
          rendererCapabilities: renderer.capabilities
        });
        this.m_copyMesh.material = this.m_copyMaterial;
      }
      if (this.m_copyGeometry.index === null) {
        throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
      }
      this.m_copyVertexBuffer.needsUpdate = true;
      this.m_copyVertexBuffer.updateRange.offset = 0;
      this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;
      this.m_copyGeometry.index.needsUpdate = true;
      this.m_copyGeometry.index.updateRange.offset = 0;
      this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;
      this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);
      this.m_copyMesh.visible = true;
      const srcPages = Array.from(this.m_copyTextureSet);
      const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);
      for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {
        const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;
        this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;
        for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {
          const pageIndex = pageOffset + i;
          if (pageIndex < this.m_copyTextureSet.size) {
            this.m_copyMaterial.uniforms["page" + i].value = srcPages[pageIndex];
          }
        }
        renderer.render(this.m_scene, this.m_camera);
      }
      this.m_copyTextureSet.clear();
      this.m_copyGeometryDrawCount = 0;
    }
    if (willClearGeometry || willCopyGeometry) {
      renderer.setRenderTarget(oldRenderTarget);
    }
  }
  initCacheEntries() {
    const dummyMetrics = {
      size: 0,
      distanceRange: 0,
      base: 0,
      lineHeight: 0,
      lineGap: 0,
      capHeight: 0,
      xHeight: 0
    };
    const dummyFont = {
      name: "",
      metrics: dummyMetrics,
      charset: ""
    };
    const dummyGlyphData = new GlyphData(0, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE67.Texture.DEFAULT_IMAGE, dummyFont);
    for (let i = 0; i < this.m_cacheHeight; i++) {
      for (let j = 0; j < this.m_cacheWidth; j++) {
        const dummyEntry = {
          glyphData: dummyGlyphData,
          location: new THREE67.Vector2(j, i)
        };
        this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);
      }
    }
  }
  copyGlyphToCache(hash, glyph, cacheLocation) {
    this.m_copyTextureSet.add(glyph.texture);
    let copyTextureIndex = 0;
    for (const value2 of this.m_copyTextureSet.values()) {
      if (value2 === glyph.texture) {
        break;
      }
      copyTextureIndex++;
    }
    glyph.copyIndex = copyTextureIndex;
    this.m_copyTransform.set(1, 0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0, 1, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0, 0, 0);
    for (let i = 0; i < 4; ++i) {
      this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);
      this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);
    }
    if (this.m_copyGeometryDrawCount >= this.capacity) {
      return;
    }
    const baseVertex = this.m_copyGeometryDrawCount * 4;
    const baseIndex = this.m_copyGeometryDrawCount * 6;
    for (let i = 0; i < 4; ++i) {
      this.m_copyPositionAttribute.setXYZ(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y, glyph.copyIndex);
      this.m_copyUVAttribute.setXY(baseVertex + i, glyph.sourceTextureCoordinates[i].x, glyph.sourceTextureCoordinates[i].y);
    }
    if (this.m_copyGeometry.index === null) {
      throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
    }
    this.m_copyGeometry.index.setX(baseIndex, baseVertex);
    this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);
    this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);
    this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);
    this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);
    this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);
    ++this.m_copyGeometryDrawCount;
    const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;
    const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;
    const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;
    const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;
    glyph.dynamicTextureCoordinates[0].set(u0, v0);
    glyph.dynamicTextureCoordinates[1].set(u1, v0);
    glyph.dynamicTextureCoordinates[2].set(u0, v1);
    glyph.dynamicTextureCoordinates[3].set(u1, v1);
    glyph.isInCache = true;
    this.m_entryCache.set(hash, {
      glyphData: glyph,
      location: cacheLocation
    });
  }
  clearCacheEntry(entry) {
    entry.glyphData.isInCache = false;
    this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);
    this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);
    this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
    this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
    if (this.m_clearGeometryDrawCount >= this.capacity) {
      return;
    }
    const baseVertex = this.m_clearGeometryDrawCount * 4;
    const baseIndex = this.m_clearGeometryDrawCount * 6;
    for (let i = 0; i < 4; ++i) {
      this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);
    }
    if (this.m_clearGeometry.index === null) {
      throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
    }
    this.m_clearGeometry.index.setX(baseIndex, baseVertex);
    this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);
    this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);
    this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);
    this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);
    this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);
    ++this.m_clearGeometryDrawCount;
  }
};

// src/text-canvas/rendering/TextStyle.ts
var THREE68 = __toESM(require("three"));
var FontStyle = /* @__PURE__ */ ((FontStyle2) => {
  FontStyle2[FontStyle2["Regular"] = 0] = "Regular";
  FontStyle2[FontStyle2["Bold"] = 1] = "Bold";
  FontStyle2[FontStyle2["Italic"] = 2] = "Italic";
  FontStyle2[FontStyle2["BoldItalic"] = 3] = "BoldItalic";
  return FontStyle2;
})(FontStyle || {});
var FontVariant = /* @__PURE__ */ ((FontVariant2) => {
  FontVariant2[FontVariant2["Regular"] = 0] = "Regular";
  FontVariant2[FontVariant2["AllCaps"] = 1] = "AllCaps";
  FontVariant2[FontVariant2["SmallCaps"] = 2] = "SmallCaps";
  return FontVariant2;
})(FontVariant || {});
var VerticalAlignment = /* @__PURE__ */ ((VerticalAlignment3) => {
  VerticalAlignment3[VerticalAlignment3["Above"] = 0] = "Above";
  VerticalAlignment3[VerticalAlignment3["Center"] = -0.5] = "Center";
  VerticalAlignment3[VerticalAlignment3["Below"] = -1] = "Below";
  return VerticalAlignment3;
})(VerticalAlignment || {});
var HorizontalAlignment = /* @__PURE__ */ ((HorizontalAlignment3) => {
  HorizontalAlignment3[HorizontalAlignment3["Left"] = 0] = "Left";
  HorizontalAlignment3[HorizontalAlignment3["Center"] = -0.5] = "Center";
  HorizontalAlignment3[HorizontalAlignment3["Right"] = -1] = "Right";
  return HorizontalAlignment3;
})(HorizontalAlignment || {});
var WrappingMode = /* @__PURE__ */ ((WrappingMode2) => {
  WrappingMode2[WrappingMode2["None"] = 0] = "None";
  WrappingMode2[WrappingMode2["Character"] = 1] = "Character";
  WrappingMode2[WrappingMode2["Word"] = 2] = "Word";
  return WrappingMode2;
})(WrappingMode || {});
function hAlignFromPlacement(hP) {
  return hP;
}
function vAlignFromPlacement(vP) {
  return vP;
}
function hPlacementFromAlignment(hA) {
  return hA;
}
function vPlacementFromAlignment(vA) {
  return vA;
}
var DefaultTextStyle;
((DefaultTextStyle2) => {
  DefaultTextStyle2.DEFAULT_FONT_NAME = "";
  DefaultTextStyle2.DEFAULT_FONT_SIZE = {
    unit: Object.freeze(1 /* Pixel */),
    size: Object.freeze(16),
    backgroundSize: Object.freeze(0)
  };
  DefaultTextStyle2.DEFAULT_FONT_STYLE = 0 /* Regular */;
  DefaultTextStyle2.DEFAULT_FONT_VARIANT = 0 /* Regular */;
  DefaultTextStyle2.DEFAULT_ROTATION = 0;
  DefaultTextStyle2.DEFAULT_COLOR = new THREE68.Color(0);
  DefaultTextStyle2.DEFAULT_OPACITY = 1;
  DefaultTextStyle2.DEFAULT_BACKGROUND_COLOR = new THREE68.Color(0);
  DefaultTextStyle2.DEFAULT_BACKGROUND_OPACITY = 0;
  DefaultTextStyle2.DEFAULT_TRACKING = 0;
  DefaultTextStyle2.DEFAULT_LEADING = 0;
  DefaultTextStyle2.DEFAULT_MAX_LINES = Infinity;
  DefaultTextStyle2.DEFAULT_LINE_WIDTH = Infinity;
  DefaultTextStyle2.DEFAULT_CANVAS_ROTATION = 0;
  DefaultTextStyle2.DEFAULT_LINE_ROTATION = 0;
  DefaultTextStyle2.DEFAULT_WRAPPING_MODE = 2 /* Word */;
  DefaultTextStyle2.DEFAULT_VERTICAL_ALIGNMENT = 0 /* Above */;
  DefaultTextStyle2.DEFAULT_HORIZONTAL_ALIGNMENT = 0 /* Left */;
  DefaultTextStyle2.DEFAULT_PLACEMENTS = [];
})(DefaultTextStyle || (DefaultTextStyle = {}));
var TextRenderStyle = class {
  m_params;
  constructor(params = {}) {
    this.m_params = {
      fontName: params.fontName !== void 0 ? params.fontName : DefaultTextStyle.DEFAULT_FONT_NAME,
      fontSize: params.fontSize !== void 0 ? { ...params.fontSize } : {
        unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,
        size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,
        backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize
      },
      fontStyle: params.fontStyle !== void 0 ? params.fontStyle : DefaultTextStyle.DEFAULT_FONT_STYLE,
      fontVariant: params.fontVariant !== void 0 ? params.fontVariant : DefaultTextStyle.DEFAULT_FONT_VARIANT,
      rotation: params.rotation !== void 0 ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,
      color: params.color !== void 0 ? params.color.clone() : DefaultTextStyle.DEFAULT_COLOR.clone(),
      opacity: params.opacity !== void 0 ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,
      backgroundColor: params.backgroundColor !== void 0 ? params.backgroundColor.clone() : DefaultTextStyle.DEFAULT_BACKGROUND_COLOR.clone(),
      backgroundOpacity: params.backgroundOpacity !== void 0 ? params.backgroundOpacity : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY
    };
  }
  get params() {
    return this.m_params;
  }
  set params(value2) {
    this.m_params = { ...this.m_params, ...value2 };
  }
  get fontName() {
    return this.m_params.fontName;
  }
  set fontName(value2) {
    this.m_params.fontName = value2;
  }
  get fontSize() {
    return this.m_params.fontSize;
  }
  set fontSize(value2) {
    this.m_params.fontSize = { ...value2 };
  }
  get fontStyle() {
    return this.m_params.fontStyle;
  }
  set fontStyle(value2) {
    this.m_params.fontStyle = value2;
  }
  get fontVariant() {
    return this.m_params.fontVariant;
  }
  set fontVariant(value2) {
    this.m_params.fontVariant = value2;
  }
  get rotation() {
    return this.m_params.rotation;
  }
  set rotation(value2) {
    this.m_params.rotation = value2;
  }
  get color() {
    return this.m_params.color;
  }
  set color(value2) {
    this.m_params.color.copy(value2);
  }
  get backgroundColor() {
    return this.m_params.backgroundColor;
  }
  set backgroundColor(value2) {
    this.m_params.backgroundColor.copy(value2);
  }
  get opacity() {
    return this.m_params.opacity;
  }
  set opacity(value2) {
    this.m_params.opacity = value2;
  }
  get backgroundOpacity() {
    return this.m_params.backgroundOpacity;
  }
  set backgroundOpacity(value2) {
    this.m_params.backgroundOpacity = value2;
  }
  clone(params = {}) {
    return new TextRenderStyle({ ...this.m_params, ...params });
  }
  copy(source) {
    this.m_params.fontName = source.fontName;
    this.m_params.fontSize = { ...source.fontSize };
    this.m_params.fontStyle = source.fontStyle;
    this.m_params.fontVariant = source.fontVariant;
    this.m_params.rotation = source.rotation;
    this.m_params.color.copy(source.color);
    this.m_params.backgroundColor.copy(source.backgroundColor);
    this.m_params.opacity = source.opacity;
    this.m_params.backgroundOpacity = source.backgroundOpacity;
    return this;
  }
};
var TextLayoutStyle = class {
  m_params;
  constructor(params = {}) {
    const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(params.horizontalAlignment, params.verticalAlignment, params.placements);
    this.m_params = {
      tracking: params.tracking !== void 0 ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,
      leading: params.leading !== void 0 ? params.leading : DefaultTextStyle.DEFAULT_LEADING,
      maxLines: params.maxLines !== void 0 ? params.maxLines : DefaultTextStyle.DEFAULT_MAX_LINES,
      lineWidth: params.lineWidth !== void 0 ? params.lineWidth : DefaultTextStyle.DEFAULT_LINE_WIDTH,
      canvasRotation: params.canvasRotation !== void 0 ? params.canvasRotation : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,
      lineRotation: params.lineRotation !== void 0 ? params.lineRotation : DefaultTextStyle.DEFAULT_LINE_ROTATION,
      wrappingMode: params.wrappingMode !== void 0 ? params.wrappingMode : DefaultTextStyle.DEFAULT_WRAPPING_MODE,
      verticalAlignment,
      horizontalAlignment,
      placements
    };
  }
  get params() {
    return this.m_params;
  }
  set params(value2) {
    this.m_params = { ...this.m_params, ...value2 };
  }
  get tracking() {
    return this.m_params.tracking;
  }
  set tracking(value2) {
    this.m_params.tracking = value2;
  }
  get leading() {
    return this.m_params.leading;
  }
  set leading(value2) {
    this.m_params.leading = value2;
  }
  get maxLines() {
    return this.m_params.maxLines;
  }
  set maxLines(value2) {
    this.m_params.maxLines = value2;
  }
  get lineWidth() {
    return this.m_params.lineWidth;
  }
  set lineWidth(value2) {
    this.m_params.lineWidth = value2;
  }
  get canvasRotation() {
    return this.m_params.canvasRotation;
  }
  set canvasRotation(value2) {
    this.m_params.canvasRotation = value2;
  }
  get lineRotation() {
    return this.m_params.lineRotation;
  }
  set lineRotation(value2) {
    this.m_params.lineRotation = value2;
  }
  get wrappingMode() {
    return this.m_params.wrappingMode;
  }
  set wrappingMode(value2) {
    this.m_params.wrappingMode = value2;
  }
  get verticalAlignment() {
    return this.m_params.verticalAlignment;
  }
  set verticalAlignment(value2) {
    this.m_params.verticalAlignment = value2;
  }
  get horizontalAlignment() {
    return this.m_params.horizontalAlignment;
  }
  set horizontalAlignment(value2) {
    this.m_params.horizontalAlignment = value2;
  }
  get placements() {
    return this.m_params.placements;
  }
  set placements(value2) {
    const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(this.horizontalAlignment, this.verticalAlignment, value2);
    this.m_params.horizontalAlignment = horizontalAlignment;
    this.m_params.verticalAlignment = verticalAlignment;
    this.m_params.placements = placements;
  }
  clone(params = {}) {
    return new TextLayoutStyle({ ...this.m_params, ...params });
  }
  copy(other) {
    this.params = { ...other.params };
    return this;
  }
};
function resolvePlacementAndAlignment(hAlignment, vAlignment, placementsOpt) {
  const placements = (placementsOpt == null ? void 0 : placementsOpt.map((v) => ({ ...v }))) ?? DefaultTextStyle.DEFAULT_PLACEMENTS.map((v) => ({ ...v }));
  const horizontalAlignment = placements.length > 0 ? hAlignFromPlacement(placements[0].h) : hAlignment ?? DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;
  const verticalAlignment = placements.length > 0 ? vAlignFromPlacement(placements[0].v) : vAlignment ?? DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;
  return { horizontalAlignment, verticalAlignment, placements };
}

// src/text-canvas/rendering/FontCatalog.ts
var ASSETS_PATH = "_Assets/";
var BOLD_ASSETS_PATH = "_BoldAssets/";
var ITALIC_ASSETS_PATH = "_ItalicAssets/";
var BOLD_ITALIC_ASSETS_PATH = "_BoldItalicAssets/";
var REPLACEMENT_PATH = "_Assets/Extra/";
var FontCatalog = class {
  constructor(url, name2, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {
    this.url = url;
    this.name = name2;
    this.type = type;
    this.size = size;
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this.distanceRange = distanceRange;
    this.fonts = fonts;
    this.unicodeBlocks = unicodeBlocks;
    this.maxCodePointCount = maxCodePointCount;
    this.m_replacementGlyph = m_replacementGlyph;
    this.m_glyphTextureCache = new GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);
    this.m_loadingJson = /* @__PURE__ */ new Map();
    this.m_loadingPages = /* @__PURE__ */ new Map();
    this.m_loadingGlyphs = /* @__PURE__ */ new Map();
    this.m_loadedJson = /* @__PURE__ */ new Map();
    this.m_loadedPages = /* @__PURE__ */ new Map();
    this.m_loadedGlyphs = /* @__PURE__ */ new Map();
  }
  static async load(path, maxCodePointCount) {
    const url = new URL(path, window.location.href);
    const fontCatalog = await FontCatalog.loadJSON(url.href);
    const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);
    const replacementJson = await FontCatalog.loadJSON(replacementDirUrl.href + "Specials.json");
    const replacementTexture = await FontCatalog.loadTexture(replacementDirUrl.href + "Specials.png");
    replacementTexture.wrapS = THREE69.ClampToEdgeWrapping;
    replacementTexture.wrapT = THREE69.ClampToEdgeWrapping;
    replacementTexture.minFilter = THREE69.NearestFilter;
    replacementTexture.needsUpdate = true;
    const replacementFont = fontCatalog.fonts.find((font) => font.name === "Extra");
    const replacementGlyph = new GlyphData(65533, "Specials", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0, 0, 1, 1, replacementTexture, replacementFont, true);
    const fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf("/")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);
    return fontCatalogInfo;
  }
  static async loadTexture(url) {
    return await new Promise((resolve) => {
      new THREE69.TextureLoader().load(url, resolve);
    });
  }
  static async loadJSON(url) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`${url} Status Text:  ${response.statusText}`);
    }
    const rawJSON = await response.text();
    return JSON.parse(rawJSON);
  }
  m_glyphTextureCache;
  m_loadingJson;
  m_loadingPages;
  m_loadingGlyphs;
  m_loadedJson;
  m_loadedPages;
  m_loadedGlyphs;
  showReplacementGlyphs = false;
  dispose() {
    this.fonts.length = 0;
    this.unicodeBlocks.length = 0;
    this.m_glyphTextureCache.dispose();
    this.m_loadingJson.clear();
    this.m_loadingPages.clear();
    this.m_loadingGlyphs.clear();
    this.m_loadedJson.clear();
    this.m_loadedPages.clear();
    this.m_loadedGlyphs.clear();
  }
  clear() {
    this.m_glyphTextureCache.clear();
    this.m_loadingJson.clear();
    this.m_loadingPages.clear();
    this.m_loadingGlyphs.clear();
    this.m_loadedJson.clear();
    this.m_loadedPages.clear();
    this.m_loadedGlyphs.clear();
  }
  update(renderer) {
    this.m_glyphTextureCache.update(renderer);
  }
  get texture() {
    return this.m_glyphTextureCache.texture;
  }
  get textureSize() {
    return this.m_glyphTextureCache.textureSize;
  }
  get isLoading() {
    return this.m_loadingJson.size > 0 || this.m_loadingPages.size > 0 || this.m_loadingGlyphs.size > 0;
  }
  async loadBlock(block, font, fontStyle, loadPages) {
    const assetsPath = this.getAssetsPath(fontStyle, font);
    const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
    let json = this.m_loadedJson.get(jsonPath);
    if (json === void 0) {
      let jsonPromise = this.m_loadingJson.get(jsonPath);
      if (jsonPromise === void 0) {
        try {
          jsonPromise = FontCatalog.loadJSON(jsonPath);
          this.m_loadingJson.set(jsonPath, jsonPromise);
          json = await jsonPromise;
          this.m_loadingJson.delete(jsonPath);
          this.m_loadedJson.set(jsonPath, json);
        } catch (e) {
          console.error(e);
          this.m_loadingJson.delete(jsonPath);
        }
      } else {
        json = await jsonPromise;
      }
    }
    const pagePromises = [];
    if (loadPages === true) {
      for (const page of json.pages) {
        pagePromises.push(this.loadPage(`${assetsPath}/${page}`));
      }
    }
    await Promise.all(pagePromises);
    return json;
  }
  removeBlock(block, font, fontStyle) {
    const assetsPath = this.getAssetsPath(fontStyle, font);
    const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
    const json = this.m_loadedJson.get(jsonPath);
    if (json !== void 0) {
      for (const page of json.pages) {
        const pagePath = `${assetsPath}/${page}`;
        this.m_loadingPages.delete(pagePath);
        this.m_loadedPages.delete(pagePath);
      }
      this.m_loadingJson.delete(jsonPath);
      this.m_loadedJson.delete(jsonPath);
    }
  }
  async loadCharset(input, style) {
    const fontName = style.fontName;
    const fontStyle = style.fontStyle;
    const shouldTransform = style.fontVariant === 1 /* AllCaps */ || style.fontVariant === 2 /* SmallCaps */;
    const charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\s\S](?=([\s\S]+))/g, (c, s) => {
      return s.indexOf(c) + 1 ? "" : c;
    });
    const glyphPromises = [];
    for (const char of charset) {
      const codePoint = char.codePointAt(0);
      const font = this.getFont(codePoint, fontName);
      const fontHash = `${font.name}_${fontStyle}`;
      const glyphHash = `${fontHash}_${codePoint}`;
      let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);
      if (fontGlyphMap === void 0) {
        fontGlyphMap = /* @__PURE__ */ new Map();
        this.m_loadedGlyphs.set(fontHash, fontGlyphMap);
      }
      const glyph = fontGlyphMap.get(codePoint);
      if (glyph === void 0) {
        let glyphPromise = this.m_loadingGlyphs.get(glyphHash);
        if (glyphPromise === void 0) {
          if (!font.charset.includes(String.fromCodePoint(codePoint))) {
            const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);
            fontGlyphMap.set(codePoint, replacementGlyph);
            this.m_glyphTextureCache.add(glyphHash, replacementGlyph);
            continue;
          }
          let charUnicodeBlock;
          for (const block of this.unicodeBlocks) {
            if (codePoint >= block.min && codePoint <= block.max) {
              charUnicodeBlock = block;
              break;
            }
          }
          glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);
          this.m_loadingGlyphs.set(glyphHash, glyphPromise);
          glyphPromise.then((loadedGlyph) => {
            this.m_loadingGlyphs.delete(glyphHash);
            fontGlyphMap.set(codePoint, loadedGlyph);
            this.m_glyphTextureCache.add(glyphHash, loadedGlyph);
          });
        }
        glyphPromises.push(glyphPromise);
      } else if (!this.m_glyphTextureCache.has(glyphHash)) {
        glyphPromises.push(Promise.resolve(glyph));
        this.m_glyphTextureCache.add(glyphHash, glyph);
      }
    }
    return Promise.all(glyphPromises);
  }
  getGlyph(codePoint, font, fontStyle) {
    const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);
    if (fontGlyphMap === void 0) {
      return void 0;
    }
    return fontGlyphMap.get(codePoint);
  }
  getGlyphs(input, style, letterCaseArray) {
    const result = [];
    const fontName = style.fontName;
    const fontStyle = style.fontStyle;
    const fontVariant = style.fontVariant;
    const shouldTransform = fontVariant === 1 /* AllCaps */ || fontVariant === 2 /* SmallCaps */;
    for (const character of input) {
      const transformedCharacter = shouldTransform ? character.toUpperCase() : character;
      for (const char of transformedCharacter) {
        const codePoint = char.codePointAt(0);
        const font = this.getFont(codePoint, fontName);
        const glyphData = this.getGlyph(codePoint, font, fontStyle);
        if (glyphData !== void 0 && (!glyphData.isReplacement || this.showReplacementGlyphs)) {
          result.push(glyphData);
          if (letterCaseArray !== void 0) {
            letterCaseArray.push(char !== character);
          }
        } else {
          return void 0;
        }
      }
    }
    return result;
  }
  getFont(codePoint, fontName) {
    let selectedFontName = this.fonts[0].name;
    for (const block of this.unicodeBlocks) {
      if (codePoint >= block.min && codePoint <= block.max) {
        selectedFontName = fontName !== void 0 && block.fonts.find((element) => {
          return element === fontName;
        }) !== void 0 ? fontName : block.fonts[0];
        break;
      }
    }
    return this.fonts.find((element) => {
      return element.name === selectedFontName;
    });
  }
  updateMemoryUsage(info) {
    let numBytes = 0;
    for (const block of this.unicodeBlocks) {
      numBytes += (block.max - block.min) * 2;
    }
    let textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;
    for (const page in this.m_loadedPages.entries) {
      if (this.m_loadedPages.get(page) !== void 0) {
        const loadedPage = this.m_loadedPages.get(page);
        if (loadedPage !== void 0) {
          textureBytes += loadedPage.image.width * loadedPage.image.height * 4;
        }
      }
    }
    info.heapSize += numBytes + textureBytes;
    info.gpuSize += textureBytes;
  }
  createReplacementGlyph(codePoint, char, font) {
    const replacementGlyph = this.m_replacementGlyph.clone();
    replacementGlyph.codePoint = codePoint;
    replacementGlyph.character = char;
    replacementGlyph.font = font;
    replacementGlyph.isReplacement = UnicodeUtils.isPrintable(codePoint);
    return replacementGlyph;
  }
  async loadAssets(codePoint, fontStyle, block, font) {
    const json = await this.loadBlock(block, font, fontStyle);
    if (json === void 0) {
      return this.m_replacementGlyph;
    }
    const sourceGlyphData = json.chars.find((char) => char.id === codePoint);
    const assetsPath = this.getAssetsPath(fontStyle, font);
    const texturePath = `${assetsPath}/${json.pages[sourceGlyphData.page]}`;
    const texture = await this.loadPage(texturePath);
    const glyphData = new GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1 - sourceGlyphData.y / texture.image.height, texture, font);
    return glyphData;
  }
  async loadPage(pagePath) {
    let page = this.m_loadedPages.get(pagePath);
    if (page === void 0) {
      let pagePromise = this.m_loadingPages.get(pagePath);
      if (pagePromise === void 0) {
        pagePromise = FontCatalog.loadTexture(pagePath);
        this.m_loadingPages.set(pagePath, pagePromise);
        page = await pagePromise;
        page.wrapS = THREE69.ClampToEdgeWrapping;
        page.wrapT = THREE69.ClampToEdgeWrapping;
        page.minFilter = THREE69.NearestFilter;
        page.needsUpdate = true;
        if (this.m_loadingPages.delete(pagePath)) {
          this.m_loadedPages.set(pagePath, page);
        }
        this.m_loadingPages.delete(pagePath);
      } else {
        page = await pagePromise;
      }
    }
    return page;
  }
  getAssetsPath(fontStyle, font) {
    let fontStylePath = ASSETS_PATH;
    switch (fontStyle) {
      case 1 /* Bold */:
        if (font.bold !== void 0) {
          fontStylePath = BOLD_ASSETS_PATH;
        }
        break;
      case 2 /* Italic */:
        if (font.italic !== void 0) {
          fontStylePath = ITALIC_ASSETS_PATH;
        }
        break;
      case 3 /* BoldItalic */:
        if (font.boldItalic !== void 0) {
          fontStylePath = BOLD_ITALIC_ASSETS_PATH;
        } else if (font.italic !== void 0) {
          fontStylePath = ITALIC_ASSETS_PATH;
        } else if (font.bold !== void 0) {
          fontStylePath = BOLD_ASSETS_PATH;
        }
        break;
    }
    return `${this.url}/${this.name}${fontStylePath}${font.name}`;
  }
};

// src/text-canvas/rendering/TextBufferObject.ts
var TextBufferObject = class {
  constructor(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {
    this.glyphs = glyphs;
    this.buffer = buffer;
    this.bounds = bounds;
    this.characterBounds = characterBounds;
    this.textRenderStyle = textRenderStyle;
    this.textLayoutStyle = textLayoutStyle;
  }
};

// src/text-canvas/rendering/TextGeometry.ts
var THREE70 = __toESM(require("three"));
var MAX_CAPACITY = 65536;
var VERTEX_BUFFER_STRIDE = 16;
var INDEX_BUFFER_STRIDE = 1;
var VERTICES_PER_QUAD = 4;
var INDICES_PER_QUAD = 6;
var QUAD_VERTEX_MEMORY_FOOTPRINT = VERTICES_PER_QUAD * VERTEX_BUFFER_STRIDE;
var QUAD_INDEX_MEMORY_FOOTPRINT = INDICES_PER_QUAD * INDEX_BUFFER_STRIDE;
var NUM_BYTES_PER_FLOAT = 4;
var NUM_BYTES_PER_INT32 = 4;
var TextGeometry = class {
  constructor(scene, material, backgroundMaterial, initialSize, capacity) {
    this.scene = scene;
    this.capacity = Math.min(capacity, MAX_CAPACITY);
    this.m_currentCapacity = Math.min(initialSize, capacity);
    this.m_drawCount = 0;
    this.m_updateOffset = 0;
    this.m_vertexBuffer = new THREE70.InterleavedBuffer(new Float32Array(this.m_currentCapacity * QUAD_VERTEX_MEMORY_FOOTPRINT), VERTEX_BUFFER_STRIDE);
    this.m_vertexBuffer.setUsage(THREE70.DynamicDrawUsage);
    this.m_positionAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
    this.m_uvAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
    this.m_colorAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
    this.m_bgColorAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
    this.m_indexBuffer = new THREE70.BufferAttribute(new Uint32Array(this.m_currentCapacity * QUAD_INDEX_MEMORY_FOOTPRINT), INDEX_BUFFER_STRIDE);
    this.m_indexBuffer.setUsage(THREE70.DynamicDrawUsage);
    this.m_geometry = new THREE70.BufferGeometry();
    this.m_geometry.setAttribute("position", this.m_positionAttribute);
    this.m_geometry.setAttribute("uv", this.m_uvAttribute);
    this.m_geometry.setAttribute("color", this.m_colorAttribute);
    this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
    this.m_geometry.setIndex(this.m_indexBuffer);
    this.m_mesh = new THREE70.Mesh(this.m_geometry, material);
    this.m_bgMesh = new THREE70.Mesh(this.m_geometry, backgroundMaterial);
    this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
    this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
    this.m_mesh.frustumCulled = false;
    this.m_bgMesh.frustumCulled = false;
    this.scene.add(this.m_bgMesh, this.m_mesh);
  }
  get drawCount() {
    return this.m_drawCount;
  }
  get mesh() {
    return this.m_mesh;
  }
  get backgroundMesh() {
    return this.m_bgMesh;
  }
  capacity;
  m_currentCapacity;
  m_drawCount;
  m_updateOffset;
  m_vertexBuffer;
  m_positionAttribute;
  m_uvAttribute;
  m_colorAttribute;
  m_bgColorAttribute;
  m_indexBuffer;
  m_geometry;
  m_mesh;
  m_bgMesh;
  m_pickingDataArray = [];
  dispose() {
    this.scene.remove(this.m_bgMesh, this.m_mesh);
    this.m_geometry.dispose();
  }
  clear() {
    this.m_drawCount = 0;
    this.m_updateOffset = 0;
    this.m_pickingDataArray.length = 0;
  }
  update() {
    if (this.drawCount > this.m_updateOffset) {
      this.m_vertexBuffer.needsUpdate = true;
      this.m_vertexBuffer.updateRange.offset = this.m_updateOffset * QUAD_VERTEX_MEMORY_FOOTPRINT;
      this.m_vertexBuffer.updateRange.count = (this.m_drawCount - this.m_updateOffset) * QUAD_VERTEX_MEMORY_FOOTPRINT;
      this.m_indexBuffer.needsUpdate = true;
      this.m_indexBuffer.updateRange.offset = this.m_updateOffset * QUAD_INDEX_MEMORY_FOOTPRINT;
      this.m_indexBuffer.updateRange.count = (this.m_drawCount - this.m_updateOffset) * QUAD_INDEX_MEMORY_FOOTPRINT;
    }
    this.m_updateOffset = this.m_drawCount;
    this.m_geometry.setDrawRange(0, this.m_drawCount * INDICES_PER_QUAD);
  }
  add(glyphData, corners, weight, bgWeight, mirrored, style) {
    if (this.m_drawCount >= this.capacity) {
      return false;
    } else if (this.m_drawCount >= this.m_currentCapacity) {
      const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
      this.resizeBuffers(newSize);
    }
    const baseVertex = this.m_drawCount * VERTICES_PER_QUAD;
    const baseIndex = this.m_drawCount * INDICES_PER_QUAD;
    for (let i = 0; i < VERTICES_PER_QUAD; ++i) {
      this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1 : 1) * style.rotation);
      const mirroredUVIdx = mirrored ? (i + 1) % 2 + Math.floor(i / 2) * 2 : i;
      this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);
      this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);
      this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);
    }
    this.m_indexBuffer.setX(baseIndex, baseVertex);
    this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);
    this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);
    this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);
    this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);
    this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);
    ++this.m_drawCount;
    return true;
  }
  addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {
    for (let i = 0; i < VERTICES_PER_QUAD; ++i) {
      const vertexOffset = offset + VERTEX_BUFFER_STRIDE * i;
      buffer[vertexOffset] = corners[i].x;
      buffer[vertexOffset + 1] = corners[i].y;
      buffer[vertexOffset + 2] = corners[i].z;
      buffer[vertexOffset + 3] = (mirrored ? -1 : 1) * style.rotation;
      const mirroredUVIdx = mirrored ? (i + 1) % 2 + Math.floor(i / 2) * 2 : i;
      buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;
      buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;
      buffer[vertexOffset + 6] = weight;
      buffer[vertexOffset + 7] = bgWeight;
      buffer[vertexOffset + 8] = style.color.r;
      buffer[vertexOffset + 9] = style.color.g;
      buffer[vertexOffset + 10] = style.color.b;
      buffer[vertexOffset + 11] = style.opacity;
      buffer[vertexOffset + 12] = style.backgroundColor.r;
      buffer[vertexOffset + 13] = style.backgroundColor.g;
      buffer[vertexOffset + 14] = style.backgroundColor.b;
      buffer[vertexOffset + 15] = style.backgroundOpacity;
    }
  }
  addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {
    if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {
      return false;
    } else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {
      const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
      this.resizeBuffers(newSize);
    }
    const s = scale ?? 1;
    const r = rotation ?? 0;
    const cosR = Math.cos(r);
    const sinR = Math.sin(r);
    const offsetX = position !== void 0 ? position.x : 0;
    const offsetY = position !== void 0 ? position.y : 0;
    const offsetZ = 0;
    const buffer = textBufferObject.buffer;
    const rot = buffer[3];
    const rotSign = rot < 0 ? -1 : 1;
    const red = color !== void 0 ? color.r : buffer[8];
    const green = color !== void 0 ? color.g : buffer[9];
    const blue = color !== void 0 ? color.b : buffer[10];
    const alpha = opacity !== void 0 ? opacity : buffer[11];
    const bgRed = bgColor !== void 0 ? bgColor.r : buffer[12];
    const bgGreen = bgColor !== void 0 ? bgColor.g : buffer[13];
    const bgBlue = bgColor !== void 0 ? bgColor.b : buffer[14];
    const bgAlpha = bgOpacity !== void 0 ? bgOpacity : buffer[15];
    const targetOffset = this.m_drawCount * VERTICES_PER_QUAD;
    for (let i = 0; i < textBufferObject.glyphs.length; ++i) {
      const srcOffset = i * QUAD_VERTEX_MEMORY_FOOTPRINT;
      const glyph = textBufferObject.glyphs[i];
      if (!glyph.isInCache) {
        return false;
      }
      const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + VERTEX_BUFFER_STRIDE + 4];
      const w = buffer[srcOffset + 6];
      const bw = buffer[srcOffset + 7];
      for (let j = 0; j < VERTICES_PER_QUAD; ++j) {
        const x = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE];
        const y = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 1];
        this.m_positionAttribute.setXYZW(targetOffset + i * VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 3] + rotSign * r);
        const mirroredUVIdx = mirrored ? (j + 1) % 2 + Math.floor(j / 2) * 2 : j;
        this.m_uvAttribute.setXYZW(targetOffset + i * VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);
        this.m_colorAttribute.setXYZW(targetOffset + i * VERTICES_PER_QUAD + j, red, green, blue, alpha);
        this.m_bgColorAttribute.setXYZW(targetOffset + i * VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);
      }
      this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD, (this.m_drawCount + i) * VERTICES_PER_QUAD);
      this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 1, (this.m_drawCount + i) * VERTICES_PER_QUAD + 1);
      this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 2, (this.m_drawCount + i) * VERTICES_PER_QUAD + 2);
      this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 3, (this.m_drawCount + i) * VERTICES_PER_QUAD + 2);
      this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 4, (this.m_drawCount + i) * VERTICES_PER_QUAD + 1);
      this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 5, (this.m_drawCount + i) * VERTICES_PER_QUAD + 3);
    }
    this.m_drawCount += textBufferObject.glyphs.length;
    return true;
  }
  addPickingData(startIdx, endIdx, pickingData) {
    if (this.m_pickingDataArray.length >= this.m_currentCapacity) {
      return false;
    }
    this.m_pickingDataArray.push({
      start: Math.min(startIdx, this.capacity),
      end: Math.min(endIdx, this.capacity),
      data: pickingData
    });
    return true;
  }
  pick(screenPosition, pickCallback) {
    for (const pickingData of this.m_pickingDataArray) {
      if (pickingData === void 0) {
        return;
      }
      for (let i = pickingData.start; i < pickingData.end; ++i) {
        const positionIndex = i * VERTICES_PER_QUAD;
        const minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
        if (screenPosition.x < minX) {
          continue;
        }
        const maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
        if (screenPosition.x > maxX) {
          continue;
        }
        const minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
        if (screenPosition.y < minY) {
          continue;
        }
        const maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
        if (screenPosition.y > maxY) {
          continue;
        }
        pickCallback(pickingData.data);
        break;
      }
    }
  }
  updateMemoryUsage(info) {
    const numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT + this.m_indexBuffer.count * NUM_BYTES_PER_INT32;
    info.heapSize += numBytes;
    info.gpuSize += numBytes;
  }
  resizeBuffers(size) {
    this.m_currentCapacity = size;
    const newVertexBuffer = new Float32Array(size * QUAD_VERTEX_MEMORY_FOOTPRINT);
    newVertexBuffer.set(this.m_vertexBuffer.array);
    this.m_vertexBuffer = new THREE70.InterleavedBuffer(newVertexBuffer, VERTEX_BUFFER_STRIDE);
    this.m_vertexBuffer.setUsage(THREE70.DynamicDrawUsage);
    this.m_positionAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
    this.m_uvAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
    this.m_colorAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
    this.m_bgColorAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
    const newIndexBuffer = new Uint32Array(size * QUAD_INDEX_MEMORY_FOOTPRINT);
    newIndexBuffer.set(this.m_indexBuffer.array);
    this.m_indexBuffer = new THREE70.BufferAttribute(newIndexBuffer, INDEX_BUFFER_STRIDE);
    this.m_indexBuffer.setUsage(THREE70.DynamicDrawUsage);
    this.m_geometry.dispose();
    this.m_geometry = new THREE70.BufferGeometry();
    this.m_geometry.setAttribute("position", this.m_positionAttribute);
    this.m_geometry.setAttribute("uv", this.m_uvAttribute);
    this.m_geometry.setAttribute("color", this.m_colorAttribute);
    this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
    this.m_geometry.setIndex(this.m_indexBuffer);
    this.m_pickingDataArray.length = this.m_currentCapacity;
    this.scene.remove(this.m_bgMesh, this.m_mesh);
    this.m_mesh = new THREE70.Mesh(this.m_geometry, this.m_mesh.material);
    this.m_bgMesh = new THREE70.Mesh(this.m_geometry, this.m_bgMesh.material);
    this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
    this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
    this.m_mesh.frustumCulled = false;
    this.m_bgMesh.frustumCulled = false;
    this.scene.add(this.m_bgMesh, this.m_mesh);
  }
};

// src/text-canvas/TextCanvas.ts
var THREE74 = __toESM(require("three"));

// src/text-canvas/typesetting/LineTypesetter.ts
var THREE72 = __toESM(require("three"));

// src/text-canvas/utils/TypesettingUtils.ts
var THREE71 = __toESM(require("three"));
var TypesettingUtils;
((TypesettingUtils2) => {
  TypesettingUtils2.EM_TO_PX = 16;
  TypesettingUtils2.PT_TO_PX = 1.25;
  TypesettingUtils2.OBLIQUE_ANGLE = 0.174533;
  TypesettingUtils2.OBLIQUE_OFFSET = Math.tan(TypesettingUtils2.OBLIQUE_ANGLE);
  function getPixelSize(size, unit, originalSize) {
    let result = size;
    switch (unit) {
      case 0 /* Em */:
        result *= TypesettingUtils2.EM_TO_PX;
        break;
      case 2 /* Point */:
        result *= TypesettingUtils2.PT_TO_PX;
        break;
      case 3 /* Percent */:
        result *= 1 / 100 * originalSize;
        break;
    }
    return result;
  }
  TypesettingUtils2.getPixelSize = getPixelSize;
  function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {
    const isSmallCaps = smallCapsTransformations[index] && fontVariant === 2 /* SmallCaps */;
    return isSmallCaps ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight : 1;
  }
  TypesettingUtils2.getSmallCapsScale = getSmallCapsScale;
  function getDirection(glyphs, offset) {
    let result = UnicodeUtils.Direction.LTR;
    let index = offset;
    while (glyphs[index].direction !== UnicodeUtils.Direction.LTR && glyphs[index].direction !== UnicodeUtils.Direction.RTL && index < glyphs.length - 1) {
      ++index;
    }
    if (Math.abs(glyphs[index].direction) === 1) {
      result = glyphs[index].direction;
    }
    return result;
  }
  TypesettingUtils2.getDirection = getDirection;
  function computeGlyphTransform(transform, position, scale, rotation, localRotation) {
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(rotation);
    const localCosAngle = Math.cos(localRotation);
    const localSinAngle = Math.sin(localRotation);
    transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1);
  }
  TypesettingUtils2.computeGlyphTransform = computeGlyphTransform;
  function updateBounds(corners, globalBounds, individualBounds) {
    const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
    const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
    const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
    const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
    if (individualBounds !== void 0) {
      if (individualBounds.array[individualBounds.offset] !== void 0) {
        individualBounds.array[individualBounds.offset].min.set(minX, minY);
        individualBounds.array[individualBounds.offset].max.set(maxX, maxY);
      } else {
        individualBounds.array.push(new THREE71.Box2(new THREE71.Vector2(minX, minY), new THREE71.Vector2(maxX, maxY)));
      }
      ++individualBounds.offset;
    }
    globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));
    globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));
  }
  TypesettingUtils2.updateBounds = updateBounds;
})(TypesettingUtils || (TypesettingUtils = {}));

// src/text-canvas/typesetting/LineTypesetter.ts
var LineTypesetter = class {
  m_tempTransform;
  m_tempCorners;
  m_tempLineDirection;
  m_tempRunDirection;
  m_tempPixelSize;
  m_tempPixelBgSize;
  m_tempScale;
  m_tempSmallCaps;
  m_currentParams;
  constructor() {
    this.m_tempTransform = new THREE72.Matrix3();
    this.m_tempCorners = [
      new THREE72.Vector3(),
      new THREE72.Vector3(),
      new THREE72.Vector3(),
      new THREE72.Vector3()
    ];
    this.m_tempLineDirection = UnicodeUtils.Direction.LTR;
    this.m_tempRunDirection = UnicodeUtils.Direction.LTR;
    this.m_tempPixelSize = 1;
    this.m_tempPixelBgSize = 1;
    this.m_tempScale = 1;
    this.m_tempSmallCaps = false;
  }
  arrangeGlyphs(params) {
    this.m_currentParams = params;
    this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
    this.m_tempRunDirection = this.m_tempLineDirection;
    this.m_tempPixelSize = TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
    this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
    this.m_tempPixelBgSize = Math.min(TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
    this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== void 0;
    this.m_currentParams.position.y += this.m_currentParams.textLayoutStyle.verticalAlignment * this.m_currentParams.glyphs[0].font.metrics.capHeight * this.m_tempScale;
    const isOnlyMeasured = this.m_currentParams.globalBounds !== void 0 && this.m_currentParams.vertexBuffer === void 0;
    const origin = this.m_currentParams.position.x;
    const lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight + this.m_currentParams.textLayoutStyle.leading;
    let lineStartIdx = 0;
    let glyphWrapIdx = 0;
    let wordWrapIdx = 0;
    let lineStartX = 0;
    let lineCurrX = 0;
    let glyphWrapX = 0;
    let wordWrapX = 0;
    let lineCount = 0;
    let isBidirectionalLine = false;
    for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
      if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {
        break;
      }
      const glyphData = this.m_currentParams.glyphs[i];
      if (!glyphData.isInCache && !isOnlyMeasured) {
        return false;
      }
      const isNewLine = UnicodeUtils.isNewLine(glyphData.codePoint);
      const isWhiteSpace = UnicodeUtils.isWhiteSpace(glyphData.codePoint);
      if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {
        isBidirectionalLine = true;
      }
      if (UnicodeUtils.isPrintable(glyphData.codePoint)) {
        lineCurrX += (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) * this.m_tempScale * (this.m_tempSmallCaps ? TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant) : 1);
      }
      if (i === lineStartIdx) {
        lineStartX = lineCurrX;
        glyphWrapX = lineCurrX;
        wordWrapX = lineCurrX;
      }
      if (isNewLine || this.m_currentParams.textLayoutStyle.wrappingMode === 1 /* Character */ && lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth || this.m_currentParams.textLayoutStyle.wrappingMode === 2 /* Word */ && lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth && wordWrapX !== lineStartX) {
        if (this.m_currentParams.textLayoutStyle.wrappingMode !== 0 /* None */) {
          let wrapPointIdx = glyphWrapIdx;
          let wrapPointX = glyphWrapX;
          if (this.m_currentParams.textLayoutStyle.wrappingMode === 2 /* Word */ && wordWrapX !== lineStartX) {
            wrapPointIdx = wordWrapIdx;
            wrapPointX = wordWrapX;
          }
          lineCurrX = wrapPointX;
          i = Math.min(isNewLine ? lineStartIdx === i ? wrapPointIdx : i : wrapPointIdx, this.m_currentParams.glyphs.length - 1);
        }
        const lineAlignment = this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine ? 1 + this.m_currentParams.textLayoutStyle.horizontalAlignment : this.m_currentParams.textLayoutStyle.horizontalAlignment;
        this.m_currentParams.position.x = this.m_currentParams.position.x + lineCurrX * lineAlignment;
        if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {
          return false;
        }
        this.m_currentParams.position.y -= lineHeight * this.m_tempScale;
        this.m_currentParams.position.x = origin;
        while (i !== lineStartIdx && i + 1 < this.m_currentParams.glyphs.length && UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)) {
          ++i;
        }
        lineStartIdx = i + 1;
        if (lineStartIdx === this.m_currentParams.glyphs.length) {
          break;
        }
        if (isNewLine) {
          this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);
          this.m_tempRunDirection = this.m_tempLineDirection;
        }
        lineStartX = 0;
        lineCurrX = 0;
        glyphWrapIdx = lineStartIdx;
        glyphWrapX = 0;
        wordWrapIdx = lineStartIdx;
        wordWrapX = 0;
        isBidirectionalLine = false;
        lineCount++;
      } else if (this.m_currentParams.textLayoutStyle.wrappingMode !== 0 /* None */ && !isWhiteSpace) {
        glyphWrapIdx = i;
        glyphWrapX = lineCurrX;
        if (this.m_currentParams.textLayoutStyle.wrappingMode === 2 /* Word */ && i + 1 < this.m_currentParams.glyphs.length && (UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) || UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {
          wordWrapIdx = i;
          wordWrapX = lineCurrX;
        }
      }
    }
    if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 && lineStartIdx <= this.m_currentParams.glyphs.length - 1) {
      const offset = this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine ? 1 + this.m_currentParams.textLayoutStyle.horizontalAlignment : this.m_currentParams.textLayoutStyle.horizontalAlignment;
      this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);
      if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {
        return false;
      }
    }
    return true;
  }
  placeLine(startIdx, endIdx, direction, isBidirectional) {
    if (!isBidirectional) {
      return this.placeRun(startIdx, endIdx, direction);
    }
    const glyphDataArray = this.m_currentParams.glyphs;
    const smallCapsArray = this.m_currentParams.smallCapsArray;
    const textRenderStyle = this.m_currentParams.textRenderStyle;
    const textLayoutStyle = this.m_currentParams.textLayoutStyle;
    const position = this.m_currentParams.position;
    const isRTL = direction === UnicodeUtils.Direction.RTL;
    const origin = position.x;
    let offset = 0;
    let runStart = startIdx;
    for (let i = startIdx; i <= endIdx; ++i) {
      const glyphData = glyphDataArray[i];
      if (glyphData.direction === -this.m_tempRunDirection) {
        if (isRTL) {
          position.x = origin + offset;
        }
        if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
          return false;
        }
        if (!isRTL) {
          position.x = origin + offset;
        }
        runStart = i;
        this.m_tempRunDirection *= -1;
      } else if (glyphData.direction === UnicodeUtils.Direction.Neutral && this.m_tempRunDirection === -direction) {
        let neutralIdx = i;
        while (neutralIdx + 1 < glyphDataArray.length && Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
          ++neutralIdx;
        }
        if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
          if (isRTL) {
            position.x = origin + offset;
          }
          if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
            return false;
          }
          if (!isRTL) {
            position.x = origin + offset;
          }
          runStart = i;
          this.m_tempRunDirection *= -1;
        }
      }
      offset += (glyphData.advanceX + textLayoutStyle.tracking) * this.m_tempScale * (this.m_tempSmallCaps ? TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant) : 1) * direction;
    }
    if (runStart <= endIdx) {
      if (isRTL) {
        position.x = origin + offset;
      }
      if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {
        return false;
      }
      if (!isRTL) {
        position.x = origin + offset;
      }
    }
    return true;
  }
  placeRun(startIdx, endIdx, direction) {
    const glyphDataArray = this.m_currentParams.glyphs;
    const smallCapsArray = this.m_currentParams.smallCapsArray;
    const fontCatalog = this.m_currentParams.fontCatalog;
    const textRenderStyle = this.m_currentParams.textRenderStyle;
    const textLayoutStyle = this.m_currentParams.textLayoutStyle;
    const position = this.m_currentParams.position;
    const geometry = this.m_currentParams.geometry;
    const globalBounds = this.m_currentParams.globalBounds;
    const individualBounds = this.m_currentParams.individualBounds;
    const vertexBuffer = this.m_currentParams.vertexBuffer;
    const start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;
    const end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;
    for (let i = start; direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
      const glyphData = glyphDataArray[i];
      if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {
        continue;
      }
      if (startIdx !== endIdx && i !== 0 && direction === UnicodeUtils.Direction.RTL && glyphData.direction === UnicodeUtils.Direction.Weak) {
        let weakRunStart = i;
        let weakGlyph = glyphDataArray[weakRunStart - 1];
        while (weakRunStart !== startIdx && (weakGlyph.direction === UnicodeUtils.Direction.Weak || weakGlyph.direction === UnicodeUtils.Direction.Neutral && !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint))) {
          --weakRunStart;
          weakGlyph = glyphDataArray[weakRunStart - 1];
        }
        this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);
        i = weakRunStart;
        continue;
      }
      const glyphFont = glyphData.font;
      const glyphFontMetrics = glyphFont.metrics;
      const fontStyle = textRenderStyle.fontStyle;
      const isBoldEmulated = fontStyle === 1 /* Bold */ && glyphFont.bold === void 0 || fontStyle === 3 /* BoldItalic */ && glyphFont.bold === void 0 && glyphFont.boldItalic === void 0;
      const isItalicEmulated = fontStyle === 2 /* Italic */ && glyphFont.italic === void 0 || fontStyle === 3 /* BoldItalic */ && glyphFont.italic === void 0 && glyphFont.boldItalic === void 0;
      const isSmallCaps = this.m_tempSmallCaps ? smallCapsArray[i] && textRenderStyle.fontVariant === 2 /* SmallCaps */ : false;
      const smallCapsScale = isSmallCaps ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight : 1;
      const glyphScale = this.m_tempScale * smallCapsScale;
      const emulationWeight = ((isBoldEmulated ? 0.02 : 0) + (isSmallCaps ? 0.01 : 0)) * (fontCatalog.size / fontCatalog.distanceRange);
      const bgWeight = 0.5 * this.m_tempPixelBgSize / (fontCatalog.distanceRange * Math.max(glyphScale, 1));
      const isMirrored = UnicodeUtils.isRtlMirrored(glyphData.codePoint) && direction === UnicodeUtils.Direction.RTL;
      const verticalOffset = glyphFontMetrics.lineHeight - glyphFontMetrics.base - glyphFontMetrics.distanceRange * 0.5;
      TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);
      for (let j = 0; j < 4; ++j) {
        const glyphVertexPosition = glyphData.positions[j];
        const horizontalOffset = isItalicEmulated && j > 1 ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size : 0;
        this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
        this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
      }
      if (globalBounds === void 0 && vertexBuffer === void 0) {
        if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
          return false;
        }
      } else {
        if (globalBounds !== void 0) {
          TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
        }
        if (vertexBuffer !== void 0) {
          geometry.addToBuffer(vertexBuffer, i * QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
        }
      }
      position.set(position.x + (glyphData.advanceX + textLayoutStyle.tracking) * glyphScale * Math.cos(textLayoutStyle.lineRotation), position.y + (glyphData.advanceX + textLayoutStyle.tracking) * glyphScale * Math.sin(textLayoutStyle.lineRotation), position.z);
    }
    return true;
  }
};

// src/text-canvas/typesetting/PathTypesetter.ts
var THREE73 = __toESM(require("three"));
var PathTypesetter = class {
  m_tempTransform;
  m_tempCorners;
  m_tempLineDirection;
  m_tempRunDirection;
  m_tempPixelSize;
  m_tempPixelBgSize;
  m_tempScale;
  m_tempSmallCaps;
  m_tempPathPosition;
  m_tempPathLength;
  m_tempPathOffset;
  m_currentParams;
  constructor() {
    this.m_tempTransform = new THREE73.Matrix3();
    this.m_tempCorners = [
      new THREE73.Vector3(),
      new THREE73.Vector3(),
      new THREE73.Vector3(),
      new THREE73.Vector3()
    ];
    this.m_tempLineDirection = UnicodeUtils.Direction.LTR;
    this.m_tempRunDirection = UnicodeUtils.Direction.LTR;
    this.m_tempPixelSize = 1;
    this.m_tempPixelBgSize = 1;
    this.m_tempScale = 1;
    this.m_tempSmallCaps = false;
    this.m_tempPathPosition = new THREE73.Vector3();
    this.m_tempPathLength = 0;
    this.m_tempPathOffset = 0;
  }
  arrangeGlyphs(params) {
    this.m_currentParams = params;
    this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
    this.m_tempRunDirection = this.m_tempLineDirection;
    this.m_tempPixelSize = TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
    this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
    this.m_tempPixelBgSize = Math.min(TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
    this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== void 0;
    this.m_tempPathLength = this.m_currentParams.path.getLength();
    this.m_tempPathOffset = 0;
    const isOnlyMeasured = this.m_currentParams.globalBounds !== void 0 && this.m_currentParams.vertexBuffer === void 0;
    let isBidirectional = false;
    let pathWidth = 0;
    for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
      const glyphData = this.m_currentParams.glyphs[i];
      if (!glyphData.isInCache && !isOnlyMeasured) {
        return false;
      }
      if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {
        continue;
      }
      if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {
        isBidirectional = true;
      }
      pathWidth += (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) * this.m_tempScale * (this.m_tempSmallCaps ? TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant) : 1);
    }
    this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment + this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth / this.m_tempPathLength, 0), 1);
    return this.placeLine(this.m_tempLineDirection, isBidirectional);
  }
  placeLine(direction, isBidirectional) {
    if (!isBidirectional) {
      return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);
    }
    const glyphDataArray = this.m_currentParams.glyphs;
    let runStart = 0;
    for (let i = runStart; i < glyphDataArray.length; ++i) {
      const glyphData = glyphDataArray[i];
      if (glyphData.direction === -this.m_tempRunDirection) {
        if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
          return false;
        }
        runStart = i;
        this.m_tempRunDirection *= -1;
      } else if (glyphData.direction === UnicodeUtils.Direction.Neutral && this.m_tempRunDirection === -direction) {
        let neutralIdx = i;
        while (neutralIdx + 1 < glyphDataArray.length && Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
          ++neutralIdx;
        }
        if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
          if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
            return false;
          }
          runStart = i;
          this.m_tempRunDirection *= -1;
        }
      }
    }
    if (runStart < glyphDataArray.length) {
      if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {
        return false;
      }
    }
    return true;
  }
  placeRun(startIdx, endIdx, direction) {
    const glyphDataArray = this.m_currentParams.glyphs;
    const smallCapsArray = this.m_currentParams.smallCapsArray;
    const fontCatalog = this.m_currentParams.fontCatalog;
    const textRenderStyle = this.m_currentParams.textRenderStyle;
    const textLayoutStyle = this.m_currentParams.textLayoutStyle;
    const position = this.m_currentParams.position;
    const geometry = this.m_currentParams.geometry;
    const globalBounds = this.m_currentParams.globalBounds;
    const individualBounds = this.m_currentParams.individualBounds;
    const vertexBuffer = this.m_currentParams.vertexBuffer;
    const path = this.m_currentParams.path;
    const defaultGlyphRotation = textRenderStyle.rotation;
    const normalDisplacement = textLayoutStyle.verticalAlignment * glyphDataArray[0].font.metrics.capHeight * this.m_tempScale;
    const start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;
    const end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;
    for (let i = start; direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
      const glyphData = glyphDataArray[i];
      if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {
        continue;
      }
      if (startIdx !== endIdx && i !== 0 && direction === UnicodeUtils.Direction.RTL && glyphData.direction === UnicodeUtils.Direction.Weak) {
        let weakRunStart = i;
        let weakGlyph = glyphDataArray[weakRunStart - 1];
        while (weakRunStart !== startIdx && (weakGlyph.direction === UnicodeUtils.Direction.Weak || weakGlyph.direction === UnicodeUtils.Direction.Neutral && !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint))) {
          --weakRunStart;
          weakGlyph = glyphDataArray[weakRunStart - 1];
        }
        this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);
        i = weakRunStart;
        continue;
      }
      const glyphFont = glyphData.font;
      const glyphFontMetrics = glyphFont.metrics;
      const fontStyle = textRenderStyle.fontStyle;
      const isBoldEmulated = fontStyle === 1 /* Bold */ && glyphFont.bold === void 0 || fontStyle === 3 /* BoldItalic */ && glyphFont.bold === void 0 && glyphFont.boldItalic === void 0;
      const isItalicEmulated = fontStyle === 2 /* Italic */ && glyphFont.italic === void 0 || fontStyle === 3 /* BoldItalic */ && glyphFont.italic === void 0 && glyphFont.boldItalic === void 0;
      const isSmallCaps = this.m_tempSmallCaps ? smallCapsArray[i] && textRenderStyle.fontVariant === 2 /* SmallCaps */ : false;
      const smallCapsScale = isSmallCaps ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight : 1;
      const glyphScale = this.m_tempScale * smallCapsScale;
      const emulationWeight = ((isBoldEmulated ? 0.02 : 0) + (isSmallCaps ? 0.01 : 0)) * (fontCatalog.size / fontCatalog.distanceRange);
      const bgWeight = 0.5 * this.m_tempPixelBgSize / (fontCatalog.distanceRange * Math.max(glyphScale, 1));
      const isMirrored = UnicodeUtils.isRtlMirrored(glyphData.codePoint) && direction === UnicodeUtils.Direction.RTL;
      const verticalOffset = glyphFontMetrics.lineHeight - glyphFontMetrics.base - glyphFontMetrics.distanceRange * 0.5;
      const textPoint = path.getPoint(this.m_tempPathOffset);
      if (textPoint === null) {
        return this.m_currentParams.pathOverflow;
      }
      const tangent = path.getTangent(this.m_tempPathOffset);
      const normal = new THREE73.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);
      const angle = Math.atan2(tangent.y, tangent.x);
      this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);
      textRenderStyle.rotation = defaultGlyphRotation + angle;
      TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0, textRenderStyle.rotation);
      for (let j = 0; j < 4; ++j) {
        const glyphVertexPosition = glyphData.positions[j];
        const horizontalOffset = isItalicEmulated && j > 1 ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size : 0;
        this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
        this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
        this.m_tempCorners[j].x -= position.x;
        this.m_tempCorners[j].y -= position.y;
      }
      if (globalBounds === void 0 && vertexBuffer === void 0) {
        if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
          return false;
        }
      } else {
        if (globalBounds !== void 0) {
          TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
        }
        if (vertexBuffer !== void 0) {
          geometry.addToBuffer(vertexBuffer, i * QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
        }
      }
      textRenderStyle.rotation = defaultGlyphRotation;
      this.m_tempPathOffset += (glyphData.advanceX + textLayoutStyle.tracking) * glyphScale / this.m_tempPathLength;
    }
    return true;
  }
};

// src/text-canvas/utils/MaterialUtils.ts
function createSdfTextMaterial(params) {
  return new SdfTextMaterial({
    texture: params.fontCatalog.texture,
    textureSize: params.fontCatalog.textureSize,
    size: params.fontCatalog.size,
    distanceRange: params.fontCatalog.distanceRange,
    isMsdf: params.fontCatalog.type === "msdf",
    isBackground: params.isBackground === true,
    vertexSource: params.vertexSource,
    fragmentSource: params.fragmentSource,
    rendererCapabilities: params.rendererCapabilities
  });
}

// src/text-canvas/TextCanvas.ts
var tempTextPosition = new THREE74.Vector3();
var tempTextBounds = {
  array: [new THREE74.Box2()],
  offset: 0
};
var tempVertexBuffer = new Float32Array();
var DEFAULT_TEXT_CANVAS_LAYER = 0;
var _TextCanvas = class {
  minGlyphCount;
  maxGlyphCount;
  name;
  m_renderer;
  m_fontCatalog;
  m_currentTextRenderStyle;
  m_currentTextLayoutStyle;
  m_material;
  m_bgMaterial;
  m_ownsMaterial;
  m_ownsBgMaterial;
  m_defaultLayer;
  m_layers;
  m_lineTypesetter;
  m_pathTypesetter;
  constructor(params) {
    this.m_renderer = params.renderer;
    this.m_fontCatalog = params.fontCatalog;
    this.minGlyphCount = params.minGlyphCount;
    this.maxGlyphCount = params.maxGlyphCount;
    this.name = params.name;
    if (params.material === void 0) {
      this.m_ownsMaterial = true;
      this.m_material = createSdfTextMaterial({
        fontCatalog: params.fontCatalog,
        rendererCapabilities: this.m_renderer.capabilities
      });
    } else {
      this.m_ownsMaterial = false;
      this.m_material = params.material;
    }
    if (params.backgroundMaterial === void 0) {
      this.m_ownsBgMaterial = true;
      this.m_bgMaterial = createSdfTextMaterial({
        fontCatalog: params.fontCatalog,
        isBackground: true,
        rendererCapabilities: this.m_renderer.capabilities
      });
    } else {
      this.m_ownsBgMaterial = false;
      this.m_bgMaterial = params.backgroundMaterial;
    }
    this.m_defaultLayer = {
      id: DEFAULT_TEXT_CANVAS_LAYER,
      storage: new TextGeometry(new THREE74.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
    };
    this.m_layers = [this.m_defaultLayer];
    this.m_currentTextRenderStyle = new TextRenderStyle().copy(_TextCanvas.defaultTextRenderStyle);
    this.m_currentTextLayoutStyle = new TextLayoutStyle().copy(_TextCanvas.defaultTextLayoutStyle);
    this.m_lineTypesetter = new LineTypesetter();
    this.m_pathTypesetter = new PathTypesetter();
  }
  get fontCatalog() {
    return this.m_fontCatalog;
  }
  set fontCatalog(value2) {
    this.m_fontCatalog = value2;
    const material = this.m_material;
    material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
    material.uniforms.sdfParams.value = new THREE74.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
    material.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1 : 0;
    const bgMaterial = this.m_bgMaterial;
    bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
    bgMaterial.uniforms.sdfParams.value = new THREE74.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
    bgMaterial.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1 : 0;
  }
  get material() {
    return this.m_material;
  }
  set material(value2) {
    if (this.m_ownsMaterial) {
      this.m_material.dispose();
      this.m_ownsMaterial = false;
    }
    this.m_material = value2;
    for (const layer of this.m_layers) {
      layer.storage.mesh.material = this.m_material;
    }
  }
  get backgroundMaterial() {
    return this.m_bgMaterial;
  }
  set backgroundMaterial(value2) {
    if (this.m_ownsBgMaterial) {
      this.m_bgMaterial.dispose();
      this.m_ownsBgMaterial = false;
    }
    this.m_bgMaterial = value2;
    for (const layer of this.m_layers) {
      layer.storage.backgroundMesh.material = this.m_bgMaterial;
    }
  }
  get textRenderStyle() {
    return this.m_currentTextRenderStyle;
  }
  set textRenderStyle(style) {
    this.m_currentTextRenderStyle.copy(style);
  }
  get textLayoutStyle() {
    return this.m_currentTextLayoutStyle;
  }
  set textLayoutStyle(style) {
    this.m_currentTextLayoutStyle.copy(style);
  }
  clear() {
    for (const layer of this.m_layers) {
      layer.storage.clear();
    }
    this.m_currentTextRenderStyle.copy(_TextCanvas.defaultTextRenderStyle);
    this.m_currentTextLayoutStyle.copy(_TextCanvas.defaultTextLayoutStyle);
  }
  render(camera, lowerLayerId, higherLayerId, target, clear) {
    this.m_fontCatalog.update(this.m_renderer);
    let oldTarget = null;
    if (target !== void 0) {
      oldTarget = this.m_renderer.getRenderTarget();
      this.m_renderer.setRenderTarget(target);
    }
    if (clear === true) {
      this.m_renderer.clear(true);
    }
    for (let i = 0; i < this.m_layers.length; i++) {
      const layer = this.m_layers[i];
      if (layer.id >= (lowerLayerId ?? 0)) {
        if (higherLayerId === void 0 || layer.id < higherLayerId) {
          layer.storage.update();
          this.m_renderer.render(layer.storage.scene, camera);
        } else {
          break;
        }
      }
    }
    if (target !== void 0) {
      this.m_renderer.setRenderTarget(oldTarget);
    }
  }
  addLayer(layerId) {
    let result = this.getLayer(layerId);
    if (result === void 0) {
      result = {
        id: layerId,
        storage: new TextGeometry(new THREE74.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
      };
      this.m_layers.push(result);
      this.m_layers.sort((a, b) => {
        return a.id - b.id;
      });
    }
    return result;
  }
  getLayer(layerId) {
    return this.m_layers.find((layer) => layer.id === layerId);
  }
  getAllLayers() {
    return this.m_layers;
  }
  measureText(text, outputBounds, params) {
    tempTextPosition.set(0, 0, 0);
    let path;
    let pathOverflow;
    let upperCaseArray;
    let outputCharacterBounds;
    if (params !== void 0) {
      path = params.path;
      pathOverflow = params.pathOverflow;
      outputCharacterBounds = params.outputCharacterBounds;
      if (params.path !== void 0) {
        const pathOrigin = params.path.getPoint(0);
        if (pathOrigin === null) {
          return false;
        }
        tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0);
      }
      if (params.letterCaseArray) {
        upperCaseArray = params.letterCaseArray;
      }
    }
    return this.placeText({
      input: text,
      layer: this.m_defaultLayer,
      textPath: path,
      textPathOverflow: pathOverflow,
      bounds: outputBounds,
      individualBounds: outputCharacterBounds,
      letterCaseArray: upperCaseArray
    });
  }
  addText(text, position, params) {
    tempTextPosition.copy(position);
    let path;
    let pathOverflow;
    let upperCaseArray;
    let targetLayer = this.m_defaultLayer;
    if (params !== void 0) {
      path = params.path;
      pathOverflow = params.pathOverflow;
      if (params.layer !== void 0) {
        let tempLayer = this.getLayer(params.layer);
        if (tempLayer === void 0) {
          tempLayer = this.addLayer(params.layer);
        }
        targetLayer = tempLayer;
      }
      if (params.path !== void 0) {
        tempTextPosition.set(0, 0, tempTextPosition.z);
      }
      if (params.letterCaseArray) {
        upperCaseArray = params.letterCaseArray;
      }
    }
    const prevDrawCount = targetLayer.storage.drawCount;
    const result = this.placeText({
      input: text,
      textPath: path,
      textPathOverflow: pathOverflow,
      layer: targetLayer,
      letterCaseArray: upperCaseArray
    });
    if (result && params !== void 0) {
      if (params.updatePosition === true) {
        position.copy(tempTextPosition);
      }
      if (params.pickingData !== void 0) {
        targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
      }
    } else if (!result) {
      ;
      targetLayer.storage.m_drawCount = prevDrawCount;
    }
    return result;
  }
  createTextBufferObject(text, params) {
    tempTextPosition.set(0, 0, 0);
    let glyphArray;
    let upperCaseArray;
    const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === 2 /* SmallCaps */;
    if (typeof text !== "string") {
      glyphArray = text;
      if (params !== void 0 && params.letterCaseArray) {
        upperCaseArray = params.letterCaseArray;
      }
    } else {
      upperCaseArray = [];
      glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : void 0);
      if (glyphArray === void 0) {
        return void 0;
      }
    }
    let path;
    let pathOverflow;
    let textBounds;
    let characterBounds;
    let renderStyle;
    let layoutStyle;
    if (params !== void 0) {
      path = params.path;
      pathOverflow = params.pathOverflow;
      if (params.outputBounds === true) {
        textBounds = new THREE74.Box2();
      }
      if (params.outputCharacterBounds === true) {
        characterBounds = [];
      }
      if (params.storeStyles === true) {
        renderStyle = this.m_currentTextRenderStyle.clone();
        layoutStyle = this.m_currentTextLayoutStyle.clone();
      }
    }
    this.placeText({
      input: text,
      layer: this.m_defaultLayer,
      computeTextBuffer: true,
      textPath: path,
      textPathOverflow: pathOverflow,
      bounds: textBounds,
      individualBounds: characterBounds,
      letterCaseArray: upperCaseArray
    });
    return new TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);
  }
  addTextBufferObject(textBufferObject, params) {
    var _a;
    let targetLayer = this.m_defaultLayer;
    let position;
    let scale;
    let rotation;
    let color;
    let opacity;
    let bgColor;
    let bgOpacity;
    if (params !== void 0) {
      if (params.layer !== void 0) {
        let tempLayer = this.getLayer(params.layer);
        if (tempLayer === void 0) {
          tempLayer = this.addLayer(params.layer);
        }
        targetLayer = tempLayer;
      }
      position = (_a = params.position) == null ? void 0 : _a.clone();
      scale = params.scale;
      rotation = params.rotation;
      color = params.color;
      opacity = params.opacity;
      bgColor = params.backgroundColor;
      bgOpacity = params.backgroundOpacity;
    }
    const prevDrawCount = targetLayer.storage.drawCount;
    const result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);
    if (result && params !== void 0) {
      if (params.pickingData !== void 0) {
        targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
      }
    } else if (!result) {
      ;
      targetLayer.storage.m_drawCount = prevDrawCount;
    }
    return result;
  }
  pickText(position, callback) {
    for (const layer of this.m_layers) {
      layer.storage.pick(position, callback);
    }
  }
  getMemoryUsage(info) {
    this.m_fontCatalog.updateMemoryUsage(info);
    for (const layer of this.m_layers) {
      layer.storage.updateMemoryUsage(info);
    }
  }
  placeText(params) {
    if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {
      if (params.bounds !== void 0) {
        params.bounds.min.set(0, 0);
        params.bounds.max.set(0, 0);
      }
      if (params.individualBounds !== void 0) {
        params.individualBounds.length = 0;
      }
      return true;
    }
    let glyphArray;
    let smallCapsTransformations;
    const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === 2 /* SmallCaps */;
    if (typeof params.input !== "string") {
      glyphArray = params.input;
      if (params.letterCaseArray) {
        smallCapsTransformations = params.letterCaseArray;
      }
    } else {
      smallCapsTransformations = [];
      glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : void 0);
      if (glyphArray === void 0) {
        return false;
      }
    }
    let glyphBounds;
    if (params.individualBounds !== void 0) {
      tempTextBounds.array = params.individualBounds;
      tempTextBounds.offset = 0;
      glyphBounds = tempTextBounds;
    }
    if (params.bounds !== void 0) {
      params.bounds.min.set(Infinity, Infinity);
      params.bounds.max.set(-Infinity, -Infinity);
    }
    if (params.computeTextBuffer === true) {
      tempVertexBuffer = new Float32Array(glyphArray.length * QUAD_VERTEX_MEMORY_FOOTPRINT);
    }
    const isPath = params.textPath !== void 0;
    const typesettingParams = {
      glyphs: glyphArray,
      fontCatalog: this.m_fontCatalog,
      textRenderStyle: this.m_currentTextRenderStyle,
      textLayoutStyle: this.m_currentTextLayoutStyle,
      position: tempTextPosition,
      geometry: params.layer.storage,
      smallCapsArray: smallCapsEnabled ? smallCapsTransformations : void 0,
      globalBounds: params.bounds,
      individualBounds: glyphBounds,
      vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : void 0
    };
    let result = true;
    if (isPath) {
      Object.assign(typesettingParams, {
        path: params.textPath,
        pathOverflow: params.textPathOverflow === true
      });
      result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);
    } else {
      result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);
    }
    if (glyphBounds !== void 0) {
      glyphBounds.array.length = glyphBounds.offset;
    }
    return result;
  }
};
var TextCanvas = _TextCanvas;
__publicField(TextCanvas, "defaultTextRenderStyle", new TextRenderStyle());
__publicField(TextCanvas, "defaultTextLayoutStyle", new TextLayoutStyle());

// src/text-canvas/utils/ContextualArabicConverter.ts
var _ContextualArabicConverter = class {
  static get instance() {
    if (this.m_instance === void 0) {
      this.m_instance = new _ContextualArabicConverter();
    }
    return this.m_instance;
  }
  m_singleCharactersMap = /* @__PURE__ */ new Map();
  m_combinedCharactersMap = /* @__PURE__ */ new Map();
  m_neutralCharacters;
  constructor() {
    this.m_singleCharactersMap.set(1569, [
      void 0,
      void 0,
      void 0
    ]);
    this.m_singleCharactersMap.set(1570, [void 0, void 0, 65154]);
    this.m_singleCharactersMap.set(1571, [void 0, void 0, 65156]);
    this.m_singleCharactersMap.set(1572, [void 0, void 0, 65158]);
    this.m_singleCharactersMap.set(1573, [void 0, void 0, 65160]);
    this.m_singleCharactersMap.set(1574, [65163, 65164, 65162]);
    this.m_singleCharactersMap.set(1575, [void 0, void 0, 65166]);
    this.m_singleCharactersMap.set(1576, [65169, 65170, 65168]);
    this.m_singleCharactersMap.set(1577, [void 0, void 0, 65172]);
    this.m_singleCharactersMap.set(1578, [65175, 65176, 65174]);
    this.m_singleCharactersMap.set(1579, [65179, 65180, 65178]);
    this.m_singleCharactersMap.set(1580, [65183, 65184, 65182]);
    this.m_singleCharactersMap.set(1581, [65187, 65188, 65186]);
    this.m_singleCharactersMap.set(1582, [65191, 65192, 65190]);
    this.m_singleCharactersMap.set(1583, [void 0, void 0, 65194]);
    this.m_singleCharactersMap.set(1584, [void 0, void 0, 65196]);
    this.m_singleCharactersMap.set(1585, [void 0, void 0, 65198]);
    this.m_singleCharactersMap.set(1586, [void 0, void 0, 65200]);
    this.m_singleCharactersMap.set(1587, [65203, 65204, 65202]);
    this.m_singleCharactersMap.set(1588, [65207, 65208, 65206]);
    this.m_singleCharactersMap.set(1589, [65211, 65212, 65210]);
    this.m_singleCharactersMap.set(1590, [65215, 65216, 65214]);
    this.m_singleCharactersMap.set(1591, [65219, 65220, 65218]);
    this.m_singleCharactersMap.set(1592, [65223, 65224, 65222]);
    this.m_singleCharactersMap.set(1593, [65227, 65228, 65226]);
    this.m_singleCharactersMap.set(1594, [65231, 65232, 65230]);
    this.m_singleCharactersMap.set(1600, [1600, 1600, 1600]);
    this.m_singleCharactersMap.set(1601, [65235, 65236, 65234]);
    this.m_singleCharactersMap.set(1602, [65239, 65240, 65238]);
    this.m_singleCharactersMap.set(1603, [65243, 65244, 65242]);
    this.m_singleCharactersMap.set(1604, [65247, 65248, 65246]);
    this.m_singleCharactersMap.set(1605, [65251, 65252, 65250]);
    this.m_singleCharactersMap.set(1606, [65255, 65256, 65254]);
    this.m_singleCharactersMap.set(1607, [65259, 65260, 65258]);
    this.m_singleCharactersMap.set(1608, [void 0, void 0, 65262]);
    this.m_singleCharactersMap.set(1609, [void 0, void 0, 65264]);
    this.m_singleCharactersMap.set(1610, [65267, 65268, 65266]);
    this.m_singleCharactersMap.set(1662, [64344, 64345, 64343]);
    this.m_singleCharactersMap.set(1740, [64510, 64511, 64509]);
    this.m_singleCharactersMap.set(1670, [64380, 64381, 64379]);
    this.m_singleCharactersMap.set(1705, [64400, 64401, 64399]);
    this.m_singleCharactersMap.set(1711, [64404, 64405, 64403]);
    this.m_singleCharactersMap.set(1688, [void 0, void 0, 64395]);
    this.m_combinedCharactersMap.set(1604, /* @__PURE__ */ new Map());
    this.m_combinedCharactersMap.get(1604).set(1570, [65269, 65270]);
    this.m_combinedCharactersMap.get(1604).set(1571, [65271, 65272]);
    this.m_combinedCharactersMap.get(1604).set(1573, [65273, 65274]);
    this.m_combinedCharactersMap.get(1604).set(1575, [65275, 65276]);
    this.m_neutralCharacters = [
      1552,
      1554,
      1555,
      1556,
      1557,
      1611,
      1612,
      1613,
      1614,
      1615,
      1616,
      1617,
      1618,
      1619,
      1620,
      1621,
      1622,
      1623,
      1624,
      1648,
      1750,
      1751,
      1752,
      1753,
      1754,
      1755,
      1756,
      1759,
      1760,
      1761,
      1762,
      1763,
      1764,
      1767,
      1768,
      1770,
      1771,
      1772,
      1773
    ];
  }
  convert(input) {
    let output = "";
    for (let i = 0; i < input.length; ++i) {
      const currentCodePoint = input.charCodeAt(i);
      if (this.isArabicCharacter(currentCodePoint)) {
        let prevIndex = i - 1;
        for (; prevIndex >= 0; --prevIndex) {
          if (!this.isNeutral(input.charCodeAt(prevIndex))) {
            break;
          }
        }
        let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : void 0;
        if (prevCodePoint !== void 0) {
          const prevMap = this.getCharacterMap(prevCodePoint);
          if (prevMap === void 0 || prevMap[0 /* Initial */] === void 0 && prevMap[1 /* Medial */] === void 0) {
            prevCodePoint = void 0;
          }
        }
        let nextIndex = i + 1;
        for (; nextIndex < input.length; ++nextIndex) {
          if (!this.isNeutral(input.charCodeAt(nextIndex))) {
            break;
          }
        }
        let nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : void 0;
        if (nextCodePoint !== void 0) {
          const nextMap = this.getCharacterMap(nextCodePoint);
          if (nextMap === void 0 || nextMap[1 /* Medial */] === void 0 && nextMap[2 /* Final */] === void 0) {
            nextCodePoint = void 0;
          }
        }
        if (currentCodePoint === 1604 && nextCodePoint !== void 0 && (nextCodePoint === 1570 || nextCodePoint === 1571 || nextCodePoint === 1573 || nextCodePoint === 1575)) {
          const combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);
          if (prevCodePoint !== void 0) {
            output += String.fromCharCode(combinedMap[1 /* Connected */]);
          } else {
            output += String.fromCharCode(combinedMap[0 /* Isolated */]);
          }
          ++i;
          continue;
        }
        const map = this.getCharacterMap(currentCodePoint);
        if (prevCodePoint !== void 0 && nextCodePoint !== void 0 && map[1 /* Medial */] !== void 0) {
          output += String.fromCharCode(map[1 /* Medial */]);
        } else if (prevCodePoint !== void 0 && map[2 /* Final */] !== void 0) {
          output += String.fromCharCode(map[2 /* Final */]);
        } else if (nextCodePoint !== void 0 && map[0 /* Initial */] !== void 0) {
          output += String.fromCharCode(map[0 /* Initial */]);
        } else {
          output += String.fromCharCode(currentCodePoint);
        }
      } else {
        output += String.fromCharCode(currentCodePoint);
      }
    }
    return output;
  }
  isArabicCharacter(codePoint) {
    return this.m_singleCharactersMap.has(codePoint);
  }
  getCharacterMap(codePoint) {
    return this.m_singleCharactersMap.get(codePoint);
  }
  getCombinedCharacterMap(codePoint, nextCodePoint) {
    const map = this.m_combinedCharactersMap.get(codePoint);
    if (map !== void 0) {
      return map.get(nextCodePoint);
    }
    return void 0;
  }
  isNeutral(codePoint) {
    for (const character of this.m_neutralCharacters) {
      if (character === codePoint) {
        return true;
      }
    }
    return false;
  }
};
var ContextualArabicConverter = _ContextualArabicConverter;
__publicField(ContextualArabicConverter, "m_instance");

// src/mapview/ColorCache.ts
var THREE75 = __toESM(require("three"));
var _ColorCache = class {
  static get instance() {
    return this.m_instance;
  }
  m_map = /* @__PURE__ */ new Map();
  getColor(colorCode) {
    if (typeof colorCode === "number") {
      colorCode = "#" + colorCode.toString(16).padStart(6, "0");
    }
    let color = this.m_map.get(colorCode);
    if (color !== void 0) {
      return color;
    }
    color = new THREE75.Color(colorCode);
    this.m_map.set(colorCode, color);
    return color;
  }
  get size() {
    return this.m_map.size;
  }
  clear() {
    this.m_map.clear();
  }
};
var ColorCache = _ColorCache;
__publicField(ColorCache, "m_instance", new _ColorCache());

// src/mapview/poi/PoiBuilder.ts
var logger13 = LoggerManager.instance.create("PoiBuilder");
function getImageTexture(technique, env) {
  return technique.imageTexture !== void 0 ? composeTechniqueTextureName(getPropertyValue(technique.imageTexture, env), technique) : void 0;
}
var PoiBuilder = class {
  constructor(m_env) {
    this.m_env = m_env;
  }
  m_iconMinZoomLevel;
  m_iconMaxZoomLevel;
  m_textMinZoomLevel;
  m_textMaxZoomLevel;
  m_technique;
  m_imageTextureName;
  m_shieldGroupIndex;
  withTechnique(technique) {
    this.m_imageTextureName = getImageTexture(technique, this.m_env);
    this.m_iconMinZoomLevel = getPropertyValue(technique.iconMinZoomLevel ?? technique.minZoomLevel, this.m_env) ?? void 0;
    this.m_iconMaxZoomLevel = getPropertyValue(technique.iconMaxZoomLevel ?? technique.maxZoomLevel, this.m_env) ?? void 0;
    this.m_textMinZoomLevel = getPropertyValue(technique.textMinZoomLevel ?? technique.minZoomLevel, this.m_env) ?? void 0;
    this.m_textMaxZoomLevel = getPropertyValue(technique.textMaxZoomLevel ?? technique.maxZoomLevel, this.m_env) ?? void 0;
    this.m_technique = technique;
    return this;
  }
  withIcon(imageTextureName, shieldGroupIndex) {
    if (imageTextureName !== void 0) {
      this.m_imageTextureName = imageTextureName;
    }
    this.m_shieldGroupIndex = shieldGroupIndex;
    return this;
  }
  build(textElement) {
    assert(this.m_technique !== void 0);
    const technique = this.m_technique;
    const env = this.m_env;
    const imageTextureName = this.m_imageTextureName;
    const poiName = technique.poiTable !== void 0 ? technique.poiName ?? imageTextureName : void 0;
    if (imageTextureName !== void 0 && poiName !== void 0) {
      logger13.warn("Possible duplicate POI icon definition via imageTextureName and poiTable!");
    }
    if (imageTextureName === void 0 && poiName === void 0) {
      textElement.minZoomLevel = textElement.minZoomLevel ?? this.m_textMinZoomLevel;
      textElement.maxZoomLevel = textElement.maxZoomLevel ?? this.m_textMaxZoomLevel;
      return void 0;
    }
    const textIsOptional = technique.textIsOptional === true;
    const iconIsOptional = technique.iconIsOptional === true;
    const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);
    const iconMayOverlap = technique.iconMayOverlap ?? technique.textMayOverlap;
    const iconReserveSpace = technique.iconReserveSpace ?? technique.textReserveSpace;
    const iconColorRaw = getPropertyValue(technique.iconColor, env);
    const iconColor = iconColorRaw !== null ? ColorCache.instance.getColor(iconColorRaw) : void 0;
    const poiInfo = {
      technique,
      imageTextureName,
      poiTableName: technique.poiTable,
      poiName,
      shieldGroupIndex: this.m_shieldGroupIndex,
      textElement,
      textIsOptional,
      iconIsOptional,
      renderTextDuringMovements,
      mayOverlap: iconMayOverlap,
      reserveSpace: iconReserveSpace,
      iconBrightness: technique.iconBrightness,
      iconColor,
      iconMinZoomLevel: this.m_iconMinZoomLevel,
      iconMaxZoomLevel: this.m_iconMaxZoomLevel,
      textMinZoomLevel: this.m_textMinZoomLevel,
      textMaxZoomLevel: this.m_textMaxZoomLevel
    };
    return poiInfo;
  }
};

// src/mapview/text/TextElement.ts
var THREE76 = __toESM(require("three"));

// src/mapview/text/TextElementType.ts
var TextElementType = /* @__PURE__ */ ((TextElementType2) => {
  TextElementType2[TextElementType2["PoiLabel"] = 0] = "PoiLabel";
  TextElementType2[TextElementType2["PathLabel"] = 1] = "PathLabel";
  TextElementType2[TextElementType2["LineMarker"] = 2] = "LineMarker";
  return TextElementType2;
})(TextElementType || {});

// src/mapview/text/TextElement.ts
function poiIsRenderable(poiInfo) {
  return poiInfo.buffer !== void 0;
}
var LoadingState = /* @__PURE__ */ ((LoadingState2) => {
  LoadingState2[LoadingState2["Requested"] = 0] = "Requested";
  LoadingState2[LoadingState2["Loaded"] = 1] = "Loaded";
  LoadingState2[LoadingState2["Initialized"] = 2] = "Initialized";
  return LoadingState2;
})(LoadingState || {});
var TextElement = class {
  constructor(text, points, renderParams, layoutParams, priority = 0, xOffset = 0, yOffset = 0, featureId, style, fadeNear, fadeFar, tileOffset, offsetDirection, dataSourceName, dataSourceOrder) {
    this.text = text;
    this.points = points;
    this.renderParams = renderParams;
    this.layoutParams = layoutParams;
    this.priority = priority;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
    this.featureId = featureId;
    this.style = style;
    this.fadeNear = fadeNear;
    this.fadeFar = fadeFar;
    this.tileOffset = tileOffset;
    this.offsetDirection = offsetDirection;
    this.dataSourceName = dataSourceName;
    this.dataSourceOrder = dataSourceOrder;
    if (renderParams instanceof TextRenderStyle) {
      this.renderStyle = renderParams;
    }
    if (layoutParams instanceof TextLayoutStyle) {
      this.layoutStyle = layoutParams;
    }
    this.type = points instanceof THREE76.Vector3 ? 0 /* PoiLabel */ : 1 /* PathLabel */;
  }
  visible = true;
  minZoomLevel;
  maxZoomLevel;
  mayOverlap;
  reserveSpace;
  alwaysOnTop;
  ignoreDistance;
  distanceScale = 0.5;
  userData;
  renderOrder = 0;
  kind;
  loadingState;
  elevated = false;
  glyphs;
  glyphCaseArray;
  bounds;
  textBufferObject;
  dbgPathTooSmall;
  pathLengthSqr;
  textFadeTime;
  type;
  m_poiInfo;
  m_renderStyle;
  m_layoutStyle;
  get position() {
    if (this.points instanceof Array) {
      const p = this.points[0];
      return p;
    }
    return this.points;
  }
  get path() {
    if (this.points instanceof Array) {
      return this.points;
    }
    return void 0;
  }
  get textMayOverlap() {
    return this.mayOverlap === true;
  }
  set textMayOverlap(mayOverlap) {
    this.mayOverlap = mayOverlap;
  }
  get textReservesSpace() {
    return this.reserveSpace !== false;
  }
  set textReservesSpace(reserveSpace) {
    this.reserveSpace = reserveSpace;
  }
  get poiInfo() {
    return this.m_poiInfo;
  }
  set poiInfo(poiInfo) {
    this.m_poiInfo = poiInfo;
    if (poiInfo !== void 0) {
      if (this.path !== void 0) {
        this.type = 2 /* LineMarker */;
      }
      const poiRenderOrder = this.renderOrder !== void 0 ? this.renderOrder : 0;
      poiInfo.renderOrder = poiRenderOrder;
    }
  }
  get renderStyle() {
    return this.m_renderStyle;
  }
  set renderStyle(style) {
    this.m_renderStyle = style;
  }
  get layoutStyle() {
    return this.m_layoutStyle;
  }
  set layoutStyle(style) {
    this.m_layoutStyle = style;
  }
  hasFeatureId() {
    if (this.featureId === void 0) {
      return false;
    }
    if (typeof this.featureId === "number") {
      return this.featureId !== 0;
    }
    return this.featureId.length > 0;
  }
  dispose() {
    var _a;
    const poiBuffer = (_a = this.poiInfo) == null ? void 0 : _a.buffer;
    if (poiBuffer) {
      poiBuffer.decreaseRefCount();
    }
  }
};
__publicField(TextElement, "HIGHEST_PRIORITY", Number.MAX_SAFE_INTEGER);

// src/mapview/text/TextElementsRenderer.ts
var THREE84 = __toESM(require("three"));

// src/mapview/DebugContext.ts
var THREE77 = __toESM(require("three"));
var isNode2 = typeof window === "undefined";
var _DebugOption = class extends THREE77.EventDispatcher {
  constructor(value2) {
    super();
    this.value = value2;
  }
  set(value2, name2) {
    this.value = value2;
    this.dispatchEvent({ type: _DebugOption.SET_EVENT_TYPE, name: name2, value: value2 });
  }
};
var DebugOption = _DebugOption;
__publicField(DebugOption, "SET_EVENT_TYPE", "set");
var DebugContext = class {
  m_optionsMap;
  constructor() {
    this.m_optionsMap = /* @__PURE__ */ new Map();
    if (!isNode2 && typeof window !== "undefined" && window) {
      const debugInfo = window;
      debugInfo.__debugContext = this;
    }
  }
  setValue(name2, value2) {
    let opt = this.m_optionsMap.get(name2);
    if (!opt) {
      opt = new DebugOption(value2);
      this.m_optionsMap.set(name2, opt);
    } else {
      opt.set(value2, name2);
    }
  }
  getValue(name2) {
    const opt = this.m_optionsMap.get(name2);
    return opt ? opt.value : void 0;
  }
  hasOption(name2) {
    return this.m_optionsMap.get(name2) !== void 0;
  }
  addEventListener(name2, listener) {
    const opt = this.m_optionsMap.get(name2);
    if (opt) {
      opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);
    } else {
      throw Error("Unknown option: " + name2);
    }
  }
  hasEventListener(name2, listener) {
    const opt = this.m_optionsMap.get(name2);
    if (opt) {
      return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);
    } else {
      throw Error("Unknown option: " + name2);
    }
  }
  removeEventListener(name2, listener) {
    const opt = this.m_optionsMap.get(name2);
    if (opt) {
      opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);
    } else {
      throw Error("Unknown option: " + name2);
    }
  }
  get options() {
    return this.m_optionsMap;
  }
  clear() {
    this.m_optionsMap.forEach((option) => {
      option.set(void 0, "");
    });
  }
};
var debugContext = new DebugContext();

// src/mapview/geometry/overlayOnElevation.ts
function overlayPosition(worldCoords, elevationProvider, displacementMap, projection) {
  const geoCoords = projection.unprojectPoint(worldCoords);
  if (displacementMap.geoBox.contains(geoCoords)) {
    geoCoords.altitude = elevationProvider.sampleHeight(geoCoords, displacementMap);
  } else {
    geoCoords.altitude = elevationProvider.getHeight(geoCoords, displacementMap.tileKey.level);
    if (geoCoords.altitude === void 0) {
      return false;
    }
  }
  projection.projectPoint(geoCoords, worldCoords);
  return true;
}
function overlayPath(path, elevationProvider, displacementMap, projection) {
  for (const position of path) {
    if (!overlayPosition(position, elevationProvider, displacementMap, projection)) {
      return false;
    }
  }
  return true;
}
function overlayTextElement(textElement, elevationProvider, displacementMap, projection) {
  assert(!textElement.elevated);
  if (!displacementMap) {
    return;
  }
  textElement.elevated = textElement.path ? overlayPath(textElement.path, elevationProvider, displacementMap, projection) : overlayPosition(textElement.position, elevationProvider, displacementMap, projection);
}

// src/mapview/poi/PoiRenderer.ts
var THREE79 = __toESM(require("three"));

// src/mapview/poi/BoxBuffer.ts
var THREE78 = __toESM(require("three"));

// src/mapview/poi/PixelPicker.ts
function getPixelFromImage(xPos, yPos, image, canvas2) {
  if (image instanceof ImageData) {
    const stride = image.data.length / (image.height * image.width);
    return getPixelFromImageData(image, xPos, yPos, stride);
  }
  if (!canvas2) {
    canvas2 = document.createElement("canvas");
  }
  return getPixelFromCanvasImageSource(image, xPos, yPos, canvas2);
}
function screenToUvCoordinates(screenX, screenY, box, uvBox) {
  const minX = box.x;
  const maxX = box.x + box.w;
  const minY = box.y;
  const maxY = box.y + box.h;
  const u = MathUtils6.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);
  const v = MathUtils6.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);
  return { u, v };
}
function getPixelFromCanvasImageSource(image, xPos, yPos, canvas2) {
  const { width, height } = image instanceof SVGImageElement ? image.getBBox() : image;
  if (xPos > width || xPos < 0 || yPos > height || yPos < 0) {
    return void 0;
  }
  let pixelData;
  canvas2.width = width;
  canvas2.height = height;
  const context2 = canvas2.getContext("2d");
  if (context2 !== null) {
    context2.drawImage(image, 0, 0);
    pixelData = context2.getImageData(xPos, yPos, 1, 1).data;
  }
  return pixelData;
}
function getPixelFromImageData(imgData, xPos, yPos, stride) {
  const getPixel = (imageData, index, strd) => {
    const i = index * strd;
    const d = imageData.data;
    const pixel = new Uint8ClampedArray(strd);
    for (let s = 0; s < strd; s++) {
      pixel[0] = d[i + s];
    }
    return pixel;
  };
  if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {
    return void 0;
  }
  return getPixel(imgData, yPos * imgData.width + xPos, stride);
}

// src/mapview/poi/BoxBuffer.ts
var START_BOX_BUFFER_SIZE = 0;
var MAX_BOX_BUFFER_SIZE = 32 * 1024;
var NUM_VERTICES_PER_ELEMENT = 4;
var NUM_INDICES_PER_ELEMENT = 6;
var NUM_POSITION_VALUES_PER_VERTEX = 3;
var NUM_COLOR_VALUES_PER_VERTEX = 4;
var NUM_UV_VALUES_PER_VERTEX = 4;
var NUM_INDEX_VALUES_PER_VERTEX = 1;
var NUM_BYTES_PER_FLOAT2 = 4;
var NUM_BYTES_PER_INT322 = 4;
var BoxBufferMesh = class extends THREE78.Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "BoxBufferMesh";
  }
  get isEmpty() {
    if (this.geometry === void 0) {
      return true;
    } else {
      const bufferGeometry = this.geometry;
      return bufferGeometry.index === null || bufferGeometry.index.count === 0;
    }
  }
};
var BoxBuffer = class {
  constructor(m_material, m_renderOrder = 0, startElementCount = START_BOX_BUFFER_SIZE, m_maxElementCount = MAX_BOX_BUFFER_SIZE) {
    this.m_material = m_material;
    this.m_renderOrder = m_renderOrder;
    this.m_maxElementCount = m_maxElementCount;
    this.resizeBuffer(startElementCount);
    this.m_pickInfos = new Array();
  }
  m_positionAttribute;
  m_colorAttribute;
  m_uvAttribute;
  m_indexAttribute;
  m_pickInfos;
  m_geometry;
  m_mesh;
  m_size = 0;
  clone() {
    return new BoxBuffer(this.m_material, this.m_renderOrder);
  }
  dispose() {
    if (this.m_geometry !== void 0) {
      this.m_geometry.dispose();
      this.m_geometry = void 0;
    }
    this.m_mesh = void 0;
  }
  get size() {
    return this.m_size;
  }
  reset() {
    if (this.m_positionAttribute !== void 0) {
      this.m_positionAttribute.count = 0;
      this.m_colorAttribute.count = 0;
      this.m_uvAttribute.count = 0;
      this.m_indexAttribute.count = 0;
      this.m_pickInfos.length = 0;
    }
  }
  canAddElements(glyphCount = 1) {
    const indexAttribute = this.m_indexAttribute;
    if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >= indexAttribute.array.length) {
      if (indexAttribute.array.length >= this.m_maxElementCount * NUM_INDICES_PER_ELEMENT) {
        return false;
      }
      const newSize = Math.min(this.m_maxElementCount, this.size === 0 ? 256 : this.size * 2);
      this.resize(newSize);
    }
    return true;
  }
  saveState() {
    const state = {
      positionAttributeCount: this.m_positionAttribute.count,
      colorAttributeCount: this.m_colorAttribute.count,
      uvAttributeCount: this.m_uvAttribute.count,
      indexAttributeCount: this.m_indexAttribute.count,
      pickInfoCount: this.m_pickInfos.length
    };
    return state;
  }
  restoreState(state) {
    this.m_positionAttribute.count = state.positionAttributeCount;
    this.m_colorAttribute.count = state.colorAttributeCount;
    this.m_uvAttribute.count = state.uvAttributeCount;
    this.m_indexAttribute.count = state.indexAttributeCount;
    this.m_pickInfos.length = state.pickInfoCount;
  }
  addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {
    if (!this.canAddElements()) {
      return false;
    }
    const { s0, t0, s1, t1 } = uvBox;
    const { x, y, w, h } = screenBox;
    const r = Math.round(color.r * opacity * 255);
    const g = Math.round(color.g * opacity * 255);
    const b = Math.round(color.b * opacity * 255);
    const a = Math.round(opacity * 255);
    const positionAttribute = this.m_positionAttribute;
    const colorAttribute = this.m_colorAttribute;
    const uvAttribute = this.m_uvAttribute;
    const indexAttribute = this.m_indexAttribute;
    const baseVertex = positionAttribute.count;
    const baseIndex = indexAttribute.count;
    positionAttribute.setXYZ(baseVertex, x, y, distance);
    positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);
    positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);
    positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);
    colorAttribute.setXYZW(baseVertex, r, g, b, a);
    colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);
    colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);
    colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);
    uvAttribute.setXY(baseVertex, s0, t0);
    uvAttribute.setXY(baseVertex + 1, s1, t0);
    uvAttribute.setXY(baseVertex + 2, s0, t1);
    uvAttribute.setXY(baseVertex + 3, s1, t1);
    indexAttribute.setX(baseIndex, baseVertex);
    indexAttribute.setX(baseIndex + 1, baseVertex + 1);
    indexAttribute.setX(baseIndex + 2, baseVertex + 2);
    indexAttribute.setX(baseIndex + 3, baseVertex + 2);
    indexAttribute.setX(baseIndex + 4, baseVertex + 1);
    indexAttribute.setX(baseIndex + 5, baseVertex + 3);
    positionAttribute.count += NUM_VERTICES_PER_ELEMENT;
    colorAttribute.count += NUM_VERTICES_PER_ELEMENT;
    uvAttribute.count += NUM_VERTICES_PER_ELEMENT;
    indexAttribute.count += NUM_INDICES_PER_ELEMENT;
    this.m_pickInfos.push(pickInfo);
    return true;
  }
  updateBufferGeometry() {
    const positionAttribute = this.m_positionAttribute;
    const colorAttribute = this.m_colorAttribute;
    const uvAttribute = this.m_uvAttribute;
    const indexAttribute = this.m_indexAttribute;
    if (positionAttribute.count > 0) {
      positionAttribute.needsUpdate = true;
      positionAttribute.updateRange.offset = 0;
      positionAttribute.updateRange.count = positionAttribute.count * NUM_VERTICES_PER_ELEMENT;
    }
    if (colorAttribute.count > 0) {
      colorAttribute.needsUpdate = true;
      colorAttribute.updateRange.offset = 0;
      colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;
    }
    if (uvAttribute.count > 0) {
      uvAttribute.needsUpdate = true;
      uvAttribute.updateRange.offset = 0;
      uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;
    }
    if (indexAttribute.count > 0) {
      indexAttribute.needsUpdate = true;
      indexAttribute.updateRange.offset = 0;
      indexAttribute.updateRange.count = indexAttribute.count;
    }
    if (this.m_geometry !== void 0) {
      this.m_geometry.clearGroups();
      this.m_geometry.addGroup(0, this.m_indexAttribute.count);
    }
  }
  cleanUp() {
    if (this.m_indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {
      this.clearAttributes();
    }
  }
  get isEmpty() {
    return this.m_mesh.isEmpty;
  }
  get mesh() {
    if (this.m_mesh === void 0) {
      this.resize();
    }
    return this.m_mesh;
  }
  pickBoxes(screenPosition, pickCallback, image) {
    const n = this.m_pickInfos.length;
    const pickInfos = this.m_pickInfos;
    const positions = this.m_positionAttribute;
    const screenX = screenPosition.x;
    const screenY = screenPosition.y;
    for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {
      const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;
      const minX = positions.getX(positionIndex);
      if (screenX < minX) {
        continue;
      }
      const maxX = positions.getX(positionIndex + 1);
      if (screenX > maxX) {
        continue;
      }
      const minY = positions.getY(positionIndex);
      if (screenY < minY) {
        continue;
      }
      const maxY = positions.getY(positionIndex + 2);
      if (screenY > maxY) {
        continue;
      }
      const box = new Math2D.Box(minX, minY, maxX - minX, maxY - minY);
      if (image !== void 0 && pickInfos[pickInfoIndex].poiInfo !== void 0 && pickInfos[pickInfoIndex].poiInfo.uvBox !== void 0 && this.isPixelTransparent(image, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, document.createElement("canvas"))) {
        continue;
      }
      if (pickInfos[pickInfoIndex] !== void 0) {
        pickCallback(pickInfos[pickInfoIndex]);
      }
    }
  }
  resize(newSize, forceResize) {
    if (this.m_geometry !== void 0) {
      this.m_geometry.dispose();
    }
    this.m_geometry = new THREE78.BufferGeometry();
    if (newSize !== void 0 && (forceResize === true || newSize > this.size)) {
      this.resizeBuffer(newSize);
    }
    this.m_geometry.setAttribute("position", this.m_positionAttribute);
    this.m_geometry.setAttribute("color", this.m_colorAttribute);
    this.m_geometry.setAttribute("uv", this.m_uvAttribute);
    this.m_geometry.setIndex(this.m_indexAttribute);
    this.m_geometry.addGroup(0, this.m_indexAttribute.count);
    if (this.m_mesh === void 0) {
      this.m_mesh = new BoxBufferMesh(this.m_geometry, this.m_material);
      this.m_mesh.renderOrder = this.m_renderOrder;
    } else {
      this.m_mesh.geometry = this.m_geometry;
    }
    return this.m_mesh;
  }
  updateMemoryUsage(info) {
    const numBytes = this.m_positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT2 + this.m_colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX + this.m_uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT2 + this.m_indexAttribute.count * NUM_BYTES_PER_INT322;
    info.heapSize += numBytes;
    info.gpuSize += numBytes;
  }
  isPixelTransparent(image, xScreenPos, yScreenPos, box, uvBox, canvas2) {
    const { u, v } = screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);
    const { width, height } = image instanceof SVGImageElement ? image.getBBox() : image;
    const x = width * u;
    const y = height * v;
    const pixel = getPixelFromImage(x, y, image, canvas2);
    return pixel !== void 0 && pixel[3] === 0;
  }
  clearAttributes() {
    this.m_positionAttribute = void 0;
    this.m_colorAttribute = void 0;
    this.m_uvAttribute = void 0;
    this.m_indexAttribute = void 0;
    this.resize(START_BOX_BUFFER_SIZE, true);
  }
  resizeBuffer(newSize) {
    const newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);
    if (this.m_positionAttribute !== void 0 && this.m_positionAttribute.array.length > 0) {
      const positionAttributeCount = this.m_positionAttribute.count;
      newPositionArray.set(this.m_positionAttribute.array);
      this.m_positionAttribute.array = newPositionArray;
      this.m_positionAttribute.count = positionAttributeCount;
    } else {
      this.m_positionAttribute = new THREE78.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);
      this.m_positionAttribute.count = 0;
      this.m_positionAttribute.setUsage(THREE78.DynamicDrawUsage);
    }
    const newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);
    if (this.m_colorAttribute !== void 0) {
      const colorAttributeCount = this.m_colorAttribute.count;
      newColorArray.set(this.m_colorAttribute.array);
      this.m_colorAttribute.array = newColorArray;
      this.m_colorAttribute.count = colorAttributeCount;
    } else {
      this.m_colorAttribute = new THREE78.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);
      this.m_colorAttribute.count = 0;
      this.m_colorAttribute.setUsage(THREE78.DynamicDrawUsage);
    }
    const newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);
    if (this.m_uvAttribute !== void 0) {
      const uvAttributeCount = this.m_uvAttribute.count;
      newUvArray.set(this.m_uvAttribute.array);
      this.m_uvAttribute.array = newUvArray;
      this.m_uvAttribute.count = uvAttributeCount;
    } else {
      this.m_uvAttribute = new THREE78.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);
      this.m_uvAttribute.count = 0;
      this.m_uvAttribute.setUsage(THREE78.DynamicDrawUsage);
    }
    const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;
    const newIndexArray = numIndexValues > 65535 ? new Uint32Array(numIndexValues) : new Uint16Array(numIndexValues);
    if (this.m_indexAttribute !== void 0) {
      const indexAttributeCount = this.m_indexAttribute.count;
      newIndexArray.set(this.m_indexAttribute.array);
      this.m_indexAttribute.array = newIndexArray;
      this.m_indexAttribute.count = indexAttributeCount;
    } else {
      this.m_indexAttribute = new THREE78.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);
      this.m_indexAttribute.count = 0;
      this.m_indexAttribute.setUsage(THREE78.DynamicDrawUsage);
    }
    this.m_size = newSize;
  }
};

// src/mapview/poi/PoiRenderer.ts
var logger14 = LoggerManager.instance.create("PoiRenderer");
var neutralColor = new THREE79.Color(1, 1, 1);
var tmpIconColor = new THREE79.Color();
var PoiBuffer = class {
  constructor(buffer, layer, m_onDispose) {
    this.buffer = buffer;
    this.layer = layer;
    this.m_onDispose = m_onDispose;
  }
  m_refCount = 0;
  increaseRefCount() {
    ++this.m_refCount;
    return this;
  }
  decreaseRefCount() {
    assert(this.m_refCount > 0);
    if (--this.m_refCount === 0) {
      this.dispose();
    }
    return this;
  }
  dispose() {
    this.layer.scene.remove(this.buffer.mesh);
    this.buffer.dispose();
    this.m_onDispose();
  }
};
var _PoiBatch = class {
  constructor(m_rendererCapabilities, imageItem, m_onDispose) {
    this.m_rendererCapabilities = m_rendererCapabilities;
    this.imageItem = imageItem;
    this.m_onDispose = m_onDispose;
    const premultipliedAlpha = true;
    const texture = new THREE79.Texture(this.imageItem.image, THREE79.UVMapping, void 0, void 0, _PoiBatch.trilinear ? THREE79.LinearFilter : THREE79.LinearFilter, _PoiBatch.trilinear ? THREE79.LinearMipMapLinearFilter : THREE79.LinearFilter, THREE79.RGBAFormat);
    if (_PoiBatch.trilinear && this.imageItem.mipMaps) {
      texture.mipmaps = this.imageItem.mipMaps;
      texture.image = texture.mipmaps[0];
    }
    texture.flipY = false;
    texture.premultiplyAlpha = premultipliedAlpha;
    texture.needsUpdate = true;
    this.m_material = new IconMaterial({
      rendererCapabilities: this.m_rendererCapabilities,
      map: texture
    });
    this.m_poiBuffers = /* @__PURE__ */ new Map();
  }
  m_poiBuffers;
  m_material;
  getBuffer(layer) {
    let poiBuffer = this.m_poiBuffers.get(layer.id);
    if (poiBuffer) {
      return poiBuffer.increaseRefCount();
    }
    const boxBuffer = new BoxBuffer(this.m_material, layer.id);
    const mesh = boxBuffer.mesh;
    mesh.frustumCulled = false;
    layer.scene.add(mesh);
    poiBuffer = new PoiBuffer(boxBuffer, layer, () => {
      this.disposeBuffer(layer.id);
    });
    this.m_poiBuffers.set(layer.id, poiBuffer);
    return poiBuffer.increaseRefCount();
  }
  reset() {
    for (const poiBuffer of this.m_poiBuffers.values()) {
      poiBuffer.buffer.reset();
    }
  }
  update() {
    for (const poiBuffer of this.m_poiBuffers.values()) {
      poiBuffer.buffer.updateBufferGeometry();
    }
  }
  pickBoxes(screenPosition, pickCallback, image) {
    for (const poiBuffer of this.m_poiBuffers.values()) {
      poiBuffer.buffer.pickBoxes(screenPosition, pickCallback, image);
    }
  }
  updateMemoryUsage(info) {
    if (this.imageItem.image !== void 0) {
      const imageBytes = this.imageItem.image.width * this.imageItem.image.height * 4;
      info.heapSize += imageBytes;
      info.gpuSize += imageBytes;
    }
    for (const poiBuffer of this.m_poiBuffers.values()) {
      poiBuffer.buffer.updateMemoryUsage(info);
    }
  }
  dispose() {
    this.m_poiBuffers.clear();
    this.m_material.map.dispose();
    this.m_material.dispose();
    this.m_onDispose();
  }
  disposeBuffer(renderOrder) {
    assert(this.m_poiBuffers.size > 0);
    this.m_poiBuffers.delete(renderOrder);
    if (this.m_poiBuffers.size === 0) {
      this.dispose();
    }
  }
};
var PoiBatch = _PoiBatch;
__publicField(PoiBatch, "trilinear", true);
var PoiBatchRegistry = class {
  constructor(m_rendererCapabilities) {
    this.m_rendererCapabilities = m_rendererCapabilities;
  }
  m_batchMap = /* @__PURE__ */ new Map();
  registerPoi(poiInfo, layer) {
    const { imageItem, imageTexture } = poiInfo;
    if (!imageItem) {
      return void 0;
    }
    assert(poiInfo.imageTextureName !== void 0);
    const batchKey = (imageTexture == null ? void 0 : imageTexture.image) ?? poiInfo.imageTextureName;
    let batch = this.m_batchMap.get(batchKey);
    if (batch === void 0) {
      batch = new PoiBatch(this.m_rendererCapabilities, imageItem, () => {
        this.deleteBatch(batchKey);
      });
      this.m_batchMap.set(batchKey, batch);
    }
    return batch.getBuffer(layer);
  }
  addPoi(poiInfo, screenBox, viewDistance, opacity) {
    if (poiInfo.isValid === false || !poiInfo.buffer) {
      logger14.warn("PoiBatchRegistry: trying to add poiInfo without buffer prepared: ", poiInfo.poiName);
      return;
    }
    assert(poiInfo.uvBox !== void 0);
    let color;
    if (poiInfo.iconBrightness !== void 0) {
      color = tmpIconColor.setScalar(poiInfo.iconBrightness);
      if (poiInfo.iconColor !== void 0) {
        color = tmpIconColor.multiply(poiInfo.iconColor);
      }
    } else if (poiInfo.iconColor !== void 0) {
      color = poiInfo.iconColor;
    } else {
      color = neutralColor;
    }
    poiInfo.buffer.buffer.addBox(screenBox, poiInfo.uvBox, color, opacity, viewDistance, poiInfo.textElement);
  }
  reset() {
    for (const batch of this.m_batchMap.values()) {
      batch.reset();
    }
  }
  update() {
    for (const batch of this.m_batchMap.values()) {
      batch.update();
    }
  }
  pickTextElements(screenPosition, pickCallback) {
    for (const batch of this.m_batchMap.values()) {
      batch.pickBoxes(screenPosition, pickCallback, batch.imageItem.image);
    }
  }
  updateMemoryUsage(info) {
    for (const batch of this.m_batchMap.values()) {
      batch.updateMemoryUsage(info);
    }
  }
  deleteBatch(batchKey) {
    this.m_batchMap.delete(batchKey);
  }
};
var missingTextureName = /* @__PURE__ */ new Map();
var SEARCH_CACHE_ATTEMPTS = 5;
function findImageItem(poiInfo, imageCaches, imageTexture) {
  assert(poiInfo.imageTextureName !== void 0);
  const imageTextureName = imageTexture ? imageTexture.image : poiInfo.imageTextureName;
  for (const imageCache of imageCaches) {
    const imageItem = imageCache.findImageByName(imageTextureName);
    if (imageItem) {
      missingTextureName.delete(imageTextureName);
      return imageItem;
    }
  }
  const missingTextureCount = missingTextureName.get(imageTextureName);
  missingTextureName.set(imageTextureName, missingTextureCount ? missingTextureCount + 1 : 0);
  if (missingTextureName.get(imageTextureName) === SEARCH_CACHE_ATTEMPTS) {
    logger14.error(`PoiRenderer::findImageItem: No imageItem found with name:
            '${(imageTexture == null ? void 0 : imageTexture.image) ?? imageTextureName}'
            after ${SEARCH_CACHE_ATTEMPTS} attempts.`);
  }
  return void 0;
}
var PoiRenderer = class {
  constructor(m_renderer, m_poiManager, m_imageCaches) {
    this.m_renderer = m_renderer;
    this.m_poiManager = m_poiManager;
    this.m_imageCaches = m_imageCaches;
    this.m_poiBatchRegistry = new PoiBatchRegistry(this.renderer.capabilities);
  }
  static computeIconScreenBox(poiInfo, screenPosition, scale, env, screenBox = new Math2D.Box()) {
    assert(poiInfo.buffer !== void 0);
    const width = poiInfo.computedWidth * scale;
    const height = poiInfo.computedHeight * scale;
    const technique = poiInfo.technique;
    const iconXOffset = getPropertyValue(technique.iconXOffset, env);
    const iconYOffset = getPropertyValue(technique.iconYOffset, env);
    const centerX = screenPosition.x + (typeof iconXOffset === "number" ? iconXOffset : 0) * scale;
    const centerY = screenPosition.y + (typeof iconYOffset === "number" ? iconYOffset : 0) * scale;
    screenBox.x = centerX - width / 2;
    screenBox.y = centerY - height / 2;
    screenBox.w = width;
    screenBox.h = height;
    return screenBox;
  }
  m_poiBatchRegistry;
  m_tempScreenBox = new Math2D.Box();
  m_layers = [];
  get renderer() {
    return this.m_renderer;
  }
  prepareRender(pointLabel, env) {
    const poiInfo = pointLabel.poiInfo;
    if (poiInfo === void 0) {
      return false;
    }
    if (poiInfo.buffer === void 0) {
      this.preparePoi(pointLabel, env);
    }
    return poiInfo.buffer !== void 0;
  }
  reset() {
    this.m_poiBatchRegistry.reset();
  }
  addPoi(poiInfo, screenPosition, screenCollisions, viewDistance, scale, allocateScreenSpace, opacity, env) {
    assert(poiInfo.buffer !== void 0);
    PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);
    if (allocateScreenSpace) {
      screenCollisions.allocate(this.m_tempScreenBox);
    }
    if (opacity > 0) {
      if (!poiInfo.buffer) {
        this.preparePoi(poiInfo.textElement, env);
      }
      this.m_poiBatchRegistry.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);
    }
  }
  update() {
    this.m_poiBatchRegistry.update();
  }
  addLayer(layerId) {
    let result = this.getLayer(layerId);
    if (result === void 0) {
      result = {
        id: layerId,
        scene: new THREE79.Scene()
      };
      this.m_layers.push(result);
      this.m_layers.sort((a, b) => {
        return a.id - b.id;
      });
    }
    return result;
  }
  getLayer(layerId) {
    return this.m_layers.find((layer) => layer.id === layerId);
  }
  get layers() {
    return this.m_layers;
  }
  render(camera, layer) {
    this.m_renderer.render(layer.scene, camera);
  }
  pickTextElements(screenPosition, pickCallback) {
    this.m_poiBatchRegistry.pickTextElements(screenPosition, pickCallback);
  }
  getMemoryUsage(info) {
    this.m_poiBatchRegistry.updateMemoryUsage(info);
  }
  preparePoi(pointLabel, env) {
    const poiInfo = pointLabel.poiInfo;
    if (!poiInfo || !pointLabel.visible) {
      return;
    }
    if (poiInfo.buffer !== void 0 || poiInfo.isValid === false) {
      return;
    }
    if (poiInfo.poiTableName !== void 0) {
      if (this.m_poiManager.updatePoiFromPoiTable(pointLabel)) {
        if (!pointLabel.visible) {
          return;
        }
      } else {
        return;
      }
    }
    const imageTextureName = poiInfo.imageTextureName;
    if (imageTextureName === void 0) {
      poiInfo.isValid = false;
      return;
    }
    const imageTexture = this.m_poiManager.getImageTexture(imageTextureName);
    const imageItem = findImageItem(poiInfo, this.m_imageCaches, imageTexture);
    if (!imageItem) {
      poiInfo.imageItem = null;
      return;
    }
    if (imageItem.loaded) {
      this.setupPoiInfo(poiInfo, imageItem, env, imageTexture);
      return;
    }
    if (imageItem.loading) {
      return;
    }
    imageItem.loadImage().then((loadedImageItem) => {
      if (loadedImageItem == null ? void 0 : loadedImageItem.image) {
        this.setupPoiInfo(poiInfo, loadedImageItem, env, imageTexture);
      }
    }).catch((error) => {
      logger14.error(`preparePoi: Failed to load imageItem: '${imageItem.url}`, error);
      poiInfo.isValid = false;
    });
  }
  setupPoiInfo(poiInfo, imageItem, env, imageTexture) {
    assert(poiInfo.uvBox === void 0);
    if (!imageItem.image) {
      logger14.error("setupPoiInfo: No imageItem/imageData found");
      poiInfo.isValid = false;
      return;
    }
    const technique = poiInfo.technique;
    const imageWidth = imageItem.image.width;
    const imageHeight = imageItem.image.height;
    const paddedSize = MipMapGenerator.getPaddedSize(imageWidth, imageHeight);
    const trilinearFiltering = PoiBatch.trilinear && imageItem.mipMaps;
    const paddedImageWidth = trilinearFiltering ? paddedSize.width : imageWidth;
    const paddedImageHeight = trilinearFiltering ? paddedSize.height : imageHeight;
    const iconWidth = (imageTexture == null ? void 0 : imageTexture.width) !== void 0 ? imageTexture.width : imageWidth;
    const iconHeight = (imageTexture == null ? void 0 : imageTexture.height) !== void 0 ? imageTexture.height : imageHeight;
    const width = (imageTexture == null ? void 0 : imageTexture.width) !== void 0 ? imageTexture.width : imageWidth;
    const height = (imageTexture == null ? void 0 : imageTexture.height) !== void 0 ? imageTexture.height : imageHeight;
    const xOffset = (imageTexture == null ? void 0 : imageTexture.xOffset) !== void 0 ? imageTexture.xOffset : 0;
    const yOffset = (imageTexture == null ? void 0 : imageTexture.yOffset) !== void 0 ? imageTexture.yOffset : 0;
    const minS = xOffset / paddedImageWidth;
    const maxS = (xOffset + width) / paddedImageWidth;
    const minT = yOffset / paddedImageHeight;
    const maxT = (yOffset + height) / paddedImageHeight;
    let iconScaleH = technique.iconScale !== void 0 ? technique.iconScale : 1;
    let iconScaleV = technique.iconScale !== void 0 ? technique.iconScale : 1;
    const screenWidth = getPropertyValue(technique.screenWidth, env);
    if (screenWidth !== void 0 && screenWidth !== null) {
      iconScaleV = iconScaleH = screenWidth / iconWidth;
    }
    const screenHeight = getPropertyValue(technique.screenHeight, env);
    if (screenHeight !== void 0 && screenHeight !== null) {
      iconScaleV = screenHeight / iconHeight;
      if (screenWidth !== void 0) {
        iconScaleH = iconScaleV;
      }
    }
    poiInfo.computedWidth = iconWidth * iconScaleH;
    poiInfo.computedHeight = iconHeight * iconScaleV;
    poiInfo.uvBox = {
      s0: minS,
      t0: maxT,
      s1: maxS,
      t1: minT
    };
    poiInfo.imageItem = imageItem;
    poiInfo.imageTexture = imageTexture;
    poiInfo.buffer = this.m_poiBatchRegistry.registerPoi(poiInfo, this.addLayer(poiInfo.renderOrder));
    poiInfo.isValid = true;
  }
};

// src/mapview/ScreenCollisions.ts
var THREE80 = __toESM(require("three"));
var RBush = require("rbush");
var logger15 = LoggerManager.instance.create("ScreenCollisions");
var CollisionBox = class extends Math2D.Box {
  constructor(box) {
    super();
    if (box !== void 0) {
      this.copy(box);
    }
  }
  copy(box) {
    if (box instanceof Math2D.Box) {
      this.set(box.x, box.y, box.w, box.h);
    } else if (box instanceof THREE80.Box2) {
      this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);
    } else {
      this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);
    }
    return this;
  }
  get minX() {
    return this.x;
  }
  set minX(minX) {
    this.x = minX;
  }
  get maxX() {
    return this.x + this.w;
  }
  set maxX(maxX) {
    this.w = maxX - this.x;
  }
  get minY() {
    return this.y;
  }
  set minY(minY) {
    this.y = minY;
  }
  get maxY() {
    return this.y + this.h;
  }
  set maxY(maxY) {
    this.h = maxY - this.y;
  }
};
var DetailedCollisionBox = class extends CollisionBox {
  constructor(box, detailBoxes) {
    super(box);
    this.detailBoxes = detailBoxes;
  }
};
function isLineWithBound(box) {
  return box.line !== void 0;
}
var tmpCollisionBox = new CollisionBox();
var ScreenCollisions = class {
  screenBounds = new Math2D.Box();
  rtree = new RBush();
  constructor() {
  }
  reset() {
    this.rtree.clear();
  }
  update(width, height) {
    this.screenBounds.set(width / -2, height / -2, width, height);
    this.reset();
  }
  allocate(bounds) {
    const bbox = !(bounds instanceof CollisionBox) ? new CollisionBox(bounds) : bounds;
    this.rtree.insert(bbox);
  }
  allocateIBoxes(bounds) {
    this.rtree.load(bounds);
  }
  search(box) {
    return this.rtree.search(box);
  }
  isAllocated(bounds) {
    const collisionBox = bounds instanceof CollisionBox ? bounds : tmpCollisionBox.copy(bounds);
    const results = this.search(collisionBox);
    return this.intersectsDetails(collisionBox, results);
  }
  isVisible(bounds) {
    return this.screenBounds.intersects(bounds);
  }
  isFullyVisible(bounds) {
    return this.screenBounds.containsBox(bounds);
  }
  intersectsDetails(testBox, boxes) {
    for (const box of boxes) {
      if (box instanceof DetailedCollisionBox) {
        for (const detailBox of box.detailBoxes) {
          if (detailBox.intersects(testBox)) {
            return true;
          }
        }
      } else if (isLineWithBound(box)) {
        const boundedLine = box;
        if (this.intersectsLine(testBox, boundedLine)) {
          return true;
        }
      } else {
        return true;
      }
    }
    return false;
  }
  intersectsLine(bbox, boundedLine) {
    const line = boundedLine.line;
    const lineXDiffTransformed = line.end.x - line.start.x;
    let signBL;
    let signBR;
    let signTL;
    let signTR;
    if (lineXDiffTransformed !== 0) {
      const lineYDiffTransformed = line.end.y - line.start.y;
      const normalX = lineYDiffTransformed;
      const normalY = -lineXDiffTransformed;
      const D = line.start.y - lineYDiffTransformed / lineXDiffTransformed * line.start.x;
      signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);
      signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);
      signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);
      signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);
    } else {
      signBL = Math.sign(bbox.minX - line.start.x);
      signBR = Math.sign(bbox.maxX - line.start.x);
      signTL = Math.sign(bbox.minX - line.start.x);
      signTR = Math.sign(bbox.maxX - line.start.x);
    }
    return signBL !== signBR || signBL !== signTL || signBL !== signTR;
  }
};
var ScreenCollisionsDebug = class extends ScreenCollisions {
  m_renderContext = null;
  m_renderingEnabled = false;
  m_numAllocations = 0;
  m_numSuccessfulTests = 0;
  m_numFailedTests = 0;
  m_numSuccessfulVisibilityTests = 0;
  m_numFailedVisibilityTests = 0;
  constructor(debugCanvas) {
    super();
    if (debugCanvas !== void 0 && debugCanvas !== null) {
      this.m_renderContext = debugCanvas.getContext("2d");
    }
  }
  reset() {
    super.reset();
    this.m_numAllocations = 0;
    this.m_numSuccessfulTests = 0;
    this.m_numFailedTests = 0;
    this.m_numSuccessfulVisibilityTests = 0;
    this.m_numFailedVisibilityTests = 0;
  }
  update(width, height) {
    if (this.m_renderingEnabled) {
      logger15.log(`Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `);
    }
    super.update(width, height);
    if (this.m_renderContext !== null) {
      this.m_renderContext.canvas.width = width;
      this.m_renderContext.canvas.height = height;
    }
    this.m_renderingEnabled = debugContext.getValue("DEBUG_SCREEN_COLLISIONS");
  }
  allocate(bounds) {
    super.allocate(bounds);
    this.m_numAllocations++;
    if (this.m_renderingEnabled && this.m_renderContext !== null) {
      this.m_renderContext.strokeStyle = "#6666ff";
      this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y, bounds.w, -bounds.h);
    }
  }
  allocateIBoxes(boundsArray) {
    for (const bounds of boundsArray) {
      this.m_numAllocations++;
      if (this.m_renderingEnabled && this.m_renderContext !== null) {
        this.m_renderContext.strokeStyle = "#aa2222";
        this.m_renderContext.strokeRect(bounds.minX - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.minY, bounds.maxX - bounds.minX, -(bounds.maxY - bounds.minY));
      }
    }
    super.allocateIBoxes(boundsArray);
  }
  intersectsDetails(testBox, boxes) {
    const collisionFound = super.intersectsDetails(testBox, boxes);
    if (this.m_renderingEnabled && this.m_renderContext !== null) {
      const padding = collisionFound ? 2 : 1;
      this.m_renderContext.strokeStyle = collisionFound ? "#FF0000" : "#00ff00";
      this.m_renderContext.strokeRect(testBox.x - this.screenBounds.x - padding, this.screenBounds.y + this.screenBounds.h - testBox.y + padding, testBox.w + 2 * padding, -testBox.h - 2 * padding);
    }
    if (collisionFound) {
      this.m_numFailedTests++;
    } else {
      this.m_numSuccessfulTests++;
    }
    return collisionFound;
  }
  isVisible(bounds) {
    const visible = super.isVisible(bounds);
    if (visible) {
      this.m_numSuccessfulVisibilityTests++;
    } else {
      this.m_numFailedVisibilityTests++;
    }
    return visible;
  }
};

// src/mapview/text/FontCatalogLoader.ts
var logger16 = LoggerManager.instance.create("FontCatalogLoader");
async function loadFontCatalog(fontCatalogConfig, onSuccess, onError) {
  return await FontCatalog.load(fontCatalogConfig.url, 1024).then(onSuccess.bind(void 0, fontCatalogConfig.name)).catch((error) => {
    logger16.error("Failed to load FontCatalog: ", fontCatalogConfig.name, error);
    if (onError) {
      onError(error);
    }
  });
}

// src/mapview/text/Placement.ts
var THREE81 = __toESM(require("three"));
var MIN_AVERAGE_CHAR_WIDTH = 5;
var tmpPosition = new THREE81.Vector3(0, 0, 0);
var tmpCameraDir = new THREE81.Vector3(0, 0, 0);
var tmpPointDir = new THREE81.Vector3(0, 0, 0);
var COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731;
function checkViewDistance(textElement, poiIndex, eyePos, eyeLookAt, projectionType, maxViewDistance) {
  const textDistance = computeViewDistance(textElement, poiIndex, eyePos, eyeLookAt);
  if (projectionType !== 1 /* Spherical */) {
    return textDistance <= maxViewDistance ? textDistance : void 0;
  }
  tmpPosition.copy(textElement.position).normalize();
  tmpCameraDir.copy(eyePos).normalize();
  const cosAlpha = tmpPosition.dot(tmpCameraDir);
  const viewDistance = cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance ? textDistance : void 0;
  return viewDistance;
}
function computeViewDistance(textElement, poiIndex, eyePosition, eyeLookAt) {
  let viewDistance;
  const path = textElement.path;
  if (path && path.length > 1) {
    if (poiIndex !== void 0 && path && path.length > poiIndex) {
      viewDistance = pointToPlaneDistance(path[poiIndex], eyePosition, eyeLookAt);
    } else {
      const viewDistance0 = pointToPlaneDistance(path[0], eyePosition, eyeLookAt);
      const viewDistance1 = pointToPlaneDistance(path[path.length - 1], eyePosition, eyeLookAt);
      viewDistance = Math.min(viewDistance0, viewDistance1);
    }
  } else {
    viewDistance = pointToPlaneDistance(textElement.position, eyePosition, eyeLookAt);
  }
  return viewDistance;
}
function pointToPlaneDistance(pointPos, planePos, planeNorm) {
  const labelCamVec = tmpPointDir.copy(pointPos).sub(planePos);
  return labelCamVec.dot(planeNorm);
}
function getMaxViewDistance(viewState, farDistanceLimitRatio) {
  return viewState.maxVisibilityDist * farDistanceLimitRatio;
}
var tmpPlacementPosition = new THREE81.Vector3();
function checkReadyForPlacement(textElement, poiIndex, viewState, poiManager, maxViewDistance) {
  let viewDistance;
  if (!textElement.visible) {
    return { result: 2 /* Invisible */, viewDistance };
  }
  if (!poiManager.updatePoiFromPoiTable(textElement)) {
    return { result: 1 /* NotReady */, viewDistance };
  }
  if (!textElement.visible || viewState.zoomLevel === textElement.maxZoomLevel || !MathUtils6.isClamped(viewState.zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {
    return { result: 2 /* Invisible */, viewDistance };
  }
  viewDistance = maxViewDistance === void 0 ? computeViewDistance(textElement, poiIndex, viewState.worldCenter, viewState.lookAtVector) : checkViewDistance(textElement, poiIndex, viewState.worldCenter, viewState.lookAtVector, viewState.projection.type, maxViewDistance);
  if (viewDistance === void 0) {
    return { result: 3 /* TooFar */, viewDistance };
  }
  return { result: 0 /* Ok */, viewDistance };
}
function computePointTextOffset(textElement, textBounds, placement, scale, env, offset = new THREE81.Vector2()) {
  assert(textElement.type === 0 /* PoiLabel */ || textElement.type === 2 /* LineMarker */);
  assert(textElement.layoutStyle !== void 0);
  offset.x = textElement.xOffset;
  offset.y = textElement.yOffset;
  switch (placement.h) {
    case -1 /* Left */:
      offset.x -= textBounds.max.x;
      break;
    case 0 /* Right */:
      offset.x -= textBounds.min.x;
      break;
  }
  switch (placement.v) {
    case 0 /* Top */:
      offset.y -= textBounds.min.y;
      break;
    case -0.5 /* Center */:
      offset.y -= 0.5 * (textBounds.max.y + textBounds.min.y);
      break;
    case -1 /* Bottom */:
      offset.y -= textBounds.max.y;
      break;
  }
  if (textElement.poiInfo !== void 0 && poiIsRenderable(textElement.poiInfo)) {
    assert(textElement.poiInfo.computedWidth !== void 0);
    assert(textElement.poiInfo.computedHeight !== void 0);
    offset.x += textElement.poiInfo.computedWidth * (0.5 + placement.h);
    offset.y += textElement.poiInfo.computedHeight * (0.5 + placement.v);
    const hAlign = hPlacementFromAlignment(textElement.layoutStyle.horizontalAlignment);
    const vAlign = vPlacementFromAlignment(textElement.layoutStyle.verticalAlignment);
    if (hAlign !== placement.h || vAlign !== placement.v) {
      const technique = textElement.poiInfo.technique;
      let iconXOffset = getPropertyValue(technique.iconXOffset, env);
      let iconYOffset = getPropertyValue(technique.iconYOffset, env);
      iconXOffset = typeof iconXOffset === "number" ? iconXOffset : 0;
      iconYOffset = typeof iconYOffset === "number" ? iconYOffset : 0;
      const hAlignDiff = hAlign - placement.h;
      const vAlignDiff = vAlign - placement.v;
      const relOffsetX = iconXOffset - textElement.xOffset;
      const relOffsetY = iconYOffset - textElement.yOffset;
      const centerBased = hAlign === -0.5 /* Center */ || vAlign === -0.5 /* Center */;
      if (centerBased) {
        offset.x += 2 * Math.abs(hAlignDiff) * relOffsetX;
        offset.y -= 2 * vAlignDiff * Math.abs(relOffsetX);
        offset.y += 2 * Math.abs(vAlignDiff) * relOffsetY;
        offset.x -= 2 * hAlignDiff * Math.abs(relOffsetY);
      } else {
        offset.x += 2 * Math.min(Math.abs(hAlignDiff), 0.5) * relOffsetX;
        offset.y -= 2 * Math.sign(vAlignDiff) * Math.min(Math.abs(vAlignDiff), 0.5) * Math.abs(relOffsetX);
        offset.y += 2 * Math.min(Math.abs(vAlignDiff), 0.5) * relOffsetY;
        offset.x -= 2 * Math.sign(hAlignDiff) * Math.min(Math.abs(hAlignDiff), 0.5) * Math.abs(relOffsetY);
      }
    }
  }
  offset.multiplyScalar(scale);
  return offset;
}
var tmpBox3 = new THREE81.Box2();
var tmpBounds = new THREE81.Box2();
var tmpBoxes = [];
var tmpMeasurementParams = {};
var tmpCollisionBoxes = [];
var tmpCollisionBox2 = new CollisionBox();
var tmpScreenPosition = new THREE81.Vector2();
var tmpTextOffset = new THREE81.Vector2();
var tmp2DBox = new Math2D.Box();
var tmpCenter = new THREE81.Vector2();
var tmpSize = new THREE81.Vector2();
var persistentPointLabelTextMargin = new THREE81.Vector2(2, 2);
var newPointLabelTextMarginPercent = 0.1;
function placeIcon(iconRenderState, poiInfo, screenPosition, scaleFactor, env, screenCollisions) {
  PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, env, tmp2DBox);
  if (!screenCollisions.isVisible(tmp2DBox)) {
    return 2 /* Invisible */;
  }
  const iconSpaceAvailable = poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);
  return !iconSpaceAvailable ? 1 /* Rejected */ : 0 /* Ok */;
}
function placePointLabel(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition, multiAnchor = false) {
  assert(labelState.element.layoutStyle !== void 0);
  const layoutStyle = labelState.element.layoutStyle;
  multiAnchor = multiAnchor && layoutStyle.placements !== void 0 && layoutStyle.placements.length > 1;
  if (!multiAnchor) {
    return placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);
  } else {
    return placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);
  }
}
function placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {
  assert(labelState.element.layoutStyle !== void 0);
  const label = labelState.element;
  const persistent = labelState.visible;
  const lastPlacement = labelState.textPlacement;
  const placements = label.layoutStyle.placements;
  const placementsNum = placements.length;
  const matchIdx = placements.findIndex((p) => p.h === lastPlacement.h && p.v === lastPlacement.v);
  assert(matchIdx >= 0);
  let allInvisible = true;
  for (let i = matchIdx; i < placementsNum + matchIdx; ++i) {
    const anchorPlacement = placements[i % placementsNum];
    const isLastPlacement = i === matchIdx && persistent;
    const placementResult = placePointLabelAtAnchor(labelState, screenPosition, anchorPlacement, scale, textCanvas, env, screenCollisions, !isLastPlacement, tmpPlacementPosition);
    if (placementResult === 0 /* Ok */) {
      outScreenPosition.copy(tmpPlacementPosition);
      return 0 /* Ok */;
    }
    if (isLastPlacement) {
      outScreenPosition.copy(tmpPlacementPosition);
    }
    allInvisible = allInvisible && placementResult === 2 /* Invisible */;
  }
  return allInvisible ? 2 /* Invisible */ : 1 /* Rejected */;
}
function placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {
  assert(labelState.element.layoutStyle !== void 0);
  const lastPlacement = labelState.textPlacement;
  const result = placePointLabelAtAnchor(labelState, screenPosition, lastPlacement, scale, textCanvas, env, screenCollisions, !labelState.visible, outScreenPosition);
  return result;
}
function placePointLabelAtAnchor(labelState, screenPosition, placement, scale, textCanvas, env, screenCollisions, forceInvalidation, outScreenPosition) {
  const label = labelState.element;
  assert(label.glyphs !== void 0);
  assert(label.layoutStyle !== void 0);
  const measureText = !label.bounds || forceInvalidation;
  const labelBounds = measureText ? tmpBounds : label.bounds;
  if (measureText) {
    applyTextPlacement(textCanvas, placement);
    tmpMeasurementParams.outputCharacterBounds = void 0;
    tmpMeasurementParams.path = void 0;
    tmpMeasurementParams.pathOverflow = false;
    tmpMeasurementParams.letterCaseArray = label.glyphCaseArray;
    textCanvas.measureText(label.glyphs, labelBounds, tmpMeasurementParams);
  }
  const textOffset = computePointTextOffset(label, labelBounds, placement, scale, env, tmpTextOffset).add(screenPosition);
  outScreenPosition.set(textOffset.x, textOffset.y, labelState.renderDistance);
  tmpBox3.copy(labelBounds).expandByVector(persistentPointLabelTextMargin).translate(textOffset);
  tmpBox3.getCenter(tmpCenter);
  tmpBox3.getSize(tmpSize);
  tmpSize.multiplyScalar(scale);
  tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);
  if (!screenCollisions.isVisible(tmp2DBox)) {
    return 2 /* Invisible */;
  }
  if (measureText) {
    tmpBox3.getSize(tmpSize);
    tmpSize.multiplyScalar(scale * (1 + newPointLabelTextMarginPercent));
    tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);
  }
  if (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox)) {
    return 1 /* Rejected */;
  }
  if (label.textReservesSpace) {
    screenCollisions.allocate(tmp2DBox);
  }
  if (measureText) {
    label.textBufferObject = void 0;
    label.bounds = label.bounds ? label.bounds.copy(labelBounds) : labelBounds.clone();
  } else {
    applyTextPlacement(textCanvas, placement);
  }
  labelState.textPlacement = placement;
  return 0 /* Ok */;
}
function applyTextPlacement(textCanvas, placement) {
  textCanvas.textLayoutStyle.horizontalAlignment = hAlignFromPlacement(placement.h);
  textCanvas.textLayoutStyle.verticalAlignment = vAlignFromPlacement(placement.v);
}
function placePathLabel(labelState, textPath, screenPosition, textCanvas, screenCollisions) {
  tmpMeasurementParams.path = textPath;
  tmpMeasurementParams.outputCharacterBounds = tmpBoxes;
  tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray;
  if (!textCanvas.measureText(labelState.element.glyphs, tmpBox3, tmpMeasurementParams)) {
    return 1 /* Rejected */;
  }
  tmpCollisionBox2.copy(tmpBox3.translate(screenPosition));
  if (!screenCollisions.isVisible(tmpCollisionBox2)) {
    return 2 /* Invisible */;
  }
  let checkGlyphCollision = false;
  let candidateBoxes;
  if (!labelState.element.textMayOverlap) {
    candidateBoxes = screenCollisions.search(tmpCollisionBox2);
    checkGlyphCollision = candidateBoxes.length > 0;
  }
  tmpCollisionBoxes.length = tmpBoxes.length;
  for (let i = 0; i < tmpBoxes.length; ++i) {
    const glyphBox = tmpBoxes[i].translate(screenPosition);
    let collisionBox = tmpCollisionBoxes[i];
    if (collisionBox === void 0) {
      collisionBox = new CollisionBox(glyphBox);
      tmpCollisionBoxes[i] = collisionBox;
    } else {
      collisionBox.copy(glyphBox);
    }
    if (checkGlyphCollision && screenCollisions.intersectsDetails(collisionBox, candidateBoxes)) {
      return 1 /* Rejected */;
    }
  }
  if (labelState.element.textReservesSpace) {
    const collisionBox = new DetailedCollisionBox(tmpCollisionBox2, tmpCollisionBoxes.slice());
    tmpCollisionBoxes.length = 0;
    screenCollisions.allocate(collisionBox);
  }
  return 0 /* Ok */;
}
function isPathLabelTooSmall(textElement, screenProjector, outScreenPoints) {
  assert(textElement.type === 1 /* PathLabel */);
  outScreenPoints.length = 0;
  let anyPointVisible = false;
  for (const pt of textElement.points) {
    const screenPoint = anyPointVisible ? screenProjector.project(pt, tmpScreenPosition) : screenProjector.projectToScreen(pt, tmpScreenPosition);
    if (screenPoint === void 0) {
      continue;
    }
    anyPointVisible = true;
    outScreenPoints.push(tmpScreenPosition.clone());
  }
  if (!anyPointVisible) {
    return true;
  }
  const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;
  tmpBox3.setFromPoints(outScreenPoints);
  const boxDiagonalSq = tmpBox3.max.sub(tmpBox3.min).lengthSq();
  if (boxDiagonalSq < minScreenSpace * minScreenSpace) {
    textElement.dbgPathTooSmall = true;
    return true;
  }
  return false;
}
var tmpOrientedBox = new OrientedBox3();
function getWorldPosition(poiLabel, projection, env, outWorldPosition) {
  var _a, _b;
  const worldOffsetShiftValue = getPropertyValue((_b = (_a = poiLabel.poiInfo) == null ? void 0 : _a.technique) == null ? void 0 : _b.worldOffset, env);
  outWorldPosition == null ? void 0 : outWorldPosition.copy(poiLabel.position);
  if (worldOffsetShiftValue !== null && worldOffsetShiftValue !== void 0 && poiLabel.offsetDirection !== void 0) {
    projection.localTangentSpace(poiLabel.position, tmpOrientedBox);
    const offsetDirectionVector = tmpOrientedBox.yAxis;
    const offsetDirectionRad = THREE81.MathUtils.degToRad(poiLabel.offsetDirection);
    offsetDirectionVector.applyAxisAngle(tmpOrientedBox.zAxis.negate(), offsetDirectionRad);
    outWorldPosition.addScaledVector(tmpOrientedBox.yAxis, worldOffsetShiftValue);
  }
  return outWorldPosition;
}

// src/mapview/text/PlacementStats.ts
var PlacementStats = class {
  constructor(m_logger) {
    this.m_logger = m_logger;
  }
  totalGroups = 0;
  resortedGroups = 0;
  total = 0;
  uninitialized = 0;
  tooFar = 0;
  numNotVisible = 0;
  numPathTooSmall = 0;
  numCannotAdd = 0;
  numRenderedPoiIcons = 0;
  numRenderedPoiTexts = 0;
  numPoiTextsInvisible = 0;
  numRenderedTextElements = 0;
  clear() {
    this.totalGroups = 0;
    this.resortedGroups = 0;
    this.total = 0;
    this.uninitialized = 0;
    this.tooFar = 0;
    this.numNotVisible = 0;
    this.numPathTooSmall = 0;
    this.numCannotAdd = 0;
    this.numRenderedPoiIcons = 0;
    this.numRenderedPoiTexts = 0;
    this.numPoiTextsInvisible = 0;
    this.numRenderedTextElements = 0;
  }
  log() {
    const numNotRendered = this.uninitialized + this.numPoiTextsInvisible + this.tooFar + this.numNotVisible + this.numCannotAdd;
    this.m_logger.debug("Total groups", this.totalGroups);
    this.m_logger.debug("Resorted groups", this.resortedGroups);
    this.m_logger.debug("Total labels", this.total);
    this.m_logger.debug("Rendered labels", this.numRenderedTextElements);
    this.m_logger.debug("Rejected labels", numNotRendered);
    this.m_logger.debug("Unitialized labels", this.uninitialized);
    this.m_logger.debug("Rendered poi icons", this.numRenderedPoiIcons);
    this.m_logger.debug("Rendered poi texts", this.numRenderedPoiTexts);
    this.m_logger.debug("Poi text invisible", this.numPoiTextsInvisible);
    this.m_logger.debug("Too far", this.tooFar);
    this.m_logger.debug("Not visible", this.numNotVisible);
    this.m_logger.debug("Path too small", this.numPathTooSmall);
    this.m_logger.debug("Rejected, max glyphs reached", this.numCannotAdd);
  }
};

// src/mapview/text/SimplePath.ts
var THREE82 = __toESM(require("three"));
var SimpleLineCurve = class extends THREE82.LineCurve {
  m_lengths;
  constructor(v1, v2) {
    super(v1, v2);
  }
  getLengths() {
    if (this.m_lengths === void 0) {
      this.m_lengths = [0, this.v2.distanceTo(this.v1)];
    }
    return this.m_lengths;
  }
};
var PathParam = class {
  constructor(path, index, t) {
    this.path = path;
    this.index = index;
    this.t = t;
  }
  m_point;
  get curve() {
    return this.path.curves[this.index];
  }
  get point() {
    if (this.m_point === void 0) {
      this.m_point = this.curve.getPoint(this.t);
    }
    return this.m_point;
  }
};
var SimplePath = class extends THREE82.Path {
  m_cache;
  constructor() {
    super();
  }
  getLengths() {
    if (this.m_cache) {
      return this.m_cache;
    }
    let sum = 0;
    const lengths = new Array();
    lengths.push(0);
    this.curves.forEach((curve) => {
      const lineCurve = curve;
      sum += lineCurve.v1.distanceTo(lineCurve.v2);
      lengths.push(sum);
    });
    this.m_cache = lengths;
    return lengths;
  }
  getParamAt(t) {
    const distance = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    for (let index = 0; index < curveLengths.length; ++index) {
      if (curveLengths[index] < distance) {
        continue;
      }
      const diff = curveLengths[index] - distance;
      const curve = this.curves[index];
      const segmentLength = curve.getLength();
      const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
      return new PathParam(this, index, u);
    }
    return null;
  }
};

// src/mapview/text/TextCanvasFactory.ts
var TextCanvasFactory = class {
  constructor(m_renderer) {
    this.m_renderer = m_renderer;
  }
  m_minGlyphCount = 0;
  m_maxGlyphCount = 0;
  setGlyphCountLimits(min, max) {
    this.m_minGlyphCount = min;
    this.m_maxGlyphCount = max;
  }
  createTextCanvas(fontCatalog, name2) {
    assert(this.m_maxGlyphCount > 0);
    return new TextCanvas({
      renderer: this.m_renderer,
      fontCatalog,
      minGlyphCount: this.m_minGlyphCount,
      maxGlyphCount: this.m_maxGlyphCount,
      name: name2
    });
  }
};

// src/mapview/text/TextElementsRendererOptions.ts
var DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;
var DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;
var DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;
var DEFAULT_MAX_DISTANCE_TO_BORDER = 0.2;
var MIN_GLYPH_COUNT = 1024;
var MAX_GLYPH_COUNT = 32768;
function initializeDefaultOptions(options) {
  if (options.minNumGlyphs === void 0) {
    options.minNumGlyphs = MIN_GLYPH_COUNT;
  }
  if (options.maxNumGlyphs === void 0) {
    options.maxNumGlyphs = MAX_GLYPH_COUNT;
  }
  if (options.labelDistanceScaleMin === void 0) {
    options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;
  }
  if (options.labelDistanceScaleMax === void 0) {
    options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;
  }
  if (options.maxDistanceRatioForTextLabels === void 0) {
    options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
  }
  if (options.maxDistanceRatioForPoiLabels === void 0) {
    options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
  }
  if (options.disableFading === void 0) {
    options.disableFading = false;
  }
  if (options.delayLabelsUntilMovementFinished === void 0) {
    options.delayLabelsUntilMovementFinished = true;
  }
  if (options.showReplacementGlyphs === void 0) {
    options.showReplacementGlyphs = false;
  }
  if (options.maxPoiDistanceToBorder === void 0) {
    options.maxPoiDistanceToBorder = DEFAULT_MAX_DISTANCE_TO_BORDER;
  }
}

// src/mapview/text/LayoutState.ts
var LayoutState = class {
  m_hAlign = DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;
  m_vAlign = DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;
  constructor(placement) {
    this.textPlacement = placement;
  }
  set textPlacement(placement) {
    this.m_hAlign = hAlignFromPlacement(placement.h);
    this.m_vAlign = vAlignFromPlacement(placement.v);
  }
  get textPlacement() {
    return {
      h: hPlacementFromAlignment(this.m_hAlign),
      v: vPlacementFromAlignment(this.m_vAlign)
    };
  }
  reset(layoutStyle) {
    this.m_hAlign = layoutStyle.horizontalAlignment;
    this.m_vAlign = layoutStyle.verticalAlignment;
  }
  get horizontalAlignment() {
    return this.m_hAlign;
  }
  get verticalAlignment() {
    return this.m_vAlign;
  }
};

// src/mapview/text/RenderState.ts
var THREE83 = __toESM(require("three"));
var DEFAULT_FADE_TIME = 800;
var RenderState = class {
  constructor(fadeTime = DEFAULT_FADE_TIME) {
    this.fadeTime = fadeTime;
  }
  value = 0;
  startTime = 0;
  opacity = 0;
  m_state = 0 /* Undefined */;
  reset() {
    this.m_state = 0 /* Undefined */;
    this.value = 0;
    this.startTime = 0;
    this.opacity = 0;
  }
  isUndefined() {
    return this.m_state === 0 /* Undefined */;
  }
  isFading() {
    const fading = this.m_state === 1 /* FadingIn */ || this.m_state === -1 /* FadingOut */;
    return fading;
  }
  isFadingIn() {
    const fadingIn = this.m_state === 1 /* FadingIn */;
    return fadingIn;
  }
  isFadingOut() {
    const fadingOut = this.m_state === -1 /* FadingOut */;
    return fadingOut;
  }
  isFadedIn() {
    const fadedIn = this.m_state === 2 /* FadedIn */;
    return fadedIn;
  }
  isFadedOut() {
    const fadedOut = this.m_state === -2 /* FadedOut */;
    return fadedOut;
  }
  isVisible() {
    return this.m_state !== -2 /* FadedOut */ && this.m_state !== 0 /* Undefined */ && this.opacity > 0;
  }
  startFadeIn(time, disableFading) {
    if (this.m_state === 1 /* FadingIn */ || this.m_state === 2 /* FadedIn */) {
      return;
    }
    if (disableFading === true) {
      this.value = 1;
      this.opacity = 1;
      this.m_state = 2 /* FadedIn */;
      this.startTime = time;
      return;
    }
    if (this.m_state === -1 /* FadingOut */) {
      this.value = 1 - this.value;
      this.startTime = time - this.value * this.fadeTime;
    } else {
      this.startTime = time;
      this.value = 0;
      this.opacity = 0;
    }
    this.m_state = 1 /* FadingIn */;
  }
  startFadeOut(time) {
    if (this.m_state === -1 /* FadingOut */ || this.m_state === -2 /* FadedOut */ || this.m_state === 0 /* Undefined */) {
      return;
    }
    if (this.m_state === 1 /* FadingIn */) {
      this.startTime = time - this.value * this.fadeTime;
      this.value = 1 - this.value;
    } else {
      this.startTime = time;
      this.value = 0;
      this.opacity = 1;
    }
    this.m_state = -1 /* FadingOut */;
  }
  updateFading(time, disableFading) {
    if (this.m_state !== 1 /* FadingIn */ && this.m_state !== -1 /* FadingOut */) {
      return;
    }
    if (this.startTime === 0) {
      this.startTime = time;
    }
    const fadingTime = time - this.startTime;
    const startValue = this.m_state === 1 /* FadingIn */ ? 0 : 1;
    const endValue = this.m_state === 1 /* FadingIn */ ? 1 : 0;
    if (disableFading || fadingTime >= this.fadeTime) {
      this.value = 1;
      this.opacity = endValue;
      this.m_state = this.m_state === 1 /* FadingIn */ ? 2 /* FadedIn */ : -2 /* FadedOut */;
    } else {
      this.value = fadingTime / this.fadeTime;
      this.opacity = THREE83.MathUtils.clamp(MathUtils6.smootherStep(startValue, endValue, this.value), 0, 1);
      assert(this.isFading());
    }
  }
};

// src/mapview/text/TextElementState.ts
var TextElementState = class {
  constructor(element, positionIndex) {
    this.element = element;
    this.m_lineMarkerIndex = positionIndex;
  }
  m_viewDistance;
  m_iconRenderState;
  m_textRenderState;
  m_textLayoutState;
  m_lineMarkerIndex;
  get initialized() {
    return this.m_textRenderState !== void 0 || this.m_iconRenderState !== void 0;
  }
  get visible() {
    if (this.m_textRenderState !== void 0 && this.m_textRenderState.isVisible()) {
      return true;
    }
    const iconRenderState = this.iconRenderState;
    if (iconRenderState !== void 0 && iconRenderState.isVisible()) {
      return true;
    }
    return false;
  }
  get textPlacement() {
    const themeLayout = this.element.layoutStyle;
    const stateLayout = this.m_textLayoutState;
    const lastPlacement = stateLayout !== void 0 ? stateLayout.textPlacement : {
      h: hPlacementFromAlignment(themeLayout.horizontalAlignment),
      v: vPlacementFromAlignment(themeLayout.verticalAlignment)
    };
    return lastPlacement;
  }
  set textPlacement(placement) {
    if (this.m_textLayoutState === void 0 && this.isBaseTextPlacement(placement) === true) {
      return;
    }
    if (this.m_textLayoutState === void 0) {
      this.m_textLayoutState = new LayoutState(placement);
    } else {
      this.m_textLayoutState.textPlacement = placement;
    }
  }
  isBaseTextPlacement(placement) {
    const themeLayout = this.element.layoutStyle;
    if (themeLayout !== void 0) {
      return hAlignFromPlacement(placement.h) === themeLayout.horizontalAlignment && vAlignFromPlacement(placement.v) === themeLayout.verticalAlignment;
    }
    return void 0;
  }
  reset() {
    if (this.m_textRenderState !== void 0) {
      this.m_textRenderState.reset();
    }
    if (this.m_textLayoutState !== void 0) {
      if (this.element.layoutStyle !== void 0) {
        this.m_textLayoutState.reset(this.element.layoutStyle);
      } else {
        this.m_textLayoutState = void 0;
      }
    }
    if (this.iconRenderState) {
      ;
      this.m_iconRenderState.reset();
    }
    this.m_viewDistance = void 0;
    this.element.textBufferObject = void 0;
    this.element.bounds = void 0;
  }
  replace(predecessor) {
    this.m_textRenderState = predecessor.m_textRenderState;
    this.m_textLayoutState = predecessor.m_textLayoutState;
    this.m_iconRenderState = predecessor.m_iconRenderState;
    predecessor.m_textRenderState = void 0;
    predecessor.m_textLayoutState = void 0;
    predecessor.m_iconRenderState = void 0;
    if (this.element.glyphs === void 0) {
      this.element.glyphs = predecessor.element.glyphs;
      this.element.glyphCaseArray = predecessor.element.glyphCaseArray;
    }
    this.element.bounds = void 0;
    this.element.textBufferObject = void 0;
  }
  get viewDistance() {
    return this.m_viewDistance;
  }
  update(viewDistance) {
    if (!this.initialized && viewDistance !== void 0) {
      this.initializeRenderStates();
    }
    this.setViewDistance(viewDistance);
  }
  setViewDistance(viewDistance) {
    this.m_viewDistance = viewDistance;
  }
  get renderDistance() {
    return this.element.alwaysOnTop === true ? 0 : this.m_viewDistance !== void 0 ? -this.m_viewDistance : 0;
  }
  get textRenderState() {
    return this.m_textRenderState;
  }
  get iconRenderState() {
    return this.m_iconRenderState;
  }
  get lineMarkerIndex() {
    return this.m_lineMarkerIndex;
  }
  get position() {
    return this.element.path !== void 0 && this.m_lineMarkerIndex !== void 0 ? this.element.path[this.m_lineMarkerIndex] : this.element.position;
  }
  updateFading(time, disableFading) {
    if (this.m_textRenderState !== void 0) {
      this.m_textRenderState.updateFading(time, disableFading);
    }
    if (this.iconRenderState !== void 0) {
      this.iconRenderState.updateFading(time, disableFading);
    }
  }
  initializeRenderStates() {
    var _a;
    assert(this.m_textRenderState === void 0);
    assert(this.m_textLayoutState === void 0);
    assert(this.m_iconRenderState === void 0);
    const { textFadeTime } = this.element;
    this.m_textRenderState = new RenderState(textFadeTime);
    if (this.element.type === 0 /* PoiLabel */ || this.element.type === 2 /* LineMarker */) {
      const techniqueIconFadeTime = (_a = this.element.poiInfo) == null ? void 0 : _a.technique.iconFadeTime;
      const iconFadeTime = techniqueIconFadeTime !== void 0 ? techniqueIconFadeTime * 1e3 : textFadeTime;
      this.m_iconRenderState = new RenderState(iconFadeTime);
    }
  }
};
function isLineMarkerElementState(state) {
  return state.m_lineMarkerIndex !== void 0;
}

// src/mapview/text/TextElementGroupState.ts
var TextElementGroupState = class {
  constructor(group, tileKey, filter) {
    this.group = group;
    this.tileKey = tileKey;
    assert(group.elements.length > 0);
    const length = group.elements.length;
    this.m_textElementStates = [];
    this.m_visited = true;
    for (let i = 0; i < length; ++i) {
      const textElement = group.elements[i];
      if (textElement.type === 2 /* LineMarker */ && textElement.path !== void 0) {
        const numPoints = textElement.path.length;
        for (let p = 0; p < numPoints; p++) {
          const state = new TextElementState(textElement, p);
          const textDistance = filter(state);
          state.update(textDistance);
          this.m_textElementStates.push(state);
        }
      } else {
        const state = new TextElementState(textElement);
        const textDistance = filter(state);
        state.update(textDistance);
        this.m_textElementStates.push(state);
      }
    }
  }
  m_textElementStates;
  m_visited = false;
  get visited() {
    return this.m_visited;
  }
  set visited(visited) {
    this.m_visited = visited;
  }
  get priority() {
    return this.group.priority;
  }
  updateFading(time, disableFading) {
    for (const elementState of this.m_textElementStates) {
      if (elementState !== void 0) {
        elementState.updateFading(time, disableFading);
      }
    }
  }
  traverseVisibleElements(visibleElementsCallback) {
    for (const elementState of this.m_textElementStates) {
      if (elementState !== void 0 && elementState.visible) {
        visibleElementsCallback(elementState);
      }
    }
  }
  updateElements(filter) {
    for (const elementState of this.m_textElementStates) {
      const textDistance = filter(elementState);
      elementState.update(textDistance);
    }
  }
  get size() {
    return this.m_textElementStates.length;
  }
  get textElementStates() {
    return this.m_textElementStates;
  }
};

// src/mapview/text/TextElementStateCache.ts
var logger17 = LoggerManager.instance.create("TextElementsStateCache", {
  level: 2 /* Log */
});
function getDedupSqDistTolerance(zoomLevel) {
  const minSqTol = 100;
  const minSqTolLevel = 13;
  const maxLevelDelta = 4;
  const levelDelta = Math.min(maxLevelDelta, minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel)));
  return minSqTol << (levelDelta << 2);
}
var tmpCachedDuplicate = {
  entries: [],
  index: -1
};
function getCacheKey(element) {
  return element.hasFeatureId() ? element.featureId : element.text;
}
function findDuplicateById(elementState, candidates) {
  const element = elementState.element;
  const duplicateIndex = candidates.findIndex((entry) => entry.element.tileOffset === element.tileOffset);
  if (duplicateIndex === -1) {
    return -1;
  }
  const candidateElement = candidates[duplicateIndex];
  const candidate = candidateElement.element;
  assert(element.featureId === candidate.featureId);
  if (candidate.text !== element.text) {
    logger17.debug(`Text feature id ${element.featureId} collision between "${element.text} and              ${candidate.text}`);
    return void 0;
  }
  return duplicateIndex;
}
function isBetterPathDuplicate(newCandidate, _newDistance, oldCandidate, _oldDistance) {
  if (newCandidate.pathLengthSqr === void 0) {
    return false;
  }
  if (oldCandidate.pathLengthSqr === void 0) {
    return false;
  }
  return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;
}
function isBetterPointDuplicate(_newCandidate, newDistance, _oldCandidate, oldDistance) {
  return newDistance < oldDistance;
}
function findDuplicateByText(elementState, candidates, zoomLevel) {
  const element = elementState.element;
  const maxSqDistError = getDedupSqDistTolerance(zoomLevel);
  const entryCount = candidates.length;
  const elementPosition = elementState.position;
  const elementVisible = elementState.visible;
  const isLineMarker = isLineMarkerElementState(elementState);
  let dupIndex = -1;
  let duplicate;
  let dupDistSquared = Infinity;
  const isBetterDuplicate = element.type === 1 /* PathLabel */ ? isBetterPathDuplicate : isBetterPointDuplicate;
  for (let i = 0; i < entryCount; ++i) {
    const candidateEntry = candidates[i];
    const cachedElement = candidateEntry.element;
    const areDiffType = element.type !== cachedElement.type || isLineMarker !== isLineMarkerElementState(candidateEntry);
    const areBothVisible = elementVisible && candidateEntry.visible;
    if (areDiffType || areBothVisible) {
      continue;
    }
    const distSquared = elementPosition.distanceToSquared(cachedElement.position);
    if (distSquared > maxSqDistError) {
      continue;
    }
    if (duplicate === void 0 || isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)) {
      dupIndex = i;
      duplicate = cachedElement;
      dupDistSquared = distSquared;
    }
  }
  return dupIndex;
}
var TextElementStateCache = class {
  m_referenceMap = /* @__PURE__ */ new Map();
  m_sortedGroupStates;
  m_textMap = /* @__PURE__ */ new Map();
  getOrSet(textElementGroup, tileKey, textElementFilter) {
    let groupState = this.get(textElementGroup);
    if (groupState !== void 0) {
      groupState.updateElements(textElementFilter);
      return [groupState, true];
    }
    groupState = new TextElementGroupState(textElementGroup, tileKey, textElementFilter);
    this.set(textElementGroup, groupState);
    return [groupState, false];
  }
  get size() {
    return this.m_referenceMap.size;
  }
  get cacheSize() {
    return this.m_textMap.size;
  }
  get sortedGroupStates() {
    if (this.m_sortedGroupStates === void 0) {
      this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());
      this.m_sortedGroupStates.sort((a, b) => {
        return b.group.priority - a.group.priority;
      });
    }
    assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);
    return this.m_sortedGroupStates;
  }
  update(time, disableFading, findReplacements, zoomLevel) {
    const replaceCallback = findReplacements ? this.replaceElement.bind(this, zoomLevel) : void 0;
    let anyEviction = false;
    for (const [key, groupState] of this.m_referenceMap.entries()) {
      if (groupState.visited) {
        groupState.updateFading(time, disableFading);
      } else {
        if (findReplacements) {
          groupState.traverseVisibleElements(replaceCallback);
        }
        this.m_referenceMap.delete(key);
        this.m_sortedGroupStates = void 0;
        anyEviction = true;
      }
    }
    return anyEviction;
  }
  clearVisited() {
    for (const groupState of this.m_referenceMap.values()) {
      groupState.visited = false;
    }
  }
  clearTextCache() {
    this.m_textMap.clear();
  }
  clear() {
    this.m_referenceMap.clear();
    this.m_sortedGroupStates = void 0;
    this.m_textMap.clear();
  }
  deduplicateElement(zoomLevel, elementState) {
    const cacheResult = this.findDuplicate(elementState, zoomLevel);
    if (cacheResult === void 0) {
      this.m_textMap.set(getCacheKey(elementState.element), [elementState]);
      return true;
    }
    if (cacheResult.index === -1) {
      cacheResult.entries.push(elementState);
      return true;
    }
    const cachedDuplicate = cacheResult.entries[cacheResult.index];
    if (!cachedDuplicate.visible && elementState.visible) {
      cacheResult.entries[cacheResult.index] = elementState;
      cachedDuplicate.reset();
      return true;
    }
    return false;
  }
  replaceElement(zoomLevel, elementState) {
    assert(elementState.visible);
    const cacheResult = this.findDuplicate(elementState, zoomLevel);
    if (cacheResult === void 0 || cacheResult.index === -1) {
      return false;
    }
    const replacement = cacheResult.entries[cacheResult.index];
    assert(!replacement.visible);
    replacement.replace(elementState);
    return true;
  }
  get(textElementGroup) {
    const groupState = this.m_referenceMap.get(textElementGroup);
    if (groupState !== void 0) {
      groupState.visited = true;
    }
    return groupState;
  }
  set(textElementGroup, textElementGroupState) {
    assert(textElementGroup.elements.length > 0);
    this.m_referenceMap.set(textElementGroup, textElementGroupState);
    this.m_sortedGroupStates = void 0;
  }
  findDuplicate(elementState, zoomLevel) {
    const element = elementState.element;
    const cachedEntries = this.m_textMap.get(getCacheKey(element));
    if (cachedEntries === void 0) {
      return void 0;
    }
    tmpCachedDuplicate.entries = cachedEntries;
    const index = element.hasFeatureId() ? findDuplicateById(elementState, cachedEntries) : findDuplicateByText(elementState, cachedEntries, zoomLevel);
    if (index === void 0) {
      element.featureId = void 0;
      return this.findDuplicate(elementState, zoomLevel);
    }
    tmpCachedDuplicate.index = index;
    return tmpCachedDuplicate;
  }
};

// src/mapview/text/TextStyleCache.ts
var logger18 = LoggerManager.instance.create("TextStyleCache");
var defaultTextRenderStyle = new TextRenderStyle({
  fontSize: {
    unit: 1 /* Pixel */,
    size: 32,
    backgroundSize: 8
  },
  color: ColorCache.instance.getColor("#6d7477"),
  opacity: 1,
  backgroundColor: ColorCache.instance.getColor("#f7fbfd"),
  backgroundOpacity: 0.5
});
var defaultTextLayoutStyle = new TextLayoutStyle({
  verticalAlignment: -0.5 /* Center */,
  horizontalAlignment: -0.5 /* Center */,
  placements: []
});
var DEFAULT_STYLE_NAME = "default";
var TextStyleCache = class {
  m_textStyles = /* @__PURE__ */ new Map();
  m_defaultStyle = {
    name: DEFAULT_STYLE_NAME,
    fontCatalog: void 0,
    renderParams: defaultTextRenderStyle.params,
    layoutParams: defaultTextLayoutStyle.params
  };
  constructor() {
    this.updateDefaultTextStyle();
  }
  updateTextStyles(textStyleDefinitions, defaultTextStyleDefinition) {
    this.m_textStyles.clear();
    textStyleDefinitions == null ? void 0 : textStyleDefinitions.forEach((element) => {
      this.m_textStyles.set(element.name, this.createTextElementStyle(element, element.name));
    });
    this.updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions);
  }
  updateTextCanvases(textCanvases) {
    this.initializeTextCanvas(this.m_defaultStyle, textCanvases);
    for (const [, style] of this.m_textStyles) {
      this.initializeTextCanvas(style, textCanvases);
    }
  }
  getTextElementStyle(styleId) {
    let result;
    if (styleId === void 0) {
      result = this.m_defaultStyle;
    } else {
      result = this.m_textStyles.get(styleId);
      if (result === void 0) {
        result = this.m_defaultStyle;
      }
    }
    return result;
  }
  createRenderStyle(tile, technique) {
    const mapView = tile.mapView;
    const zoomLevel = mapView.zoomLevel;
    const discreteZoomLevel = Math.floor(zoomLevel);
    const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
    const defaultRenderParams = this.m_defaultStyle.renderParams;
    const defaultOpacity = getOptionValue(defaultRenderParams.opacity, 1);
    let opacity = getPropertyValue(getOptionValue(technique.opacity, defaultOpacity), discreteZoomEnv);
    let color;
    if (technique.color !== void 0) {
      let hexColor = evaluateColorProperty(technique.color, discreteZoomEnv);
      if (hexColor !== void 0) {
        if (ColorUtils.hasAlphaInHex(hexColor)) {
          const alpha = ColorUtils.getAlphaFromHex(hexColor);
          opacity = opacity * alpha;
          hexColor = ColorUtils.removeAlphaFromHex(hexColor);
        }
        color = ColorCache.instance.getColor(hexColor);
      }
    }
    const defaultBackgroundSize = getOptionValue(defaultRenderParams.fontSize.backgroundSize, 0);
    const backgroundSize = getPropertyValue(getOptionValue(technique.backgroundSize, defaultBackgroundSize), discreteZoomEnv);
    const hasBackgroundDefined = technique.backgroundColor !== void 0 && technique.backgroundSize !== void 0 && backgroundSize > 0;
    const defaultBackgroundOpacity = getOptionValue(defaultRenderParams.backgroundOpacity, 0);
    let backgroundOpacity = getPropertyValue(getOptionValue(technique.backgroundOpacity, hasBackgroundDefined ? 1 : defaultBackgroundOpacity), discreteZoomEnv);
    let backgroundColor;
    if (technique.backgroundColor !== void 0) {
      let hexBgColor = evaluateColorProperty(technique.backgroundColor, discreteZoomEnv);
      if (hexBgColor !== void 0) {
        if (ColorUtils.hasAlphaInHex(hexBgColor)) {
          const alpha = ColorUtils.getAlphaFromHex(hexBgColor);
          backgroundOpacity = backgroundOpacity * alpha;
          hexBgColor = ColorUtils.removeAlphaFromHex(hexBgColor);
        }
        backgroundColor = ColorCache.instance.getColor(hexBgColor);
      }
    }
    const renderParams = {
      fontName: getOptionValue(technique.fontName, defaultRenderParams.fontName),
      fontSize: {
        unit: 1 /* Pixel */,
        size: getPropertyValue(getOptionValue(technique.size, defaultRenderParams.fontSize.size), discreteZoomEnv),
        backgroundSize
      },
      fontStyle: technique.fontStyle === "Regular" || technique.fontStyle === "Bold" || technique.fontStyle === "Italic" || technique.fontStyle === "BoldItalic" ? FontStyle[technique.fontStyle] : defaultRenderParams.fontStyle,
      fontVariant: technique.fontVariant === "Regular" || technique.fontVariant === "AllCaps" || technique.fontVariant === "SmallCaps" ? FontVariant[technique.fontVariant] : defaultRenderParams.fontVariant,
      rotation: getOptionValue(technique.rotation, defaultRenderParams.rotation),
      color: getOptionValue(color, getOptionValue(defaultRenderParams.color, DefaultTextStyle.DEFAULT_COLOR)),
      backgroundColor: getOptionValue(backgroundColor, getOptionValue(defaultRenderParams.backgroundColor, DefaultTextStyle.DEFAULT_BACKGROUND_COLOR)),
      opacity,
      backgroundOpacity
    };
    const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;
    const renderStyle = new TextRenderStyle({
      ...themeRenderParams,
      ...renderParams
    });
    return renderStyle;
  }
  createLayoutStyle(tile, technique) {
    const mapView = tile.mapView;
    const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);
    const discreteZoomEnv = new MapEnv({ $zoom: floorZoomLevel }, mapView.env);
    const defaultLayoutParams = this.m_defaultStyle.layoutParams;
    const hAlignment = getPropertyValue(technique.hAlignment, discreteZoomEnv);
    const vAlignment = getPropertyValue(technique.vAlignment, discreteZoomEnv);
    const textPlacements = isPoiTechnique(technique) ? getPropertyValue(technique.placements, discreteZoomEnv) : null;
    const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(hAlignment, vAlignment, textPlacements);
    const wrapping = getPropertyValue(technique.wrappingMode, discreteZoomEnv);
    const wrappingMode = wrapping === "None" || wrapping === "Character" || wrapping === "Word" ? WrappingMode[wrapping] : defaultLayoutParams.wrappingMode;
    const layoutParams = {
      tracking: getPropertyValue(technique.tracking, discreteZoomEnv) ?? defaultLayoutParams.tracking,
      leading: getPropertyValue(technique.leading, discreteZoomEnv) ?? defaultLayoutParams.leading,
      maxLines: getPropertyValue(technique.maxLines, discreteZoomEnv) ?? defaultLayoutParams.maxLines,
      lineWidth: getPropertyValue(technique.lineWidth, discreteZoomEnv) ?? defaultLayoutParams.lineWidth,
      canvasRotation: getPropertyValue(technique.canvasRotation, discreteZoomEnv) ?? defaultLayoutParams.canvasRotation,
      lineRotation: getPropertyValue(technique.lineRotation, discreteZoomEnv) ?? defaultLayoutParams.lineRotation,
      wrappingMode,
      horizontalAlignment,
      verticalAlignment,
      placements
    };
    const themeLayoutParams = this.getTextElementStyle(technique.style);
    const layoutStyle = new TextLayoutStyle({
      ...themeLayoutParams,
      ...layoutParams
    });
    return layoutStyle;
  }
  updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions) {
    this.m_defaultStyle.fontCatalog = void 0;
    const style = (textStyleDefinitions == null ? void 0 : textStyleDefinitions.find((definition) => {
      return definition.name === DEFAULT_STYLE_NAME;
    })) ?? defaultTextStyleDefinition ?? (textStyleDefinitions == null ? void 0 : textStyleDefinitions[0]);
    if (style) {
      this.m_defaultStyle = this.createTextElementStyle(style, DEFAULT_STYLE_NAME);
    }
    this.m_defaultStyle.textCanvas = void 0;
  }
  initializeTextCanvas(style, textCanvases) {
    var _a;
    if (style.textCanvas) {
      return;
    }
    if (style.fontCatalog !== void 0) {
      const styledTextCanvas = textCanvases.get(style.fontCatalog);
      style.textCanvas = styledTextCanvas;
      if (textCanvases.has(style.fontCatalog) && !styledTextCanvas) {
        logger18.info(`fontCatalog(${style.fontCatalog}), not yet loaded`);
        return;
      }
    }
    if (style.textCanvas === void 0) {
      if (style.fontCatalog !== void 0 && style.fontCatalog !== DEFAULT_FONT_CATALOG_NAME) {
        logger18.warn(`FontCatalog '${style.fontCatalog}' set in TextStyle
                     '${style.name}' not found`);
      }
      let alternativeTextCanvas = textCanvases.get(DEFAULT_FONT_CATALOG_NAME);
      if (!alternativeTextCanvas && textCanvases.size > 0) {
        for (const [, canvas2] of textCanvases) {
          if (canvas2) {
            alternativeTextCanvas = canvas2;
            break;
          }
        }
      }
      if (alternativeTextCanvas) {
        style.textCanvas = alternativeTextCanvas;
        if (style.fontCatalog !== void 0) {
          logger18.info(`fontCatalog: '${style.fontCatalog}' not found,
                      using default fontCatalog(${(_a = style.textCanvas) == null ? void 0 : _a.name}).`);
        }
      }
    }
  }
  createTextElementStyle(style, styleName) {
    const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(style.hAlignment, style.vAlignment, style.placements);
    return {
      name: styleName,
      fontCatalog: getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),
      renderParams: {
        fontName: style.fontName,
        fontSize: {
          unit: 1 /* Pixel */,
          size: 32,
          backgroundSize: style.backgroundSize ?? 8
        },
        fontStyle: style.fontStyle === "Regular" || style.fontStyle === "Bold" || style.fontStyle === "Italic" || style.fontStyle === "BoldItalic" ? FontStyle[style.fontStyle] : void 0,
        fontVariant: style.fontVariant === "Regular" || style.fontVariant === "AllCaps" || style.fontVariant === "SmallCaps" ? FontVariant[style.fontVariant] : void 0,
        rotation: style.rotation,
        color: style.color !== void 0 ? ColorCache.instance.getColor(style.color) : void 0,
        backgroundColor: style.backgroundColor !== void 0 ? ColorCache.instance.getColor(style.backgroundColor) : void 0,
        opacity: style.opacity,
        backgroundOpacity: style.backgroundOpacity
      },
      layoutParams: {
        tracking: style.tracking,
        leading: style.leading,
        maxLines: style.maxLines,
        lineWidth: style.lineWidth,
        canvasRotation: style.canvasRotation,
        lineRotation: style.lineRotation,
        wrappingMode: style.wrappingMode === "None" || style.wrappingMode === "Character" || style.wrappingMode === "Word" ? WrappingMode[style.wrappingMode] : 2 /* Word */,
        verticalAlignment,
        horizontalAlignment,
        placements
      }
    };
  }
};
function parseAlignmentAndPlacements(hAlignment, vAlignment, placementsTokens) {
  const placements = placementsTokens ? parseTechniquePlacements(placementsTokens) : void 0;
  return resolvePlacementAndAlignment(parseTechniqueHAlignValue(hAlignment), parseTechniqueVAlignValue(vAlignment), placements);
}
function parseTechniqueHAlignValue(hAlignment) {
  return hAlignment === "Left" || hAlignment === "Center" || hAlignment === "Right" ? HorizontalAlignment[hAlignment] : defaultTextLayoutStyle.horizontalAlignment;
}
function parseTechniqueVAlignValue(vAlignment) {
  return vAlignment === "Above" || vAlignment === "Center" || vAlignment === "Below" ? VerticalAlignment[vAlignment] : defaultTextLayoutStyle.verticalAlignment;
}
function parseTechniquePlacements(placementsString) {
  const placements = [];
  const placementsTokens = placementsString ? placementsString.toUpperCase().replace(" ", "").split(",") : [];
  placementsTokens.forEach((p) => {
    const val = parseTechniquePlacementValue(p);
    if (val !== void 0) {
      placements.push(val);
    }
  });
  return placements;
}
function parseTechniquePlacementValue(p) {
  if (p.length < 1 || p.length > 2) {
    return void 0;
  }
  const textPlacement = {
    h: -0.5 /* Center */,
    v: -0.5 /* Center */
  };
  let modifier = p.charAt(0);
  let found = true;
  switch (modifier) {
    case "T" /* Top */:
    case "N" /* North */:
      textPlacement.v = 0 /* Top */;
      break;
    case "B" /* Bottom */:
    case "S" /* South */:
      textPlacement.v = -1 /* Bottom */;
      break;
    default:
      found = false;
      if (p.length === 2) {
        return void 0;
      }
  }
  if (found && p.length === 1) {
    return textPlacement;
  }
  modifier = p.length === 1 ? p.charAt(0) : p.charAt(1);
  switch (modifier) {
    case "R" /* Right */:
    case "E" /* East */:
      textPlacement.h = 0 /* Right */;
      break;
    case "L" /* Left */:
    case "W" /* West */:
      textPlacement.h = -1 /* Left */;
      break;
    default:
      return void 0;
  }
  return textPlacement;
}

// src/mapview/text/UpdateStats.ts
var UpdateStats = class {
  constructor(m_logger) {
    this.m_logger = m_logger;
    this.results.fill(0);
  }
  tiles = 0;
  totalGroups = 0;
  newGroups = 0;
  totalLabels = 0;
  results = new Array(5 /* Count */);
  clear() {
    this.tiles = 0;
    this.totalGroups = 0;
    this.newGroups = 0;
    this.totalLabels = 0;
    this.results.fill(0);
  }
  log() {
    this.m_logger.debug("Tiles", this.tiles);
    this.m_logger.debug("Total groups", this.totalGroups);
    this.m_logger.debug("New groups", this.newGroups);
    this.m_logger.debug("Total labels", this.totalLabels);
    this.m_logger.debug("Placed labels", this.results[0 /* Ok */]);
    this.m_logger.debug("Invisible", this.results[2 /* Invisible */]);
    this.m_logger.debug("Poi not ready", this.results[1 /* NotReady */]);
    this.m_logger.debug("Too far", this.results[3 /* TooFar */]);
    this.m_logger.debug("Duplicate", this.results[4 /* Duplicate */]);
  }
};

// src/mapview/text/TextElementsRenderer.ts
var DEFAULT_FONT_CATALOG_NAME = "default";
var DEFAULT_TEXT_DISTANCE_SCALE = 0.5;
var OVERLOAD_LABEL_LIMIT = 2e4;
var OVERLOAD_UPDATED_LABEL_LIMIT = 100;
var OVERLOAD_UPDATE_TIME_LIMIT = 5;
var OVERLOAD_PLACE_TIME_LIMIT = 10;
var logger19 = LoggerManager.instance.create("TextElementsRenderer", {
  level: 2 /* Log */
});
var PRINT_LABEL_DEBUG_INFO = false;
var updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats(logger19) : void 0;
var placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats(logger19) : void 0;
var tempPosition = new THREE84.Vector3();
var tempScreenPosition = new THREE84.Vector2();
var tempScreenPoints = [];
var tempPoiScreenPosition = new THREE84.Vector2();
var tmpTextBufferCreationParams = {};
var tmpAdditionParams = {};
var tmpBufferAdditionParams = {};
var cache2 = {
  vector2: [new THREE84.Vector2()]
};
var TileTextElements = class {
  constructor(tile, group) {
    this.tile = tile;
    this.group = group;
  }
};
var TextElementLists = class {
  constructor(lists) {
    this.lists = lists;
  }
  get priority() {
    assert(this.lists.length > 0);
    return this.lists[0].group.priority;
  }
  count() {
    let n = 0;
    for (const list of this.lists) {
      n += list.group.elements.length;
    }
    return n;
  }
};
function checkIfTextElementsChanged(dataSourceTileList) {
  let textElementsChanged = false;
  dataSourceTileList.forEach(({ renderedTiles }) => {
    renderedTiles.forEach((tile) => {
      if (tile.textElementsChanged) {
        tile.textElementsChanged = false;
        textElementsChanged = true;
      }
    });
  });
  return textElementsChanged;
}
function hasTextElements(dataSourceTileList) {
  for (let i = 0; i < dataSourceTileList.length; i++) {
    for (const [_key, value2] of dataSourceTileList[i].renderedTiles) {
      if (value2.hasTextElements()) {
        return true;
      }
    }
  }
  return false;
}
function addTextToCanvas(textElement, canvas2, screenPosition, path, pathOverflow) {
  tmpAdditionParams.path = path;
  tmpAdditionParams.pathOverflow = pathOverflow;
  tmpAdditionParams.layer = textElement.renderOrder;
  tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;
  tmpAdditionParams.pickingData = textElement.userData ? textElement : void 0;
  canvas2.addText(textElement.glyphs, screenPosition, tmpAdditionParams);
}
function addTextBufferToCanvas(textElementState, canvas2, screenPosition, fadeFactor, scaleFactor) {
  const textElement = textElementState.element;
  const textRenderState = textElementState.textRenderState;
  const opacity = textRenderState.opacity * fadeFactor * textElement.renderStyle.opacity;
  if (opacity === 0) {
    return false;
  }
  tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;
  if (textElement.textBufferObject === void 0) {
    textElement.textBufferObject = canvas2.createTextBufferObject(textElement.glyphs, tmpTextBufferCreationParams);
  }
  const backgroundIsVisible = textElement.renderStyle.backgroundOpacity > 0 && canvas2.textRenderStyle.fontSize.backgroundSize > 0;
  tmpBufferAdditionParams.layer = textElement.renderOrder;
  tmpBufferAdditionParams.position = screenPosition;
  tmpBufferAdditionParams.scale = scaleFactor;
  tmpBufferAdditionParams.opacity = opacity;
  tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible ? tmpBufferAdditionParams.opacity * textElement.renderStyle.backgroundOpacity : 0;
  tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : void 0;
  canvas2.addTextBufferObject(textElement.textBufferObject, tmpBufferAdditionParams);
  return true;
}
function shouldRenderPointText(labelState, viewState, options) {
  const textRenderState = labelState.textRenderState;
  const label = labelState.element;
  const poiInfo = label.poiInfo;
  assert(label.type !== 1 /* PathLabel */);
  const hasText = textRenderState !== void 0 && label.text !== "";
  if (!hasText) {
    return false;
  }
  const visibleInZoomLevel = poiInfo === void 0 || MathUtils6.isClamped(viewState.zoomLevel, poiInfo.textMinZoomLevel, poiInfo.textMaxZoomLevel);
  if (!visibleInZoomLevel) {
    return false;
  }
  const poiTextMaxDistance = getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels);
  const visibleAtDistance = label.ignoreDistance === true || labelState.viewDistance === void 0 || labelState.viewDistance < poiTextMaxDistance && labelState.viewDistance > 0;
  if (!visibleAtDistance) {
    return false;
  }
  return !poiInfo || poiInfo.isValid === true || poiInfo.iconIsOptional === true;
}
function shouldRenderPoiText(labelState, viewState) {
  const poiInfo = labelState.element.poiInfo;
  return !viewState.cameraIsMoving || poiInfo === void 0 || poiInfo.renderTextDuringMovements === true;
}
function isPlacementTimeExceeded(startTime) {
  if (startTime === void 0 || OVERLOAD_PLACE_TIME_LIMIT <= 0) {
    return false;
  }
  const endTime = PerformanceTimer.now();
  const elapsedTime = endTime - startTime;
  if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {
    logger19.debug("Placement time limit exceeded.");
    return true;
  }
  return false;
}
function createDefaultFontCatalogConfig(defaultFontCatalogUrl) {
  return {
    name: DEFAULT_FONT_CATALOG_NAME,
    url: defaultFontCatalogUrl
  };
}
var TextElementsRenderer = class {
  constructor(m_viewState, m_screenProjector, m_poiManager, m_renderer, m_imageCaches, options, textCanvasFactory, poiRenderer, screenCollisions) {
    this.m_viewState = m_viewState;
    this.m_screenProjector = m_screenProjector;
    this.m_poiManager = m_poiManager;
    this.m_renderer = m_renderer;
    this.m_imageCaches = m_imageCaches;
    this.m_options = { ...options };
    initializeDefaultOptions(this.m_options);
    if (screenCollisions) {
      this.m_screenCollisions = screenCollisions;
    } else if (this.m_options.collisionDebugCanvas !== void 0 && this.m_options.collisionDebugCanvas !== null) {
      this.m_screenCollisions = new ScreenCollisionsDebug(this.m_options.collisionDebugCanvas);
    }
    this.m_textCanvasFactory = textCanvasFactory ?? new TextCanvasFactory(this.m_renderer);
    this.m_textCanvasFactory.setGlyphCountLimits(this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs);
    this.m_poiRenderer = poiRenderer ?? new PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);
    this.initializeCamera();
    this.initializeDefaultFontCatalog();
    this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
  }
  m_loadPromisesCount = 0;
  m_loadPromise;
  m_options;
  m_textCanvases = /* @__PURE__ */ new Map();
  m_overlayTextElements;
  m_debugGlyphTextureCacheMesh;
  m_debugGlyphTextureCacheWireMesh;
  m_tmpVector = new THREE84.Vector2();
  m_tmpVector3 = new THREE84.Vector3();
  m_cameraLookAt = new THREE84.Vector3();
  m_overloaded = false;
  m_cacheInvalidated = false;
  m_addNewLabels = true;
  m_forceNewLabelsPass = false;
  m_textElementStateCache = new TextElementStateCache();
  m_camera = new THREE84.OrthographicCamera(-1, 1, 1, -1);
  m_defaultFontCatalogConfig;
  m_poiRenderer;
  m_textStyleCache = new TextStyleCache();
  m_screenCollisions = new ScreenCollisions();
  m_textCanvasFactory;
  m_isUpdatePending = false;
  set disableFading(disable) {
    this.m_options.disableFading = disable;
  }
  get disableFading() {
    return this.m_options.disableFading === true;
  }
  get styleCache() {
    return this.m_textStyleCache;
  }
  get delayLabelsUntilMovementFinished() {
    return this.m_options.delayLabelsUntilMovementFinished === true;
  }
  set delayLabelsUntilMovementFinished(delay) {
    this.m_options.delayLabelsUntilMovementFinished = delay;
  }
  get showReplacementGlyphs() {
    return this.m_options.showReplacementGlyphs === true;
  }
  set showReplacementGlyphs(value2) {
    this.m_options.showReplacementGlyphs = value2;
    this.m_textCanvases.forEach((textCanvas) => {
      if (textCanvas == null ? void 0 : textCanvas.fontCatalog) {
        textCanvas.fontCatalog.showReplacementGlyphs = value2;
      }
    });
  }
  restoreRenderers(renderer) {
    this.m_renderer = renderer;
    this.m_poiRenderer = new PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);
  }
  async updateFontCatalogs(fontCatalogs) {
    if (this.m_defaultFontCatalogConfig) {
      if (!fontCatalogs || fontCatalogs.findIndex((config) => {
        return config.name === DEFAULT_FONT_CATALOG_NAME;
      }) === -1) {
        if (!fontCatalogs) {
          fontCatalogs = [];
        }
        fontCatalogs.unshift(this.m_defaultFontCatalogConfig);
      } else {
        if (this.m_textCanvases.has(DEFAULT_FONT_CATALOG_NAME)) {
          this.m_textCanvases.delete(DEFAULT_FONT_CATALOG_NAME);
        }
      }
    }
    if (fontCatalogs && fontCatalogs.length > 0) {
      for (const [name2] of this.m_textCanvases) {
        if (fontCatalogs.findIndex((catalog) => {
          return catalog.name === name2;
        }) < 0) {
          this.m_textCanvases.delete(name2);
        }
      }
      for (const fontCatalog of fontCatalogs) {
        await this.addTextCanvas(fontCatalog);
      }
    } else {
      this.m_textCanvases.clear();
    }
    this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
  }
  async updateTextStyles(textStyles, defaultTextStyle) {
    this.m_textStyleCache.updateTextStyles(textStyles, defaultTextStyle);
    await this.waitLoaded();
    this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
    this.invalidateCache();
  }
  renderText(farPlane) {
    this.m_camera.far = farPlane;
    this.updateGlyphDebugMesh();
    let previousLayer;
    this.m_poiRenderer.update();
    for (const poiLayer of this.m_poiRenderer.layers) {
      for (const [, textCanvas] of this.m_textCanvases) {
        textCanvas == null ? void 0 : textCanvas.render(this.m_camera, previousLayer == null ? void 0 : previousLayer.id, poiLayer.id, void 0, false);
      }
      this.m_poiRenderer.render(this.m_camera, poiLayer);
      previousLayer = poiLayer;
    }
    for (const [, textCanvas] of this.m_textCanvases) {
      textCanvas == null ? void 0 : textCanvas.render(this.m_camera, previousLayer == null ? void 0 : previousLayer.id, void 0, void 0, false);
    }
  }
  invalidateCache() {
    this.m_cacheInvalidated = true;
  }
  movementStarted() {
    if (this.delayLabelsUntilMovementFinished) {
      this.m_addNewLabels = false;
    }
  }
  movementFinished() {
    this.invalidateCache();
    if (this.delayLabelsUntilMovementFinished) {
      this.m_addNewLabels = true;
    }
  }
  get overloaded() {
    return this.m_overloaded;
  }
  placeText(dataSourceTileList, time) {
    const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);
    const textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged || hasTextElements(dataSourceTileList);
    this.m_isUpdatePending = false;
    if (!textElementsAvailable && !this.m_cacheInvalidated && !this.m_viewState.renderedTilesChanged) {
      return;
    }
    const updateTextElements = this.m_cacheInvalidated || tileTextElementsChanged || this.m_viewState.renderedTilesChanged;
    const findReplacements = updateTextElements && this.m_addNewLabels;
    if (findReplacements) {
      this.m_textElementStateCache.clearVisited();
      this.updateTextElements(dataSourceTileList);
    }
    const anyTextGroupEvicted = this.m_textElementStateCache.update(time, this.m_options.disableFading, findReplacements, this.m_viewState.zoomLevel);
    this.reset();
    if (this.m_addNewLabels) {
      this.prepopulateScreenWithBlockingElements(dataSourceTileList);
    }
    const placeNewTextElements = (updateTextElements || anyTextGroupEvicted) && this.m_addNewLabels;
    this.placeTextElements(time, placeNewTextElements);
    this.placeOverlayTextElements();
  }
  addOverlayText(textElements) {
    if (textElements.length === 0) {
      return;
    }
    this.m_overlayTextElements = this.m_overlayTextElements === void 0 ? textElements.slice() : this.m_overlayTextElements.concat(textElements);
  }
  clearOverlayText() {
    this.m_overlayTextElements = [];
  }
  hasOverlayText() {
    return this.m_overlayTextElements !== void 0 && this.m_overlayTextElements.length > 0;
  }
  get overlayText() {
    return this.m_overlayTextElements;
  }
  pickTextElements(screenPosition, pickListener) {
    const pickHandler = (pickData, pickObjectType) => {
      if (pickData === void 0) {
        return;
      }
      const textElement = pickData;
      const pickResult = {
        type: pickObjectType,
        point: screenPosition,
        distance: 0,
        renderOrder: textElement.renderOrder,
        featureId: textElement.featureId,
        userData: textElement.userData,
        dataSourceName: textElement.dataSourceName,
        dataSourceOrder: textElement.dataSourceOrder,
        text: textElement.text
      };
      pickListener.addResult(pickResult);
    };
    for (const [, textCanvas] of this.m_textCanvases) {
      textCanvas == null ? void 0 : textCanvas.pickText(screenPosition, (pickData) => {
        pickHandler(pickData, 4 /* Text */);
      });
    }
    this.m_poiRenderer.pickTextElements(screenPosition, (pickData) => {
      pickHandler(pickData, 5 /* Icon */);
    });
  }
  get loading() {
    return this.m_loadPromisesCount > 0;
  }
  get isUpdatePending() {
    return this.m_isUpdatePending;
  }
  async waitLoaded() {
    if (this.m_loadPromise !== void 0) {
      return await this.m_loadPromise;
    }
  }
  clearRenderStates() {
    this.m_textElementStateCache.clear();
  }
  getMemoryUsage() {
    const memoryUsage = {
      heapSize: 0,
      gpuSize: 0
    };
    for (const [, textCanvas] of this.m_textCanvases) {
      textCanvas == null ? void 0 : textCanvas.getMemoryUsage(memoryUsage);
    }
    this.m_poiRenderer.getMemoryUsage(memoryUsage);
    return memoryUsage;
  }
  async addDefaultTextCanvas() {
    if (this.m_textCanvases.has(DEFAULT_FONT_CATALOG_NAME) || !this.m_defaultFontCatalogConfig) {
      return;
    }
    await this.addTextCanvas(this.m_defaultFontCatalogConfig);
    this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
  }
  reset() {
    this.m_cameraLookAt.copy(this.m_viewState.lookAtVector);
    this.m_screenCollisions.reset();
    for (const [, textCanvas] of this.m_textCanvases) {
      textCanvas == null ? void 0 : textCanvas.clear();
    }
    this.m_poiRenderer.reset();
  }
  prepopulateScreenWithBlockingElements(dataSourceTileList) {
    const boxes = [];
    dataSourceTileList.forEach((renderListEntry) => {
      const startLinePointProj = new THREE84.Vector3();
      const endLinePointProj = new THREE84.Vector3();
      for (const tile of renderListEntry.renderedTiles.values()) {
        for (const pathBlockingElement of tile.blockingElements) {
          if (pathBlockingElement.points.length < 2) {
            continue;
          }
          this.m_screenProjector.project3(pathBlockingElement.points[0], startLinePointProj);
          for (let i = 1; i < pathBlockingElement.points.length; i++) {
            this.m_screenProjector.project3(pathBlockingElement.points[i], endLinePointProj);
            const line = pathBlockingElement.screenSpaceLines[i - 1];
            line.start.copy(startLinePointProj);
            line.end.copy(endLinePointProj);
            const lineWithBound = {
              minX: Math.min(startLinePointProj.x, endLinePointProj.x),
              maxX: Math.max(startLinePointProj.x, endLinePointProj.x),
              minY: Math.min(startLinePointProj.y, endLinePointProj.y),
              maxY: Math.max(startLinePointProj.y, endLinePointProj.y),
              line
            };
            boxes.push(lineWithBound);
            startLinePointProj.copy(endLinePointProj);
          }
        }
      }
    });
    this.m_screenCollisions.allocateIBoxes(boxes);
  }
  placeTextElementGroup(groupState, renderParams, maxNumPlacedLabels, pass) {
    assert(groupState.visited);
    const shieldGroups = [];
    const hiddenKinds = this.m_viewState.hiddenGeometryKinds;
    const projection = this.m_viewState.projection;
    const elevationProvider = this.m_viewState.elevationProvider;
    const elevationMap = elevationProvider == null ? void 0 : elevationProvider.getDisplacementMap(groupState.tileKey);
    for (const textElementState of groupState.textElementStates) {
      if (pass === 0 /* PersistentLabels */) {
        if (placementStats) {
          ++placementStats.total;
        }
      } else if (maxNumPlacedLabels !== void 0 && renderParams.numRenderedTextElements >= maxNumPlacedLabels) {
        logger19.debug("Placement label limit exceeded.");
        return false;
      }
      if (!textElementState.initialized) {
        if (placementStats) {
          ++placementStats.uninitialized;
        }
        continue;
      }
      if (textElementState.viewDistance === void 0 || textElementState.viewDistance < 0) {
        if (placementStats) {
          ++placementStats.tooFar;
        }
        continue;
      }
      const elementVisible = textElementState.visible;
      if (pass === 0 /* PersistentLabels */ && !elementVisible || pass === 1 /* NewLabels */ && elementVisible) {
        continue;
      }
      const textElement = textElementState.element;
      const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
      const textCanvas = textElementStyle.textCanvas;
      if (hiddenKinds !== void 0 && textElement.kind !== void 0 && hiddenKinds.hasOrIntersects(textElement.kind)) {
        continue;
      }
      if (elevationProvider !== void 0 && !textElement.elevated) {
        if (!elevationMap) {
          this.m_isUpdatePending = true;
          this.m_forceNewLabelsPass = true;
          continue;
        }
        overlayTextElement(textElement, elevationProvider, elevationMap, projection);
      }
      const elementType = textElement.type;
      const isPathLabel = elementType === 1 /* PathLabel */;
      if (isPathLabel) {
        if (isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {
          if (placementStats) {
            placementStats.numNotVisible++;
          }
          if (textElement.dbgPathTooSmall === true) {
            if (placementStats) {
              placementStats.numPathTooSmall++;
            }
          }
          textElementState.reset();
          continue;
        }
      }
      const forceNewPassOnLoaded = true;
      if (textCanvas) {
        if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {
          continue;
        }
        const layer = textCanvas.getLayer(textElement.renderOrder ?? DEFAULT_TEXT_CANVAS_LAYER);
        if (layer !== void 0) {
          if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
            if (placementStats) {
              ++placementStats.numCannotAdd;
            }
            logger19.warn("layer glyph storage capacity exceeded.");
            continue;
          }
        }
        textCanvas.textRenderStyle = textElement.renderStyle;
        textCanvas.textLayoutStyle = textElement.layoutStyle;
      }
      switch (elementType) {
        case 0 /* PoiLabel */:
          this.addPoiLabel(textElementState, textCanvas, renderParams);
          break;
        case 2 /* LineMarker */:
          this.addLineMarkerLabel(textElementState, shieldGroups, textCanvas, renderParams);
          break;
        case 1 /* PathLabel */:
          if (textCanvas) {
            this.addPathLabel(textElementState, tempScreenPoints, textCanvas, renderParams);
          }
      }
    }
    return true;
  }
  initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded) {
    if (textElement.loadingState === 2 /* Initialized */) {
      return textElement.glyphs !== void 0;
    }
    assert(textElementStyle.textCanvas !== void 0);
    const textCanvas = textElementStyle.textCanvas;
    if (textElement.loadingState === void 0) {
      textElement.loadingState = 0 /* Requested */;
      if (textElement.renderStyle === void 0) {
        textElement.renderStyle = new TextRenderStyle({
          ...textElementStyle.renderParams,
          ...textElement.renderParams
        });
      }
      if (textElement.layoutStyle === void 0) {
        textElement.layoutStyle = new TextLayoutStyle({
          ...textElementStyle.layoutParams,
          ...textElement.layoutParams
        });
      }
      if (textElement.text === "") {
        textElement.loadingState = 1 /* Loaded */;
      } else {
        const newLoadPromise = textCanvas.fontCatalog.loadCharset(textElement.text, textElement.renderStyle).then(() => {
          --this.m_loadPromisesCount;
          textElement.loadingState = 1 /* Loaded */;
          this.m_isUpdatePending = true;
          this.m_forceNewLabelsPass = this.m_forceNewLabelsPass || forceNewPassOnLoaded;
        });
        if (this.m_loadPromisesCount === 0) {
          this.m_loadPromise = void 0;
        }
        ++this.m_loadPromisesCount;
        this.m_loadPromise = this.m_loadPromise === void 0 ? newLoadPromise : Promise.all([this.m_loadPromise, newLoadPromise]);
      }
    }
    if (textElement.loadingState === 1 /* Loaded */) {
      textCanvas.textRenderStyle = textElement.renderStyle;
      textCanvas.textLayoutStyle = textElement.layoutStyle;
      textElement.glyphCaseArray = [];
      textElement.bounds = void 0;
      textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
      textElement.loadingState = 2 /* Initialized */;
    }
    return textElement.glyphs !== void 0;
  }
  initializeCamera() {
    this.m_camera.position.z = 1;
    this.m_camera.near = 0;
  }
  updateCamera() {
    const { width, height } = this.m_renderer.getSize(cache2.vector2[0]);
    this.m_camera.left = width / -2;
    this.m_camera.right = width / 2;
    this.m_camera.bottom = height / -2;
    this.m_camera.top = height / 2;
    this.m_camera.updateProjectionMatrix();
    this.m_camera.updateMatrixWorld(false);
    this.m_screenCollisions.update(width, height);
  }
  initializeDefaultFontCatalog() {
    if (this.m_options.fontCatalog) {
      this.m_defaultFontCatalogConfig = createDefaultFontCatalogConfig(this.m_options.fontCatalog);
      this.addDefaultTextCanvas();
    }
  }
  async addTextCanvas(fontCatalogConfig) {
    const catalogCallback = (name2, catalog) => {
      if (this.m_textCanvases.has(name2)) {
        const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog, name2);
        catalog.showReplacementGlyphs = this.showReplacementGlyphs;
        this.m_textCanvases.set(name2, loadedTextCanvas);
      }
    };
    const errorCallback = () => {
      this.m_textCanvases.delete(fontCatalogConfig.name);
    };
    if (this.m_textCanvases.has(fontCatalogConfig.name)) {
      return Promise.resolve();
    } else {
      this.m_textCanvases.set(fontCatalogConfig.name, void 0);
      const newLoadPromise = loadFontCatalog(fontCatalogConfig, catalogCallback, errorCallback).then(() => {
        --this.m_loadPromisesCount;
      }).catch((error) => {
        logger19.info("rendering without font catalog, only icons possible", error);
        --this.m_loadPromisesCount;
      });
      if (this.m_loadPromisesCount === 0) {
        this.m_loadPromise = void 0;
      }
      ++this.m_loadPromisesCount;
      this.m_loadPromise = this.m_loadPromise === void 0 ? newLoadPromise : Promise.all([this.m_loadPromise, newLoadPromise]);
      return newLoadPromise;
    }
  }
  updateGlyphDebugMesh() {
    const debugGlyphs = debugContext.getValue("DEBUG_GLYPHS");
    if (debugGlyphs === void 0) {
      return;
    }
    if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === void 0) {
      this.initializeGlyphDebugMesh();
    }
    assert(this.m_debugGlyphTextureCacheMesh !== void 0);
    assert(this.m_debugGlyphTextureCacheWireMesh !== void 0);
    this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;
    this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;
  }
  initializeGlyphDebugMesh() {
    if (this.m_textCanvases.size === 0) {
      return;
    }
    const defaultTextCanvas = this.m_textCanvases.values().next().value;
    const defaultFontCatalog = defaultTextCanvas.fontCatalog;
    const planeGeometry = new THREE84.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);
    const material = new THREE84.MeshBasicMaterial({
      transparent: true,
      depthWrite: false,
      depthTest: false,
      map: defaultFontCatalog.texture
    });
    this.m_debugGlyphTextureCacheMesh = new THREE84.Mesh(planeGeometry, material);
    this.m_debugGlyphTextureCacheMesh.renderOrder = 1e4;
    this.m_debugGlyphTextureCacheMesh.visible = false;
    this.m_debugGlyphTextureCacheMesh.name = "glyphDebug";
    const wireframe = new THREE84.WireframeGeometry(planeGeometry);
    const wireframeMaterial = new THREE84.LineBasicMaterial({
      transparent: true,
      color: 10066329,
      depthWrite: false,
      depthTest: false
    });
    this.m_debugGlyphTextureCacheWireMesh = new THREE84.LineSegments(wireframe, wireframeMaterial);
    this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;
    this.m_debugGlyphTextureCacheWireMesh.visible = false;
    this.m_debugGlyphTextureCacheWireMesh.name = "glyphDebug";
    defaultTextCanvas.getLayer(DEFAULT_TEXT_CANVAS_LAYER).storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);
  }
  updateTextElements(dataSourceTileList) {
    if (updateStats) {
      updateStats.clear();
    }
    this.m_textElementStateCache.clearTextCache();
    this.m_cacheInvalidated = false;
    this.checkIfOverloaded(dataSourceTileList);
    const updateStartTime = this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : void 0;
    dataSourceTileList.forEach((tileList) => {
      this.updateTextElementsFromSource(tileList.dataSource, tileList.storageLevel, Array.from(tileList.renderedTiles.values()), updateStartTime);
    });
    if (updateStats) {
      updateStats.log();
    }
  }
  updateTextElementsFromSource(tileDataSource, storageLevel, visibleTiles, updateStartTime) {
    if (updateStats) {
      updateStats.tiles += visibleTiles.length;
    }
    const sortedTiles = visibleTiles;
    sortedTiles.sort((a, b) => {
      return a.tileKey.mortonCode() - b.tileKey.mortonCode();
    });
    const sortedGroups = [];
    this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);
    let numTextElementsUpdated = 0;
    for (const textElementLists of sortedGroups) {
      this.selectTextElementsToUpdateByDistance(textElementLists);
      if (updateStartTime !== void 0) {
        if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {
          const endTime = PerformanceTimer.now();
          const elapsedTime = endTime - updateStartTime;
          if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {
            logger19.debug("Update time limit exceeded.");
            break;
          }
        }
        numTextElementsUpdated += textElementLists.count();
        if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {
          logger19.debug("Update label limit exceeded.");
          break;
        }
      }
    }
  }
  prepareTextElementGroup(textElementGroup, tileKey, maxViewDistance) {
    if (textElementGroup.elements.length === 0) {
      return;
    }
    const textElementSelection = (textElementState) => {
      let { result, viewDistance } = checkReadyForPlacement(textElementState.element, textElementState.element.type === 2 /* LineMarker */ ? textElementState.lineMarkerIndex : void 0, this.m_viewState, this.m_poiManager, maxViewDistance);
      if (result === 0 /* Ok */ && !this.m_textElementStateCache.deduplicateElement(this.m_viewState.zoomLevel, textElementState)) {
        result = 4 /* Duplicate */;
        viewDistance = void 0;
      }
      if (updateStats) {
        updateStats.totalLabels++;
        updateStats.results[result]++;
      }
      return viewDistance;
    };
    const [, found] = this.m_textElementStateCache.getOrSet(textElementGroup, tileKey, textElementSelection);
    if (updateStats) {
      ++updateStats.totalGroups;
      if (!found) {
        ++updateStats.newGroups;
      }
    }
  }
  createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {
    if (sortedTiles.length === 0) {
      return;
    }
    const tilesToRender = [];
    for (const tile of sortedTiles) {
      if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {
        tilesToRender.push(tile);
      }
    }
    const groupedPriorityLists = /* @__PURE__ */ new Map();
    for (const tile of tilesToRender) {
      for (const group of tile.textElementGroups.groups.values()) {
        if (group.elements.length === 0) {
          continue;
        }
        const foundGroup = groupedPriorityLists.get(group.priority);
        if (foundGroup === void 0) {
          groupedPriorityLists.set(group.priority, new TextElementLists([new TileTextElements(tile, group)]));
        } else {
          foundGroup.lists.push(new TileTextElements(tile, group));
        }
      }
    }
    if (groupedPriorityLists.size === 0) {
      return;
    }
    for (const g of groupedPriorityLists) {
      const lists = g[1];
      sortedGroups.push(lists);
    }
    sortedGroups.sort((a, b) => {
      return b.priority - a.priority;
    });
    const printTextInfo = false;
    if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {
      let outString = "";
      for (const textElementLists of sortedGroups) {
        let size = 0;
        for (const tileTextElements of textElementLists.lists) {
          size += tileTextElements.group.elements.length;
        }
        outString += `priority ${textElementLists.priority} size: ${size}
`;
      }
      logger19.log(outString);
    }
  }
  selectTextElementsToUpdateByDistance(textElementLists) {
    const farDistanceLimitRatio = Math.max(this.m_options.maxDistanceRatioForTextLabels, this.m_options.maxDistanceRatioForPoiLabels);
    const maxViewDistance = getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);
    for (const tileTextElements of textElementLists.lists) {
      this.prepareTextElementGroup(tileTextElements.group, tileTextElements.tile.tileKey, maxViewDistance);
    }
  }
  placeTextElements(time, placeNewTextElements) {
    const renderParams = {
      numRenderedTextElements: 0,
      fadeAnimationRunning: false,
      time
    };
    const placeStartTime = this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : void 0;
    if (placementStats) {
      placementStats.clear();
    }
    if (this.m_textElementStateCache.size === 0) {
      logger19.debug("Text element cache empty.");
      return;
    }
    const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;
    if (this.m_forceNewLabelsPass) {
      this.m_forceNewLabelsPass = false;
    }
    const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels;
    const groupStates = this.m_textElementStateCache.sortedGroupStates;
    let currentPriority = groupStates[0].priority;
    let currentPriorityBegin = 0;
    for (let i = 0; i < groupStates.length; ++i) {
      const textElementGroupState = groupStates[i];
      if (placementStats) {
        ++placementStats.totalGroups;
      }
      const newPriority = textElementGroupState.priority;
      if (placeNew && currentPriority !== newPriority) {
        this.placeNewTextElements(currentPriorityBegin, i, renderParams);
        if (isPlacementTimeExceeded(placeStartTime)) {
          break;
        }
        currentPriority = newPriority;
        currentPriorityBegin = i;
      }
      if (!this.placeTextElementGroup(textElementGroupState, renderParams, maxNumPlacedTextElements, 0 /* PersistentLabels */)) {
        break;
      }
      if (isPlacementTimeExceeded(placeStartTime)) {
        break;
      }
    }
    if (placeNew) {
      this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);
    }
    if (placementStats) {
      placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;
      placementStats.log();
    }
    if (renderParams.fadeAnimationRunning) {
      this.m_isUpdatePending = true;
    }
  }
  placeNewTextElements(beginGroupIndex, endGroupIndex, renderParams) {
    const groupStates = this.m_textElementStateCache.sortedGroupStates;
    for (let i = beginGroupIndex; i < endGroupIndex; ++i) {
      if (!this.placeTextElementGroup(groupStates[i], renderParams, this.m_options.maxNumVisibleLabels, 1 /* NewLabels */)) {
        break;
      }
    }
  }
  placeOverlayTextElements() {
    if (this.m_overlayTextElements === void 0 || this.m_overlayTextElements.length === 0) {
      return;
    }
    const screenSize = this.m_tmpVector.set(this.m_screenProjector.width, this.m_screenProjector.height);
    const screenXOrigin = -screenSize.width / 2;
    const screenYOrigin = screenSize.height / 2;
    for (const textElement of this.m_overlayTextElements) {
      const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
      const textCanvas = textElementStyle.textCanvas;
      if (textCanvas === void 0) {
        continue;
      }
      const forceNewPassOnLoaded = false;
      this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);
      if (textElement.loadingState !== 2 /* Initialized */) {
        continue;
      }
      const layer = textCanvas.getLayer(textElement.renderOrder ?? DEFAULT_TEXT_CANVAS_LAYER);
      if (layer !== void 0) {
        if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
          continue;
        }
      }
      textCanvas.textRenderStyle = textElement.renderStyle;
      textCanvas.textLayoutStyle = textElement.layoutStyle;
      let textPath;
      if (!(textElement.type === 1 /* PathLabel */)) {
        tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;
        tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;
        if (textElement.xOffset !== void 0) {
          tempScreenPosition.x += textElement.xOffset;
        }
        if (textElement.yOffset !== void 0) {
          tempScreenPosition.y -= textElement.yOffset;
        }
        tempPosition.x = tempScreenPosition.x;
        tempPosition.y = tempScreenPosition.y;
        tempPosition.z = 0;
        addTextToCanvas(textElement, textCanvas, tempPosition);
      } else {
        tempScreenPosition.x = screenXOrigin;
        tempScreenPosition.y = screenYOrigin;
        if (textElement.xOffset !== void 0) {
          tempScreenPosition.x += textElement.xOffset;
        }
        if (textElement.yOffset !== void 0) {
          tempScreenPosition.y -= textElement.yOffset;
        }
        const screenPoints = [];
        for (const pt of textElement.path) {
          const pX = tempScreenPosition.x + pt.x * screenSize.width;
          const pY = tempScreenPosition.y - pt.y * screenSize.height;
          screenPoints.push(new THREE84.Vector2(pX, pY));
        }
        textPath = new SimplePath();
        for (let i = 0; i < screenPoints.length - 1; ++i) {
          textPath.add(new THREE84.LineCurve(screenPoints[i], screenPoints[i + 1]));
        }
        addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);
      }
    }
  }
  getDistanceScalingFactor(label, distance, lookAtDistance) {
    let factor = lookAtDistance / distance;
    factor = 1 + (factor - 1) * label.distanceScale;
    factor = Math.max(factor, this.m_options.labelDistanceScaleMin);
    factor = Math.min(factor, this.m_options.labelDistanceScaleMax);
    return factor;
  }
  getDistanceFadingFactor(label, state, maxVisibilityDist) {
    let distanceFadeValue = 1;
    const textDistance = state.viewDistance;
    if (textDistance !== void 0 && label.fadeFar !== void 0 && label.fadeFar > 0) {
      const fadeNear = label.fadeNear === void 0 ? 0 : label.fadeNear;
      const fadeFar = label.fadeFar;
      if (fadeFar > fadeNear) {
        distanceFadeValue = 1 - THREE84.MathUtils.clamp((textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear), 0, 1);
      }
    }
    return distanceFadeValue;
  }
  addPointLabel(labelState, position, screenPosition, textCanvas, renderParams) {
    var _a;
    const pointLabel = labelState.element;
    const textRenderState = labelState.textRenderState;
    const isLineMarker = pointLabel.type === 2 /* LineMarker */;
    const iconRenderState = labelState.iconRenderState;
    assert(iconRenderState !== void 0);
    tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;
    tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;
    const textDistance = pointToPlaneDistance(position, this.m_viewState.worldCenter, this.m_cameraLookAt);
    if (pointLabel.fadeFar !== void 0 && (pointLabel.fadeFar <= 0 || pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)) {
      if (placementStats) {
        ++placementStats.tooFar;
      }
      return false;
    }
    labelState.setViewDistance(textDistance);
    const poiInfo = pointLabel.poiInfo;
    let iconRejected = false;
    const renderIcon = poiInfo !== void 0 && MathUtils6.isClamped(this.m_viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel) && poiInfo.isValid !== false;
    const distanceScaleFactor = this.getDistanceScalingFactor(pointLabel, textDistance, this.m_viewState.lookAtDistance);
    const iconReady = renderIcon && this.m_poiRenderer.prepareRender(pointLabel, this.m_viewState.env);
    let iconInvisible = false;
    if (iconReady) {
      const result = placeIcon(iconRenderState, poiInfo, tempPoiScreenPosition, distanceScaleFactor, this.m_viewState.env, this.m_screenCollisions);
      iconInvisible = result === 2 /* Invisible */;
      iconRejected = result === 1 /* Rejected */;
      if (iconInvisible) {
        iconRenderState.reset();
      }
    } else if (renderIcon && (poiInfo == null ? void 0 : poiInfo.imageItem) !== null) {
      this.m_forceNewLabelsPass = true;
      this.m_isUpdatePending = true;
    }
    const distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, labelState, this.m_viewState.maxVisibilityDist);
    if (textCanvas && shouldRenderPointText(labelState, this.m_viewState, this.m_options)) {
      const newLabel = !labelState.visible;
      const placeResult = iconRejected && newLabel ? 1 /* Rejected */ : placePointLabel(labelState, tempScreenPosition, distanceScaleFactor, textCanvas, this.m_viewState.env, this.m_screenCollisions, tempPosition, !isLineMarker);
      const textInvisible = placeResult === 2 /* Invisible */;
      if (textInvisible) {
        if (placementStats) {
          placementStats.numPoiTextsInvisible++;
        }
        if (!renderIcon || iconInvisible) {
          labelState.reset();
          return false;
        }
        textRenderState.reset();
      }
      const iconIsOptional = (poiInfo == null ? void 0 : poiInfo.iconIsOptional) === true;
      const requiredIconRejected = iconRejected && iconReady && !iconIsOptional;
      const textRejected = requiredIconRejected || placeResult === 1 /* Rejected */;
      if (!iconRejected && !iconInvisible) {
        const textIsOptional = ((_a = pointLabel.poiInfo) == null ? void 0 : _a.textIsOptional) === true;
        iconRejected = textRejected && !textIsOptional;
      }
      if (textRejected) {
        textRenderState.startFadeOut(renderParams.time);
      }
      const textNeedsDraw = !textInvisible && (!textRejected && shouldRenderPoiText(labelState, this.m_viewState) || textRenderState.isFading());
      if (textNeedsDraw) {
        if (!textRejected) {
          textRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
        }
        renderParams.fadeAnimationRunning = renderParams.fadeAnimationRunning || textRenderState.isFading();
        if (addTextBufferToCanvas(labelState, textCanvas, tempPosition, distanceFadeFactor, distanceScaleFactor) && placementStats) {
          placementStats.numRenderedPoiTexts++;
        }
      }
    }
    if (iconReady && !iconInvisible) {
      if (iconRejected) {
        iconRenderState.startFadeOut(renderParams.time);
      } else {
        iconRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
      }
      renderParams.fadeAnimationRunning = renderParams.fadeAnimationRunning || iconRenderState.isFading();
      const opacity = iconRenderState.opacity * distanceFadeFactor;
      if (opacity > 0) {
        const allocateSpace = poiInfo.reserveSpace !== false && !iconRejected;
        this.m_poiRenderer.addPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, labelState.renderDistance, distanceScaleFactor, allocateSpace, opacity, this.m_viewState.env);
        if (placementStats) {
          placementStats.numRenderedPoiIcons++;
        }
      }
    }
    renderParams.numRenderedTextElements++;
    return true;
  }
  addPoiLabel(labelState, textCanvas, renderParams) {
    const worldPosition = getWorldPosition(labelState.element, this.m_viewState.projection, this.m_viewState.env, this.m_tmpVector3);
    if (!this.labelPotentiallyVisible(worldPosition, tempScreenPosition)) {
      return false;
    }
    return this.addPointLabel(labelState, worldPosition, tempScreenPosition, textCanvas, renderParams);
  }
  addLineMarkerLabel(labelState, shieldGroups, textCanvas, renderParams) {
    var _a;
    const lineMarkerLabel = labelState.element;
    const poiInfo = lineMarkerLabel.poiInfo;
    if (!((_a = this.m_poiRenderer) == null ? void 0 : _a.prepareRender(lineMarkerLabel, this.m_viewState.env))) {
      return;
    }
    let shieldGroup;
    if (poiInfo.shieldGroupIndex !== void 0) {
      shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];
      if (shieldGroup === void 0) {
        shieldGroup = [];
        shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;
      }
    }
    const lineTechnique = poiInfo.technique;
    const minDistanceSqr = lineTechnique.minDistance !== void 0 ? lineTechnique.minDistance * lineTechnique.minDistance : 0;
    if (minDistanceSqr > 0 && shieldGroup !== void 0) {
      let numShieldsVisible = 0;
      const point = labelState.position;
      if (this.labelPotentiallyVisible(point, tempScreenPosition)) {
        let tooClose = false;
        for (let j = 0; j < shieldGroup.length; j += 2) {
          const distanceSqr = Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);
          tooClose = distanceSqr < minDistanceSqr;
          if (tooClose) {
            break;
          }
        }
        if (!tooClose) {
          if (this.addPointLabel(labelState, point, tempScreenPosition, textCanvas, renderParams)) {
            shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);
            numShieldsVisible++;
          }
        }
      }
      if (numShieldsVisible === 0) {
        labelState.reset();
      }
    } else {
      const point = labelState.position;
      if (this.labelPotentiallyVisible(point, tempScreenPosition)) {
        this.addPointLabel(labelState, point, tempScreenPosition, textCanvas, renderParams);
      }
    }
  }
  addPathLabel(labelState, screenPoints, textCanvas, renderParams) {
    const textMaxDistance = getMaxViewDistance(this.m_viewState, this.m_options.maxDistanceRatioForTextLabels);
    const pathLabel = labelState.element;
    if (!(pathLabel.ignoreDistance === true || labelState.viewDistance === void 0 || labelState.viewDistance < textMaxDistance)) {
      if (placementStats) {
        ++placementStats.tooFar;
      }
      labelState.textRenderState.reset();
      return false;
    }
    if (pathLabel.fadeFar !== void 0 && (pathLabel.fadeFar <= 0 || pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)) {
      if (placementStats) {
        ++placementStats.tooFar;
      }
      labelState.textRenderState.reset();
      return false;
    }
    let textPath = new THREE84.Path();
    tempScreenPosition.copy(screenPoints[0]);
    for (let i = 0; i < screenPoints.length - 1; ++i) {
      textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));
    }
    if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {
      tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);
      textPath = new THREE84.Path();
      for (let i = screenPoints.length - 1; i > 0; --i) {
        textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));
      }
    }
    labelState.setViewDistance(computeViewDistance(pathLabel, void 0, this.m_viewState.worldCenter, this.m_cameraLookAt));
    const textRenderDistance = -labelState.renderDistance;
    const distanceScaleFactor = this.getDistanceScalingFactor(pathLabel, textRenderDistance, this.m_viewState.lookAtDistance);
    const prevSize = textCanvas.textRenderStyle.fontSize.size;
    textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;
    if (placePathLabel(labelState, textPath, tempScreenPosition, textCanvas, this.m_screenCollisions) !== 0 /* Ok */) {
      textCanvas.textRenderStyle.fontSize.size = prevSize;
      if (placementStats) {
        ++placementStats.numNotVisible;
      }
      labelState.textRenderState.reset();
      return false;
    }
    labelState.textRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
    let opacity = pathLabel.renderStyle.opacity;
    if (labelState.textRenderState.isFading()) {
      opacity *= labelState.textRenderState.opacity;
      renderParams.fadeAnimationRunning = true;
    }
    if (labelState.textRenderState.opacity === 0) {
      textCanvas.textRenderStyle.fontSize.size = prevSize;
      return false;
    }
    const prevOpacity = textCanvas.textRenderStyle.opacity;
    const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;
    const distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, labelState, this.m_viewState.maxVisibilityDist);
    textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;
    textCanvas.textRenderStyle.backgroundOpacity = textCanvas.textRenderStyle.opacity * pathLabel.renderStyle.backgroundOpacity;
    tempPosition.z = labelState.renderDistance;
    addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);
    renderParams.numRenderedTextElements++;
    textCanvas.textRenderStyle.fontSize.size = prevSize;
    textCanvas.textRenderStyle.opacity = prevOpacity;
    textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;
    return true;
  }
  checkIfOverloaded(dataSourceTileList) {
    let numTextElementsInScene = 0;
    dataSourceTileList.forEach((renderListEntry) => {
      for (const tile of renderListEntry.renderedTiles.values()) {
        numTextElementsInScene += tile.textElementGroups.count();
      }
    });
    const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;
    if (newOverloaded && !this.m_overloaded) {
      logger19.debug("Overloaded Mode enabled.");
    }
    this.m_overloaded = newOverloaded;
    return this.m_overloaded;
  }
  labelPotentiallyVisible(point, outPoint) {
    const maxDistance = THREE84.MathUtils.clamp(this.m_options.maxPoiDistanceToBorder ?? 0, 0, 1);
    const projectionResult = this.m_screenProjector.projectAreaToScreen(point, maxDistance, maxDistance, outPoint);
    return projectionResult !== void 0;
  }
};

// src/mapview/text/TextElementBuilder.ts
var logger20 = LoggerManager.instance.create("TextElementBuilder");
var _TextElementBuilder = class {
  constructor(m_env, m_styleCache, m_baseRenderOrder) {
    this.m_env = m_env;
    this.m_styleCache = m_styleCache;
    this.m_baseRenderOrder = m_baseRenderOrder;
    this.m_renderOrder = m_baseRenderOrder;
    if (Number.isInteger(m_baseRenderOrder)) {
      this.renderOrderUpBound = _TextElementBuilder.RENDER_ORDER_UP_BOUND;
    } else {
      const absBaseRenderOrder = Math.abs(m_baseRenderOrder);
      this.renderOrderUpBound = (absBaseRenderOrder - Math.floor(absBaseRenderOrder)) * _TextElementBuilder.RENDER_ORDER_UP_BOUND;
    }
    if (!this.isValidRenderOrder(m_baseRenderOrder)) {
      logger20.warn(`Large base render order (${m_baseRenderOrder}) might cause precision issues.`);
    }
  }
  m_priority;
  m_fadeNear;
  m_fadeFar;
  m_minZoomLevel;
  m_maxZoomLevel;
  m_distanceScale = DEFAULT_TEXT_DISTANCE_SCALE;
  m_mayOverlap;
  m_reserveSpace;
  m_renderStyle;
  m_layoutStype;
  m_technique;
  m_renderOrder;
  m_xOffset;
  m_yOffset;
  m_poiBuilder;
  m_alwaysOnTop;
  renderOrderUpBound;
  static alignZoomLevelRanges(textElement) {
    if (!textElement.poiInfo) {
      return;
    }
    const poiInfo = textElement.poiInfo;
    textElement.minZoomLevel = textElement.minZoomLevel ?? MathUtils6.min2(poiInfo.iconMinZoomLevel, poiInfo.textMinZoomLevel);
    textElement.maxZoomLevel = textElement.maxZoomLevel ?? MathUtils6.max2(poiInfo.iconMaxZoomLevel, poiInfo.textMaxZoomLevel);
  }
  static composeRenderOrder(baseRenderOrder, offset) {
    return baseRenderOrder * _TextElementBuilder.RENDER_ORDER_UP_BOUND + offset;
  }
  withTechnique(technique) {
    this.m_technique = technique;
    this.m_priority = getPropertyValue(technique.priority, this.m_env) ?? 0;
    this.m_fadeNear = getPropertyValue(technique.fadeNear, this.m_env) ?? void 0;
    this.m_fadeFar = getPropertyValue(technique.fadeFar, this.m_env) ?? void 0;
    this.m_minZoomLevel = getPropertyValue(technique.minZoomLevel, this.m_env) ?? void 0;
    this.m_maxZoomLevel = getPropertyValue(technique.maxZoomLevel, this.m_env) ?? void 0;
    this.m_distanceScale = technique.distanceScale ?? DEFAULT_TEXT_DISTANCE_SCALE;
    this.m_renderStyle = this.m_styleCache.getRenderStyle(technique);
    this.m_layoutStype = this.m_styleCache.getLayoutStyle(technique);
    this.m_xOffset = getPropertyValue(technique.xOffset, this.m_env);
    this.m_yOffset = getPropertyValue(technique.yOffset, this.m_env);
    const techniqueRenderOrder = getPropertyValue(technique.renderOrder, this.m_env) ?? 0;
    if (!this.isValidRenderOrder(techniqueRenderOrder)) {
      const msg = `Unsupported large render order (${techniqueRenderOrder})`;
      logger20.error(msg);
      assert(false, msg);
    }
    this.m_renderOrder = _TextElementBuilder.composeRenderOrder(this.m_baseRenderOrder, techniqueRenderOrder);
    if (isTextTechnique(technique)) {
      this.withTextTechnique(technique);
    } else {
      this.withPoiTechnique(technique);
    }
    return this;
  }
  withIcon(imageTextureName, shieldGroupIndex) {
    assert(this.m_poiBuilder !== void 0);
    this.m_poiBuilder.withIcon(imageTextureName, shieldGroupIndex);
    return this;
  }
  build(text, points, tileOffset, dataSourceName, dataSourceOrder, attributes, pathLengthSqr, offsetDirection) {
    var _a;
    const featureId = getFeatureId(attributes);
    assert(this.m_technique !== void 0);
    assert(this.m_renderStyle !== void 0);
    assert(this.m_layoutStype !== void 0);
    const technique = this.m_technique;
    const renderStyle = this.m_renderStyle;
    const layoutStyle = this.m_layoutStype;
    const textElement = new TextElement(ContextualArabicConverter.instance.convert(text), points, renderStyle, layoutStyle, this.m_priority, this.m_xOffset, this.m_yOffset, featureId, technique.style, this.m_fadeNear, this.m_fadeFar, tileOffset, offsetDirection, dataSourceName, dataSourceOrder);
    textElement.minZoomLevel = this.m_minZoomLevel;
    textElement.maxZoomLevel = this.m_maxZoomLevel;
    textElement.distanceScale = this.m_distanceScale;
    textElement.mayOverlap = this.m_mayOverlap;
    textElement.reserveSpace = this.m_reserveSpace;
    textElement.kind = technique.kind;
    textElement.userData = attributes;
    textElement.textFadeTime = technique.textFadeTime !== void 0 ? technique.textFadeTime * 1e3 : void 0;
    textElement.pathLengthSqr = pathLengthSqr;
    textElement.alwaysOnTop = this.m_alwaysOnTop;
    textElement.renderOrder = this.m_renderOrder;
    textElement.poiInfo = (_a = this.m_poiBuilder) == null ? void 0 : _a.build(textElement);
    _TextElementBuilder.alignZoomLevelRanges(textElement);
    return textElement;
  }
  withTextTechnique(technique) {
    this.m_mayOverlap = technique.mayOverlap === true;
    this.m_reserveSpace = technique.reserveSpace !== false;
    this.m_poiBuilder = void 0;
  }
  withPoiTechnique(technique) {
    this.m_mayOverlap = technique.textMayOverlap === true;
    this.m_reserveSpace = technique.textReserveSpace !== false;
    this.m_alwaysOnTop = technique.alwaysOnTop === true;
    if (!this.m_poiBuilder) {
      this.m_poiBuilder = new PoiBuilder(this.m_env);
    }
    this.m_poiBuilder.withTechnique(technique);
  }
  isValidRenderOrder(renderOrder) {
    return Math.abs(renderOrder) < this.renderOrderUpBound;
  }
};
var TextElementBuilder = _TextElementBuilder;
__publicField(TextElementBuilder, "RENDER_ORDER_UP_BOUND", 1e7);

// src/mapview/poi/PoiManager.ts
var logger21 = LoggerManager.instance.create("PoiManager");
function getImageTexture2(poiGeometry, index = 0) {
  if (poiGeometry.imageTextures) {
    const textureNameIndex = poiGeometry.imageTextures[index];
    if (textureNameIndex >= 0) {
      assert(poiGeometry.imageTextures.length > index);
      return poiGeometry.stringCatalog[textureNameIndex];
    }
  }
  return void 0;
}
function getAttributes(poiGeometry, index = 0) {
  return poiGeometry.objInfos ? poiGeometry.objInfos[index] : void 0;
}
function getPosition(positionAttribute, worldOffsetX, index = 0) {
  const position = new THREE85.Vector3().fromBufferAttribute(positionAttribute, index);
  position.x += worldOffsetX;
  return position;
}
function getText(poiGeometry, index = 0) {
  assert(poiGeometry.texts.length > index);
  const stringIndex = poiGeometry.texts[index];
  assert(poiGeometry.stringCatalog.length > stringIndex);
  return poiGeometry.stringCatalog[stringIndex] ?? "";
}
var _PoiManager = class {
  constructor(mapView) {
    this.mapView = mapView;
  }
  static notifyMissingPoiTable(poiTableName, poiTable) {
    if (poiTableName === void 0) {
      poiTableName = "undefined";
    }
    if (_PoiManager.m_missingPoiTableName.get(poiTableName) === void 0) {
      _PoiManager.m_missingPoiTableName.set(poiTableName, true);
      if (poiTable !== void 0 && !poiTable.loadedOk) {
        logger21.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);
      } else {
        logger21.error(`updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`);
      }
    }
  }
  static notifyMissingPoi(poiName, poiTableName) {
    if (poiName === void 0) {
      poiName = "undefined";
    }
    const key = `${poiTableName}[${poiName}]`;
    if (_PoiManager.m_missingPoiName.get(key) === void 0) {
      _PoiManager.m_missingPoiName.set(key, true);
      logger21.warn(`updatePoiFromPoiTable: Cannot find POI info for '${poiName}' in table '${poiTableName}'.`);
    }
  }
  m_imageTextures = /* @__PURE__ */ new Map();
  m_poiShieldGroups = /* @__PURE__ */ new Map();
  addPois(tile, decodedTile) {
    const poiGeometries = assertExists(decodedTile.poiGeometries);
    const worldOffsetX = tile.computeWorldOffsetX();
    const mapView = tile.mapView;
    const discreteZoomLevel = Math.floor(mapView.zoomLevel);
    const intZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
    const poiBuilder = new TextElementBuilder(intZoomEnv, tile.textStyleCache, tile.dataSource.dataSourceOrder);
    for (const poiGeometry of poiGeometries) {
      assert(poiGeometry.technique !== void 0);
      const techniqueIndex = assertExists(poiGeometry.technique);
      const technique = decodedTile.techniques[techniqueIndex];
      if (technique._kindState === false || !isLineMarkerTechnique(technique) && !isPoiTechnique(technique)) {
        continue;
      }
      if (technique.showOnMap === false) {
        continue;
      }
      const positions = new THREE85.BufferAttribute(new Float64Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);
      poiBuilder.withTechnique(technique);
      if (isLineMarkerTechnique(technique) && positions.count > 0) {
        this.addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX);
      } else if (isPoiTechnique(technique)) {
        this.addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX);
      }
    }
  }
  async addTextureAtlas(imageName, atlas, abortSignal) {
    const response = await fetch(atlas, { signal: abortSignal });
    if (!response.ok) {
      throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);
    }
    try {
      const jsonAtlas = await response.json();
      if (jsonAtlas === void 0) {
        logger21.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);
        return;
      }
      logger21.debug(`addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`);
      for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {
        const imageTextureDef = jsonAtlas[textureName];
        const imageTexture = {
          name: textureName,
          image: imageName,
          xOffset: imageTextureDef.x,
          yOffset: imageTextureDef.y,
          width: imageTextureDef.width,
          height: imageTextureDef.height
        };
        this.addImageTexture(imageTexture);
      }
      this.mapView.update();
    } catch (error) {
      logger21.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${error}`);
    }
  }
  addImageTexture(imageTexture) {
    if (imageTexture.name === void 0) {
      logger21.error("addImageTexture: Name required", imageTexture);
      return;
    }
    if (this.m_imageTextures.get(imageTexture.name) !== void 0) {
      logger21.warn(`addImageTexture: Name already used: ${imageTexture.name} (overriding it)`);
    }
    this.m_imageTextures.set(imageTexture.name, imageTexture);
  }
  getImageTexture(name2) {
    return this.m_imageTextures.get(name2);
  }
  updatePoiFromPoiTable(pointLabel) {
    const poiInfo = pointLabel.poiInfo;
    if (!poiInfo || poiInfo.poiTableName === void 0 || poiInfo.poiName === void 0) {
      return true;
    }
    const poiTableName = poiInfo.poiTableName;
    const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);
    if (poiTable && poiTable.isLoading) {
      return false;
    }
    poiInfo.poiTableName = void 0;
    if (!poiTable || !poiTable.loadedOk) {
      _PoiManager.notifyMissingPoiTable(poiTableName, poiTable);
      return true;
    }
    const poiName = poiInfo.poiName;
    const poiTableEntry = poiTable.getEntry(poiName);
    if (!poiTableEntry) {
      _PoiManager.notifyMissingPoi(poiName, poiTableName);
      return true;
    }
    if (poiTableEntry.iconName !== void 0 && poiTableEntry.iconName.length > 0) {
      poiInfo.imageTextureName = composeTechniqueTextureName(poiTableEntry.iconName, poiInfo.technique);
    }
    pointLabel.visible = poiTableEntry.visible ?? pointLabel.visible;
    pointLabel.priority = poiTableEntry.priority ?? pointLabel.priority;
    poiInfo.iconMinZoomLevel = poiTableEntry.iconMinLevel ?? poiInfo.iconMinZoomLevel;
    poiInfo.iconMaxZoomLevel = poiTableEntry.iconMaxLevel ?? poiInfo.iconMaxZoomLevel;
    poiInfo.textMinZoomLevel = poiTableEntry.textMinLevel ?? poiInfo.textMinZoomLevel;
    poiInfo.textMaxZoomLevel = poiTableEntry.textMaxLevel ?? poiInfo.textMaxZoomLevel;
    TextElementBuilder.alignZoomLevelRanges(pointLabel);
    return true;
  }
  clear() {
    this.m_imageTextures.clear();
    this.m_poiShieldGroups.clear();
  }
  addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX) {
    const text = getText(poiGeometry);
    const imageTextureName = getImageTexture2(poiGeometry);
    const groupKey = imageTextureName + "-" + text;
    let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);
    if (shieldGroupIndex === void 0) {
      shieldGroupIndex = this.m_poiShieldGroups.size;
      this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);
    }
    const positionArray = [];
    for (let i = 0; i < positions.count; i += 3) {
      positionArray.push(getPosition(positions, worldOffsetX, i));
    }
    const textElement = poiBuilder.withIcon(imageTextureName, shieldGroupIndex).build(text, positionArray, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, getAttributes(poiGeometry));
    tile.addTextElement(textElement);
  }
  addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX) {
    var _a;
    for (let i = 0; i < positions.count; ++i) {
      const offsetDirection = ((_a = poiGeometry.offsetDirections) == null ? void 0 : _a[i]) ?? 0;
      const textElement = poiBuilder.withIcon(getImageTexture2(poiGeometry, i)).build(getText(poiGeometry, i), getPosition(positions, worldOffsetX, i), tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, getAttributes(poiGeometry, i), void 0, offsetDirection);
      tile.addTextElement(textElement);
    }
  }
};
var PoiManager = _PoiManager;
__publicField(PoiManager, "m_missingPoiTableName", /* @__PURE__ */ new Map());
__publicField(PoiManager, "m_missingPoiName", /* @__PURE__ */ new Map());

// src/mapview/poi/PoiTableManager.ts
var logger22 = LoggerManager.instance.create("PoiTable");
var PoiTableEntry = class {
  static verifyJSON(jsonEntry) {
    let isOK = typeof jsonEntry.name === "string" && jsonEntry.name.length > 0 && (jsonEntry.altNames === void 0 || Array.isArray(jsonEntry.altNames)) && (jsonEntry.stackMode === void 0 || jsonEntry.stackMode === "yes" || jsonEntry.stackMode === "no" || jsonEntry.stackMode === "parent") && (jsonEntry.visible === void 0 || typeof jsonEntry.visible === "boolean") && (jsonEntry.priority === void 0 || typeof jsonEntry.priority === "number") && (jsonEntry.iconMinLevel === void 0 || typeof jsonEntry.iconMinLevel === "number") && (jsonEntry.iconMaxLevel === void 0 || typeof jsonEntry.iconMaxLevel === "number") && (jsonEntry.textMinLevel === void 0 || typeof jsonEntry.textMinLevel === "number") && (jsonEntry.textMaxLevel === void 0 || typeof jsonEntry.textMaxLevel === "number");
    if (isOK && jsonEntry.altNames !== void 0) {
      const altNames = jsonEntry.altNames;
      for (const str in altNames) {
        if (typeof str !== "string") {
          isOK = false;
          break;
        }
      }
    }
    return isOK;
  }
  name;
  altNames;
  visible;
  iconName;
  stackMode;
  priority;
  iconMinLevel;
  iconMaxLevel;
  textMinLevel;
  textMaxLevel;
  setup(jsonEntry) {
    this.name = jsonEntry.name;
    this.altNames = jsonEntry.altNames;
    this.iconName = jsonEntry.iconName;
    this.visible = jsonEntry.visible;
    this.priority = jsonEntry.priority;
    this.iconMinLevel = jsonEntry.iconMinLevel;
    this.iconMaxLevel = jsonEntry.iconMaxLevel;
    this.textMinLevel = jsonEntry.textMinLevel;
    this.textMaxLevel = jsonEntry.textMaxLevel;
    switch (jsonEntry.stackMode) {
      case "yes":
        this.stackMode = "show-in-stack" /* Show */;
        break;
      case "no":
        this.stackMode = "hide-in-stack" /* Hide */;
        break;
      case "parent":
        this.stackMode = "show-parent" /* ShowParent */;
        break;
      default:
    }
  }
};
var PoiTable = class {
  constructor(name2, useAltNamesForKey) {
    this.name = name2;
    this.useAltNamesForKey = useAltNamesForKey;
  }
  poiList = new Array();
  poiDict = /* @__PURE__ */ new Map();
  m_isLoading = false;
  m_loadedOk = void 0;
  get isLoading() {
    return this.m_isLoading;
  }
  get loadedOk() {
    return this.m_loadedOk === true;
  }
  getEntry(poiName) {
    const entryIdx = this.poiDict.get(poiName);
    if (entryIdx !== void 0) {
      if (entryIdx < this.poiList.length) {
        return this.poiList[entryIdx];
      } else {
        throw new Error("Poi table entry index out of stored list!");
      }
    }
    return void 0;
  }
  async load(poiTableUrl, abortSignal) {
    if (this.m_loadedOk !== void 0) {
      return true;
    }
    this.m_loadedOk = false;
    const response = await fetch(poiTableUrl, { signal: abortSignal });
    if (!response.ok) {
      throw new Error(`load: Cannot load POI table at ${poiTableUrl}: ${response.statusText}`);
    }
    const jsonPoiTable = await response.json();
    if (jsonPoiTable === void 0) {
      logger22.info(`load: TextureAtlas empty: ${poiTableUrl}`);
      return true;
    }
    this.startLoading();
    try {
      logger22.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);
      if (jsonPoiTable.poiList !== void 0 && Array.isArray(jsonPoiTable.poiList)) {
        for (const tableEntry of jsonPoiTable.poiList) {
          if (PoiTableEntry.verifyJSON(tableEntry)) {
            const newPoiEntry = new PoiTableEntry();
            newPoiEntry.setup(tableEntry);
            const entryIdx = this.poiList.push(newPoiEntry) - 1;
            if (!this.useAltNamesForKey) {
              if (newPoiEntry.name === void 0) {
                logger22.warn(`load: Invalid entry in POI table '${poiTableUrl}' : . No name set in entry: ${tableEntry}.`);
              } else {
                this.poiDict.set(newPoiEntry.name, entryIdx);
              }
            } else {
              if (newPoiEntry.altNames !== void 0 && newPoiEntry.altNames.length > 0) {
                for (const altName of newPoiEntry.altNames) {
                  this.poiDict.set(altName, entryIdx);
                }
              } else {
                logger22.debug(`load: Invalid entry in POI table '${poiTableUrl}' : No alternative names set in entry: ${JSON.stringify(tableEntry)}.`);
              }
            }
          } else {
            logger22.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(tableEntry)}`);
          }
        }
      }
      this.m_loadedOk = true;
      this.finishedLoading();
    } catch (ex) {
      logger22.error(`load: Failed to load POI table '${poiTableUrl}' : ${ex}`);
      this.m_loadedOk = false;
      this.finishedLoading();
      return false;
    }
    return true;
  }
  startLoading() {
    this.m_isLoading = true;
  }
  finishedLoading() {
    this.m_isLoading = false;
  }
};
var PoiTableManager = class {
  constructor(mapView) {
    this.mapView = mapView;
  }
  m_isLoading = false;
  m_poiTables = /* @__PURE__ */ new Map();
  m_abortControllers = /* @__PURE__ */ new Map();
  async loadPoiTables(poiTables) {
    const finished = new Promise((resolve) => {
      this.clear();
      if (poiTables !== void 0) {
        this.startLoading();
        const loadPromises = new Array();
        poiTables.forEach((poiTableRef) => {
          var _a;
          if (poiTableRef !== void 0 && poiTableRef.name !== void 0 && typeof poiTableRef.name === "string") {
            const poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);
            if (poiTableRef.url !== void 0 && typeof poiTableRef.url === "string") {
              this.addTable(poiTable);
              this.m_abortControllers.set(poiTableRef.name, new AbortController());
              loadPromises.push(poiTable.load(poiTableRef.url, (_a = this.m_abortControllers.get(poiTableRef.name)) == null ? void 0 : _a.signal));
            } else {
              logger22.error(`POI table definition has no valid url: ${poiTableRef}`);
            }
          } else {
            logger22.error(`POI table definition has no valid name: ${poiTableRef}`);
          }
        });
        if (loadPromises.length > 0) {
          Promise.all(loadPromises).finally(() => {
            this.finishLoading();
            resolve();
          });
        } else {
          this.finishLoading();
          resolve();
        }
      } else {
        this.finishLoading();
        resolve();
      }
    });
    return finished;
  }
  clear() {
    this.m_poiTables = /* @__PURE__ */ new Map();
    this.m_abortControllers.forEach((abortController, name2) => {
      abortController.abort();
      this.m_abortControllers.delete(name2);
    });
  }
  get poiTables() {
    return this.m_poiTables;
  }
  addTable(poiTable) {
    this.m_poiTables.set(poiTable.name, poiTable);
  }
  getPoiTable(poiTableName) {
    return poiTableName === void 0 ? void 0 : this.m_poiTables.get(poiTableName);
  }
  get finishedLoading() {
    return !this.m_isLoading;
  }
  startLoading() {
    this.m_isLoading = true;
  }
  finishLoading() {
    this.m_isLoading = false;
  }
};

// src/mapview/PolarTileDataSource.ts
var THREE87 = __toESM(require("three"));

// src/datasource-protocol/StyleSetEvaluator.ts
var logger23 = LoggerManager.instance.create("StyleSetEvaluator");
var DEFAULT_TECHNIQUE_ATTR_SCOPE = 1 /* TechniqueGeometry */;
function getStyleAttributeScope(style, attrName) {
  var _a;
  if (style.technique === "extruded-polygon") {
    if (attrName === "color" && style.vertexColors !== false) {
      return DEFAULT_TECHNIQUE_ATTR_SCOPE;
    }
  }
  return ((_a = getTechniqueAttributeDescriptor(style.technique, attrName)) == null ? void 0 : _a.scope) ?? DEFAULT_TECHNIQUE_ATTR_SCOPE;
}
var StyleConditionClassifier = class {
  _style;
  classify(style) {
    if (style._whenExpr) {
      const savedStyle = this.switchStyle(style);
      style._whenExpr = style._whenExpr.accept(this, void 0);
      this._style = savedStyle;
    }
  }
  visitNullLiteralExpr(expr, enclosingExpr) {
    return expr;
  }
  visitBooleanLiteralExpr(expr, enclosingExpr) {
    return expr;
  }
  visitNumberLiteralExpr(expr, enclosingExpr) {
    return expr;
  }
  visitStringLiteralExpr(expr, enclosingExpr) {
    return expr;
  }
  visitObjectLiteralExpr(expr, enclosingExpr) {
    return expr;
  }
  visitVarExpr(expr, enclosingExpr) {
    return expr;
  }
  visitHasAttributeExpr(expr, enclosingExpr) {
    return expr;
  }
  visitMatchExpr(expr, enclosingExpr) {
    return expr;
  }
  visitCaseExpr(expr, enclosingExpr) {
    return expr;
  }
  visitCallExpr(call, enclosingExpr) {
    if (call.op === "all") {
      const children = call.args.map((childExpr) => childExpr.accept(this, call)).filter((childExpr) => childExpr !== void 0);
      return new CallExpr7(call.op, children);
    } else if (enclosingExpr) {
      const matched = this.matchVarStringComparison(call);
      if (matched) {
        if (this._style.layer === void 0 && matched.name === "$layer") {
          this._style.layer = matched.value;
          return void 0;
        } else if (this._style._geometryType === void 0 && matched.name === "$geometryType") {
          this._style._geometryType = matched.value;
          return void 0;
        }
      }
    }
    return call;
  }
  visitLookupExpr(lookup, enclosingExpr) {
    return this.visitCallExpr(lookup, enclosingExpr);
  }
  visitStepExpr(expr, enclosingExpr) {
    return expr;
  }
  visitInterpolateExpr(expr, enclosingExpr) {
    return expr;
  }
  matchVarStringComparison(call) {
    if (call.op === "==") {
      const left = call.args[0];
      const right = call.args[1];
      if (left instanceof VarExpr3 && right instanceof StringLiteralExpr) {
        return { name: left.name, value: right.value };
      }
      if (right instanceof VarExpr3 && left instanceof StringLiteralExpr) {
        return { name: right.name, value: left.value };
      }
    }
    return void 0;
  }
  switchStyle(style) {
    const saved = this._style;
    this._style = style;
    return saved;
  }
};
var OptimizedSubSetKey = class {
  key;
  layer;
  geometryType;
  cachedStyleSet;
  constructor(layer, geometryType) {
    this.key = "";
    this.set(layer, geometryType);
  }
  set(layer, geometryType, env) {
    let keyUpdateNeeded = false;
    if (layer === void 0) {
      const envLayer = env !== void 0 ? env.lookup("$layer") : void 0;
      layer = typeof envLayer === "string" ? envLayer : void 0;
    }
    if (this.layer !== layer) {
      this.layer = layer;
      keyUpdateNeeded = true;
    }
    if (geometryType === void 0) {
      const envGeometryType = env !== void 0 ? env.lookup("$geometryType") : void 0;
      geometryType = typeof envGeometryType === "string" ? envGeometryType : void 0;
    }
    if (this.geometryType !== geometryType) {
      this.geometryType = geometryType;
      keyUpdateNeeded = true;
    }
    if (keyUpdateNeeded) {
      this.updateKey();
    }
    return this;
  }
  updateKey() {
    if (this.layer !== void 0) {
      if (this.geometryType !== void 0) {
        this.key = `${this.layer}:${this.geometryType}`;
      } else {
        this.key = `${this.layer}:`;
      }
    } else {
      if (this.geometryType !== void 0) {
        this.key = `:${this.geometryType}`;
      } else {
        this.key = "all";
      }
    }
    this.cachedStyleSet = void 0;
  }
};
var StyleSetEvaluator = class {
  constructor(m_options) {
    this.m_options = m_options;
    this.m_definitions = this.m_options.definitions;
    this.styleSet = resolveReferences(this.m_options.styleSet, this.m_definitions);
    computeDefaultRenderOrder(this.styleSet);
    this.compileStyleSet();
  }
  styleSet;
  m_techniques = [];
  m_exprPool = new ExprPool();
  m_cachedResults = /* @__PURE__ */ new Map();
  m_styleConditionClassifier = new StyleConditionClassifier();
  m_subStyleSetCache = /* @__PURE__ */ new Map();
  m_definitions;
  m_definitionExprCache = /* @__PURE__ */ new Map();
  m_tmpOptimizedSubSetKey = new OptimizedSubSetKey();
  m_emptyEnv = new Env();
  m_featureDependencies = [];
  m_layer;
  m_geometryType;
  m_zoomLevel;
  m_previousResult;
  m_previousEnv;
  m_nextArrayBufferId = 0;
  getMatchingTechniques(env, layer, geometryType) {
    if (this.m_previousResult && this.m_previousEnv && this.m_featureDependencies.every((p) => {
      var _a;
      return ((_a = this.m_previousEnv) == null ? void 0 : _a.lookup(p)) === env.lookup(p);
    })) {
      return this.m_previousResult;
    }
    const result = [];
    this.m_cachedResults.clear();
    const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;
    optimizedSubSetKey.set(layer, geometryType, env);
    this.m_layer = optimizedSubSetKey.layer;
    this.m_geometryType = optimizedSubSetKey.geometryType;
    this.m_zoomLevel = env.lookup("$zoom");
    const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);
    for (const currStyle of searchedStyleSet) {
      if (this.processStyle(env, currStyle, result)) {
        break;
      }
    }
    this.m_previousResult = result;
    this.m_previousEnv = env;
    return result;
  }
  wantsLayer(layer) {
    return this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, void 0)).length > 0;
  }
  wantsFeature(layer, geometryType) {
    return this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType)).length > 0;
  }
  resetTechniques() {
    for (const techinque of this.m_techniques) {
      techinque._index = void 0;
    }
    this.m_techniques.length = 0;
    this.m_previousResult = void 0;
    this.m_previousEnv = void 0;
  }
  get techniques() {
    return this.m_techniques;
  }
  get decodedTechniques() {
    return this.m_techniques.map(makeDecodedTechnique);
  }
  getOptimizedStyleSet(subSetKey) {
    if (subSetKey.cachedStyleSet !== void 0) {
      return subSetKey.cachedStyleSet;
    }
    let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);
    if (optimizedStyleSet !== void 0) {
      subSetKey.cachedStyleSet = optimizedStyleSet;
      return optimizedStyleSet;
    }
    optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);
    this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);
    subSetKey.cachedStyleSet = optimizedStyleSet;
    return optimizedStyleSet;
  }
  createPreFilteredStyleSet(subSetKey) {
    const { layer, geometryType } = subSetKey;
    return this.styleSet.filter((style) => {
      if (layer !== void 0 && style.layer !== void 0 && style.layer !== layer) {
        return false;
      }
      if (geometryType !== void 0 && style._geometryType !== void 0 && style._geometryType !== geometryType) {
        return false;
      }
      return true;
    });
  }
  compileStyleSet() {
    this.m_featureDependencies = ["$layer", "$geometryType", "$zoom"];
    this.styleSet.forEach((style) => this.compileStyle(style));
    this.styleSet.forEach((style) => {
      this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));
    });
  }
  compileStyle(style) {
    this.checkStyleDynamicAttributes(style);
    if (style.when !== void 0) {
      try {
        style._whenExpr = Array.isArray(style.when) ? Expr3.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache) : Expr3.parse(style.when);
        this.m_styleConditionClassifier.classify(style);
        if (style._whenExpr !== void 0) {
          style._whenExpr = style._whenExpr.intern(this.m_exprPool);
        }
        const deps = style._whenExpr.dependencies();
        deps == null ? void 0 : deps.properties.forEach((prop) => {
          if (!this.m_featureDependencies.includes(prop)) {
            this.m_featureDependencies.push(prop);
          }
        });
        if (isJsonExpr(style.minZoomLevel)) {
          style._minZoomLevelExpr = Expr3.fromJSON(style.minZoomLevel, this.m_definitions).intern(this.m_exprPool);
        }
        if (isJsonExpr(style.maxZoomLevel)) {
          style._maxZoomLevelExpr = Expr3.fromJSON(style.maxZoomLevel, this.m_definitions).intern(this.m_exprPool);
        }
      } catch (err) {
        logger23.log("failed to evaluate expression", JSON.stringify(style.when), "error", String(err));
      }
    }
  }
  processStyle(env, style, result) {
    if (!this.checkZoomLevel(env, style)) {
      return false;
    }
    if (this.m_layer !== void 0 && style.layer !== void 0 && style.layer !== this.m_layer) {
      return false;
    }
    if (this.m_geometryType !== void 0 && style._geometryType !== void 0 && style._geometryType !== this.m_geometryType) {
      return false;
    }
    if (style._whenExpr) {
      try {
        if (!style._whenExpr.evaluate(env, 1 /* Condition */, this.m_cachedResults)) {
          return false;
        }
      } catch (error) {
        logger23.error(`failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`);
        return false;
      }
    }
    if (style.technique === void 0) {
      return false;
    }
    if (style.technique !== "none") {
      result.push(this.getTechniqueForStyleMatch(env, style));
    }
    return style.final === true;
  }
  checkZoomLevel(env, style) {
    var _a, _b;
    if (style.minZoomLevel === void 0 && style.maxZoomLevel === void 0) {
      return true;
    }
    const zoomLevel = this.m_zoomLevel;
    if (zoomLevel === void 0) {
      return true;
    }
    if (style.minZoomLevel !== void 0) {
      let minZoomLevel = style.minZoomLevel;
      if (((_a = style._minZoomLevelExpr) == null ? void 0 : _a.isDynamic()) === false) {
        try {
          minZoomLevel = style._minZoomLevelExpr.evaluate(env, 1 /* Condition */, this.m_cachedResults);
        } catch (error) {
          logger23.error(`failed to evaluate expression '${JSON.stringify(style._minZoomLevelExpr)}': ${error}`);
        }
      }
      if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
        return false;
      }
    }
    if (style.maxZoomLevel !== void 0) {
      let maxZoomLevel = style.maxZoomLevel;
      if (((_b = style._maxZoomLevelExpr) == null ? void 0 : _b.isDynamic()) === false) {
        try {
          maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, 1 /* Condition */, this.m_cachedResults);
        } catch (error) {
          logger23.error(`failed to evaluate expression '${JSON.stringify(style._maxZoomLevelExpr)}': ${error}`);
        }
      }
      if (typeof maxZoomLevel === "number" && zoomLevel >= maxZoomLevel) {
        return false;
      }
    }
    return true;
  }
  getTechniqueForStyleMatch(env, style) {
    let technique;
    if (style._dynamicTechniques !== void 0) {
      const dynamicAttributes = this.evaluateTechniqueProperties(style, env);
      const key = this.getDynamicTechniqueKey(style, dynamicAttributes);
      technique = style._dynamicTechniques.get(key);
      if (technique === void 0) {
        technique = this.createTechnique(style, key, dynamicAttributes);
        style._dynamicTechniques.set(key, technique);
      }
    } else {
      technique = style._staticTechnique;
      if (technique === void 0) {
        style._staticTechnique = technique = this.createTechnique(style, `${style._styleSetIndex}`, []);
      }
    }
    if (technique._index === void 0) {
      technique._index = this.m_techniques.length;
      this.m_techniques.push(technique);
    }
    return technique;
  }
  getDynamicTechniqueKey(style, dynamicAttributes) {
    const dynamicAttrKey = dynamicAttributes.map(([_attrName, attrValue]) => {
      if (attrValue === void 0) {
        return "U";
      } else if (typeof attrValue === "object") {
        return JSON.stringify(attrValue, (_, value2) => {
          if (value2 instanceof ArrayBuffer) {
            let arrayBufferId = value2.id;
            if (arrayBufferId === void 0) {
              arrayBufferId = value2.id = this.m_nextArrayBufferId++;
            }
            return arrayBufferId;
          }
          return value2;
        });
      } else {
        return JSON.stringify(attrValue);
      }
    }).join(":");
    return `${style._styleSetIndex}:${dynamicAttrKey}`;
  }
  checkStyleDynamicAttributes(style) {
    if (style._dynamicTechniqueAttributes !== void 0 || style.technique === "none") {
      return;
    }
    style._dynamicTechniqueAttributes = [];
    style._dynamicFeatureAttributes = [];
    style._dynamicForwardedAttributes = [];
    style._staticAttributes = [];
    const dynamicFeatureAttributes = style._dynamicFeatureAttributes;
    const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;
    const dynamicForwardedAttributes = style._dynamicForwardedAttributes;
    const targetStaticAttributes = style._staticAttributes;
    const processAttribute = (attrName, attrValue) => {
      if (attrValue === void 0) {
        return;
      }
      if (isJsonExpr(attrValue)) {
        attrValue = Expr3.fromJSON(attrValue, this.m_definitions, this.m_definitionExprCache).intern(this.m_exprPool);
      } else if (isInterpolatedPropertyDefinition(attrValue)) {
        attrValue = Expr3.fromJSON(interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(this.m_exprPool);
      }
      if (Expr3.isExpr(attrValue)) {
        const deps = attrValue.dependencies();
        if (deps.featureState) {
          if (attrName !== "enabled") {
            logger23.log("feature-state is not supported in this context");
          } else {
            style._usesFeatureState = true;
          }
        }
        if (deps.properties.size === 0 && !attrValue.isDynamic()) {
          attrValue = attrValue.evaluate(this.m_emptyEnv);
        }
      }
      if (Expr3.isExpr(attrValue)) {
        const attrScope = getStyleAttributeScope(style, attrName);
        const deps = attrValue.dependencies();
        deps.properties.forEach((prop) => {
          if (!this.m_featureDependencies.includes(prop)) {
            this.m_featureDependencies.push(prop);
          }
        });
        switch (attrScope) {
          case 0 /* FeatureGeometry */:
            dynamicFeatureAttributes.push([attrName, attrValue]);
            break;
          case 1 /* TechniqueGeometry */:
            dynamicTechniqueAttributes.push([attrName, attrValue]);
            break;
          case 2 /* TechniqueRendering */:
            if (deps.properties.size === 0) {
              dynamicForwardedAttributes.push([attrName, attrValue]);
            } else {
              dynamicTechniqueAttributes.push([attrName, attrValue]);
            }
            break;
        }
      } else if (attrValue !== void 0 && attrValue !== null) {
        targetStaticAttributes.push([attrName, attrValue]);
      }
    };
    const replacement = /* @__PURE__ */ new Map([
      ["category", "_category"],
      ["secondaryCategory", "_secondaryCategory"]
    ]);
    for (const p in style) {
      if (!style.hasOwnProperty(p)) {
        continue;
      }
      if (p.startsWith("_")) {
        continue;
      }
      if (["when", "technique", "layer", "attr", "description"].includes(p)) {
        continue;
      }
      const pp = replacement.get(p) ?? p;
      processAttribute(pp, style[p]);
    }
    if (style.attr !== void 0) {
      for (const attrName in style.attr) {
        if (!style.attr.hasOwnProperty(attrName)) {
          continue;
        }
        processAttribute(attrName, style.attr[attrName]);
      }
    }
    if (dynamicTechniqueAttributes.length > 0) {
      style._dynamicTechniques = /* @__PURE__ */ new Map();
    }
  }
  evaluateTechniqueProperties(style, env) {
    if (style._dynamicTechniqueAttributes === void 0) {
      return [];
    }
    return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {
      try {
        const evaluatedValue = attrExpr.evaluate(env, 0 /* Value */, this.m_cachedResults);
        return [attrName, evaluatedValue];
      } catch (error) {
        logger23.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);
        return [attrName, null];
      }
    });
  }
  createTechnique(style, key, dynamicAttrs) {
    const technique = {};
    technique.name = style.technique;
    if (style._staticAttributes !== void 0) {
      for (const [attrName, attrValue] of style._staticAttributes) {
        if (attrValue !== null) {
          technique[attrName] = attrValue;
        }
      }
    }
    for (const [attrName, attrValue] of dynamicAttrs) {
      if (attrValue !== null) {
        technique[attrName] = attrValue;
      }
    }
    if (style._dynamicFeatureAttributes !== void 0) {
      for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {
        technique[attrName] = attrValue;
      }
    }
    if (style._dynamicForwardedAttributes !== void 0) {
      for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {
        technique[attrName] = attrValue;
      }
    }
    technique._index = this.m_techniques.length;
    technique._styleSetIndex = style._styleSetIndex;
    if (style.styleSet !== void 0) {
      technique._styleSet = style.styleSet;
    }
    if (style._usesFeatureState !== void 0) {
      technique._usesFeatureState = style._usesFeatureState;
    }
    setTechniqueRenderOrderOrPriority(technique, this.m_options.priorities ?? [], this.m_options.labelPriorities ?? []);
    this.m_techniques.push(technique);
    return technique;
  }
};
function computeDefaultRenderOrder(styleSet) {
  let techniqueRenderOrder = 0;
  let styleSetIndex = 0;
  for (const style of styleSet) {
    style._styleSetIndex = styleSetIndex++;
    if (style.technique !== void 0 && style.renderOrder === void 0) {
      style.renderOrder = techniqueRenderOrder++;
    }
  }
}
function resolveReferences(styleSet, definitions) {
  return styleSet.map((style) => resolveStyleReferences(style, definitions));
}
function resolveStyleReferences(style, definitions) {
  return { ...style };
}
function makeDecodedTechnique(technique) {
  const result = {};
  for (const attrName in technique) {
    if (!technique.hasOwnProperty(attrName)) {
      continue;
    }
    let attrValue = technique[attrName];
    if (typeof attrValue === "object" && (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)) {
      attrValue = LiteralExpr.fromValue(attrValue);
    }
    if (Expr3.isExpr(attrValue)) {
      attrValue = attrValue.toJSON();
    }
    ;
    result[attrName] = attrValue;
  }
  return result;
}

// src/datasource-protocol/Outliner.ts
var THREE86 = __toESM(require("three"));
var currEdgeStart = new THREE86.Vector2();
var currEdgeGoal = new THREE86.Vector2();
var prevEdgeStart = new THREE86.Vector2();
var prevEdgeGoal = new THREE86.Vector2();

// src/datasource-protocol/ThreeBufferUtils.ts
var ThreeBufferUtils;
((ThreeBufferUtils2) => {
  function getBufferElementType(buffer) {
    if (buffer instanceof Int8Array) {
      return "int8";
    } else if (buffer instanceof Uint8Array) {
      return "uint8";
    } else if (buffer instanceof Int16Array) {
      return "int16";
    } else if (buffer instanceof Uint16Array) {
      return "uint16";
    } else if (buffer instanceof Int32Array) {
      return "int32";
    } else if (buffer instanceof Uint32Array) {
      return "uint32";
    } else if (buffer instanceof Float32Array) {
      return "float";
    }
    throw new Error(`Unsupported buffer type ${name}`);
  }
  ThreeBufferUtils2.getBufferElementType = getBufferElementType;
  function fromThreeBufferAttribute(bufferAttribute) {
    const buffer = bufferAttribute.array;
    return {
      name: bufferAttribute.name,
      buffer: buffer.buffer,
      type: getBufferElementType(buffer),
      itemCount: bufferAttribute.itemSize,
      normalized: bufferAttribute.normalized
    };
  }
  ThreeBufferUtils2.fromThreeBufferAttribute = fromThreeBufferAttribute;
  function fromThreeInterleavedBufferAttribute(bufferAttribute) {
    throw new Error("Not implemented yet");
  }
  ThreeBufferUtils2.fromThreeInterleavedBufferAttribute = fromThreeInterleavedBufferAttribute;
  function fromThreeBufferGeometry(bufferGeometry, techniqueIndex) {
    const vertexAttributes = [];
    const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);
    for (const name2 of attributeNames) {
      const attribute = bufferGeometry.attributes[name2];
      const vertexAttribute = fromThreeBufferAttribute(attribute);
      vertexAttribute.name = name2;
      vertexAttributes.push(vertexAttribute);
    }
    const index = bufferGeometry.index !== null ? fromThreeBufferAttribute(bufferGeometry.index) : void 0;
    let count = 0;
    if (index !== void 0) {
      count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;
    } else {
      const posAttr = bufferGeometry.attributes.position;
      if (posAttr === void 0) {
        throw new Error("Missing position attibute to deduce item count");
      }
      count = posAttr.count;
    }
    return {
      type: 0 /* Unspecified */,
      vertexAttributes,
      index,
      groups: [{ start: 0, count, technique: techniqueIndex }]
    };
  }
  ThreeBufferUtils2.fromThreeBufferGeometry = fromThreeBufferGeometry;
})(ThreeBufferUtils || (ThreeBufferUtils = {}));

// src/mapview/PolarTileDataSource.ts
var PolarTileDataSource = class extends DataSource {
  m_tilingScheme = polarTilingScheme;
  m_maxLatitude = THREE87.MathUtils.radToDeg(MercatorConstants.MAXIMUM_LATITUDE);
  m_geometryLevelOffset;
  m_debugTiles;
  m_styleSetEvaluator;
  m_northPoleEntry;
  m_southPoleEntry;
  constructor({
    name: name2 = "polar",
    styleSetName = "polar",
    minDataLevel,
    maxDataLevel,
    minDisplayLevel,
    maxDisplayLevel,
    storageLevelOffset = -2,
    geometryLevelOffset = 1,
    debugTiles = false
  }) {
    super({
      name: name2,
      styleSetName,
      minDataLevel,
      maxDataLevel,
      minDisplayLevel,
      maxDisplayLevel,
      storageLevelOffset
    });
    this.m_geometryLevelOffset = geometryLevelOffset;
    this.m_debugTiles = debugTiles;
    this.cacheable = false;
    this.enablePicking = false;
  }
  dispose() {
    if (this.m_northPoleEntry) {
      this.m_northPoleEntry.material.dispose();
      delete this.m_northPoleEntry;
    }
    if (this.m_southPoleEntry) {
      this.m_southPoleEntry.material.dispose();
      delete this.m_southPoleEntry;
    }
    if (this.m_styleSetEvaluator) {
      delete this.m_styleSetEvaluator;
    }
  }
  createTechiqueEntry(kind) {
    if (!this.m_styleSetEvaluator) {
      return void 0;
    }
    const env = new MapEnv({
      $geometryType: "polygon",
      $layer: "earth",
      kind
    });
    const techniques = this.m_styleSetEvaluator.getMatchingTechniques(env);
    if (techniques.length === 0) {
      return void 0;
    }
    const technique = techniques[0];
    const material = createMaterial(this.mapView.renderer.capabilities, {
      technique,
      env: this.mapView.env
    });
    if (!material) {
      return void 0;
    }
    return { material, technique };
  }
  async setTheme(theme) {
    theme = await ThemeLoader.load(theme);
    const styleSet = getStyles(theme.styles).filter((style) => {
      return !style.styleSet || style.styleSet === this.styleSetName;
    });
    if (styleSet.length > 0) {
      this.m_styleSetEvaluator = new StyleSetEvaluator({
        styleSet,
        definitions: theme.definitions,
        priorities: theme.priorities,
        labelPriorities: theme.labelPriorities
      });
    }
    this.m_northPoleEntry = this.createTechiqueEntry("north_pole");
    this.m_southPoleEntry = this.createTechiqueEntry("south_pole");
    this.mapView.markTilesDirty(this);
  }
  canGetTile(zoomLevel, tileKey) {
    if (zoomLevel !== tileKey.level || tileKey.level < 1) {
      return false;
    }
    const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);
    return north > this.m_maxLatitude || south < -this.m_maxLatitude;
  }
  shouldSubdivide(zoomLevel, tileKey) {
    if (zoomLevel <= tileKey.level) {
      return false;
    }
    const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);
    return north > this.m_maxLatitude || south < -this.m_maxLatitude;
  }
  getTilingScheme() {
    return this.m_tilingScheme;
  }
  getTile(tileKey) {
    const tile = new Tile(this, tileKey);
    this.createTileGeometry(tile);
    return tile;
  }
  get geometryLevelOffset() {
    return this.m_geometryLevelOffset;
  }
  set geometryLevelOffset(geometryLevelOffset) {
    this.m_geometryLevelOffset = geometryLevelOffset;
  }
  intersectEdge(latitude, a, b) {
    const latA = a.latitude;
    const latB = b.latitude;
    let lonA = a.longitude;
    let lonB = b.longitude;
    if (Math.abs(latA) === 90) {
      lonA = lonB;
    }
    if (Math.abs(latB) === 90) {
      lonB = lonA;
    }
    const deltaLat = latB - latA;
    const deltaLon = lonB - lonA;
    const scale = (latitude - latA) / deltaLat;
    return new GeoCoordinates(latitude, lonA + deltaLon * scale, 0);
  }
  createTileGeometry(tile) {
    const { north, south } = tile.geoBox;
    const isNorthPole = north > 0 && south >= 0;
    const techniqueEntry = isNorthPole ? this.m_northPoleEntry : this.m_southPoleEntry;
    if (techniqueEntry === void 0) {
      tile.forceHasGeometry(true);
      return;
    }
    const srcProjection = this.m_tilingScheme.projection;
    const dstProjection = this.projection;
    const maxLat = this.m_maxLatitude;
    const poleLat = isNorthPole ? maxLat : -maxLat;
    const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);
    const pBL = srcProjection.unprojectPoint(new THREE87.Vector3(box.min.x, box.min.y, 0));
    const pBR = srcProjection.unprojectPoint(new THREE87.Vector3(box.max.x, box.min.y, 0));
    const pTR = srcProjection.unprojectPoint(new THREE87.Vector3(box.max.x, box.max.y, 0));
    const pTL = srcProjection.unprojectPoint(new THREE87.Vector3(box.min.x, box.max.y, 0));
    let points;
    let needsGeometryCut = false;
    if (tile.tileKey.level === 1) {
      const isLeftHalf = box.min.x === 0;
      const poleX = isLeftHalf ? box.max.x : box.min.x;
      const poleY = (box.max.y + box.min.y) / 2;
      const pPole = srcProjection.unprojectPoint(new THREE87.Vector3(poleX, poleY, 0));
      const pXX = isLeftHalf ? pBL : pBR;
      points = isNorthPole ? isLeftHalf ? [pPole, pTR, pXX, pBR] : [pPole, pBL, pXX, pTL] : isLeftHalf ? [pPole, pBR, pXX, pTR] : [pPole, pTL, pXX, pBL];
      needsGeometryCut = true;
    } else {
      points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];
      const lats = points.map((p) => p.latitude);
      const lmax = Math.max(...lats);
      const lmin = Math.min(...lats);
      const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;
      if (isAllPointsOut) {
        return;
      }
      const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;
      needsGeometryCut = isSomePointsOut;
      if (needsGeometryCut) {
        const nearest = lats.indexOf(isNorthPole ? lmax : lmin);
        if (nearest !== 0) {
          for (let i = 0; i < nearest; i++) {
            points.push(points.shift());
          }
        }
      }
    }
    if (needsGeometryCut) {
      const centerX = (box.min.x + box.max.x) / 2;
      const centerY = (box.min.y + box.max.y) / 2;
      const center = srcProjection.unprojectPoint(new THREE87.Vector3(centerX, centerY, 0));
      TransverseMercatorUtils.alignLongitude(points, center);
      const a = points[0];
      const b = points[1];
      const c = points[2];
      const d = points[3];
      const inPointB = Math.abs(b.latitude) >= maxLat;
      const inPointD = Math.abs(d.latitude) >= maxLat;
      const cutStart = inPointB ? this.intersectEdge(poleLat, b, c) : this.intersectEdge(poleLat, a, b);
      const cutEnd = inPointD ? this.intersectEdge(poleLat, d, c) : this.intersectEdge(poleLat, a, d);
      points.splice(inPointB ? 2 : 1, 4, cutStart);
      const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;
      const subdivisions = 1 << Math.max(0, level);
      const step = 360 / subdivisions;
      const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);
      const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);
      for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {
        points.push(new GeoCoordinates(poleLat, i * step - 180, 0));
      }
      points.push(cutEnd);
      if (inPointD) {
        points.push(d);
      }
    }
    const geometry = new THREE87.BufferGeometry();
    const vertices = points.map((point) => {
      const projected = dstProjection.projectPoint(point, new THREE87.Vector3());
      projected.sub(tile.center);
      return projected;
    });
    geometry.setFromPoints(vertices);
    const indices = [];
    for (let i = 1; i < vertices.length - 1; i++) {
      isNorthPole ? indices.push(0, i, i + 1) : indices.push(0, i + 1, i);
    }
    geometry.setIndex(indices);
    const mesh = new THREE87.Mesh(geometry, techniqueEntry.material);
    mesh.userData = {
      dataSource: this.name,
      tileKey: tile.tileKey
    };
    if (this.m_debugTiles) {
      const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 16777215);
      mesh.material = new THREE87.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0.5
      });
      tile.objects.push(new THREE87.Mesh(geometry, new THREE87.MeshBasicMaterial({ color, wireframe: true })));
    }
    MapObjectAdapter.create(mesh, {
      dataSource: this,
      technique: techniqueEntry.technique,
      kind: [isNorthPole ? "water" /* Water */ : "background" /* Background */]
    });
    tile.objects.push(mesh);
  }
};

// src/mapview/ScreenProjector.ts
var THREE88 = __toESM(require("three"));
function isOnScreen(ndc) {
  return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;
}
function isInRange(ndc) {
  return ndc.z > -1 && ndc.z < 1;
}
var _ScreenProjector = class {
  constructor(m_camera) {
    this.m_camera = m_camera;
  }
  m_width = 0;
  m_height = 0;
  get width() {
    return this.m_width;
  }
  get height() {
    return this.m_height;
  }
  project(source, target = new THREE88.Vector2()) {
    const p = this.projectVector(source, _ScreenProjector.tempV3);
    return this.ndcToScreen(p, target);
  }
  projectToScreen(source, target = new THREE88.Vector2()) {
    const p = this.projectVector(source, _ScreenProjector.tempV3);
    if (isInRange(p)) {
      return this.ndcToScreen(p, target);
    }
    return void 0;
  }
  projectAreaToScreen(source, halfWidth, halfHeight, target = new THREE88.Vector2()) {
    halfWidth *= 2;
    halfHeight *= 2;
    const p = this.projectVector(source, _ScreenProjector.tempV3);
    if (isInRange(p) && p.x + halfWidth >= -1 && p.x - halfWidth <= 1 && p.y + halfHeight >= -1 && p.y - halfHeight <= 1) {
      return this.ndcToScreen(p, target);
    }
    return void 0;
  }
  project3(source, target = new THREE88.Vector3()) {
    const p = this.projectVector(source, _ScreenProjector.tempV3);
    if (p.z > -1 && p.z < 1) {
      target.set(p.x * this.m_width / 2, p.y * this.m_height / 2, p.z);
      return target;
    }
    return void 0;
  }
  projectVector(source, target) {
    target.set(source.x, source.y, source.z).project(this.m_camera);
    return target;
  }
  onScreen(source) {
    const p = this.projectVector(source, _ScreenProjector.tempV3);
    return isOnScreen(p);
  }
  update(camera, width, height) {
    this.m_camera = camera;
    this.m_width = width;
    this.m_height = height;
  }
  ndcToScreen(ndc, screenCoords) {
    return screenCoords.set(ndc.x * this.m_width / 2, ndc.y * this.m_height / 2);
  }
};
var ScreenProjector = _ScreenProjector;
__publicField(ScreenProjector, "tempV2", new THREE88.Vector2());
__publicField(ScreenProjector, "tempV3", new THREE88.Vector3());

// src/mapview/text/MapViewState.ts
var THREE89 = __toESM(require("three"));
var MapViewState = class {
  constructor(m_mapView, m_renderedTilesChangeCheck) {
    this.m_mapView = m_mapView;
    this.m_renderedTilesChangeCheck = m_renderedTilesChangeCheck;
  }
  m_lookAtVector = new THREE89.Vector3();
  get worldCenter() {
    return this.m_mapView.worldCenter;
  }
  get cameraIsMoving() {
    return this.m_mapView.cameraIsMoving;
  }
  get maxVisibilityDist() {
    return this.m_mapView.viewRanges.maximum;
  }
  get zoomLevel() {
    return this.m_mapView.zoomLevel;
  }
  get env() {
    return this.m_mapView.env;
  }
  get frameNumber() {
    return this.m_mapView.frameNumber;
  }
  get lookAtVector() {
    return this.m_mapView.camera.getWorldDirection(this.m_lookAtVector);
  }
  get lookAtDistance() {
    return this.m_mapView.targetDistance;
  }
  get isDynamic() {
    return this.m_mapView.isDynamicFrame;
  }
  get hiddenGeometryKinds() {
    return this.m_mapView.tileGeometryManager === void 0 ? void 0 : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;
  }
  get renderedTilesChanged() {
    return this.m_renderedTilesChangeCheck();
  }
  get projection() {
    return this.m_mapView.projection;
  }
  get elevationProvider() {
    return this.m_mapView.elevationProvider;
  }
};

// src/mapview/TileObjectsRenderer.ts
var DEFAULT_STENCIL_VALUE = 1;
var TileObjectRenderer = class {
  constructor(m_env, m_renderer) {
    this.m_env = m_env;
    this.m_renderer = m_renderer;
  }
  m_renderOrderStencilValues = /* @__PURE__ */ new Map();
  m_stencilValue = DEFAULT_STENCIL_VALUE;
  render(tile, storageLevel, zoomLevel, cameraPosition, rootNode) {
    const worldOffsetX = tile.computeWorldOffsetX();
    if (tile.willRender(storageLevel)) {
      for (const object of tile.objects) {
        const mapObjectAdapter = MapObjectAdapter.get(object);
        if (!this.processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter)) {
          continue;
        }
        this.updateStencilRef(object);
        object.position.copy(tile.center);
        if (object.displacement !== void 0) {
          object.position.add(object.displacement);
        }
        object.position.x += worldOffsetX;
        object.position.sub(cameraPosition);
        if (tile.localTangentSpace) {
          object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());
        }
        object.frustumCulled = false;
        rootNode.add(object);
      }
      tile.didRender();
    }
  }
  prepareRender() {
    this.m_stencilValue = DEFAULT_STENCIL_VALUE;
    this.m_renderOrderStencilValues.clear();
  }
  setupRenderer() {
    const stableSort = (a, b) => {
      if (a.groupOrder !== b.groupOrder) {
        return a.groupOrder - b.groupOrder;
      } else if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
      } else if (a.object.userData.tileKey && b.object.userData.tileKey && a.object.userData.tileKey.mortonCode() !== b.object.userData.tileKey.mortonCode()) {
        return a.object.userData.tileKey.mortonCode() - b.object.userData.tileKey.mortonCode();
      } else if (a.program !== b.program) {
        return a.program.id - b.program.id;
      } else if (a.material.id !== b.material.id) {
        return a.material.id - b.material.id;
      } else if (a.z !== b.z) {
        return a.z - b.z;
      } else {
        return a.id - b.id;
      }
    };
    const painterSortStable = (a, b) => {
      var _a, _b, _c, _d;
      const mapObjectAdapterA = MapObjectAdapter.get(a.object);
      const mapObjectAdapterB = MapObjectAdapter.get(b.object);
      const dataSourceOrder = (_a = mapObjectAdapterA == null ? void 0 : mapObjectAdapterA.dataSource) == null ? void 0 : _a.dataSourceOrder;
      const otherDataSourceOrder = (_b = mapObjectAdapterB == null ? void 0 : mapObjectAdapterB.dataSource) == null ? void 0 : _b.dataSourceOrder;
      if (dataSourceOrder !== void 0 && otherDataSourceOrder !== void 0 && dataSourceOrder !== otherDataSourceOrder) {
        return dataSourceOrder - otherDataSourceOrder;
      }
      if (a.renderOrder === BackgroundDataSource.GROUND_RENDER_ORDER || b.renderOrder === BackgroundDataSource.GROUND_RENDER_ORDER) {
        return stableSort(a, b);
      }
      if ((mapObjectAdapterA == null ? void 0 : mapObjectAdapterA.level) !== void 0 && (mapObjectAdapterB == null ? void 0 : mapObjectAdapterB.level) !== void 0) {
        const eitherIsBuilding = ((_c = mapObjectAdapterA.kind) == null ? void 0 : _c.find((s) => s === "building")) !== void 0 || ((_d = mapObjectAdapterB.kind) == null ? void 0 : _d.find((s) => s === "building")) !== void 0;
        const sameLevel = mapObjectAdapterA.level === mapObjectAdapterB.level;
        if (sameLevel || eitherIsBuilding) {
          return stableSort(a, b);
        }
        return mapObjectAdapterA.level - mapObjectAdapterB.level;
      }
      return stableSort(a, b);
    };
    this.m_renderer.setOpaqueSort(painterSortStable);
  }
  updateStencilRef(object) {
    if (object.renderOrder !== void 0 && object instanceof SolidLineMesh) {
      const material = object.material;
      if (Array.isArray(material)) {
        material.forEach((mat) => mat.stencilRef = this.getStencilValue(object.renderOrder));
      } else {
        material.stencilRef = this.getStencilValue(object.renderOrder);
      }
    }
  }
  allocateStencilValue(renderOrder) {
    const stencilValue = this.m_stencilValue++;
    this.m_renderOrderStencilValues.set(renderOrder, stencilValue);
    return stencilValue;
  }
  getStencilValue(renderOrder) {
    return this.m_renderOrderStencilValues.get(renderOrder) ?? this.allocateStencilValue(renderOrder);
  }
  processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter) {
    if (!object.visible) {
      return false;
    }
    if (!this.processTileObjectFeatures(tile, storageLevel, zoomLevel, object)) {
      return false;
    }
    if (mapObjectAdapter) {
      mapObjectAdapter.ensureUpdated(tile.mapView);
      if (!mapObjectAdapter.isVisible() && !(mapObjectAdapter.pickability === "all" /* all */)) {
        return false;
      }
    }
    return true;
  }
  processTileObjectFeatures(tile, storageLevel, zoomLevel, object) {
    var _a;
    const technique = object.userData.technique;
    const minZoomLevel = getPropertyValue(technique == null ? void 0 : technique.minZoomLevel, this.m_env);
    const maxZoomLevel = getPropertyValue(technique == null ? void 0 : technique.maxZoomLevel, this.m_env);
    if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
      return false;
    }
    if (typeof maxZoomLevel === "number" && zoomLevel >= maxZoomLevel) {
      return false;
    }
    if ((technique == null ? void 0 : technique.enabled) === void 0) {
      return true;
    }
    const feature = object.userData.feature;
    if (!feature || !Expr3.isExpr(technique.enabled)) {
      return Boolean(getPropertyValue(technique.enabled, this.m_env));
    }
    const { starts, objInfos } = feature;
    if (!Array.isArray(objInfos) || !Array.isArray(starts)) {
      return true;
    }
    const geometry = object.geometry;
    if (!geometry || !geometry.isBufferGeometry) {
      return true;
    }
    const finalIndex = ((_a = geometry.getIndex()) == null ? void 0 : _a.count) ?? geometry.attributes.position.count;
    geometry.clearGroups();
    let endOfLastGroup;
    objInfos.forEach((properties, featureIndex) => {
      const featureId = getFeatureId(properties);
      let enabled = true;
      if (Expr3.isExpr(technique.enabled)) {
        const featureState = tile.dataSource.getFeatureState(featureId);
        const $state = featureState ? new MapEnv(featureState) : null;
        const parentEnv = typeof properties === "object" ? new MapEnv(properties, this.m_env) : this.m_env;
        const env = new MapEnv({ $state }, parentEnv);
        enabled = Boolean(getPropertyValue(technique.enabled, env));
      }
      if (!enabled) {
        return;
      }
      const start = starts[featureIndex] ?? 0;
      const end = starts[featureIndex + 1] ?? finalIndex;
      const count = end - start;
      if (start === endOfLastGroup) {
        geometry.groups[geometry.groups.length - 1].count += count;
      } else {
        geometry.addGroup(start, count);
      }
      endOfLastGroup = start + count;
    });
    return geometry.groups.length > 0;
  }
};

// src/mapview/VisibleTileSet.ts
var THREE90 = __toESM(require("three"));
var ResourceComputationType = /* @__PURE__ */ ((ResourceComputationType2) => {
  ResourceComputationType2[ResourceComputationType2["EstimationInMb"] = 0] = "EstimationInMb";
  ResourceComputationType2[ResourceComputationType2["NumberOfTiles"] = 1] = "NumberOfTiles";
  return ResourceComputationType2;
})(ResourceComputationType || {});
var MB_FACTOR = 1 / (1024 * 1024);
var DataSourceCache = class {
  static getKey(mortonCode, offset, dataSource) {
    return `${dataSource.name}_${mortonCode}_${offset}`;
  }
  static getKeyForTile(tile) {
    return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);
  }
  m_tileCache;
  m_disposedTiles = [];
  m_resourceComputationType;
  constructor(cacheSize, rct = 0 /* EstimationInMb */) {
    this.m_resourceComputationType = rct;
    this.m_tileCache = new LRUCache(cacheSize, (tile) => {
      if (this.m_resourceComputationType === 0 /* EstimationInMb */) {
        return tile.memoryUsage * MB_FACTOR;
      } else {
        return 1;
      }
    });
    this.m_tileCache.evictionCallback = (_, tile) => {
      if (tile.tileLoader !== void 0) {
        tile.tileLoader.cancel();
      }
      this.m_disposedTiles.push(tile);
    };
    this.m_tileCache.canEvict = (_, tile) => {
      return !tile.isVisible;
    };
  }
  get resourceComputationType() {
    return this.m_resourceComputationType;
  }
  get capacity() {
    return this.m_tileCache.capacity;
  }
  get size() {
    return this.m_tileCache.size;
  }
  setCapacity(size, rct) {
    this.m_resourceComputationType = rct;
    this.m_tileCache.setCapacityAndMeasure(size, (tile) => {
      if (this.m_resourceComputationType === 0 /* EstimationInMb */) {
        return tile.memoryUsage * MB_FACTOR;
      } else {
        return 1;
      }
    });
  }
  get(mortonCode, offset, dataSource) {
    return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));
  }
  set(mortonCode, offset, dataSource, tile) {
    this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);
  }
  delete(tile) {
    const tileKey = DataSourceCache.getKeyForTile(tile);
    this.deleteByKey(tileKey);
  }
  deleteByKey(tileKey) {
    this.m_tileCache.delete(tileKey);
  }
  disposeTiles() {
    this.m_disposedTiles.forEach((tile) => {
      tile.dispose();
    });
    this.m_disposedTiles.length = 0;
  }
  shrinkToCapacity() {
    this.m_tileCache.shrinkToCapacity();
  }
  evictAll() {
    this.m_tileCache.evictAll();
  }
  evictSelected(selector) {
    this.m_tileCache.evictSelected(selector);
  }
  forEach(callback, inDataSource) {
    this.m_tileCache.forEach((entry, key) => {
      if (inDataSource === void 0 || entry.dataSource === inDataSource) {
        callback(entry, key);
      }
    });
  }
};
var compareDistances = (a, b) => {
  const distanceDiff = a.distance - b.distance;
  const minDiff = (a.distance + b.distance) * 1e-6;
  return Math.abs(distanceDiff) < minDiff ? a.tileKey.mortonCode() - b.tileKey.mortonCode() : distanceDiff;
};
var VisibleTileSet = class {
  constructor(m_frustumIntersection, m_tileGeometryManager, options, m_taskQueue) {
    this.m_frustumIntersection = m_frustumIntersection;
    this.m_tileGeometryManager = m_tileGeometryManager;
    this.options = options;
    this.m_taskQueue = m_taskQueue;
    this.options = options;
    this.options.maxTilesPerFrame = Math.floor(this.options.maxTilesPerFrame ?? 0);
    this.m_resourceComputationType = options.resourceComputationType === void 0 ? 0 /* EstimationInMb */ : options.resourceComputationType;
    this.m_dataSourceCache = new DataSourceCache(this.options.tileCacheSize, this.m_resourceComputationType);
  }
  dataSourceTileList = [];
  allVisibleTilesLoaded = false;
  m_cameraOverride = new THREE90.PerspectiveCamera();
  m_dataSourceCache;
  m_viewRange = {
    near: 0.1,
    far: Infinity,
    minimum: 0.1,
    maximum: Infinity
  };
  m_coveringMap = /* @__PURE__ */ new Map();
  m_resourceComputationType = 0 /* EstimationInMb */;
  getDataSourceCacheSize() {
    return this.options.tileCacheSize;
  }
  setDataSourceCacheSize(size, computationType = 0 /* EstimationInMb */) {
    this.options.tileCacheSize = size;
    this.resourceComputationType = computationType;
  }
  getNumberOfVisibleTiles() {
    return this.options.maxVisibleDataSourceTiles;
  }
  setNumberOfVisibleTiles(size) {
    this.options.maxVisibleDataSourceTiles = size;
  }
  get maxTilesPerFrame() {
    return this.options.maxTilesPerFrame;
  }
  set maxTilesPerFrame(value2) {
    if (value2 < 0) {
      throw new Error("Invalid value, this will result in no tiles ever showing");
    }
    this.options.maxTilesPerFrame = Math.floor(value2);
  }
  get resourceComputationType() {
    return this.m_resourceComputationType;
  }
  set resourceComputationType(computationType) {
    this.m_resourceComputationType = computationType;
    this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);
  }
  updateClipPlanes(maxElevation, minElevation) {
    if (maxElevation !== void 0) {
      this.options.clipPlanesEvaluator.maxElevation = maxElevation;
    }
    if (minElevation !== void 0) {
      this.options.clipPlanesEvaluator.minElevation = minElevation;
    }
    const { camera, projection, elevationProvider } = this.m_frustumIntersection.mapView;
    this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(camera, projection, elevationProvider);
    return this.m_viewRange;
  }
  updateRenderList(storageLevel, zoomLevel, dataSources, frameNumber, elevationRangeSource) {
    let allVisibleTilesLoaded = true;
    const newTilesPerFrame = 0;
    const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource);
    this.dataSourceTileList = [];
    this.m_coveringMap.clear();
    for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {
      visibleTileKeys.sort(compareDistances);
      const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);
      const visibleResult = this.processVisibleTiles(visibleTileKeys, dataSource, frameNumber, {
        newTilesPerFrame
      }, true);
      const dependentResult = this.processVisibleTiles(visibleResult.dependentTiles, dataSource, frameNumber, {
        newTilesPerFrame
      }, false);
      this.m_tileGeometryManager.updateTiles(visibleResult.visibleTiles);
      this.m_tileGeometryManager.updateTiles(dependentResult.visibleTiles);
      this.dataSourceTileList.push({
        dataSource,
        storageLevel,
        zoomLevel: dataZoomLevel,
        allVisibleTileLoaded: visibleResult.allDataSourceTilesLoaded && dependentResult.allDataSourceTilesLoaded,
        numTilesLoading: visibleResult.numTilesLoading + dependentResult.numTilesLoading,
        visibleTiles: [...visibleResult.visibleTiles, ...dependentResult.visibleTiles],
        renderedTiles: /* @__PURE__ */ new Map()
      });
      allVisibleTilesLoaded = allVisibleTilesLoaded && visibleResult.allDataSourceTilesLoaded;
    }
    this.allVisibleTilesLoaded = allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;
    this.populateRenderedTiles();
    this.forEachCachedTile((tile) => {
      if (!tile.isVisible && !tile.allGeometryLoaded) {
        this.disposeTile(tile);
      }
    });
    this.m_dataSourceCache.shrinkToCapacity();
    let minElevation;
    let maxElevation;
    this.dataSourceTileList.forEach((renderListEntry) => {
      const tiles = renderListEntry.renderedTiles;
      tiles.forEach((tile) => {
        tile.update(renderListEntry.zoomLevel);
        minElevation = MathUtils6.min2(minElevation, tile.geoBox.minAltitude);
        maxElevation = MathUtils6.max2(maxElevation, tile.geoBox.maxAltitude);
      });
    });
    if (minElevation === void 0) {
      minElevation = 0;
    }
    if (maxElevation === void 0) {
      maxElevation = 0;
    }
    let viewRangesChanged = false;
    const oldViewRanges = this.m_viewRange;
    const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);
    viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;
    return {
      viewRanges: newViewRanges,
      viewRangesChanged
    };
  }
  getTile(dataSource, tileKey, offset, frameNumber) {
    const cacheOnly = false;
    return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);
  }
  getCachedTile(dataSource, tileKey, offset, frameNumber) {
    assert(dataSource.cacheable);
    const cacheOnly = true;
    return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);
  }
  getRenderedTile(dataSource, tileKey, offset = 0) {
    const dataSourceVisibleTileList = this.dataSourceTileList.find((list) => {
      return list.dataSource === dataSource;
    });
    if (dataSourceVisibleTileList === void 0) {
      return void 0;
    }
    return dataSourceVisibleTileList.renderedTiles.get(TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset));
  }
  getRenderedTileAtLocation(dataSource, geoPoint, offset = 0) {
    const dataSourceVisibleTileList = this.dataSourceTileList.find((list) => {
      return list.dataSource === dataSource;
    });
    if (dataSourceVisibleTileList === void 0) {
      return void 0;
    }
    const tilingScheme = dataSource.getTilingScheme();
    const visibleLevel = dataSourceVisibleTileList.zoomLevel;
    const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);
    if (!visibleTileKey) {
      return void 0;
    }
    let tile = dataSourceVisibleTileList.renderedTiles.get(TileKeyUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset));
    if (tile !== void 0) {
      return tile;
    }
    const { searchLevelsUp, searchLevelsDown } = this.getSearchDirection(dataSource, visibleLevel);
    let parentTileKey = visibleTileKey;
    for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {
      parentTileKey = parentTileKey.parent();
      tile = dataSourceVisibleTileList.renderedTiles.get(TileKeyUtils.getKeyForTileKeyAndOffset(parentTileKey, offset));
      if (tile !== void 0) {
        return tile;
      }
    }
    const worldPoint = tilingScheme.projection.projectPoint(geoPoint);
    for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {
      const childLevel = visibleLevel + levelOffset;
      const childTileKey = TileKeyUtils.worldCoordinatesToTileKey(tilingScheme, worldPoint, childLevel);
      if (childTileKey) {
        tile = dataSourceVisibleTileList.renderedTiles.get(TileKeyUtils.getKeyForTileKeyAndOffset(childTileKey, offset));
        if (tile !== void 0) {
          return tile;
        }
      }
    }
    return void 0;
  }
  removeDataSource(dataSource) {
    this.clearTileCache(dataSource);
    this.dataSourceTileList = this.dataSourceTileList.filter((tileList) => tileList.dataSource !== dataSource);
  }
  clearTileCache(dataSource, filter) {
    if (dataSource !== void 0) {
      this.m_dataSourceCache.evictSelected((tile, _) => {
        return tile.dataSource === dataSource && (filter !== void 0 ? filter(tile) : true);
      });
    } else if (filter !== void 0) {
      this.m_dataSourceCache.evictSelected(filter);
    } else {
      this.m_dataSourceCache.evictAll();
    }
  }
  markTilesDirty(dataSource, filter) {
    if (dataSource === void 0) {
      this.dataSourceTileList.forEach((renderListEntry) => {
        this.markDataSourceTilesDirty(renderListEntry, filter);
      });
    } else {
      const renderListEntry = this.dataSourceTileList.find((e) => e.dataSource === dataSource);
      if (renderListEntry === void 0) {
        return;
      }
      this.markDataSourceTilesDirty(renderListEntry, filter);
    }
  }
  disposePendingTiles() {
    this.m_dataSourceCache.disposeTiles();
  }
  forEachVisibleTile(fun) {
    for (const listEntry of this.dataSourceTileList) {
      listEntry.renderedTiles.forEach(fun);
    }
  }
  forEachCachedTile(fun, dataSource) {
    this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);
  }
  disposeTile(tile) {
    this.m_dataSourceCache.delete(tile);
    tile.dispose();
  }
  processVisibleTiles(visibleTileKeys, dataSource, frameNumber, refs, processDependentTiles) {
    let allDataSourceTilesLoaded = true;
    let numTilesLoading = 0;
    const visibleTiles = [];
    const dependentTiles = [];
    for (let i = 0; i < visibleTileKeys.length && visibleTiles.length < this.options.maxVisibleDataSourceTiles; i++) {
      const tileEntry = visibleTileKeys[i];
      const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset, frameNumber);
      if (tile === void 0) {
        continue;
      }
      visibleTiles.push(tile);
      allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;
      if (!tile.allGeometryLoaded) {
        numTilesLoading++;
      } else {
        this.skipOverlappedTiles(dataSource, tile);
        if (this.processDelayTileRendering(tile, refs.newTilesPerFrame, frameNumber)) {
          refs.newTilesPerFrame++;
        }
      }
      tile.visibleArea = tileEntry.area;
      tile.elevationRange = tileEntry.elevationRange ?? {
        minElevation: 0,
        maxElevation: 0
      };
      if (processDependentTiles) {
        for (const tileKey of tile.dependencies) {
          if (visibleTileKeys.find((tileKeyEntry) => tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode()) === void 0 && dependentTiles.find((tileKeyEntry) => tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode()) === void 0) {
            dependentTiles.push(new TileKeyEntry(tileKey, 0));
          }
        }
      }
    }
    return {
      allDataSourceTilesLoaded,
      numTilesLoading,
      visibleTiles,
      dependentTiles
    };
  }
  processDelayTileRendering(tile, newTilesPerFrame, frameNumber) {
    let isNewTile = false;
    if (this.options.maxTilesPerFrame !== 0 && newTilesPerFrame > this.options.maxTilesPerFrame && !(tile.frameNumLastVisible === frameNumber - 1)) {
      tile.delayRendering = true;
      tile.mapView.update();
    } else {
      if (tile.frameNumVisible < 0) {
        tile.frameNumVisible = frameNumber;
        isNewTile = true;
      }
      tile.numFramesVisible++;
      tile.delayRendering = false;
    }
    return isNewTile;
  }
  skipOverlappedTiles(dataSource, tile) {
    if (this.options.projection.type === 1 /* Spherical */) {
      return;
    }
    if (dataSource.isFullyCovering()) {
      const key = tile.uniqueKey;
      const entry = this.m_coveringMap.get(key);
      if (entry === void 0) {
        tile.skipRendering = false;
        this.m_coveringMap.set(key, tile);
      } else {
        if (entry.dataSource instanceof BackgroundDataSource) {
          entry.skipRendering = true;
        } else if (dataSource instanceof BackgroundDataSource) {
          tile.skipRendering = true;
        }
      }
    }
  }
  getSearchDirection(dataSource, visibleLevel) {
    const searchLevelsUp = Math.min(this.options.quadTreeSearchDistanceUp, Math.max(0, visibleLevel - dataSource.minDataLevel));
    const searchLevelsDown = Math.min(this.options.quadTreeSearchDistanceDown, Math.max(0, dataSource.maxDataLevel - visibleLevel));
    const searchDirection = searchLevelsDown > 0 && searchLevelsUp > 0 ? 3 /* BOTH */ : searchLevelsDown > 0 ? 2 /* DOWN */ : searchLevelsUp > 0 ? 1 /* UP */ : 0 /* NONE */;
    return { searchDirection, searchLevelsUp, searchLevelsDown };
  }
  populateRenderedTiles() {
    this.dataSourceTileList.forEach((renderListEntry) => {
      const renderedTiles = renderListEntry.renderedTiles;
      const incompleteTiles = [];
      renderListEntry.visibleTiles.forEach((tile) => {
        tile.levelOffset = 0;
        if (tile.hasGeometry && !tile.delayRendering) {
          renderedTiles.set(tile.uniqueKey, tile);
        } else {
          incompleteTiles.push(tile.uniqueKey);
        }
      });
      const dataSource = renderListEntry.dataSource;
      if (incompleteTiles.length === 0 || dataSource.allowOverlappingTiles === false) {
        return;
      }
      const dataZoomLevel = renderListEntry.zoomLevel;
      const { searchDirection } = this.getSearchDirection(dataSource, dataZoomLevel);
      const checkedTiles = /* @__PURE__ */ new Map();
      for (const tileKeyCode of incompleteTiles) {
        if (searchDirection === 3 /* BOTH */ || searchDirection === 1 /* UP */) {
          if (this.findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource)) {
            continue;
          }
        }
        if (searchDirection === 3 /* BOTH */ || searchDirection === 2 /* DOWN */) {
          this.findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource);
        }
      }
    });
  }
  findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource) {
    const { offset, mortonCode } = TileKeyUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);
    const tileKey = TileKey.fromMortonCode(mortonCode);
    const tilingScheme = dataSource.getTilingScheme();
    for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
      const childTileCode = TileKeyUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
      const childTile = this.m_dataSourceCache.get(childTileKey.mortonCode(), offset, dataSource);
      const nextLevelDiff = Math.abs(childTileKey.level - dataZoomLevel);
      if (childTile !== void 0 && childTile.hasGeometry && !childTile.delayRendering) {
        renderedTiles.set(childTileCode, childTile);
        childTile.levelOffset = nextLevelDiff;
        continue;
      }
      if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {
        this.findDown(childTileCode, dataZoomLevel, renderedTiles, dataSource);
      }
    }
  }
  findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource) {
    const parentCode = TileKeyUtils.getParentKeyFromKey(tileKeyCode);
    if (renderedTiles.get(parentCode) !== void 0) {
      return true;
    }
    const exists = checkedTiles.get(parentCode);
    if (exists !== void 0) {
      return exists;
    }
    const { offset, mortonCode } = TileKeyUtils.extractOffsetAndMortonKeyFromKey(parentCode);
    const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);
    const parentTileKey = parentTile ? parentTile.tileKey : TileKey.fromMortonCode(mortonCode);
    const nextLevelDiff = Math.abs(dataZoomLevel - parentTileKey.level);
    if (parentTile !== void 0 && parentTile.hasGeometry && !parentTile.delayRendering) {
      checkedTiles.set(parentCode, true);
      renderedTiles.set(parentCode, parentTile);
      parentTile.levelOffset = -nextLevelDiff;
      return true;
    } else {
      checkedTiles.set(parentCode, false);
    }
    if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {
      const foundUp = this.findUp(parentCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource);
      checkedTiles.set(parentCode, foundUp);
      if (foundUp) {
        return true;
      }
    }
    return false;
  }
  getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber) {
    function touchTile(tileToUpdate) {
      tileToUpdate.frameNumLastRequested = frameNumber;
    }
    if (!dataSource.cacheable && !cacheOnly) {
      const resultTile = dataSource.getTile(tileKey, true);
      if (resultTile !== void 0) {
        this.addToTaskQueue(resultTile);
        touchTile(resultTile);
      }
      return resultTile;
    }
    const tileCache = this.m_dataSourceCache;
    let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);
    if (tile !== void 0 && tile.offset === offset) {
      touchTile(tile);
      return tile;
    }
    if (cacheOnly) {
      return void 0;
    }
    tile = dataSource.getTile(tileKey, true);
    if (tile !== void 0) {
      this.addToTaskQueue(tile);
      tile.offset = offset;
      touchTile(tile);
      tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);
    }
    return tile;
  }
  addToTaskQueue(tile) {
    this.m_taskQueue.add({
      execute: tile.load.bind(tile),
      group: "fetch" /* FETCH_AND_DECODE */,
      getPriority: () => {
        var _a;
        return ((_a = tile == null ? void 0 : tile.tileLoader) == null ? void 0 : _a.priority) ?? 0;
      },
      isExpired: () => {
        return !(tile == null ? void 0 : tile.isVisible);
      },
      estimatedProcessTime: () => {
        return 1;
      }
    });
  }
  markDataSourceTilesDirty(renderListEntry, filter) {
    const dataSourceCache = this.m_dataSourceCache;
    const retainedTiles = /* @__PURE__ */ new Set();
    const markTileDirty = (tile) => {
      var _a;
      const tileKey = DataSourceCache.getKeyForTile(tile);
      if (!retainedTiles.has(tileKey)) {
        retainedTiles.add(tileKey);
        (_a = tile.tileLoader) == null ? void 0 : _a.cancel();
        this.addToTaskQueue(tile);
      }
    };
    renderListEntry.visibleTiles.forEach((tile) => {
      if (filter === void 0 || filter(tile)) {
        markTileDirty(tile);
      }
    });
    renderListEntry.renderedTiles.forEach((tile) => {
      if (filter === void 0 || filter(tile)) {
        markTileDirty(tile);
      }
    });
    dataSourceCache.forEach((tile, key) => {
      if ((filter === void 0 || filter(tile)) && !retainedTiles.has(key)) {
        dataSourceCache.deleteByKey(key);
        tile.dispose();
      }
    }, renderListEntry.dataSource);
  }
  getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource) {
    const tileKeys = Array();
    let allBoundingBoxesFinal = true;
    if (dataSources.length === 0) {
      return { tileKeys, allBoundingBoxesFinal };
    }
    const dataSourceBuckets = /* @__PURE__ */ new Map();
    dataSources.forEach((dataSource) => {
      const tilingScheme = dataSource.getTilingScheme();
      const bucket = dataSourceBuckets.get(tilingScheme);
      if (bucket === void 0) {
        dataSourceBuckets.set(tilingScheme, [dataSource]);
      } else {
        bucket.push(dataSource);
      }
    });
    if (elevationRangeSource !== void 0) {
      this.m_cameraOverride.copy(this.m_frustumIntersection.camera);
      this.m_cameraOverride.near = Math.min(this.m_cameraOverride.near, this.m_viewRange.minimum);
      this.m_cameraOverride.far = Math.max(this.m_cameraOverride.far, this.m_viewRange.maximum);
      this.m_cameraOverride.updateProjectionMatrix();
      this.m_frustumIntersection.updateFrustum(this.m_cameraOverride.projectionMatrix);
    } else {
      this.m_frustumIntersection.updateFrustum();
    }
    for (const [tilingScheme, bucket] of dataSourceBuckets) {
      const zoomLevels = bucket.map((dataSource) => dataSource.getDataZoomLevel(zoomLevel));
      const result = this.m_frustumIntersection.compute(tilingScheme, elevationRangeSource, zoomLevels, bucket);
      allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;
      for (const dataSource of bucket) {
        const visibleTileKeys = [];
        const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);
        for (const tileKeyEntry of result.tileKeyEntries.get(dataZoomLevel).values()) {
          if (dataSource.canGetTile(dataZoomLevel, tileKeyEntry.tileKey)) {
            visibleTileKeys.push(tileKeyEntry);
          }
        }
        tileKeys.push({ dataSource, visibleTileKeys });
      }
    }
    return { tileKeys, allBoundingBoxesFinal };
  }
};
function viewRangesEqual(a, b) {
  return a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near;
}

// src/mapview/MapView.ts
var isProduction2 = process.env.NODE_ENV === "production";
var TileTaskGroups = /* @__PURE__ */ ((TileTaskGroups2) => {
  TileTaskGroups2["FETCH_AND_DECODE"] = "fetch";
  TileTaskGroups2["CREATE"] = "create";
  return TileTaskGroups2;
})(TileTaskGroups || {});
var logger24 = LoggerManager.instance.create("MapView");
var DEFAULT_CAM_NEAR_PLANE = 0.1;
var DEFAULT_CAM_FAR_PLANE = 4e6;
var DEFAULT_MIN_ZOOM_LEVEL2 = 1;
var DEFAULT_MAX_ZOOM_LEVEL = 20;
var DEFAULT_MIN_CAMERA_HEIGHT = 20;
var DEFAULT_POLAR_STYLE_SET_NAME = "polar";
var MapViewDefaults = {
  projection: mercatorProjection,
  addBackgroundDatasource: true,
  maxVisibleDataSourceTiles: 100,
  extendedFrustumCulling: true,
  tileCacheSize: 200,
  resourceComputationType: 0 /* EstimationInMb */,
  quadTreeSearchDistanceUp: 3,
  quadTreeSearchDistanceDown: 2,
  pixelRatio: typeof window !== "undefined" && window.devicePixelRatio !== void 0 ? window.devicePixelRatio : 1,
  target: new GeoCoordinates(25, 0),
  zoomLevel: 5,
  tilt: 0,
  heading: 0,
  theme: {},
  maxTilesPerFrame: 0
};
var MapView = class extends EventDispatcher {
  handleRequestAnimationFrame;
  m_animatedExtrusionHandler;
  m_animationCount = 0;
  m_animationFrameHandle;
  m_camera;
  m_canvas;
  m_collisionDebugCanvas;
  m_connectedDataSources = /* @__PURE__ */ new Set();
  m_context;
  m_copyrightInfo = [];
  m_disposed = false;
  m_drawing = false;
  m_elevationProvider;
  m_elevationRangeSource;
  m_elevationSource;
  m_enableMixedLod;
  m_enablePolarDataSource = true;
  m_env = new MapEnv({});
  m_failedDataSources = /* @__PURE__ */ new Set();
  m_firstFrameComplete = false;
  m_firstFrameRendered = false;
  m_forceCameraAspect = void 0;
  m_frameNumber = 0;
  m_geoMaxBounds;
  m_languages;
  m_lastTileIds = "";
  m_lodMinTilePixelSize;
  m_mapAnchors = new MapAnchors();
  mapRenderingManager;
  m_maxZoomLevel = DEFAULT_MAX_ZOOM_LEVEL;
  m_minCameraHeight = DEFAULT_MIN_CAMERA_HEIGHT;
  m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL2;
  m_movementDetector;
  m_movementFinishedUpdateTimerId;
  m_options;
  m_overlayScene = new THREE91.Scene();
  m_overlaySceneRoot = new THREE91.Object3D();
  m_pickHandler;
  m_pitch = 0;
  m_pixelRatio;
  m_pixelToWorld;
  m_plane = new THREE91.Plane(new THREE91.Vector3(0, 0, 1));
  m_poiManager = new PoiManager(this);
  m_pointOfView;
  m_poiTableManager = new PoiTableManager(this);
  m_polarDataSource;
  m_politicalView;
  m_postEffects;
  m_previousFrameTimeStamp;
  m_raycaster = new THREE91.Raycaster();
  m_renderer;
  m_renderLabels = true;
  m_roll = 0;
  m_rteCamera = new THREE91.PerspectiveCamera();
  m_scene = new THREE91.Scene();
  m_sceneEntity;
  m_sceneEnvironment;
  m_sceneRoot = new THREE91.Object3D();
  m_screenProjector;
  m_sphere = new THREE91.Sphere(void 0, EarthConstants.EQUATORIAL_RADIUS);
  m_targetGeoPos = GeoCoordinates.fromObject(MapViewDefaults.target);
  m_targetDistance = 0;
  m_targetWorldPos = new THREE91.Vector3();
  m_taskScheduler;
  m_taskSchedulerTimeout = void 0;
  m_textElementsRenderer;
  m_themeManager;
  m_thisFrameTilesChanged;
  m_tileDataSources = [];
  m_tileGeometryManager;
  m_tileObjectRenderer;
  m_tileWrappingEnabled = true;
  m_updatePending = false;
  m_uriResolver;
  m_userImageCache = new MapViewImageCache();
  m_viewRanges = {
    near: DEFAULT_CAM_NEAR_PLANE,
    far: DEFAULT_CAM_FAR_PLANE,
    minimum: DEFAULT_CAM_NEAR_PLANE,
    maximum: DEFAULT_CAM_FAR_PLANE
  };
  m_visibleTiles;
  m_visibleTileSetLock = false;
  m_visibleTileSetOptions;
  m_world;
  m_worldMaxBounds;
  m_yaw = 0;
  m_zoomLevel = DEFAULT_MIN_ZOOM_LEVEL2;
  UPDATE_EVENT = {
    type: MapViewEventNames.Update
  };
  RENDER_EVENT = {
    type: MapViewEventNames.Render
  };
  DID_RENDER_EVENT = {
    type: MapViewEventNames.AfterRender
  };
  FIRST_FRAME_EVENT = {
    type: MapViewEventNames.FirstFrame
  };
  FRAME_COMPLETE_EVENT = {
    type: MapViewEventNames.FrameComplete
  };
  THEME_LOADED_EVENT = {
    type: MapViewEventNames.ThemeLoaded
  };
  ANIMATION_STARTED_EVENT = {
    type: MapViewEventNames.AnimationStarted
  };
  ANIMATION_FINISHED_EVENT = {
    type: MapViewEventNames.AnimationFinished
  };
  MOVEMENT_STARTED_EVENT = {
    type: MapViewEventNames.MovementStarted
  };
  MOVEMENT_FINISHED_EVENT = {
    type: MapViewEventNames.MovementFinished
  };
  CONTEXT_LOST_EVENT = {
    type: MapViewEventNames.ContextLost
  };
  CONTEXT_RESTORED_EVENT = {
    type: MapViewEventNames.ContextRestored
  };
  COPYRIGHT_CHANGED_EVENT = {
    type: MapViewEventNames.CopyrightChanged
  };
  DISPOSE_EVENT = {
    type: MapViewEventNames.Dispose
  };
  constructor(options) {
    super();
    this.m_options = { ...options };
    this.m_uriResolver = this.m_options.uriResolver;
    if (this.m_options.minZoomLevel !== void 0) {
      this.m_minZoomLevel = this.m_options.minZoomLevel;
    }
    if (this.m_options.maxZoomLevel !== void 0) {
      this.m_maxZoomLevel = this.m_options.maxZoomLevel;
    }
    if (this.m_options.minCameraHeight !== void 0) {
      this.m_minCameraHeight = this.m_options.minCameraHeight;
    }
    if (this.m_options.maxBounds !== void 0) {
      this.m_geoMaxBounds = this.m_options.maxBounds;
    }
    if (this.m_options.decoderUrl !== void 0) {
      ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl) : this.m_options.decoderUrl;
    }
    if (this.m_options.decoderCount !== void 0) {
      ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;
    }
    this.m_visibleTileSetOptions = {
      ...MapViewDefaults,
      clipPlanesEvaluator: options.clipPlanesEvaluator !== void 0 ? options.clipPlanesEvaluator : createDefaultClipPlanesEvaluator()
    };
    if (options.projection !== void 0) {
      this.m_visibleTileSetOptions.projection = options.projection;
    }
    if (options.extendedFrustumCulling !== void 0) {
      this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;
    }
    if (options.maxVisibleDataSourceTiles !== void 0) {
      this.m_visibleTileSetOptions.maxVisibleDataSourceTiles = options.maxVisibleDataSourceTiles;
    }
    if (options.tileCacheSize !== void 0) {
      this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;
    }
    if (options.resourceComputationType !== void 0) {
      this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;
    }
    if (options.quadTreeSearchDistanceUp !== void 0) {
      this.m_visibleTileSetOptions.quadTreeSearchDistanceUp = options.quadTreeSearchDistanceUp;
    }
    if (options.quadTreeSearchDistanceDown !== void 0) {
      this.m_visibleTileSetOptions.quadTreeSearchDistanceDown = options.quadTreeSearchDistanceDown;
    }
    if (options.enablePolarDataSource !== void 0) {
      this.m_enablePolarDataSource = options.enablePolarDataSource;
    }
    this.m_pixelRatio = options.pixelRatio;
    this.m_options.maxFps = this.m_options.maxFps ?? 0;
    this.m_options.enableStatistics = this.m_options.enableStatistics === true;
    this.m_languages = this.m_options.languages;
    this.m_politicalView = this.m_options.politicalView;
    this.handleRequestAnimationFrame = this.renderLoop.bind(this);
    if (this.m_options.tileWrappingEnabled !== void 0) {
      this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;
    }
    this.setupStats(this.m_options.enableStatistics);
    if (this.m_options.renderer !== void 0) {
      this.m_renderer = this.m_options.renderer;
      this.m_canvas = this.m_options.renderer.domElement;
      console.log("Renderer set to passed-in renderer:", this.m_renderer);
    } else {
      this.m_canvas = this.m_options.canvas;
      this.m_renderer = new (THREE91.WebGL1Renderer ?? THREE91.WebGLRenderer)({
        canvas: this.m_canvas
      });
    }
    this.m_renderer.autoClear = false;
    this.m_renderer.debug.checkShaderErrors = !isProduction2;
    this.m_context = this.m_renderer.getContext();
    this.m_canvas.addEventListener("webglcontextlost", this.onWebGLContextLost);
    this.m_canvas.addEventListener("webglcontextrestored", this.onWebGLContextRestored);
    this.m_renderer.info.autoReset = false;
    this.m_tileObjectRenderer = new TileObjectRenderer(this.m_env, this.m_renderer);
    this.setupRenderer(this.m_tileObjectRenderer);
    this.m_options.fovCalculation = this.m_options.fovCalculation === void 0 ? DEFAULT_FOV_CALCULATION : this.m_options.fovCalculation;
    this.m_options.fovCalculation.fov = THREE91.MathUtils.clamp(this.m_options.fovCalculation.fov, MIN_FOV_DEG, MAX_FOV_DEG);
    const { width, height } = this.getCanvasClientSize();
    const aspect = width / height;
    if (this.m_options.camera !== void 0) {
      this.m_camera = this.m_options.camera;
      console.log("Camera set to passed-in camera:", this.m_camera);
    } else {
      this.m_camera = new THREE91.PerspectiveCamera(this.m_options.fovCalculation.fov, aspect, DEFAULT_CAM_NEAR_PLANE, DEFAULT_CAM_FAR_PLANE);
    }
    this.m_camera.up.set(0, 0, 1);
    this.setFovOnCamera(this.m_options.fovCalculation, height);
    this.projection.projectPoint(this.m_targetGeoPos, this.m_targetWorldPos);
    this.m_scene.add(this.m_camera);
    this.m_screenProjector = new ScreenProjector(this.m_camera);
    this.m_taskScheduler = new MapViewTaskScheduler(this.maxFps);
    this.m_tileGeometryManager = new TileGeometryManager(this);
    if (options.enableMixedLod !== void 0) {
      this.m_enableMixedLod = options.enableMixedLod;
    }
    if (options.lodMinTilePixelSize !== void 0) {
      this.m_lodMinTilePixelSize = options.lodMinTilePixelSize;
    }
    this.m_visibleTiles = this.createVisibleTileSet();
    this.m_sceneEnvironment = new MapViewEnvironment(this, options);
    this.setupCamera();
    this.m_pickHandler = new PickHandler(this, this.m_rteCamera, this.m_options.enablePickTechnique === true);
    this.m_movementDetector = new CameraMovementDetector(this.m_options.movementThrottleTimeout, () => this.movementStarted(), () => this.movementFinished());
    const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;
    this.mapRenderingManager = new MapRenderingManager(width, height, this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);
    this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler(this);
    if (this.m_enablePolarDataSource) {
      const styleSetName = options.polarStyleSetName !== void 0 ? options.polarStyleSetName : DEFAULT_POLAR_STYLE_SET_NAME;
      this.m_polarDataSource = new PolarTileDataSource({
        styleSetName,
        geometryLevelOffset: options.polarGeometryLevelOffset
      });
      this.updatePolarDataSource();
    }
    this.m_taskScheduler.addEventListener(MapViewEventNames.Update, () => {
      this.update();
    });
    if (options.throttlingEnabled !== void 0) {
      this.m_taskScheduler.throttlingEnabled = options.throttlingEnabled;
    }
    this.m_themeManager = new MapViewThemeManager(this, this.m_uriResolver);
    this.m_textElementsRenderer = this.createTextRenderer();
    this.setTheme(getOptionValue(this.m_options.theme, MapViewDefaults.theme));
    this.update();
  }
  async addDataSource(dataSource) {
    var _a;
    const twinDataSource = this.getDataSourceByName(dataSource.name);
    if (twinDataSource !== void 0) {
      throw new Error(`A DataSource with the name "${dataSource.name}" already exists in this MapView.`);
    }
    dataSource.attach(this);
    dataSource.setEnableElevationOverlay(this.m_elevationProvider !== void 0);
    const conflictingDataSource = this.m_tileDataSources.find((ds) => ds.addGroundPlane === true && !(ds instanceof BackgroundDataSource));
    if (dataSource.addGroundPlane === true && conflictingDataSource !== void 0) {
      console.warn(`The DataSources ${dataSource.name} and ${conflictingDataSource.name} both have a ground plane added, this will cause problems with the fallback logic, see HARP-14728 & HARP-15488.`);
    }
    this.m_tileDataSources.push(dataSource);
    (_a = this.m_sceneEnvironment) == null ? void 0 : _a.updateBackgroundDataSource();
    try {
      await dataSource.connect();
      const alreadyRemoved = !this.m_tileDataSources.includes(dataSource);
      if (alreadyRemoved) {
        return;
      }
      dataSource.addEventListener(MapViewEventNames.Update, () => {
        this.update();
      });
      const theme = await this.getTheme();
      dataSource.setLanguages(this.m_languages);
      if (theme !== void 0 && theme.styles !== void 0) {
        await dataSource.setTheme(theme);
      }
      this.m_connectedDataSources.add(dataSource.name);
      this.dispatchEvent({
        type: MapViewEventNames.DataSourceConnect,
        dataSourceName: dataSource.name
      });
      this.update();
    } catch (error) {
      logger24.error(`Failed to connect to datasource ${dataSource.name}: ${error.message ?? error}`);
      this.m_failedDataSources.add(dataSource.name);
      this.dispatchEvent({
        type: MapViewEventNames.DataSourceConnect,
        dataSourceName: dataSource.name,
        error
      });
    }
  }
  get animatedExtrusionHandler() {
    return this.m_animatedExtrusionHandler;
  }
  get animating() {
    return this.m_animationCount > 0;
  }
  beginAnimation() {
    if (this.m_animationCount++ === 0) {
      this.update();
      this.ANIMATION_STARTED_EVENT.time = Date.now();
      this.dispatchEvent(this.ANIMATION_STARTED_EVENT);
    }
  }
  get camera() {
    return this.m_camera;
  }
  get cameraIsMoving() {
    0;
    return this.m_movementDetector.cameraIsMoving;
  }
  get cameraMovementDetector() {
    return this.m_movementDetector;
  }
  get canvas() {
    return this.m_canvas;
  }
  checkCopyrightUpdates() {
    if (!this.checkIfTilesChanged()) {
      return;
    }
    const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();
    if (newCopyrightInfo === this.m_copyrightInfo) {
      return;
    }
    if (newCopyrightInfo.length === this.m_copyrightInfo.length) {
      let allEqual = true;
      for (let i = 0; i < newCopyrightInfo.length; i++) {
        const a = newCopyrightInfo[i];
        const b = this.m_copyrightInfo[i];
        if (a.label !== b.label) {
          allEqual = false;
          break;
        }
      }
      if (allEqual) {
        return;
      }
    }
    this.m_copyrightInfo = newCopyrightInfo;
    this.dispatchEvent(this.COPYRIGHT_CHANGED_EVENT);
  }
  checkIfTilesChanged() {
    if (this.m_thisFrameTilesChanged !== void 0) {
      return this.m_thisFrameTilesChanged;
    }
    const renderList = this.m_visibleTiles.dataSourceTileList;
    const tileIdList = [];
    tileIdList.length = 0;
    renderList.forEach(({ dataSource, renderedTiles }) => {
      renderedTiles.forEach((tile) => {
        tileIdList.push(dataSource.name + "-" + tile.tileKey.mortonCode());
      });
    });
    tileIdList.sort();
    const newTileIds = tileIdList.join("#");
    if (newTileIds !== this.m_lastTileIds) {
      this.m_lastTileIds = newTileIds;
      this.m_thisFrameTilesChanged = true;
    } else {
      this.m_thisFrameTilesChanged = false;
    }
    return this.m_thisFrameTilesChanged;
  }
  get clearColor() {
    const rendererClearColor = this.m_renderer.getClearColor(cache3.color);
    return rendererClearColor !== void 0 ? rendererClearColor.getHex() : 0;
  }
  clearTileCache(dataSourceName, filter) {
    if (this.m_visibleTiles === void 0) {
      return;
    }
    if (dataSourceName !== void 0) {
      const dataSource = this.getDataSourceByName(dataSourceName);
      if (dataSource) {
        this.m_visibleTiles.clearTileCache(dataSource, filter);
        dataSource.clearCache();
      }
    } else {
      this.m_visibleTiles.clearTileCache(void 0, filter);
      this.m_tileDataSources.forEach((dataSource) => dataSource.clearCache());
    }
    if (this.m_elevationProvider !== void 0) {
      this.m_elevationProvider.clearCache();
    }
  }
  get collisionDebugCanvas() {
    return this.m_collisionDebugCanvas;
  }
  get copyrightInfo() {
    return this.m_copyrightInfo;
  }
  createBox(x, y) {
    const geometry = new THREE91.BoxGeometry(100, 100, 100);
    const material = new THREE91.MeshStandardMaterial({
      color: 16711934
    });
    const cube = new THREE91.Mesh(geometry, material);
    cube.renderOrder = 1e5;
    const geoPosition = this.getGeoCoordinatesAt(x, y);
    cube.anchor = geoPosition ?? void 0;
    this.world.createEntity().addComponent(Rotating, { speed: 5 }).addObject3DComponent(cube, this.sceneEntity);
    this.mapAnchors.add(cube);
    this.update();
  }
  createTextRenderer() {
    return new TextElementsRenderer(new MapViewState(this, this.checkIfTilesChanged.bind(this)), this.m_screenProjector, this.m_poiManager, this.m_renderer, [this.imageCache, this.userImageCache], {});
  }
  createVisibleTileSet() {
    assert(this.m_tileGeometryManager !== void 0);
    if (this.m_visibleTiles) {
      this.m_visibleTiles.clearTileCache();
      this.m_visibleTiles.disposePendingTiles();
    }
    const enableMixedLod = this.m_enableMixedLod === void 0 ? this.projection.type === 1 /* Spherical */ : this.m_enableMixedLod;
    this.m_visibleTiles = new VisibleTileSet(new FrustumIntersection(this.m_camera, this, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled, enableMixedLod, this.m_lodMinTilePixelSize), this.m_tileGeometryManager, this.m_visibleTileSetOptions, this.taskQueue);
    return this.m_visibleTiles;
  }
  get dataSources() {
    return this.m_tileDataSources;
  }
  get disposed() {
    return this.m_disposed;
  }
  get elevationProvider() {
    return this.m_elevationProvider;
  }
  get enableMixedLod() {
    return this.m_enableMixedLod;
  }
  endAnimation() {
    if (this.m_animationCount > 0) {
      --this.m_animationCount;
    }
    if (this.m_animationCount === 0) {
      this.ANIMATION_FINISHED_EVENT.time = Date.now();
      this.dispatchEvent(this.ANIMATION_FINISHED_EVENT);
    }
  }
  get env() {
    return this.m_env;
  }
  extractAttitude() {
    const camera = this.m_camera;
    const projection = this.projection;
    const cameraPos = cache3.vector3[1];
    const transform = cache3.transform[0];
    const tangentSpaceMatrix = cache3.matrix4[1];
    cameraPos.setFromMatrixPosition(camera.matrixWorld);
    projection.localTangentSpace(this.m_targetGeoPos, transform);
    tangentSpaceMatrix.makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
    cache3.matrix4[0].copy(tangentSpaceMatrix).invert().multiply(camera.matrixWorld);
    transform.xAxis.setFromMatrixColumn(cache3.matrix4[0], 0);
    transform.yAxis.setFromMatrixColumn(cache3.matrix4[0], 1);
    transform.zAxis.setFromMatrixColumn(cache3.matrix4[0], 2);
    let yaw = 0;
    let pitch = 0;
    let roll = 0;
    const epsilon3 = 1e-10;
    const d = transform.zAxis.dot(cameraPos.set(0, 0, 1));
    if (d < 1 - epsilon3) {
      if (d > -1 + epsilon3) {
        yaw = Math.atan2(transform.zAxis.x, -transform.zAxis.y);
        pitch = Math.acos(transform.zAxis.z);
        roll = Math.atan2(transform.xAxis.x, transform.yAxis.z);
      } else {
        yaw = -Math.atan2(-transform.yAxis.x, transform.xAxis.x);
        pitch = 180;
        roll = 0;
      }
    } else {
      yaw = Math.atan2(-transform.yAxis.x, transform.xAxis.x);
      pitch = 0;
      roll = 0;
    }
    return {
      yaw,
      pitch,
      roll
    };
  }
  flyTo(coords, distance = 800, tilt = 0) {
    let cameraAnimation;
    const animOptions = {
      globe: true,
      orbit: false,
      flyTo: "Dubai",
      flyOver: false
    };
    const animationOptions = {
      interpolation: THREE91.InterpolateSmooth,
      loop: THREE91.LoopOnce,
      repetitions: 1,
      rotateOnlyClockWise: true
    };
    if (cameraAnimation) {
      cameraAnimation.stop();
      cameraAnimation = void 0;
      animOptions.flyOver = false;
      animOptions.orbit = false;
    }
    if (coords) {
      const target = new ControlPoint({
        target: coords,
        distance,
        tilt,
        timestamp: 1
      });
      const flyToOpts = CameraAnimationBuilder.createBowFlyToOptions(this, new ControlPoint({
        ...CameraAnimationBuilder.getLookAtFromView(this),
        timestamp: 0
      }), target, 50);
      Object.assign(flyToOpts, animationOptions);
      cameraAnimation = new CameraKeyTrackAnimation(this, flyToOpts);
      cameraAnimation.start();
    }
  }
  get focalLength() {
    const focalLength = CameraUtils.getFocalLength(this.m_camera) ?? 0;
    return focalLength;
  }
  get frameNumber() {
    return this.m_frameNumber;
  }
  get geoCenter() {
    return this.projection.unprojectPoint(this.m_camera.position).normalized();
  }
  set geoCenter(geoCenter) {
    if (geoCenter.altitude !== void 0) {
      this.projection.projectPoint(geoCenter, this.m_camera.position);
    } else {
      const altitude = this.geoCenter.altitude;
      this.projection.projectPoint(new GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);
    }
    this.update();
  }
  get geoMaxBounds() {
    return this.m_geoMaxBounds;
  }
  set geoMaxBounds(bounds) {
    this.m_geoMaxBounds = bounds;
    this.m_worldMaxBounds = this.m_geoMaxBounds ? this.projection.projectBox(this.m_geoMaxBounds, this.projection.type === 0 /* Planar */ ? new THREE91.Box3() : new OrientedBox3()) : void 0;
  }
  getCanvasClientSize() {
    const { clientWidth, clientHeight } = this.canvas;
    if (clientWidth === 0 || clientHeight === 0 || typeof clientWidth !== "number" || typeof clientHeight !== "number") {
      const pixelRatio = this.m_renderer.getPixelRatio();
      return {
        width: Math.round(this.canvas.width / pixelRatio),
        height: Math.round(this.canvas.height / pixelRatio)
      };
    } else {
      return { width: clientWidth, height: clientHeight };
    }
  }
  getDataSourceByName(dataSourceName) {
    return this.m_tileDataSources.find((ds) => ds.name === dataSourceName);
  }
  getEnabledTileDataSources() {
    const enabledDataSources = [];
    for (const dataSource of this.m_tileDataSources) {
      if (this.isDataSourceEnabled(dataSource)) {
        enabledDataSources.push(dataSource);
      }
    }
    return enabledDataSources;
  }
  getGeoCoordinatesAt(x, y, fallback) {
    const worldPosition = this.getWorldPositionAt(x, y, fallback);
    if (!worldPosition) {
      return null;
    }
    const geoPos = this.projection.unprojectPoint(worldPosition);
    if (!this.tileWrappingEnabled && this.projection.type === 0 /* Planar */) {
      geoPos.longitude = THREE91.MathUtils.clamp(geoPos.longitude, -180, 180);
    }
    return geoPos;
  }
  getNormalizedScreenCoordinates(x, y) {
    const { width, height } = this.getCanvasClientSize();
    return new THREE91.Vector3(x / width * 2 - 1, -(y / height * 2) + 1, 0);
  }
  getRenderedTilesCopyrightInfo() {
    let result = [];
    for (const tileList of this.m_visibleTiles.dataSourceTileList) {
      for (const tile of tileList.renderedTiles.values()) {
        const tileCopyrightInfo = tile.copyrightInfo;
        if (tileCopyrightInfo === void 0 || tileCopyrightInfo.length === 0) {
          continue;
        }
        result = CopyrightInfo.mergeArrays(result, tileCopyrightInfo);
      }
    }
    return result;
  }
  async getTheme() {
    return await this.m_themeManager.getTheme();
  }
  getWorldPositionAt(x, y, fallback) {
    this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);
    const worldPos = this.projection.type === 1 /* Spherical */ ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache3.vector3[0]) : this.m_raycaster.ray.intersectPlane(this.m_plane, cache3.vector3[0]);
    if (worldPos === null && fallback === true) {
      const cosAlpha = this.m_camera.getWorldDirection(cache3.vector3[0]).dot(this.m_raycaster.ray.direction);
      return cache3.vector3[0].copy(this.m_raycaster.ray.direction).multiplyScalar(this.m_camera.far / cosAlpha).add(this.m_camera.position);
    }
    return worldPos;
  }
  get heading() {
    return -THREE91.MathUtils.radToDeg(this.m_yaw);
  }
  set heading(heading) {
    this.lookAtImpl({ heading });
  }
  get isDynamicFrame() {
    return !this.m_visibleTiles.allVisibleTilesLoaded || this.m_themeManager.isUpdating() || this.cameraIsMoving || this.animating || this.m_updatePending || this.m_animatedExtrusionHandler.isAnimating || this.m_textElementsRenderer.isUpdatePending || this.m_textElementsRenderer.loading;
  }
  get imageCache() {
    return this.m_themeManager.imageCache;
  }
  isDataSourceEnabled(dataSource) {
    return dataSource.enabled && dataSource.ready() && this.m_connectedDataSources.has(dataSource.name) && dataSource.isVisible(this.zoomLevel);
  }
  get lockVisibleTileSet() {
    return this.m_visibleTileSetLock;
  }
  set lockVisibleTileSet(value2) {
    this.m_visibleTileSetLock = value2;
  }
  lookAt(targetOrParams, distance, tiltDeg, headingDeg) {
    if (isGeoCoordinatesLike(targetOrParams)) {
      const zoomLevel = distance !== void 0 ? MapViewUtils.calculateZoomLevelFromDistance(this, distance) : void 0;
      const params = {
        target: targetOrParams,
        zoomLevel,
        tilt: tiltDeg,
        heading: headingDeg
      };
      this.lookAtImpl(params);
    } else if (typeof targetOrParams === "object") {
      this.lookAtImpl(targetOrParams);
    }
  }
  lookAtImpl(params) {
    const tilt = Math.min(getOptionValue(params.tilt, this.tilt), MapViewUtils.MAX_TILT_DEG);
    const heading = getOptionValue(params.heading, this.heading);
    const distance = params.zoomLevel !== void 0 ? MapViewUtils.calculateDistanceFromZoomLevel(this, THREE91.MathUtils.clamp(params.zoomLevel, this.m_minZoomLevel, this.m_maxZoomLevel)) : params.distance !== void 0 ? params.distance : this.m_targetDistance;
    let target;
    if (params.bounds !== void 0) {
      let geoPoints;
      if (params.bounds instanceof GeoBox) {
        target = params.target ? GeoCoordinates.fromObject(params.target) : params.bounds.center;
        geoPoints = MapViewUtils.geoBoxToGeoPoints(params.bounds);
      } else if (params.bounds instanceof GeoPolygon) {
        target = params.bounds.getCentroid();
        geoPoints = params.bounds.coordinates;
      } else if (isGeoBoxExtentLike(params.bounds)) {
        target = params.target ? GeoCoordinates.fromObject(params.target) : this.target;
        const box = GeoBox.fromCenterAndExtents(target, params.bounds);
        geoPoints = MapViewUtils.geoBoxToGeoPoints(box);
      } else if (Array.isArray(params.bounds)) {
        geoPoints = params.bounds;
        if (params.target !== void 0) {
          target = GeoCoordinates.fromObject(params.target);
        }
      } else {
        throw Error("#lookAt: Invalid 'bounds' value");
      }
      if (!(params.bounds instanceof GeoBox || params.bounds instanceof GeoPolygon) && this.m_tileWrappingEnabled && this.projection.type === 0 /* Planar */) {
        geoPoints = MapViewUtils.wrapGeoPointsToScreen(geoPoints, target);
      }
      const worldPoints = geoPoints.map((point) => this.projection.projectPoint(GeoCoordinates.fromObject(point), new THREE91.Vector3()));
      const worldTarget = new THREE91.Vector3();
      if (target === void 0) {
        const box = new THREE91.Box3().setFromPoints(worldPoints);
        box.getCenter(worldTarget);
        this.projection.scalePointToSurface(worldTarget);
        target = this.projection.unprojectPoint(worldTarget);
      } else {
        this.projection.projectPoint(target, worldTarget);
      }
      if (params.zoomLevel !== void 0 || params.distance !== void 0) {
        return this.lookAtImpl({
          tilt,
          heading,
          distance,
          target
        });
      }
      return this.lookAtImpl(MapViewUtils.getFitBoundsLookAtParams(target, worldTarget, worldPoints, {
        tilt,
        heading,
        minDistance: MapViewUtils.calculateDistanceFromZoomLevel(this, this.maxZoomLevel),
        projection: this.projection,
        camera: this.camera
      }));
    }
    target = params.target !== void 0 ? GeoCoordinates.fromObject(params.target) : this.target;
    MapViewUtils.getCameraRotationAtTarget(this.projection, target, -heading, tilt, this.camera.quaternion);
    MapViewUtils.getCameraPositionFromTargetCoordinates(target, distance, -heading, tilt, this.projection, this.camera.position);
    this.camera.updateMatrixWorld(true);
    this.updateLookAtSettings();
    this.update();
  }
  get mapAnchors() {
    return this.m_mapAnchors;
  }
  markTilesDirty(dataSource, filter) {
    this.m_visibleTiles.markTilesDirty(dataSource, filter);
    this.update();
  }
  get maxFps() {
    return this.m_options.maxFps;
  }
  get maxZoomLevel() {
    return this.m_maxZoomLevel;
  }
  get minCameraHeight() {
    return this.m_minCameraHeight;
  }
  get minZoomLevel() {
    return this.m_minZoomLevel;
  }
  movementStarted() {
    this.m_textElementsRenderer.movementStarted();
    this.MOVEMENT_STARTED_EVENT.time = Date.now();
    this.dispatchEvent(this.MOVEMENT_STARTED_EVENT);
  }
  movementFinished() {
    this.m_textElementsRenderer.movementFinished();
    this.MOVEMENT_FINISHED_EVENT.time = Date.now();
    this.dispatchEvent(this.MOVEMENT_FINISHED_EVENT);
    if (!this.animating) {
      if (this.m_movementFinishedUpdateTimerId !== void 0) {
        clearTimeout(this.m_movementFinishedUpdateTimerId);
      }
      this.m_movementFinishedUpdateTimerId = setTimeout(() => {
        this.m_movementFinishedUpdateTimerId = void 0;
        this.update();
      }, 0);
    }
  }
  ndcToView(vector, result) {
    result.set(vector.x, vector.y, vector.z).applyMatrix4(this.camera.projectionMatrixInverse).applyMatrix4(this.m_rteCamera.matrixWorld);
    return result;
  }
  onWebGLContextLost = (event) => {
    this.dispatchEvent(this.CONTEXT_LOST_EVENT);
    logger24.warn("WebGL context lost", event);
  };
  onWebGLContextRestored = (event) => {
    this.dispatchEvent(this.CONTEXT_RESTORED_EVENT);
    if (this.m_renderer !== void 0) {
      this.textElementsRenderer.restoreRenderers(this.m_renderer);
      this.getTheme().then((theme) => {
        this.m_sceneEnvironment.updateClearColor(theme.clearColor, theme.clearAlpha);
        this.update();
      });
    }
    logger24.warn("WebGL context restored", event);
  };
  get overlayScene() {
    return this.m_overlayScene;
  }
  get pixelRatio() {
    if (this.m_pixelRatio !== void 0) {
      return this.m_pixelRatio;
    }
    return typeof window !== "undefined" && window.devicePixelRatio !== void 0 ? window.devicePixelRatio : 1;
  }
  get pixelToWorld() {
    if (this.m_pixelToWorld === void 0) {
      assert(this.m_options.fovCalculation !== void 0);
      const lookAtDistance = this.m_targetDistance;
      const focalLength = CameraUtils.getFocalLength(this.m_camera);
      assert(focalLength !== void 0);
      this.m_pixelToWorld = CameraUtils.convertScreenToWorldSize(focalLength, lookAtDistance, 1);
    }
    return this.m_pixelToWorld;
  }
  get poiManager() {
    return this.m_poiManager;
  }
  get poiTableManager() {
    return this.m_poiTableManager;
  }
  loadPostEffects(postEffectsFile) {
    fetch(postEffectsFile).then((response) => response.json()).then((postEffects) => {
      this.m_postEffects = postEffects;
      this.setPostEffects();
    });
  }
  get postEffects() {
    return this.m_postEffects;
  }
  set postEffects(postEffects) {
    this.m_postEffects = postEffects;
    this.setPostEffects();
  }
  get projection() {
    return this.m_visibleTileSetOptions.projection;
  }
  set projection(projection) {
    const tilt = this.tilt;
    const heading = this.heading;
    this.m_visibleTileSetOptions.projection = projection;
    this.updatePolarDataSource();
    this.clearTileCache();
    this.textElementsRenderer.clearRenderStates();
    this.m_visibleTiles = this.createVisibleTileSet();
    this.geoMaxBounds = this.geoMaxBounds;
    this.lookAtImpl({ tilt, heading });
  }
  removeDataSource(dataSource) {
    const dsIndex = this.m_tileDataSources.indexOf(dataSource);
    if (dsIndex === -1) {
      return;
    }
    dataSource.detach(this);
    this.m_visibleTiles.removeDataSource(dataSource);
    this.m_tileDataSources.splice(dsIndex, 1);
    this.m_connectedDataSources.delete(dataSource.name);
    this.m_failedDataSources.delete(dataSource.name);
    this.m_sceneEnvironment.updateBackgroundDataSource();
    this.update();
  }
  render(frameStartTime) {
    if (this.m_drawing) {
      return;
    }
    if (this.disposed) {
      logger24.warn("render(): MapView has been disposed of.");
      return;
    }
    this.RENDER_EVENT.time = frameStartTime;
    this.dispatchEvent(this.RENDER_EVENT);
    this.m_tileObjectRenderer.prepareRender();
    ++this.m_frameNumber;
    let currentFrameEvent;
    const stats = PerformanceStatistics.instance;
    const gatherStatistics = stats.enabled;
    if (gatherStatistics) {
      currentFrameEvent = stats.currentFrame;
      if (this.m_previousFrameTimeStamp !== void 0) {
        const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;
        currentFrameEvent.setValue("render.fps", 1e3 / timeSincePreviousFrame);
      }
      stats.storeAndClearFrameInfo();
      currentFrameEvent = currentFrameEvent;
      currentFrameEvent.setValue("renderCount.frameNumber", this.m_frameNumber);
    }
    this.m_previousFrameTimeStamp = frameStartTime;
    let setupTime;
    let cullTime;
    let textPlacementTime;
    let drawTime;
    let textDrawTime;
    let endTime;
    this.m_renderer.info.reset();
    this.m_updatePending = false;
    this.m_thisFrameTilesChanged = void 0;
    this.m_drawing = true;
    if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
      this.m_renderer.setPixelRatio(this.pixelRatio);
    }
    this.updateCameras();
    this.updateEnv();
    this.m_renderer.clear();
    this.m_sceneRoot.children.length = 0;
    this.m_overlaySceneRoot.children.length = 0;
    if (gatherStatistics) {
      setupTime = PerformanceTimer.now();
    }
    if (!this.lockVisibleTileSet) {
      const viewRangesStatus = this.m_visibleTiles.updateRenderList(this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_frameNumber, this.m_elevationRangeSource);
      if (viewRangesStatus.viewRangesChanged) {
        this.updateCameras(viewRangesStatus.viewRanges);
      }
    }
    if (gatherStatistics) {
      cullTime = PerformanceTimer.now();
    }
    const renderList = this.m_visibleTiles.dataSourceTileList;
    renderList.forEach(({ zoomLevel, renderedTiles }) => {
      renderedTiles.forEach((tile) => {
        this.m_tileObjectRenderer.render(tile, zoomLevel, this.zoomLevel, this.m_camera.position, this.m_sceneRoot);
        tile.frameNumLastVisible = this.m_frameNumber;
      });
    });
    this.m_mapAnchors.update(this.projection, this.camera.position, this.m_sceneRoot, this.m_overlaySceneRoot);
    this.m_animatedExtrusionHandler.update(this.zoomLevel);
    if (currentFrameEvent !== void 0) {
      currentFrameEvent.addValue("renderCount.numTilesRendered", 0);
      currentFrameEvent.addValue("renderCount.numTilesVisible", 0);
      currentFrameEvent.addValue("renderCount.numTilesLoading", 0);
      renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {
        currentFrameEvent.addValue("renderCount.numTilesRendered", renderedTiles.size);
        currentFrameEvent.addValue("renderCount.numTilesVisible", visibleTiles.length);
        currentFrameEvent.addValue("renderCount.numTilesLoading", numTilesLoading);
      });
    }
    if (this.m_movementDetector.checkCameraMoved(this, frameStartTime)) {
      const { latitude, longitude, altitude } = this.geoCenter;
      this.dispatchEvent({
        type: MapViewEventNames.CameraPositionChanged,
        latitude,
        longitude,
        altitude,
        yaw: this.m_yaw,
        pitch: this.m_pitch,
        roll: this.m_roll,
        tilt: this.tilt,
        heading: this.heading,
        zoom: this.zoomLevel
      });
    }
    const camera = this.m_pointOfView !== void 0 ? this.m_pointOfView : this.m_rteCamera;
    if (this.renderLabels && !this.m_pointOfView) {
      this.m_textElementsRenderer.placeText(renderList, frameStartTime);
    }
    if (gatherStatistics) {
      textPlacementTime = PerformanceTimer.now();
    }
    this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !this.isDynamicFrame);
    if (gatherStatistics) {
      drawTime = PerformanceTimer.now();
    }
    if (this.renderLabels && !this.m_pointOfView) {
      this.m_textElementsRenderer.renderText(this.m_viewRanges.maximum);
    }
    if (this.m_overlaySceneRoot.children.length > 0) {
      this.m_renderer.render(this.m_overlayScene, camera);
    }
    if (gatherStatistics) {
      textDrawTime = PerformanceTimer.now();
    }
    if (!this.m_firstFrameRendered) {
      this.m_firstFrameRendered = true;
      if (gatherStatistics) {
        stats.appResults.set("firstFrame", frameStartTime);
      }
      this.FIRST_FRAME_EVENT.time = frameStartTime;
      this.dispatchEvent(this.FIRST_FRAME_EVENT);
    }
    this.m_visibleTiles.disposePendingTiles();
    this.m_drawing = false;
    this.checkCopyrightUpdates();
    if (this.m_taskSchedulerTimeout !== void 0) {
      clearTimeout(this.m_taskSchedulerTimeout);
    }
    this.m_taskSchedulerTimeout = setTimeout(() => {
      this.m_taskSchedulerTimeout = void 0;
      this.m_taskScheduler.processPending(frameStartTime);
    }, 0);
    if (currentFrameEvent !== void 0) {
      endTime = PerformanceTimer.now();
      const frameRenderTime = endTime - frameStartTime;
      currentFrameEvent.setValue("render.setupTime", setupTime - frameStartTime);
      currentFrameEvent.setValue("render.cullTime", cullTime - setupTime);
      currentFrameEvent.setValue("render.textPlacementTime", textPlacementTime - cullTime);
      currentFrameEvent.setValue("render.drawTime", drawTime - textPlacementTime);
      currentFrameEvent.setValue("render.textDrawTime", textDrawTime - drawTime);
      currentFrameEvent.setValue("render.cleanupTime", endTime - textDrawTime);
      currentFrameEvent.setValue("render.frameRenderTime", frameRenderTime);
      currentFrameEvent.setValue("render.fullFrameTime", frameRenderTime);
      currentFrameEvent.setValue("render.geometryCreationTime", 0);
      stats.addWebGLInfo(this.m_renderer.info);
      stats.addMemoryInfo();
    }
    this.DID_RENDER_EVENT.time = frameStartTime;
    this.dispatchEvent(this.DID_RENDER_EVENT);
    if (!this.isDynamicFrame) {
      if (this.m_firstFrameComplete === false) {
        this.m_firstFrameComplete = true;
        if (gatherStatistics) {
          stats.appResults.set("firstFrameComplete", frameStartTime);
        }
      }
      this.FRAME_COMPLETE_EVENT.time = frameStartTime;
      this.dispatchEvent(this.FRAME_COMPLETE_EVENT);
    }
  }
  get renderer() {
    return this.m_renderer;
  }
  get renderLabels() {
    return this.m_renderLabels;
  }
  set renderLabels(value2) {
    this.m_renderLabels = value2;
  }
  renderLoop(frameStartTime) {
    if (this.m_options.synchronousRendering === true || this.disposed) {
      return;
    }
    if (this.maxFps === 0) {
      this.render(frameStartTime);
    } else {
      const fudgeTimeInMs = 3;
      const frameInterval = 1e3 / this.maxFps;
      const previousFrameTime = this.m_previousFrameTimeStamp === void 0 ? 0 : this.m_previousFrameTimeStamp;
      const targetTime = previousFrameTime + frameInterval - fudgeTimeInMs;
      if (frameStartTime >= targetTime) {
        this.render(frameStartTime);
      }
    }
    requestAnimationFrame(this.handleRequestAnimationFrame);
  }
  renderSync(frameStartTime) {
    if (frameStartTime === void 0) {
      frameStartTime = PerformanceTimer.now();
    }
    this.render(frameStartTime);
  }
  async resetTextRenderer(fontCatalogs, textStyles, defaultTextStyle) {
    await this.m_textElementsRenderer.updateFontCatalogs(fontCatalogs);
    await this.m_textElementsRenderer.updateTextStyles(textStyles, defaultTextStyle);
    this.update();
  }
  resize(width, height) {
    this.m_renderer.setSize(width, height, false);
    if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
      this.m_renderer.setPixelRatio(this.pixelRatio);
    }
    if (this.mapRenderingManager !== void 0) {
      this.mapRenderingManager.setSize(width, height);
    }
    if (this.collisionDebugCanvas !== void 0) {
      this.collisionDebugCanvas.width = width;
      this.collisionDebugCanvas.height = height;
    }
    this.updateCameras();
    this.update();
    this.dispatchEvent({
      type: MapViewEventNames.Resize,
      size: {
        width,
        height
      }
    });
  }
  get scene() {
    return this.m_scene;
  }
  get sceneEntity() {
    return this.m_sceneEntity;
  }
  set sceneEntity(sceneEntity) {
    this.m_sceneEntity = sceneEntity;
  }
  get sceneEnvironment() {
    return this.m_sceneEnvironment;
  }
  setFovOnCamera(fovCalculation, height) {
    const fovRad = THREE91.MathUtils.degToRad(fovCalculation.fov);
    if (fovCalculation.type === "fixed") {
      CameraUtils.setVerticalFov(this.m_camera, fovRad, height);
      return;
    }
    let focalLength = CameraUtils.getFocalLength(this.m_camera);
    if (focalLength === void 0) {
      CameraUtils.setVerticalFov(this.m_camera, fovRad, height);
      focalLength = CameraUtils.getFocalLength(this.m_camera);
    }
    CameraUtils.setFocalLength(this.m_camera, focalLength, height);
  }
  setPostEffects() {
    this.mapRenderingManager.bloom.enabled = false;
    this.mapRenderingManager.outline.enabled = false;
    this.mapRenderingManager.vignette.enabled = false;
    this.mapRenderingManager.sepia.enabled = false;
    if (this.m_postEffects !== void 0) {
      if (this.m_postEffects.bloom !== void 0) {
        this.mapRenderingManager.bloom = this.m_postEffects.bloom;
      }
      if (this.m_postEffects.outline !== void 0) {
        this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;
        this.mapRenderingManager.updateOutline(this.m_postEffects.outline);
      }
      if (this.m_postEffects.vignette !== void 0) {
        this.mapRenderingManager.vignette = this.m_postEffects.vignette;
      }
      if (this.m_postEffects.sepia !== void 0) {
        this.mapRenderingManager.sepia = this.m_postEffects.sepia;
      }
    }
  }
  async setTheme(theme) {
    const newTheme = await this.m_themeManager.setTheme(theme);
    this.THEME_LOADED_EVENT.time = Date.now();
    this.dispatchEvent(this.THEME_LOADED_EVENT);
    this.update();
    return newTheme;
  }
  setupCamera() {
    assert(this.m_visibleTiles !== void 0);
    this.m_options.target = GeoCoordinates.fromObject(getOptionValue(this.m_options.target, MapViewDefaults.target));
    this.m_options.target.altitude = 0;
    this.m_options.tilt = getOptionValue(this.m_options.tilt, MapViewDefaults.tilt);
    this.m_options.heading = getOptionValue(this.m_options.heading, MapViewDefaults.heading);
    this.m_options.zoomLevel = getOptionValue(this.m_options.zoomLevel, MapViewDefaults.zoomLevel);
    this.lookAtImpl(this.m_options);
    const { width, height } = this.getCanvasClientSize();
    this.resize(width, height);
  }
  setupStats(enable) {
    new PerformanceStatistics(enable, 1e3);
  }
  setupRenderer(tileObjectRenderer) {
    this.m_scene.add(this.m_sceneRoot);
    this.m_overlayScene.add(this.m_overlaySceneRoot);
    this.shadowsEnabled = this.m_options.enableShadows ?? false;
    tileObjectRenderer.setupRenderer();
  }
  get shadowsEnabled() {
    return this.m_options.enableShadows === true;
  }
  set shadowsEnabled(enabled) {
    if (this.m_renderer.shadowMap === void 0 || enabled === this.m_renderer.shadowMap.enabled) {
      return;
    }
    this.m_options.enableShadows = enabled;
    this.m_renderer.shadowMap.enabled = enabled;
    this.m_renderer.shadowMap.type = THREE91.PCFSoftShadowMap;
    this.clearTileCache();
  }
  startRenderLoop() {
    if (this.m_animationFrameHandle !== void 0 || this.m_options.synchronousRendering) {
      return;
    }
    this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
  }
  get storageLevel() {
    return THREE91.MathUtils.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);
  }
  get target() {
    return this.m_targetGeoPos;
  }
  get targetDistance() {
    return this.m_targetDistance;
  }
  get taskQueue() {
    return this.m_taskScheduler.taskQueue;
  }
  get textElementsRenderer() {
    return this.m_textElementsRenderer;
  }
  get tilt() {
    return THREE91.MathUtils.radToDeg(this.m_pitch);
  }
  get tileGeometryManager() {
    return this.m_tileGeometryManager;
  }
  get tileWrappingEnabled() {
    return this.m_tileWrappingEnabled;
  }
  update() {
    if (this.disposed) {
      logger24.warn("update(): MapView has been disposed of.");
      return;
    }
    this.dispatchEvent(this.UPDATE_EVENT);
    if (this.m_updatePending) {
      return;
    }
    this.m_updatePending = true;
    this.startRenderLoop();
  }
  updateCameras(viewRanges) {
    var _a;
    this.m_camera.updateMatrixWorld(false);
    this.updateLookAtSettings();
    const { width, height } = this.m_renderer.getSize(cache3.vector2[0]);
    this.m_camera.aspect = this.m_forceCameraAspect !== void 0 ? this.m_forceCameraAspect : width / height;
    this.setFovOnCamera(this.m_options.fovCalculation, height);
    const projectionScale = this.projection.getScaleFactor(this.camera.position);
    const maxGeometryHeightScaled = projectionScale * this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);
    const minGeometryHeightScaled = projectionScale * this.m_tileDataSources.reduce((r, ds) => Math.min(r, ds.minGeometryHeight), 0);
    Object.assign(this.m_viewRanges, viewRanges === void 0 ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled, minGeometryHeightScaled) : viewRanges);
    this.m_camera.near = this.m_viewRanges.near;
    this.m_camera.far = this.m_viewRanges.far;
    this.m_camera.updateProjectionMatrix();
    this.m_rteCamera.copy(this.m_camera);
    this.m_rteCamera.position.setScalar(0);
    this.m_rteCamera.updateMatrixWorld(true);
    (_a = this.m_textElementsRenderer) == null ? void 0 : _a.updateCamera();
    this.m_screenProjector.update(this.camera, width, height);
    this.m_pixelToWorld = void 0;
    this.m_sceneEnvironment.update();
  }
  updateEnv() {
    this.m_env.entries.$zoom = this.m_zoomLevel;
    this.m_env.entries.$pixelToMeters = this.pixelToWorld;
    this.m_env.entries.$frameNumber = this.m_frameNumber;
  }
  updateLookAtSettings() {
    let { target, distance, final } = MapViewUtils.getTargetAndDistance(this.projection, this.camera, this.elevationProvider);
    if (!final) {
      this.update();
    }
    if (this.geoMaxBounds) {
      ;
      ({ target, distance } = MapViewUtils.constrainTargetAndDistanceToViewBounds(target, distance, this));
    }
    this.m_targetWorldPos.copy(target);
    this.m_targetGeoPos = this.projection.unprojectPoint(this.m_targetWorldPos);
    this.m_targetDistance = distance;
    this.m_zoomLevel = MapViewUtils.calculateZoomLevelFromDistance(this, this.m_targetDistance);
    const { yaw, pitch, roll } = this.extractAttitude();
    this.m_yaw = yaw;
    this.m_pitch = pitch;
    this.m_roll = roll;
  }
  updatePolarDataSource() {
    const dataSource = this.m_polarDataSource;
    if (this.m_enablePolarDataSource === true && dataSource !== void 0) {
      const twinDataSource = this.getDataSourceByName(dataSource.name);
      if (this.projection.type === 1 /* Spherical */) {
        if (twinDataSource === void 0) {
          this.addDataSource(dataSource);
        }
      } else {
        if (twinDataSource !== void 0) {
          this.removeDataSource(dataSource);
        }
      }
    }
  }
  get userImageCache() {
    return this.m_userImageCache;
  }
  get viewportHeight() {
    return this.canvas.height;
  }
  get viewRanges() {
    return this.m_viewRanges;
  }
  get visibleTileSet() {
    return this.m_visibleTiles;
  }
  get world() {
    return this.m_world;
  }
  set world(world) {
    this.m_world = world;
  }
  get worldCenter() {
    return this.m_camera.position;
  }
  get worldMaxBounds() {
    return this.m_worldMaxBounds;
  }
  get worldTarget() {
    return this.m_targetWorldPos;
  }
  get zoomLevel() {
    return this.m_zoomLevel;
  }
};
var MapViewEventNames = /* @__PURE__ */ ((MapViewEventNames2) => {
  MapViewEventNames2["Update"] = "update";
  MapViewEventNames2["Resize"] = "resize";
  MapViewEventNames2["Render"] = "render";
  MapViewEventNames2["AfterRender"] = "didrender";
  MapViewEventNames2["FirstFrame"] = "first-render";
  MapViewEventNames2["FrameComplete"] = "frame-complete";
  MapViewEventNames2["ThemeLoaded"] = "theme-loaded";
  MapViewEventNames2["AnimationStarted"] = "animation-started";
  MapViewEventNames2["AnimationFinished"] = "animation-finished";
  MapViewEventNames2["MovementStarted"] = "movement-started";
  MapViewEventNames2["MovementFinished"] = "movement-finished";
  MapViewEventNames2["DataSourceConnect"] = "datasource-connect";
  MapViewEventNames2["CopyrightChanged"] = "copyright-changed";
  MapViewEventNames2["ContextLost"] = "webglcontext-lost";
  MapViewEventNames2["ContextRestored"] = "webglcontext-restored";
  MapViewEventNames2["CameraPositionChanged"] = "camera-changed";
  MapViewEventNames2["Dispose"] = "dispose";
  return MapViewEventNames2;
})(MapViewEventNames || {});
var cache3 = {
  vector2: [new THREE91.Vector2()],
  vector3: [new THREE91.Vector3(), new THREE91.Vector3(), new THREE91.Vector3()],
  rayCaster: new THREE91.Raycaster(),
  groundPlane: new THREE91.Plane(),
  groundSphere: new THREE91.Sphere(void 0, EarthConstants.EQUATORIAL_RADIUS),
  matrix4: [new THREE91.Matrix4(), new THREE91.Matrix4()],
  transform: [
    {
      position: new THREE91.Vector3(),
      xAxis: new THREE91.Vector3(),
      yAxis: new THREE91.Vector3(),
      zAxis: new THREE91.Vector3()
    }
  ],
  color: new THREE91.Color()
};

// src/mapview/geometry/TileGeometryCreator.ts
var THREE94 = __toESM(require("three"));

// src/mapview/DepthPrePass.ts
var THREE92 = __toESM(require("three"));
var DEPTH_PRE_PASS_STENCIL_MASK = 1;
var DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;
function isRenderDepthPrePassEnabled(technique, env) {
  if (technique.enableDepthPrePass === false) {
    return false;
  }
  let transparent = technique.opacity !== void 0 && technique.opacity > 0 && technique.opacity < 1;
  if (!transparent) {
    const color = evaluateBaseColorProperty(technique, env);
    if (color !== void 0) {
      const alpha = ColorUtils.getAlphaFromHex(color);
      transparent = alpha > 0 && alpha < 1;
    }
  }
  return transparent;
}
function createDepthPrePassMaterial(baseMaterial) {
  baseMaterial.depthWrite = false;
  baseMaterial.depthFunc = THREE92.EqualDepth;
  baseMaterial.colorWrite = true;
  enforceBlending(baseMaterial);
  const depthPassMaterial = baseMaterial.clone();
  depthPassMaterial.isDepthPrepassMaterial = true;
  depthPassMaterial.depthWrite = true;
  depthPassMaterial.depthTest = true;
  depthPassMaterial.depthFunc = THREE92.LessDepth;
  depthPassMaterial.colorWrite = false;
  depthPassMaterial.opacity = 1;
  depthPassMaterial.blending = THREE92.NoBlending;
  return depthPassMaterial;
}
function isDepthPrePassMesh(object) {
  if (object.isMesh !== true) {
    return false;
  }
  const mesh = object;
  return mesh.material instanceof Array ? mesh.material.every((material) => material.isDepthPrepassMaterial === true) : mesh.material.isDepthPrepassMaterial === true;
}
function createDepthPrePassMesh(mesh) {
  const originalGeometry = mesh.geometry;
  if (!(originalGeometry instanceof THREE92.BufferGeometry)) {
    throw new Error("#createDepthPassMesh only BufferGeometry is supported");
  }
  const positionAttribute = originalGeometry.getAttribute("position");
  if (!positionAttribute) {
    throw new Error("#createDepthPassMesh position attribute not found");
  }
  const depthPassGeometry = new THREE92.BufferGeometry();
  depthPassGeometry.setAttribute("position", positionAttribute);
  const uvAttribute = originalGeometry.getAttribute("uv");
  if (uvAttribute) {
    depthPassGeometry.setAttribute("uv", uvAttribute);
  }
  const normalAttribute = originalGeometry.getAttribute("normal");
  if (normalAttribute) {
    depthPassGeometry.setAttribute("normal", normalAttribute);
  }
  const extrusionAxisAttribute = originalGeometry.getAttribute("extrusionAxis");
  if (extrusionAxisAttribute) {
    depthPassGeometry.setAttribute("extrusionAxis", extrusionAxisAttribute);
  }
  if (originalGeometry.index) {
    depthPassGeometry.setIndex(originalGeometry.index);
  }
  for (const group of originalGeometry.groups) {
    const { start, count, materialIndex } = group;
    depthPassGeometry.addGroup(start, count, materialIndex);
  }
  const depthPassMaterial = mesh.material instanceof Array ? mesh.material.map(createDepthPrePassMaterial) : createDepthPrePassMaterial(mesh.material);
  const depthPassMesh = new THREE92.Mesh(depthPassGeometry, depthPassMaterial);
  depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;
  return depthPassMesh;
}
function setDepthPrePassStencil(depthMesh, colorMesh) {
  function setupDepthMaterialStencil(depthMeshMaterial) {
    const depthMaterial = depthMeshMaterial;
    depthMaterial.stencilWrite = true;
    depthMaterial.stencilFail = THREE92.KeepStencilOp;
    depthMaterial.stencilZFail = THREE92.KeepStencilOp;
    depthMaterial.stencilZPass = THREE92.ReplaceStencilOp;
    depthMaterial.stencilFunc = THREE92.AlwaysStencilFunc;
    depthMaterial.stencilRef = 255;
    depthMaterial.stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;
  }
  function setupColorMaterialStencil(colorMeshMaterial) {
    const colorMaterial = colorMeshMaterial;
    colorMaterial.stencilWrite = true;
    colorMaterial.stencilFail = THREE92.KeepStencilOp;
    colorMaterial.stencilZFail = THREE92.KeepStencilOp;
    colorMaterial.stencilZPass = THREE92.ZeroStencilOp;
    colorMaterial.stencilFunc = THREE92.EqualStencilFunc;
    colorMaterial.stencilRef = 255;
    colorMaterial.stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;
  }
  if (depthMesh.material instanceof Array) {
    depthMesh.material.map(setupDepthMaterialStencil);
  } else {
    setupDepthMaterialStencil(depthMesh.material);
  }
  if (colorMesh.material instanceof Array) {
    colorMesh.material.map(setupColorMaterialStencil);
  } else {
    setupColorMaterialStencil(colorMesh.material);
  }
}

// src/mapview/PathBlockingElement.ts
var THREE93 = __toESM(require("three"));
var PathBlockingElement = class {
  constructor(points) {
    this.points = points;
    this.screenSpaceLines = new Array(points.length >= 2 ? points.length - 1 : 0);
    for (let i = 0; i < this.screenSpaceLines.length; i++) {
      this.screenSpaceLines[i] = new THREE93.Line3(new THREE93.Vector3(), new THREE93.Vector3());
    }
  }
  screenSpaceLines;
};

// src/mapview/geometry/TileGeometryCreator.ts
var logger25 = LoggerManager.instance.create("TileGeometryCreator");
var tmpVector3 = new THREE94.Vector3();
var tmpVector2 = new THREE94.Vector2();
var AttachmentCache = class {
  bufferAttributes = /* @__PURE__ */ new Map();
  interleavedAttributes = /* @__PURE__ */ new Map();
};
var MemoCallExpr = class extends CallExpr7 {
  m_deps;
  m_cachedProperties = [];
  m_cachedValue;
  constructor(expr) {
    super("memo", [expr]);
    this.m_deps = Array.from(expr.dependencies().properties);
    this.descriptor = this;
  }
  call(context2) {
    let changed = false;
    this.m_deps.forEach((d, i) => {
      const newValue = context2.env.lookup(d);
      if (!changed && newValue !== this.m_cachedProperties[i]) {
        changed = true;
      }
      if (changed) {
        this.m_cachedProperties[i] = newValue;
      }
    });
    if (changed || this.m_cachedValue === void 0) {
      this.m_cachedValue = context2.evaluate(this.args[0]);
    }
    return this.m_cachedValue;
  }
};
var AttachmentInfo = class {
  constructor(geometry, info, cache6) {
    this.geometry = geometry;
    this.info = info;
    this.cache = cache6;
  }
  getBufferAttribute(description) {
    if (this.cache.bufferAttributes.has(description)) {
      return this.cache.bufferAttributes.get(description);
    }
    const attribute = getBufferAttribute(description);
    this.cache.bufferAttributes.set(description, attribute);
    return attribute;
  }
  getInterleavedBufferAttributes(description) {
    const interleavedAttributes = this.cache.interleavedAttributes.get(description);
    if (interleavedAttributes) {
      return interleavedAttributes;
    }
    const ArrayCtor = getArrayConstructor(description.type);
    const buffer = new ArrayCtor(description.buffer);
    const interleavedBuffer = new THREE94.InterleavedBuffer(buffer, description.stride);
    const attrs = description.attributes.map((interleavedAttr) => {
      const attribute = new THREE94.InterleavedBufferAttribute(interleavedBuffer, interleavedAttr.itemSize, interleavedAttr.offset, false);
      const name2 = interleavedAttr.name;
      return { name: name2, attribute };
    });
    this.cache.interleavedAttributes.set(description, attrs);
    return attrs;
  }
};
function addToExtrudedMaterials(material, extrudedMaterials) {
  if (Array.isArray(material)) {
    const materials = material;
    extrudedMaterials.push(...materials);
  } else {
    extrudedMaterials.push(material);
  }
}
var _TileGeometryCreator = class {
  static get instance() {
    return this.m_instance || (this.m_instance = new _TileGeometryCreator());
  }
  constructor() {
  }
  initDecodedTile(decodedTile, enabledKinds, disabledKinds) {
    for (const technique of decodedTile.techniques) {
      const kind = technique.kind;
      if (kind === void 0 || kind instanceof Set && kind.size === 0) {
        technique._kindState = true;
        continue;
      }
      technique._kindState = !(disabledKinds !== void 0 && disabledKinds.hasOrIntersects(kind)) || enabledKinds !== void 0 && enabledKinds.hasOrIntersects(kind);
    }
    for (const srcGeometry of decodedTile.geometries) {
      for (const group of srcGeometry.groups) {
        group.createdOffsets = [];
      }
    }
  }
  createAllGeometries(tile, decodedTile) {
    const filter = (technique) => {
      return technique._kindState !== false;
    };
    let texturesReady = Promise.resolve();
    const onNewTexture = (texturePromise) => {
      texturesReady = Promise.all([
        texturesReady,
        texturePromise.then((texture) => {
          tile.addOwnedTexture(texture);
          if (!texture.image) {
            return Promise.resolve();
          }
          return new Promise((resolve) => {
            texture.onUpdate = () => {
              ;
              texture.onUpdate = null;
              resolve();
            };
            tile.mapView.renderer.initTexture(texture);
          });
        }).catch(() => {
        })
      ]);
    };
    this.createObjects(tile, decodedTile, onNewTexture, filter);
    this.preparePois(tile, decodedTile);
    const textFilter = (technique) => {
      if (!isPoiTechnique(technique) && !isLineMarkerTechnique(technique) && !isTextTechnique(technique)) {
        return false;
      }
      return filter(technique);
    };
    this.createTextElements(tile, decodedTile, textFilter);
    this.createLabelRejectionElements(tile, decodedTile);
    if (tile.dataSource.addGroundPlane && tile.projection.type === 0 /* Planar */) {
      addGroundPlane(tile, -1);
    }
    return texturesReady;
  }
  createLabelRejectionElements(tile, decodedTile) {
    if (decodedTile.pathGeometries === void 0) {
      return;
    }
    for (const path of decodedTile.pathGeometries) {
      tile.addBlockingElement(new PathBlockingElement(path.path));
    }
  }
  processTechniques(tile, enabledKinds, disabledKinds) {
    const decodedTile = tile.decodedTile;
    if (decodedTile === void 0) {
      return;
    }
    this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
    const exprPool = tile.dataSource.exprPool;
    decodedTile.techniques.forEach((technique) => {
      for (const propertyName in technique) {
        if (!technique.hasOwnProperty(propertyName)) {
          continue;
        }
        const value2 = technique[propertyName];
        if (isJsonExpr(value2) && propertyName !== "kind") {
          try {
            let expr = Expr3.fromJSON(value2);
            if (expr.dependencies().volatile !== true) {
              expr = new MemoCallExpr(Expr3.fromJSON(value2));
            }
            technique[propertyName] = expr.intern(exprPool);
          } catch (error) {
            logger25.error("Failed to compile expression:", error);
          }
        }
      }
    });
  }
  prepareTextPaths(textPathGeometries, decodedTile, textFilter) {
    const processedPaths = new Array();
    const newPaths = textPathGeometries.slice();
    while (newPaths.length > 0) {
      const textPath = newPaths.pop();
      if (textPath === void 0) {
        break;
      }
      const technique = decodedTile.techniques[textPath.technique];
      if (!isTextTechnique(technique) || textFilter !== void 0 && !textFilter(technique)) {
        continue;
      }
      processedPaths.push(textPath);
    }
    return processedPaths;
  }
  createTextElements(tile, decodedTile, textFilter) {
    var _a;
    const mapView = tile.mapView;
    const worldOffsetX = tile.computeWorldOffsetX();
    const discreteZoomLevel = Math.floor(mapView.zoomLevel);
    const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
    const textElementBuilder = new TextElementBuilder(discreteZoomEnv, tile.textStyleCache, tile.dataSource.dataSourceOrder);
    if (decodedTile.textPathGeometries !== void 0) {
      const textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);
      for (const textPath of textPathGeometries) {
        const technique = decodedTile.techniques[textPath.technique];
        if (technique._kindState === false || !isTextTechnique(technique) || textFilter !== void 0 && !textFilter(technique)) {
          continue;
        }
        const path = [];
        for (let i = 0; i < textPath.path.length; i += 3) {
          path.push(new THREE94.Vector3(textPath.path[i] + worldOffsetX, textPath.path[i + 1], textPath.path[i + 2]));
        }
        const textElement = textElementBuilder.withTechnique(technique).build(textPath.text, path, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, textPath.objInfos, textPath.pathLengthSqr);
        tile.addTextElement(textElement);
      }
    }
    if (decodedTile.textGeometries !== void 0) {
      for (const text of decodedTile.textGeometries) {
        if (text.technique === void 0 || text.stringCatalog === void 0) {
          continue;
        }
        const technique = decodedTile.techniques[text.technique];
        if (technique._kindState === false || !isTextTechnique(technique) || textFilter !== void 0 && !textFilter(technique)) {
          continue;
        }
        const positions = new THREE94.BufferAttribute(new Float64Array(text.positions.buffer), text.positions.itemCount);
        const numPositions = positions.count;
        if (numPositions < 1) {
          continue;
        }
        textElementBuilder.withTechnique(technique);
        for (let i = 0; i < numPositions; ++i) {
          const x = positions.getX(i) + worldOffsetX;
          const y = positions.getY(i);
          const z = positions.getZ(i);
          const label = text.stringCatalog[text.texts[i]];
          if (label === void 0) {
            continue;
          }
          const attributes = (_a = text.objInfos) == null ? void 0 : _a[i];
          const point = new THREE94.Vector3(x, y, z);
          const textElement = textElementBuilder.build(label, point, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, attributes);
          tile.addTextElement(textElement);
        }
      }
    }
  }
  createObjects(tile, decodedTile, onTextureCreated, techniqueFilter) {
    var _a, _b;
    const mapView = tile.mapView;
    const materials = [];
    const extrudedMaterials = [];
    const animatedExtrusionHandler = mapView.animatedExtrusionHandler;
    const discreteZoomLevel = Math.floor(mapView.zoomLevel);
    const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
    const objects = tile.objects;
    const viewRanges = mapView.viewRanges;
    const elevationEnabled = mapView.elevationProvider !== void 0;
    for (const attachment of this.getAttachments(decodedTile)) {
      const srcGeometry = attachment.geometry;
      const groups = attachment.info.groups;
      const groupCount = groups.length;
      for (let groupIndex = 0; groupIndex < groupCount; ) {
        const group = groups[groupIndex++];
        const start = group.start;
        const techniqueIndex = group.technique;
        const technique = decodedTile.techniques[techniqueIndex];
        if (group.createdOffsets === void 0) {
          group.createdOffsets = [];
        }
        if (group.createdOffsets.includes(tile.offset) || technique._kindState === false || techniqueFilter !== void 0 && !techniqueFilter(technique)) {
          continue;
        }
        let count = group.count;
        group.createdOffsets.push(tile.offset);
        for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {
          if (start + count !== groups[groupIndex].start) {
            break;
          }
          count += groups[groupIndex].count;
          groups[groupIndex].createdOffsets.push(tile.offset);
        }
        if (!usesObject3D(technique)) {
          continue;
        }
        const extrusionAnimationEnabled = (animatedExtrusionHandler == null ? void 0 : animatedExtrusionHandler.setAnimationProperties(technique, discreteZoomEnv)) ?? false;
        let material = materials[techniqueIndex];
        if (material === void 0) {
          material = createMaterial(mapView.renderer.capabilities, {
            technique,
            env: mapView.env,
            fog: mapView.scene.fog !== null,
            shadowsEnabled: mapView.shadowsEnabled
          }, onTextureCreated);
          if (material === void 0) {
            continue;
          }
          if (extrusionAnimationEnabled && hasExtrusionFeature(material)) {
            addToExtrudedMaterials(material, extrudedMaterials);
          }
          materials[techniqueIndex] = material;
        }
        const techniqueKind = technique.kind;
        if (isTerrainTechnique(technique)) {
          this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);
        }
        const bufferGeometry = new THREE94.BufferGeometry();
        (_a = srcGeometry.vertexAttributes) == null ? void 0 : _a.forEach((vertexAttribute) => {
          const buffer = attachment.getBufferAttribute(vertexAttribute);
          bufferGeometry.setAttribute(vertexAttribute.name, buffer);
        });
        (_b = srcGeometry.interleavedVertexAttributes) == null ? void 0 : _b.forEach((attr) => {
          attachment.getInterleavedBufferAttributes(attr).forEach(({ name: name2, attribute }) => bufferGeometry.setAttribute(name2, attribute));
        });
        const index = attachment.info.index ?? srcGeometry.index;
        if (index) {
          bufferGeometry.setIndex(attachment.getBufferAttribute(index));
        }
        if (!bufferGeometry.getAttribute("normal") && needsVertexNormals(technique)) {
          bufferGeometry.computeVertexNormals();
        }
        bufferGeometry.addGroup(start, count);
        if (isSolidLineTechnique(technique)) {
          assert(!isHighPrecisionLineMaterial(material));
          const lineMaterial = material;
          if (technique.clipping === true && tile.projection.type === 0 /* Planar */) {
            tile.boundingBox.getSize(tmpVector3);
            tmpVector2.set(tmpVector3.x, tmpVector3.y);
            lineMaterial.clipTileSize = tmpVector2;
          }
          if (bufferGeometry.getAttribute("color")) {
            setShaderMaterialDefine(lineMaterial, "USE_COLOR", true);
          }
        }
        const hasSolidLinesOutlines = isSolidLineTechnique(technique) && technique.secondaryWidth !== void 0;
        const hasFeatureGroups = Expr3.isExpr(technique.enabled) && srcGeometry.featureStarts && srcGeometry.featureStarts.length > 0;
        const object = buildObject(technique, bufferGeometry, hasFeatureGroups ? [material] : material, tile, elevationEnabled);
        object.renderOrder = getPropertyValue(technique.renderOrder, mapView.env);
        if (attachment.info.uuid !== void 0) {
          object.uuid = attachment.info.uuid;
          object.userData.geometryId = attachment.info.uuid;
        }
        if ((isCirclesTechnique(technique) || isSquaresTechnique(technique)) && technique.enablePicking !== void 0) {
          ;
          object.enableRayTesting = technique.enablePicking;
        }
        if (isLineTechnique(technique) || isSegmentsTechnique(technique)) {
          const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
          FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
        }
        if (isSolidLineTechnique(technique)) {
          const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
          FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
        }
        if (isExtrudedLineTechnique(technique)) {
          if (technique.fadeFar !== void 0) {
            const fadingParams = this.getFadingParams(mapView.env, technique);
            FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);
          }
        }
        this.addUserData(tile, srcGeometry, technique, object);
        if (isExtrudedPolygonTechnique(technique)) {
          object.castShadow = mapView.shadowsEnabled;
          object.receiveShadow = mapView.shadowsEnabled;
        } else if (isStandardTechnique(technique) || isFillTechnique(technique)) {
          object.receiveShadow = mapView.shadowsEnabled;
        }
        if (isExtrudedPolygonTechnique(technique) || isStandardTechnique(technique) || isFillTechnique(technique)) {
          if (technique.fadeFar !== void 0) {
            const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
            FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);
          }
        }
        const renderDepthPrePass = isExtrudedPolygonTechnique(technique) && isRenderDepthPrePassEnabled(technique, discreteZoomEnv);
        if (renderDepthPrePass) {
          const depthPassMesh = createDepthPrePassMesh(object);
          this.addUserData(tile, srcGeometry, technique, depthPassMesh);
          registerTileObject(tile, depthPassMesh, techniqueKind, {
            technique,
            pickability: "transient" /* transient */
          });
          objects.push(depthPassMesh);
          if (extrusionAnimationEnabled) {
            addToExtrudedMaterials(depthPassMesh.material, extrudedMaterials);
          }
          setDepthPrePassStencil(depthPassMesh, object);
        }
        const techniquePickability = transientToPickability(getPropertyValue(technique.transient, mapView.env));
        registerTileObject(tile, object, techniqueKind, {
          technique,
          pickability: hasSolidLinesOutlines ? "transient" /* transient */ : techniquePickability
        });
        objects.push(object);
        if (isExtrudedPolygonTechnique(technique) && attachment.info.edgeIndex !== void 0) {
          const hasEdgeFeatureGroups = Expr3.isExpr(technique.enabled) && srcGeometry.edgeFeatureStarts && srcGeometry.edgeFeatureStarts.length > 0;
          const buildingTechnique = technique;
          const edgeGeometry = new THREE94.BufferGeometry();
          edgeGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
          const colorAttribute = bufferGeometry.getAttribute("color");
          if (colorAttribute !== void 0) {
            edgeGeometry.setAttribute("color", colorAttribute);
          }
          const extrusionAttribute = bufferGeometry.getAttribute("extrusionAxis");
          if (extrusionAttribute !== void 0) {
            edgeGeometry.setAttribute("extrusionAxis", extrusionAttribute);
          }
          const normalAttribute = bufferGeometry.getAttribute("normal");
          if (normalAttribute !== void 0) {
            edgeGeometry.setAttribute("normal", normalAttribute);
          }
          const uvAttribute = bufferGeometry.getAttribute("uv");
          if (uvAttribute !== void 0) {
            edgeGeometry.setAttribute("uv", uvAttribute);
          }
          edgeGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
          const extrudedPolygonTechnique = technique;
          const fadingParams = this.getPolygonFadingParams(discreteZoomEnv, extrudedPolygonTechnique);
          const materialParams = {
            color: fadingParams.color,
            colorMix: fadingParams.colorMix,
            fadeNear: fadingParams.lineFadeNear,
            fadeFar: fadingParams.lineFadeFar,
            extrusionRatio: extrusionAnimationEnabled ? 0 : void 0,
            vertexColors: bufferGeometry.getAttribute("color") ? true : false,
            rendererCapabilities: mapView.renderer.capabilities
          };
          const edgeMaterial = new EdgeMaterial(materialParams);
          const edgeObj = new THREE94.LineSegments(edgeGeometry, hasEdgeFeatureGroups ? [edgeMaterial] : edgeMaterial);
          this.addUserData(tile, srcGeometry, technique, edgeObj);
          edgeObj.renderOrder = object.renderOrder + 0.1;
          FadingFeature.addRenderHelper(edgeObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);
          if (extrusionAnimationEnabled) {
            addToExtrudedMaterials(edgeObj.material, extrudedMaterials);
          }
          registerTileObject(tile, edgeObj, techniqueKind, {
            technique,
            pickability: "transient" /* transient */
          });
          MapMaterialAdapter.create(edgeMaterial, {
            color: buildingTechnique.lineColor,
            objectColor: buildingTechnique.color,
            opacity: buildingTechnique.opacity,
            lineWidth: (frameMapView) => {
              const value2 = getPropertyValue(buildingTechnique.lineWidth, frameMapView.env);
              if (typeof value2 === "number") {
                return THREE94.MathUtils.clamp(value2, 0, 1);
              } else {
                return 0;
              }
            }
          });
          objects.push(edgeObj);
        }
        if (isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {
          object.customDepthMaterial = new MapMeshDepthMaterial({
            depthPacking: THREE94.RGBADepthPacking
          });
          addToExtrudedMaterials(object.customDepthMaterial, extrudedMaterials);
        }
        if (isFillTechnique(technique) && attachment.info.edgeIndex) {
          const hasEdgeFeatureGroups = Expr3.isExpr(technique.enabled) && srcGeometry.edgeFeatureStarts && srcGeometry.edgeFeatureStarts.length > 0;
          const outlineGeometry = new THREE94.BufferGeometry();
          outlineGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
          outlineGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
          const fillTechnique = technique;
          const fadingParams = this.getPolygonFadingParams(mapView.env, fillTechnique);
          const materialParams = {
            color: fadingParams.color,
            colorMix: fadingParams.colorMix,
            fadeNear: fadingParams.lineFadeNear,
            fadeFar: fadingParams.lineFadeFar,
            vertexColors: bufferGeometry.getAttribute("color") ? true : false,
            rendererCapabilities: mapView.renderer.capabilities
          };
          const outlineMaterial = new EdgeMaterial(materialParams);
          const outlineObj = new THREE94.LineSegments(outlineGeometry, hasEdgeFeatureGroups ? [outlineMaterial] : outlineMaterial);
          outlineObj.renderOrder = object.renderOrder + 0.1;
          FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);
          this.addUserData(tile, srcGeometry, technique, outlineObj);
          registerTileObject(tile, outlineObj, techniqueKind, {
            technique,
            pickability: techniquePickability
          });
          MapMaterialAdapter.create(outlineMaterial, {
            color: fillTechnique.lineColor,
            objectColor: fillTechnique.color,
            opacity: fillTechnique.opacity
          });
          objects.push(outlineObj);
        }
        if (hasSolidLinesOutlines) {
          const outlineTechnique = technique;
          const outlineMaterial = material.clone();
          applyBaseColorToMaterial(outlineMaterial, outlineMaterial.color, outlineTechnique, outlineTechnique.secondaryColor ?? 0, discreteZoomEnv);
          if (outlineTechnique.secondaryCaps !== void 0) {
            outlineMaterial.caps = getPropertyValue(outlineTechnique.secondaryCaps, mapView.env);
          }
          const outlineObj = buildObject(technique, bufferGeometry, outlineMaterial, tile, elevationEnabled);
          outlineObj.renderOrder = (getPropertyValue(outlineTechnique.secondaryRenderOrder, mapView.env) ?? 0) - 1e-7;
          this.addUserData(tile, srcGeometry, technique, outlineObj);
          const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
          FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
          const secondaryWidth = buildMetricValueEvaluator(outlineTechnique.secondaryWidth, outlineTechnique.metricUnit);
          registerTileObject(tile, outlineObj, techniqueKind, {
            technique
          });
          const mainMaterialAdapter = MapMaterialAdapter.get(material);
          const outlineMaterialAdapter = MapMaterialAdapter.create(outlineMaterial, {
            color: outlineTechnique.secondaryColor,
            opacity: outlineTechnique.opacity,
            caps: outlineTechnique.secondaryCaps,
            lineWidth: (frameMapView) => {
              if (!mainMaterialAdapter) {
                return;
              }
              mainMaterialAdapter.ensureUpdated(frameMapView);
              const mainLineWidth = mainMaterialAdapter.currentStyledProperties.lineWidth;
              const secondaryLineWidth = getPropertyValue(secondaryWidth, mapView.env);
              const opacity = outlineMaterialAdapter.currentStyledProperties.opacity;
              if (typeof mainLineWidth === "number" && typeof secondaryLineWidth === "number") {
                if (secondaryLineWidth <= mainLineWidth && (opacity === null || opacity === void 0 || opacity === 1)) {
                  return 0;
                } else {
                  return secondaryLineWidth;
                }
              } else {
                return 0;
              }
            }
          });
          objects.push(outlineObj);
        }
      }
    }
    if (extrudedMaterials.length > 0) {
      mapView.animatedExtrusionHandler.add(tile, extrudedMaterials);
    }
  }
  preparePois(tile, decodedTile) {
    if (decodedTile.poiGeometries !== void 0) {
      tile.mapView.poiManager.addPois(tile, decodedTile);
    }
  }
  *getAttachments(decodedTile) {
    const cache6 = new AttachmentCache();
    for (const geometry of decodedTile.geometries) {
      const mainAttachment = {
        index: geometry.index,
        edgeIndex: geometry.edgeIndex,
        uuid: geometry.uuid,
        groups: geometry.groups
      };
      yield new AttachmentInfo(geometry, mainAttachment, cache6);
      if (geometry.attachments) {
        for (const info of geometry.attachments) {
          yield new AttachmentInfo(geometry, info, cache6);
        }
      }
    }
  }
  setupTerrainMaterial(technique, material, terrainColor) {
    if (!technique.map || !technique.displacementMap) {
      const stdMaterial = material;
      stdMaterial.color.set(terrainColor);
      setDisplacementMapToMaterial(null, stdMaterial);
      return;
    }
    ;
    material.onBeforeCompile = (shader) => {
      shader.fragmentShader = shader.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;`);
      shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `#ifdef USE_MAP
    float minElevation = ${EarthConstants.MIN_ELEVATION.toFixed(1)};
    float maxElevation = ${EarthConstants.MAX_ELEVATION.toFixed(1)};
    float elevationRange = maxElevation - minElevation;

    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;
    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif`);
      shader.vertexShader = shader.vertexShader.replace("#include <displacementmap_vertex>", "");
    };
    material.displacementMap.needsUpdate = true;
  }
  addUserData(tile, srcGeometry, technique, object) {
    if (isTerrainTechnique(technique)) {
      assert(Object.keys(object.userData).length === 0, "Unexpected user data in terrain object");
      assert(typeof srcGeometry.objInfos[0] === "object", "Wrong attribute map type for terrain geometry");
      const displacementMap = srcGeometry.objInfos[0];
      const tileDisplacementMap = {
        tileKey: tile.tileKey,
        texture: new THREE94.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE94.LuminanceFormat, THREE94.FloatType),
        displacementMap,
        geoBox: tile.geoBox
      };
      object.userData = tileDisplacementMap;
    } else {
      const isOutline = object.type === "LineSegments" && (isExtrudedPolygonTechnique(technique) || isFillTechnique(technique));
      const featureData = {
        geometryType: srcGeometry.type,
        starts: isOutline ? srcGeometry.edgeFeatureStarts : srcGeometry.featureStarts,
        objInfos: srcGeometry.objInfos
      };
      object.userData.feature = featureData;
      object.userData.technique = technique;
    }
  }
  getFadingParams(env, technique) {
    const fadeNear = technique.fadeNear !== void 0 ? getPropertyValue(technique.fadeNear, env) : FadingFeature.DEFAULT_FADE_NEAR;
    const fadeFar = technique.fadeFar !== void 0 ? getPropertyValue(technique.fadeFar, env) : FadingFeature.DEFAULT_FADE_FAR;
    return {
      fadeNear,
      fadeFar
    };
  }
  getPolygonFadingParams(env, technique) {
    let color;
    let colorMix = EdgeMaterial.DEFAULT_COLOR_MIX;
    if (technique.lineColor !== void 0) {
      color = getPropertyValue(technique.lineColor, env);
      if (isExtrudedPolygonTechnique(technique)) {
        const extrudedPolygonTechnique = technique;
        colorMix = extrudedPolygonTechnique.lineColorMix !== void 0 ? extrudedPolygonTechnique.lineColorMix : EdgeMaterial.DEFAULT_COLOR_MIX;
      }
    }
    const fadeNear = technique.fadeNear !== void 0 ? getPropertyValue(technique.fadeNear, env) : FadingFeature.DEFAULT_FADE_NEAR;
    const fadeFar = technique.fadeFar !== void 0 ? getPropertyValue(technique.fadeFar, env) : FadingFeature.DEFAULT_FADE_FAR;
    const lineFadeNear = technique.lineFadeNear !== void 0 ? getPropertyValue(technique.lineFadeNear, env) : fadeNear;
    const lineFadeFar = technique.lineFadeFar !== void 0 ? getPropertyValue(technique.lineFadeFar, env) : fadeFar;
    if (color === void 0) {
      color = EdgeMaterial.DEFAULT_COLOR;
    }
    return {
      color,
      colorMix,
      fadeNear,
      fadeFar,
      lineFadeNear,
      lineFadeFar
    };
  }
};
var TileGeometryCreator = _TileGeometryCreator;
__publicField(TileGeometryCreator, "m_instance");

// src/mapview/geometry/TileGeometryLoader.ts
function addDiscardedTileToStats(tile) {
  const stats = PerformanceStatistics.instance;
  if (stats.enabled) {
    const name2 = tile.dataSource.name;
    const level = tile.tileKey.level;
    const col = tile.tileKey.column;
    const row = tile.tileKey.row;
    const reason = tile.disposed ? `disposed` : `invisible`;
    stats.currentFrame.addMessage(`Decoded tile: ${name2} # lvl=${level} col=${col} row=${row} DISCARDED - ${reason}`);
  }
}
var TileGeometryLoader = class {
  constructor(m_tile, m_taskQueue) {
    this.m_tile = m_tile;
    this.m_taskQueue = m_taskQueue;
    this.m_finishedPromise = new Promise((resolve, reject) => {
      this.m_resolveFinishedPromise = resolve;
      this.m_rejectFinishedPromise = reject;
    });
  }
  static prepareAvailableGeometryKinds(decodedTile) {
    const foundSet = new GeometryKindSet();
    for (const technique of decodedTile.techniques) {
      const geometryKind = TileGeometryLoader.compileGeometryKind(technique);
      if (geometryKind instanceof Set) {
        for (const kind of geometryKind) {
          foundSet.add(kind);
        }
      } else {
        foundSet.add(geometryKind);
      }
    }
    return foundSet;
  }
  static compileGeometryKind(technique) {
    let geometryKind = technique.kind;
    if (geometryKind === void 0) {
      if (isFillTechnique(technique)) {
        geometryKind = GeometryKind.Area;
      } else if (isLineTechnique(technique) || isSolidLineTechnique(technique) || isSegmentsTechnique(technique) || isExtrudedLineTechnique(technique)) {
        geometryKind = GeometryKind.Line;
      } else if (isExtrudedPolygonTechnique(technique)) {
        geometryKind = GeometryKind.Building;
      } else if (isPoiTechnique(technique) || isLineMarkerTechnique(technique) || isTextTechnique(technique)) {
        geometryKind = GeometryKind.Label;
      } else {
        geometryKind = GeometryKind.All;
      }
      technique.kind = geometryKind;
    } else if (Array.isArray(geometryKind)) {
      geometryKind = technique.kind = new GeometryKindSet(geometryKind);
    }
    return geometryKind;
  }
  m_decodedTile;
  m_availableGeometryKinds;
  m_enabledKinds;
  m_disabledKinds;
  m_priority = 0;
  m_state = 0 /* Initialized */;
  m_finishedPromise;
  m_resolveFinishedPromise;
  m_rejectFinishedPromise;
  set priority(value2) {
    this.m_priority = value2;
  }
  getPriority() {
    return this.m_priority;
  }
  get tile() {
    return this.m_tile;
  }
  get hasDecodedTile() {
    return this.m_decodedTile !== void 0;
  }
  get isFinished() {
    return this.m_state === 3 /* Finished */;
  }
  get isSettled() {
    return this.isFinished || this.isCanceled || this.isDisposed;
  }
  waitFinished() {
    return this.m_finishedPromise;
  }
  setDecodedTile(decodedTile) {
    this.m_decodedTile = decodedTile;
    if (this.hasDecodedTile) {
      this.m_availableGeometryKinds = TileGeometryLoader.prepareAvailableGeometryKinds(this.m_decodedTile);
    }
    return this.m_decodedTile;
  }
  get availableGeometryKinds() {
    return this.m_availableGeometryKinds;
  }
  update(enabledKinds, disabledKinds) {
    const tile = this.tile;
    if (this.tile.hasGeometry && !this.compareGeometryKinds(enabledKinds, disabledKinds)) {
      this.reset();
    }
    if ((this.m_state === 0 /* Initialized */ || this.m_state === 4 /* Canceled */) && tile.decodedTile !== void 0) {
      if (this.m_state === 0 /* Initialized */) {
        TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);
        this.setGeometryKinds(enabledKinds, disabledKinds);
        this.setDecodedTile(tile.decodedTile);
      }
      this.queueGeometryCreation(enabledKinds, disabledKinds);
    }
  }
  cancel() {
    var _a;
    addDiscardedTileToStats(this.tile);
    this.m_state = 4 /* Canceled */;
    (_a = this.m_rejectFinishedPromise) == null ? void 0 : _a.call(this);
  }
  dispose() {
    var _a;
    addDiscardedTileToStats(this.tile);
    this.clear();
    this.m_state = 5 /* Disposed */;
    (_a = this.m_rejectFinishedPromise) == null ? void 0 : _a.call(this);
  }
  reset() {
    this.clear();
    if (this.isSettled) {
      this.m_finishedPromise = new Promise((resolve, reject) => {
        this.m_resolveFinishedPromise = resolve;
        this.m_rejectFinishedPromise = reject;
      });
    }
    this.m_state = 0 /* Initialized */;
  }
  finish() {
    var _a;
    this.m_decodedTile = void 0;
    this.m_state = 3 /* Finished */;
    (_a = this.m_resolveFinishedPromise) == null ? void 0 : _a.call(this);
  }
  clear() {
    var _a, _b, _c;
    (_a = this.m_availableGeometryKinds) == null ? void 0 : _a.clear();
    (_b = this.m_enabledKinds) == null ? void 0 : _b.clear();
    (_c = this.m_disabledKinds) == null ? void 0 : _c.clear();
    this.m_decodedTile = void 0;
  }
  queueGeometryCreation(enabledKinds, disabledKinds) {
    if (this.m_state === 1 /* CreationQueued */) {
      return;
    }
    this.m_taskQueue.add({
      execute: this.createGeometry.bind(this, enabledKinds, disabledKinds),
      group: "create" /* CREATE */,
      getPriority: this.getPriority.bind(this),
      isExpired: () => {
        return this.m_state !== 1 /* CreationQueued */;
      },
      estimatedProcessTime: () => {
        var _a;
        return (((_a = this.tile.decodedTile) == null ? void 0 : _a.decodeTime) ?? 30) / 6;
      }
    });
    this.m_state = 1 /* CreationQueued */;
  }
  async createGeometry(enabledKinds, disabledKinds) {
    if (this.m_state === 2 /* CreatingGeometry */) {
      return;
    }
    this.m_state = 2 /* CreatingGeometry */;
    const tile = this.tile;
    const decodedTile = this.m_decodedTile;
    if (decodedTile === void 0) {
      this.finish();
      return;
    }
    const stats = PerformanceStatistics.instance;
    let now2 = 0;
    if (stats.enabled) {
      now2 = PerformanceTimer.now();
    }
    const geometryCreator = TileGeometryCreator.instance;
    tile.clear();
    geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
    await geometryCreator.createAllGeometries(tile, decodedTile);
    if (stats.enabled) {
      this.addStats(stats, now2);
    }
    this.finish();
    tile.dataSource.requestUpdate();
  }
  addStats(stats, now2) {
    const tile = this.tile;
    const decodedTile = this.m_decodedTile;
    if (decodedTile === void 0) {
      return;
    }
    const geometryCreationTime = PerformanceTimer.now() - now2;
    const currentFrame = stats.currentFrame;
    currentFrame.addValue("render.fullFrameTime", geometryCreationTime);
    currentFrame.addValue("render.geometryCreationTime", geometryCreationTime);
    currentFrame.addValue("geometry.geometryCreationTime", geometryCreationTime);
    currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
    currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
    currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== void 0 ? decodedTile.poiGeometries.length : 0);
    currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== void 0 ? decodedTile.textGeometries.length : 0);
    currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== void 0 ? decodedTile.textPathGeometries.length : 0);
    currentFrame.addValue("geometryCount.numPathGeometries", decodedTile.pathGeometries !== void 0 ? decodedTile.pathGeometries.length : 0);
    currentFrame.addMessage(`Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`);
  }
  setGeometryKinds(enabledKinds, disabledKinds) {
    if (enabledKinds !== void 0) {
      this.m_enabledKinds = Object.assign(this.m_enabledKinds ?? new GeometryKindSet(), enabledKinds);
    }
    if (disabledKinds !== void 0) {
      this.m_disabledKinds = Object.assign(this.m_disabledKinds ?? new GeometryKindSet(), disabledKinds);
    }
  }
  compareGeometryKinds(enabledKinds, disabledKinds) {
    const enabledSame = this.m_enabledKinds === enabledKinds;
    const disabledSame = this.m_disabledKinds === disabledKinds;
    if (enabledSame && disabledSame) {
      return true;
    }
    const enabledEmpty = (this.m_enabledKinds === void 0 || this.m_enabledKinds.size === 0) && (enabledKinds === void 0 || enabledKinds.size === 0);
    const disabledEmpty = (this.m_disabledKinds === void 0 || this.m_disabledKinds.size === 0) && (disabledKinds === void 0 || disabledKinds.size === 0);
    if (enabledEmpty && disabledEmpty || enabledSame && disabledEmpty || disabledSame && enabledEmpty) {
      return true;
    }
    if (!enabledEmpty) {
      if (enabledKinds === void 0 || this.m_enabledKinds === void 0) {
        return false;
      } else if (!enabledKinds.has(this.m_enabledKinds)) {
        return false;
      }
    }
    if (!disabledEmpty) {
      if (disabledKinds === void 0 || this.m_disabledKinds === void 0) {
        return false;
      } else if (!disabledKinds.has(this.m_disabledKinds)) {
        return false;
      }
    }
    return true;
  }
  get isCanceled() {
    return this.m_state === 4 /* Canceled */;
  }
  get isDisposed() {
    return this.m_state === 5 /* Disposed */;
  }
};

// src/mapview/text/TextElementGroup.ts
var TextElementGroup = class extends PriorityListGroup {
};

// src/mapview/text/TextElementGroupPriorityList.ts
var TextElementGroupPriorityList = class extends GroupedPriorityList {
};

// src/mapview/text/TileTextStyleCache.ts
var TileTextStyleCache = class {
  textRenderStyles = [];
  textLayoutStyles = [];
  tile;
  constructor(tile) {
    this.tile = tile;
  }
  clear() {
    this.textRenderStyles.length = 0;
    this.textLayoutStyles.length = 0;
  }
  getRenderStyle(technique) {
    let style = this.textRenderStyles[technique._index];
    if (style === void 0) {
      style = this.textRenderStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createRenderStyle(this.tile, technique);
    }
    return style;
  }
  getLayoutStyle(technique) {
    let style = this.textLayoutStyles[technique._index];
    if (style === void 0) {
      style = this.textLayoutStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createLayoutStyle(this.tile, technique);
    }
    return style;
  }
};

// src/mapview/Tile.ts
var logger26 = LoggerManager.instance.create("Tile");
var MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;
var MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
function getFeatureDataSize(featureData) {
  let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
  if (featureData.starts !== void 0) {
    numBytes += featureData.starts.length * 8;
  }
  if (featureData.objInfos !== void 0) {
    numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
  }
  return numBytes;
}
var Tile = class {
  constructor(dataSource, tileKey, offset = 0, localTangentSpace) {
    this.dataSource = dataSource;
    this.tileKey = tileKey;
    this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);
    this.updateBoundingBox();
    this.m_worldCenter.copy(this.boundingBox.position);
    this.m_localTangentSpace = localTangentSpace ?? false;
    this.m_textStyleCache = new TileTextStyleCache(this);
    this.m_offset = offset;
    this.m_uniqueKey = TileKeyUtils.getKeyForTileKeyAndOffset(this.tileKey, this.offset);
    if (dataSource.useGeometryLoader) {
      this.m_tileGeometryLoader = new TileGeometryLoader(this, this.mapView.taskQueue);
      this.attachGeometryLoadedCallback();
    }
  }
  objects = [];
  dependencies = [];
  geoBox;
  copyrightInfo;
  frameNumLastRequested = -1;
  frameNumVisible = -1;
  frameNumLastVisible = -1;
  numFramesVisible = 0;
  visibilityCounter = -1;
  levelOffset = 0;
  skipRendering = false;
  delayRendering = false;
  preparedTextPaths;
  m_tileGeometryLoader;
  m_boundingBox = new OrientedBox3();
  m_disposed = false;
  m_disposeCallback;
  m_localTangentSpace;
  m_forceHasGeometry = void 0;
  m_tileLoader;
  m_decodedTile;
  m_textElementGroups = new TextElementGroupPriorityList();
  m_pathBlockingElements = [];
  m_textElementsChanged;
  m_worldCenter = new THREE95.Vector3();
  m_visibleArea = 0;
  m_elevationRange = {
    minElevation: 0,
    maxElevation: 0
  };
  m_maxGeometryHeight;
  m_minGeometryHeight;
  m_resourceInfo;
  m_ownedTextures = /* @__PURE__ */ new WeakSet();
  m_textStyleCache;
  m_uniqueKey;
  m_offset;
  get isVisible() {
    try {
      return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;
    } catch (error) {
      logger26.debug(error);
      return false;
    }
  }
  set isVisible(visible) {
    this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;
    if (!visible && this.m_tileGeometryLoader && !this.m_tileGeometryLoader.isSettled) {
      this.m_tileGeometryLoader.cancel();
    }
  }
  get projection() {
    return this.dataSource.projection;
  }
  get mapView() {
    return this.dataSource.mapView;
  }
  get localTangentSpace() {
    return this.m_localTangentSpace;
  }
  get memoryUsage() {
    if (this.m_resourceInfo === void 0) {
      this.computeResourceInfo();
    }
    return this.m_resourceInfo.heapSize;
  }
  get center() {
    return this.m_worldCenter;
  }
  get uniqueKey() {
    return this.m_uniqueKey;
  }
  get offset() {
    return this.m_offset;
  }
  set offset(offset) {
    if (this.m_offset !== offset) {
      this.m_uniqueKey = TileKeyUtils.getKeyForTileKeyAndOffset(this.tileKey, offset);
    }
    this.m_offset = offset;
  }
  getResourceInfo() {
    if (this.m_resourceInfo === void 0) {
      this.computeResourceInfo();
    }
    return this.m_resourceInfo;
  }
  invalidateResourceInfo() {
    this.m_resourceInfo = void 0;
  }
  addOwnedTexture(texture) {
    this.m_ownedTextures.add(texture);
  }
  get userTextElements() {
    let group = this.m_textElementGroups.groups.get(TextElement.HIGHEST_PRIORITY);
    if (group === void 0) {
      group = new TextElementGroup(TextElement.HIGHEST_PRIORITY);
      this.m_textElementGroups.groups.set(group.priority, group);
    }
    return group;
  }
  addUserTextElement(textElement) {
    textElement.priority = TextElement.HIGHEST_PRIORITY;
    this.addTextElement(textElement);
  }
  removeUserTextElement(textElement) {
    textElement.priority = TextElement.HIGHEST_PRIORITY;
    return this.removeTextElement(textElement);
  }
  addTextElement(textElement) {
    this.textElementGroups.add(textElement);
    if (this.m_textElementsChanged === false) {
      this.m_textElementGroups = this.textElementGroups.clone();
    }
    this.textElementsChanged = true;
  }
  addBlockingElement(blockingElement) {
    this.m_pathBlockingElements.push(blockingElement);
  }
  removeTextElement(textElement) {
    const groups = this.textElementGroups;
    if (!groups.remove(textElement)) {
      return false;
    }
    if (this.m_textElementsChanged === false) {
      this.m_textElementGroups = groups.clone();
    }
    this.textElementsChanged = true;
    return true;
  }
  get textElementGroups() {
    return this.m_textElementGroups;
  }
  get textElementsChanged() {
    return this.m_textElementsChanged ?? false;
  }
  set textElementsChanged(changed) {
    this.m_textElementsChanged = changed;
  }
  hasTextElements() {
    return this.m_textElementGroups.count() > 0;
  }
  get blockingElements() {
    return this.m_pathBlockingElements;
  }
  willRender(_zoomLevel) {
    return !this.skipRendering && !this.delayRendering;
  }
  didRender() {
  }
  get visibleArea() {
    return this.m_visibleArea;
  }
  set visibleArea(area) {
    this.m_visibleArea = area;
    if (this.tileLoader !== void 0) {
      this.tileLoader.priority = area;
    }
  }
  get elevationRange() {
    return this.m_elevationRange;
  }
  set elevationRange(elevationRange) {
    var _a;
    if (elevationRange.minElevation === this.m_elevationRange.minElevation && elevationRange.maxElevation === this.m_elevationRange.maxElevation && elevationRange.calculationStatus === this.m_elevationRange.calculationStatus) {
      return;
    }
    this.m_elevationRange.minElevation = elevationRange.minElevation;
    this.m_elevationRange.maxElevation = elevationRange.maxElevation;
    this.m_elevationRange.calculationStatus = elevationRange.calculationStatus;
    this.elevateGeoBox();
    if (this.m_maxGeometryHeight !== void 0 || this.m_minGeometryHeight !== void 0) {
      assert(((_a = this.decodedTile) == null ? void 0 : _a.boundingBox) === void 0);
      this.updateBoundingBox();
    }
  }
  get decodedTile() {
    return this.m_decodedTile;
  }
  set decodedTile(decodedTile) {
    this.m_decodedTile = decodedTile;
    this.invalidateResourceInfo();
    if (decodedTile === void 0) {
      return;
    }
    if (decodedTile.geometries.length === 0) {
      this.forceHasGeometry(true);
    }
    this.m_maxGeometryHeight = decodedTile.boundingBox ? void 0 : decodedTile.maxGeometryHeight ?? 0;
    this.m_minGeometryHeight = decodedTile.boundingBox ? void 0 : decodedTile.minGeometryHeight ?? 0;
    this.elevateGeoBox();
    this.updateBoundingBox(decodedTile.boundingBox);
    const stats = PerformanceStatistics.instance;
    if (stats.enabled && decodedTile.decodeTime !== void 0) {
      stats.currentFrame.addValue("decode.decodingTime", decodedTile.decodeTime);
      stats.currentFrame.addValue("decode.decodedTiles", 1);
    }
    if (decodedTile.copyrightHolderIds !== void 0) {
      this.copyrightInfo = decodedTile.copyrightHolderIds.map((id) => ({
        id
      }));
    }
    this.dataSource.requestUpdate();
  }
  shouldDisposeObjectGeometry(object) {
    return true;
  }
  shouldDisposeObjectMaterial(object) {
    return true;
  }
  shouldDisposeTexture(texture) {
    return this.m_ownedTextures.has(texture);
  }
  get disposed() {
    return this.m_disposed;
  }
  get allGeometryLoaded() {
    var _a;
    return ((_a = this.m_tileGeometryLoader) == null ? void 0 : _a.isFinished) ?? this.hasGeometry;
  }
  get hasGeometry() {
    if (this.m_forceHasGeometry === void 0) {
      return this.objects.length !== 0;
    } else {
      return this.m_forceHasGeometry;
    }
  }
  forceHasGeometry(value2) {
    this.m_forceHasGeometry = value2;
  }
  resetVisibilityCounter() {
    this.visibilityCounter = -1;
  }
  get tileLoader() {
    return this.m_tileLoader;
  }
  set tileLoader(tileLoader) {
    this.m_tileLoader = tileLoader;
  }
  async load() {
    const tileLoader = this.tileLoader;
    if (tileLoader === void 0) {
      return await Promise.resolve();
    }
    if (this.m_tileGeometryLoader) {
      const wasSettled = this.m_tileGeometryLoader.isSettled;
      this.m_tileGeometryLoader.reset();
      if (wasSettled) {
        this.attachGeometryLoadedCallback();
      }
    }
    return await tileLoader.loadAndDecode().then((tileLoaderState) => {
      var _a;
      assert(tileLoaderState === 4 /* Ready */);
      const decodedTile = tileLoader.decodedTile;
      this.decodedTile = decodedTile;
      (_a = decodedTile == null ? void 0 : decodedTile.dependencies) == null ? void 0 : _a.forEach((mortonCode) => {
        this.dependencies.push(TileKey.fromMortonCode(mortonCode));
      });
    }).catch((tileLoaderState) => {
      if (tileLoaderState === 6 /* Failed */) {
        this.dispose();
      } else if (tileLoaderState !== 5 /* Canceled */) {
        logger26.error("Unknown error" + tileLoaderState);
      }
    });
  }
  get textStyleCache() {
    return this.m_textStyleCache;
  }
  clear() {
    const disposeMaterial = (material) => {
      Object.getOwnPropertyNames(material).forEach((property) => {
        const materialProperty = material[property];
        if (materialProperty !== void 0 && materialProperty instanceof THREE95.Texture) {
          const texture = materialProperty;
          if (this.shouldDisposeTexture(texture)) {
            texture.dispose();
          }
        }
      });
      material.dispose();
    };
    const disposeObject = (object) => {
      if (this.shouldDisposeObjectGeometry(object)) {
        if (object.geometry !== void 0) {
          object.geometry.dispose();
        }
        if (object.geometries !== void 0) {
          for (const geometry of object.geometries) {
            geometry.dispose();
          }
        }
      }
      if (object.material !== void 0 && this.shouldDisposeObjectMaterial(object)) {
        if (object.material instanceof Array) {
          object.material.forEach((material) => {
            if (material !== void 0) {
              disposeMaterial(material);
            }
          });
        } else {
          disposeMaterial(object.material);
        }
      }
    };
    this.objects.forEach((rootObject) => {
      rootObject.traverse((object) => {
        disposeObject(object);
      });
      disposeObject(rootObject);
    });
    this.objects.length = 0;
    if (this.preparedTextPaths) {
      this.preparedTextPaths = [];
    }
    this.m_textStyleCache.clear();
    this.clearTextElements();
    this.invalidateResourceInfo();
  }
  clearTextElements() {
    if (!this.hasTextElements()) {
      return;
    }
    this.textElementsChanged = true;
    this.m_pathBlockingElements.splice(0);
    this.textElementGroups.forEach((element) => {
      element.dispose();
    });
    this.textElementGroups.clear();
  }
  addDisposeCallback(callback) {
    this.m_disposeCallback = chainCallbacks(this.m_disposeCallback, callback);
  }
  dispose() {
    var _a;
    if (this.m_disposed) {
      return;
    }
    if (this.m_tileLoader) {
      this.m_tileLoader.cancel();
      this.m_tileLoader = void 0;
    }
    this.clear();
    this.frameNumLastRequested = 0;
    this.m_disposed = true;
    (_a = this.m_tileGeometryLoader) == null ? void 0 : _a.dispose();
    if (this.m_disposeCallback) {
      this.m_disposeCallback(this);
    }
  }
  computeWorldOffsetX() {
    return this.projection.worldExtent(0, 0).max.x * this.offset;
  }
  update(zoomLevel) {
    for (const object of this.objects) {
      if (object instanceof LodMesh) {
        object.setLevelOfDetail(zoomLevel - this.tileKey.level);
      }
    }
  }
  get boundingBox() {
    return this.m_boundingBox;
  }
  updateGeometry(priority, enabledKinds, disabledKinds) {
    if (!this.m_tileGeometryLoader) {
      return false;
    }
    if (this.m_tileGeometryLoader.isSettled) {
      return true;
    }
    if (this.dataSource.isDetached()) {
      this.m_tileGeometryLoader.cancel();
      return true;
    }
    if (this.tileLoader) {
      if (!this.tileLoader.isFinished) {
        return true;
      } else if (!this.decodedTile) {
        this.m_tileGeometryLoader.finish();
        return true;
      }
    }
    if (priority !== void 0) {
      this.m_tileGeometryLoader.priority = priority;
    }
    this.m_tileGeometryLoader.update(enabledKinds, disabledKinds);
    return true;
  }
  get loadedGeometryKinds() {
    var _a;
    return (_a = this.m_tileGeometryLoader) == null ? void 0 : _a.availableGeometryKinds;
  }
  loadingFinished() {
  }
  attachGeometryLoadedCallback() {
    assert(this.m_tileGeometryLoader !== void 0);
    this.m_tileGeometryLoader.waitFinished().then(() => {
      this.loadingFinished();
      this.removeDecodedTile();
    }).catch(() => {
      if (this.disposed) {
        return;
      }
      if (!this.dataSource.isDetached()) {
        this.mapView.visibleTileSet.disposeTile(this);
      }
    });
  }
  removeDecodedTile() {
    this.m_decodedTile = void 0;
    this.invalidateResourceInfo();
  }
  updateBoundingBox(newBoundingBox) {
    if (newBoundingBox) {
      this.m_boundingBox.copy(newBoundingBox);
      this.m_worldCenter.copy(this.boundingBox.position);
    } else {
      this.projection.projectBox(this.geoBox, this.boundingBox);
    }
  }
  elevateGeoBox() {
    this.geoBox.southWest.altitude = this.m_elevationRange.minElevation + (this.m_minGeometryHeight ?? 0);
    this.geoBox.northEast.altitude = this.m_elevationRange.maxElevation + (this.m_maxGeometryHeight ?? 0);
  }
  computeResourceInfo() {
    let heapSize = 0;
    let num3dObjects = 0;
    let numTextElements = 0;
    const aggregatedObjSize = {
      heapSize: 0,
      gpuSize: 0
    };
    const visitedObjects = /* @__PURE__ */ new Map();
    for (const object of this.objects) {
      if (object.visible) {
        num3dObjects++;
      }
      Object3DUtils.estimateSize(object, aggregatedObjSize, visitedObjects);
    }
    for (const group of this.textElementGroups.groups) {
      numTextElements += group[1].elements.length;
    }
    heapSize += numTextElements * 312;
    if (this.m_decodedTile !== void 0 && this.m_decodedTile.tileInfo !== void 0) {
      aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;
    }
    this.m_resourceInfo = {
      heapSize: aggregatedObjSize.heapSize + heapSize,
      gpuSize: aggregatedObjSize.gpuSize,
      num3dObjects,
      numTextElements,
      numUserTextElements: 0
    };
  }
};

// src/mapview/geometry/Object3DUtils.ts
var MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1e3;
var MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;
var logger27 = LoggerManager.instance.create("Object3DUtils");
var Object3DUtils;
((Object3DUtils2) => {
  function estimateTextureSize(texture, objectSize, visitedObjects) {
    if (texture === null || texture === void 0 || texture.image === void 0 || texture.image === null) {
      return;
    }
    if (texture.uuid !== void 0 && visitedObjects.get(texture.uuid) === true) {
      return;
    }
    visitedObjects.set(texture.uuid, true);
    const image = texture.image;
    const imageBytes = 4 * image.width * image.height;
    objectSize.heapSize += imageBytes;
    objectSize.gpuSize += imageBytes;
  }
  function estimateMaterialSize(material, objectSize, visitedObjects) {
    if (material.uuid !== void 0 && visitedObjects.get(material.uuid) === true) {
      return;
    }
    visitedObjects.set(material.uuid, true);
    if (material instanceof THREE96.RawShaderMaterial || material instanceof THREE96.ShaderMaterial) {
      const rawMaterial = material;
      for (const name2 in rawMaterial.uniforms) {
        if (rawMaterial.uniforms[name2] !== void 0) {
          const uniform = rawMaterial.uniforms[name2];
          if (uniform instanceof THREE96.Texture) {
            estimateTextureSize(uniform, objectSize, visitedObjects);
          }
        }
      }
    } else if (material instanceof THREE96.MeshBasicMaterial || material instanceof MapMeshBasicMaterial) {
      const meshMaterial = material;
      estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);
      estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);
      estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);
      estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);
      estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);
    } else if (material instanceof MapMeshStandardMaterial) {
      const standardMaterial = material;
      estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);
      estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);
    } else if (material instanceof THREE96.LineBasicMaterial || material instanceof THREE96.LineDashedMaterial || material instanceof THREE96.PointsMaterial) {
    } else {
      logger27.warn("estimateMeshSize: unidentified material: ", material);
    }
  }
  function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {
    if (attribute.uuid === void 0) {
      attribute.uuid = THREE96.MathUtils.generateUUID();
    }
    if (visitedObjects.get(attribute.uuid) === true) {
      return;
    }
    visitedObjects.set(attribute.uuid, true);
    let attrBytes = 0;
    let bytesPerElement = 4;
    if (attribute.array.BYTES_PER_ELEMENT !== void 0) {
      bytesPerElement = attribute.array.BYTES_PER_ELEMENT;
    }
    if (attribute instanceof THREE96.InterleavedBufferAttribute || attribute instanceof THREE96.BufferAttribute) {
      attrBytes = bytesPerElement * attribute.count * attribute.itemSize;
    } else {
      logger27.warn("estimateMeshSize: unidentified attribute: ", attrName);
    }
    objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;
    objectSize.gpuSize += attrBytes;
  }
  function estimateGeometrySize(geometry, objectSize, visitedObjects) {
    const isNewObject = geometry.uuid === void 0 || visitedObjects.get(geometry.uuid) !== true;
    if (!isNewObject) {
      return;
    }
    visitedObjects.set(geometry.uuid, true);
    if (geometry === void 0) {
      return;
    }
    const attributes = geometry.attributes;
    if (attributes === void 0) {
      logger27.warn("estimateGeometrySize: unidentified geometry: ", geometry);
      return;
    }
    for (const property in attributes) {
      if (attributes[property] !== void 0) {
        estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);
      }
    }
    if (geometry.index !== null) {
      estimateAttributeSize(geometry.index, "index", objectSize, visitedObjects);
    }
  }
  function estimateMeshSize(object, objectSize, visitedObjects) {
    if (!object.isObject3D || object instanceof THREE96.Scene) {
      return;
    }
    if (object.uuid !== void 0 && visitedObjects.get(object.uuid) === true) {
      return;
    }
    visitedObjects.set(object.uuid, true);
    if (object.isMesh || object.isLine || object.isPoints) {
      let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;
      const gpuSize = 0;
      const mesh = object;
      if (mesh.material !== void 0) {
        if (Array.isArray(mesh.material)) {
          const materials = mesh.material;
          for (const material of materials) {
            estimateMaterialSize(material, objectSize, visitedObjects);
          }
        } else {
          const material = mesh.material;
          estimateMaterialSize(material, objectSize, visitedObjects);
        }
      }
      if (mesh.geometries !== void 0) {
        for (const geometry of mesh.geometries) {
          estimateGeometrySize(geometry, objectSize, visitedObjects);
        }
      } else if (mesh.geometry !== void 0) {
        estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);
      }
      const featureData = object.userData !== void 0 ? object.userData.feature : void 0;
      if (featureData !== void 0) {
        heapSize += getFeatureDataSize(featureData);
      }
      objectSize.heapSize += heapSize;
      objectSize.gpuSize += gpuSize;
    } else {
      logger27.warn("estimateMeshSize: unidentified object", object);
    }
  }
  function estimateSize(object, parentSize, visitedObjects) {
    const size = parentSize !== void 0 ? parentSize : {
      heapSize: 0,
      gpuSize: 0
    };
    if (visitedObjects === void 0) {
      visitedObjects = /* @__PURE__ */ new Map();
    }
    estimateMeshSize(object, size, visitedObjects);
    if (object.children.length > 0) {
      for (const child of object.children) {
        estimateSize(child, size, visitedObjects);
      }
    }
    return size;
  }
  Object3DUtils2.estimateSize = estimateSize;
})(Object3DUtils || (Object3DUtils = {}));

// src/mapview/Utils.ts
var logger28 = LoggerManager.instance.create("MapViewUtils");
var TERRAIN_ZOOM_LEVEL = 4;
var groundNormalPlanarProj = new THREE97.Vector3(0, 0, 1);
var groundPlane = new THREE97.Plane(groundNormalPlanarProj.clone());
var groundSphere = new THREE97.Sphere(void 0, EarthConstants.EQUATORIAL_RADIUS);
var rayCaster = new THREE97.Raycaster();
var epsilon2 = 1e-5;
var space = {
  x: new THREE97.Vector3(),
  y: new THREE97.Vector3(),
  z: new THREE97.Vector3()
};
var tangentSpace = {
  x: new THREE97.Vector3(),
  y: new THREE97.Vector3(),
  z: new THREE97.Vector3()
};
var cache4 = {
  box3: [new THREE97.Box3()],
  obox3: [new OrientedBox3()],
  quaternions: [new THREE97.Quaternion(), new THREE97.Quaternion()],
  vector2: [new THREE97.Vector2(), new THREE97.Vector2()],
  vector3: [new THREE97.Vector3(), new THREE97.Vector3(), new THREE97.Vector3(), new THREE97.Vector3()],
  matrix4: [new THREE97.Matrix4(), new THREE97.Matrix4()],
  transforms: [
    {
      xAxis: new THREE97.Vector3(),
      yAxis: new THREE97.Vector3(),
      zAxis: new THREE97.Vector3(),
      position: new THREE97.Vector3()
    }
  ]
};
var tmpCamera = new THREE97.PerspectiveCamera();
function snapToCeilingZoomLevel(zoomLevel) {
  const eps = 1e-6;
  const ceiling = Math.ceil(zoomLevel);
  return ceiling - zoomLevel < eps ? ceiling : zoomLevel;
}
var MapViewUtils;
((MapViewUtils2) => {
  MapViewUtils2.MAX_TILT_DEG = 89;
  MapViewUtils2.MAX_TILT_RAD = MapViewUtils2.MAX_TILT_DEG * THREE97.MathUtils.DEG2RAD;
  function zoomOnTargetPosition(mapView, targetNDCx, targetNDCy, zoomLevel, maxTiltAngle = MapViewUtils2.MAX_TILT_RAD) {
    const { elevationProvider, camera, projection } = mapView;
    const elevation = elevationProvider ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL) : void 0;
    const zoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);
    const cameraTarget = MapViewUtils2.getTargetAndDistance(projection, camera, elevationProvider).target;
    const newCameraDistance = calculateDistanceFromZoomLevel(mapView, zoomLevel);
    if (mapView.geoMaxBounds) {
      const constrained = constrainTargetAndDistanceToViewBounds(cameraTarget, newCameraDistance, mapView);
      if (constrained.distance !== newCameraDistance) {
        return zoomLevel >= mapView.zoomLevel;
      }
    }
    camera.getWorldDirection(camera.position).multiplyScalar(-newCameraDistance).add(cameraTarget);
    if (projection.type === 1 /* Spherical */) {
      const tilt = extractCameraTilt(camera, projection);
      const deltaTilt = tilt - maxTiltAngle;
      if (deltaTilt > 0) {
        orbitAroundScreenPoint(mapView, { deltaTilt, maxTiltAngle });
      }
    }
    const newZoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);
    if (!zoomTarget || !newZoomTarget) {
      return true;
    }
    if (projection.type === 0 /* Planar */) {
      zoomTarget.sub(newZoomTarget);
      panCameraAboveFlatMap(mapView, zoomTarget.x, zoomTarget.y);
    } else if (projection.type === 1 /* Spherical */) {
      panCameraAroundGlobe(mapView, zoomTarget, newZoomTarget);
    }
    return true;
  }
  MapViewUtils2.zoomOnTargetPosition = zoomOnTargetPosition;
  function orbitAroundScreenPoint(mapView, offsetXOrOrbitParams, offsetY, deltaAzimuth, deltaTilt, maxTiltAngle) {
    const ppalPoint = CameraUtils.getPrincipalPoint(mapView.camera, cache4.vector2[0]);
    const mapTargetWorld = MapViewUtils2.rayCastWorldCoordinates(mapView, ppalPoint.x, ppalPoint.y);
    if (mapTargetWorld === null) {
      return;
    }
    let orbitCenter;
    if (typeof offsetXOrOrbitParams === "number") {
      orbitCenter = cache4.vector2[1].set(offsetXOrOrbitParams, offsetY);
    } else {
      const params = offsetXOrOrbitParams;
      orbitCenter = params.center ?? ppalPoint;
      deltaAzimuth = params.deltaAzimuth ?? 0;
      deltaTilt = params.deltaTilt ?? 0;
      maxTiltAngle = params.maxTiltAngle;
    }
    const orbitAroundPpalPoint = orbitCenter.x === ppalPoint.x && orbitCenter.y === ppalPoint.y;
    const rotationTargetWorld = orbitAroundPpalPoint ? mapTargetWorld : MapViewUtils2.rayCastWorldCoordinates(mapView, orbitCenter.x, orbitCenter.y);
    if (rotationTargetWorld === null) {
      return;
    }
    applyAzimuthAroundTarget(mapView, rotationTargetWorld, -deltaAzimuth);
    const tiltAxis = new THREE97.Vector3(1, 0, 0).applyQuaternion(mapView.camera.quaternion);
    const clampedDeltaTilt = computeClampedDeltaTilt(mapView, orbitCenter.y - ppalPoint.y, deltaTilt, maxTiltAngle, mapTargetWorld, rotationTargetWorld, tiltAxis);
    applyTiltAroundTarget(mapView, rotationTargetWorld, clampedDeltaTilt, tiltAxis);
  }
  MapViewUtils2.orbitAroundScreenPoint = orbitAroundScreenPoint;
  function applyAzimuthAroundTarget(mapView, rotationTargetWorld, deltaAzimuth) {
    const camera = mapView.camera;
    const projection = mapView.projection;
    const headingAxis = projection.surfaceNormal(rotationTargetWorld, cache4.vector3[0]);
    const headingQuat = cache4.quaternions[0].setFromAxisAngle(headingAxis, deltaAzimuth);
    camera.quaternion.premultiply(headingQuat);
    camera.position.sub(rotationTargetWorld);
    camera.position.applyQuaternion(headingQuat);
    camera.position.add(rotationTargetWorld);
  }
  function computeClampedDeltaTilt(mapView, offsetY, deltaTilt, maxTiltAngle, mapTargetWorld, rotationTargetWorld, tiltAxis) {
    const camera = mapView.camera;
    const projection = mapView.projection;
    const tilt = extractTiltAngleFromLocation(projection, camera, mapTargetWorld, tiltAxis);
    if (tilt + deltaTilt < 0) {
      return -tilt;
    } else if (deltaTilt <= 0) {
      return deltaTilt;
    } else if (mapTargetWorld.equals(rotationTargetWorld) || offsetY < 0) {
      return MathUtils3.clamp(deltaTilt + tilt, 0, maxTiltAngle) - tilt;
    }
    const rotationCenterTilt = extractTiltAngleFromLocation(projection, camera, rotationTargetWorld, tiltAxis);
    const maxRotationTiltAngle = THREE97.MathUtils.degToRad(89);
    if (rotationCenterTilt > maxRotationTiltAngle) {
      return 0;
    }
    let angleBetweenNormals = 0;
    if (projection === sphereProjection) {
      const projectedRotationTargetNormal = projection.surfaceNormal(rotationTargetWorld, cache4.vector3[0]).projectOnPlane(tiltAxis).normalize();
      const mapTargetNormal = projection.surfaceNormal(mapTargetWorld, cache4.vector3[1]);
      angleBetweenNormals = projectedRotationTargetNormal.angleTo(mapTargetNormal);
    }
    const ninetyRad = THREE97.MathUtils.degToRad(90);
    const MRpC = ninetyRad + angleBetweenNormals - rotationCenterTilt;
    const CMRp = ninetyRad + tilt;
    const RpCM = ninetyRad * 2 - (MRpC + CMRp);
    const CMRpMaxTilt = ninetyRad * 2 - RpCM - ninetyRad - maxTiltAngle;
    const maxTilt = ninetyRad + angleBetweenNormals - CMRpMaxTilt;
    const clampedDeltaTilt = MathUtils3.clamp(deltaTilt + rotationCenterTilt, 0, Math.min(maxTilt, maxRotationTiltAngle)) - rotationCenterTilt;
    return clampedDeltaTilt;
  }
  function applyTiltAroundTarget(mapView, rotationTargetWorld, deltaTilt, tiltAxis) {
    const camera = mapView.camera;
    const posBackup = camera.position.clone();
    const quatBackup = camera.quaternion.clone();
    const tiltQuat = cache4.quaternions[0].setFromAxisAngle(tiltAxis, deltaTilt);
    camera.quaternion.premultiply(tiltQuat);
    camera.position.sub(rotationTargetWorld);
    camera.position.applyQuaternion(tiltQuat);
    camera.position.add(rotationTargetWorld);
    if (MapViewUtils2.rayCastWorldCoordinates(mapView, 0, 0) === null) {
      logger28.warn("Target got invalidated during rotation.");
      camera.position.copy(posBackup);
      camera.quaternion.copy(quatBackup);
    }
  }
  function getGeoTargetFromCamera(camera, projection, elevation) {
    const targetWorldPos = getWorldTargetFromCamera(camera, projection, elevation);
    if (targetWorldPos !== null) {
      return projection.unprojectPoint(targetWorldPos);
    }
    return null;
  }
  MapViewUtils2.getGeoTargetFromCamera = getGeoTargetFromCamera;
  function getWorldTargetFromCamera(camera, projection, elevation) {
    const cameraPos = cache4.vector3[0].copy(camera.position);
    const cameraLookAt = camera.getWorldDirection(cache4.vector3[1]);
    rayCaster.set(cameraPos, cameraLookAt);
    if (elevation !== void 0) {
      groundPlane.constant -= elevation;
      groundSphere.radius += elevation;
    }
    const targetWorldPos = new THREE97.Vector3();
    const result = projection.type === 0 /* Planar */ ? rayCaster.ray.intersectPlane(groundPlane, targetWorldPos) : rayCaster.ray.intersectSphere(groundSphere, targetWorldPos);
    if (elevation !== void 0) {
      groundPlane.constant = 0;
      groundSphere.radius = EarthConstants.EQUATORIAL_RADIUS;
    }
    return result;
  }
  MapViewUtils2.getWorldTargetFromCamera = getWorldTargetFromCamera;
  function constrainTargetAndDistanceToViewBounds(target, distance, mapView) {
    const unconstrained = { target, distance };
    const worldMaxBounds = mapView.worldMaxBounds;
    const camera = mapView.camera;
    const projection = mapView.projection;
    if (!worldMaxBounds) {
      return unconstrained;
    }
    const boundsSize = worldMaxBounds.getSize(cache4.vector3[1]);
    const screenSize = mapView.renderer.getSize(cache4.vector2[0]);
    const viewHeight = CameraUtils.convertScreenToWorldSize(mapView.focalLength, unconstrained.distance, screenSize.height);
    const viewWidth = viewHeight * camera.aspect;
    const scale = Math.max(viewWidth / boundsSize.x, viewHeight / boundsSize.y);
    const viewHalfSize = new THREE97.Vector3(viewWidth / 2, viewHeight / 2, 0);
    const constrained = {
      target: unconstrained.target.clone(),
      distance: unconstrained.distance
    };
    if (projection.type === 0 /* Planar */) {
      if (scale > 1) {
        constrained.distance /= scale;
        camera.getWorldDirection(camera.position).multiplyScalar(-constrained.distance).add(worldMaxBounds.getCenter(constrained.target));
      } else {
        const targetBounds = cache4.box3[0].copy(worldMaxBounds).expandByVector(viewHalfSize.multiplyScalar(-1));
        targetBounds.clampPoint(unconstrained.target, constrained.target).setZ(unconstrained.target.z);
        if (constrained.target.equals(unconstrained.target)) {
          return unconstrained;
        }
        camera.position.x += constrained.target.x - unconstrained.target.x;
        camera.position.y += constrained.target.y - unconstrained.target.y;
      }
      return constrained;
    }
    if (scale > 1) {
      worldMaxBounds.getCenter(constrained.target);
      constrained.target.setLength(unconstrained.target.length());
      constrained.distance /= scale;
    } else {
      const targetMaxBounds = cache4.obox3[0];
      targetMaxBounds.copy(worldMaxBounds);
      targetMaxBounds.position.setLength(unconstrained.target.length());
      targetMaxBounds.extents.sub(viewHalfSize);
      const rotMatrix = targetMaxBounds.getRotationMatrix(cache4.matrix4[0]);
      const localTarget = cache4.vector3[1].copy(constrained.target).sub(targetMaxBounds.position).applyMatrix4(cache4.matrix4[1].copy(rotMatrix).transpose()).setZ(0);
      const constrainedLocalTarget = cache4.vector3[2].copy(localTarget).clamp(cache4.vector3[3].copy(targetMaxBounds.extents).multiplyScalar(-1), targetMaxBounds.extents);
      if (constrainedLocalTarget.equals(localTarget)) {
        return unconstrained;
      }
      constrained.target.copy(constrainedLocalTarget).applyMatrix4(rotMatrix).add(targetMaxBounds.position);
      const targetHeightSq = targetMaxBounds.position.lengthSq();
      const constTargetDistSq = constrained.target.distanceToSquared(targetMaxBounds.position);
      const constTargetDistToGround = Math.sqrt(targetHeightSq) - Math.sqrt(targetHeightSq - constTargetDistSq);
      constrained.target.addScaledVector(targetMaxBounds.zAxis, -constTargetDistToGround);
      constrained.target.setLength(unconstrained.target.length());
    }
    MapViewUtils2.panCameraAroundGlobe(mapView, cache4.vector3[1].copy(constrained.target), cache4.vector3[2].copy(unconstrained.target));
    camera.getWorldDirection(camera.position).multiplyScalar(-constrained.distance).add(constrained.target);
    return constrained;
  }
  MapViewUtils2.constrainTargetAndDistanceToViewBounds = constrainTargetAndDistanceToViewBounds;
  function getTargetAndDistance(projection, camera, elevationProvider) {
    const cameraPitch = extractAttitude({ projection }, camera).pitch;
    const elevation = elevationProvider ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL) : void 0;
    const final = !elevationProvider || elevation !== void 0;
    const target = cameraPitch < MapViewUtils2.MAX_TILT_RAD ? getWorldTargetFromCamera(camera, projection, elevation) : null;
    if (target !== null) {
      const distance = camera.position.distanceTo(target);
      return { target, distance, final };
    } else {
      const groundDistance = projection.groundDistance(camera.position);
      const heightAboveTerrain = Math.max(groundDistance - (elevation ?? 0), 0);
      const distance = projection.type === 0 /* Planar */ ? heightAboveTerrain / Math.cos(Math.min(cameraPitch, MapViewUtils2.MAX_TILT_RAD)) : Math.sqrt(Math.pow(heightAboveTerrain + EarthConstants.EQUATORIAL_RADIUS, 2) - Math.pow(EarthConstants.EQUATORIAL_RADIUS, 2));
      const cameraDir2 = camera.getWorldDirection(cache4.vector3[0]);
      cameraDir2.multiplyScalar(distance);
      const fallbackTarget = cache4.vector3[1];
      fallbackTarget.copy(camera.position).add(cameraDir2);
      return { target: fallbackTarget, distance, final };
    }
  }
  MapViewUtils2.getTargetAndDistance = getTargetAndDistance;
  function getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, projection, result = new THREE97.Vector3()) {
    const pitchRad = THREE97.MathUtils.degToRad(pitchDeg);
    const altitude = Math.cos(pitchRad) * distance;
    const yawRad = THREE97.MathUtils.degToRad(yawDeg);
    projection.projectPoint(targetCoordinates, result);
    const groundDistance = distance * Math.sin(pitchRad);
    if (projection.type === 0 /* Planar */) {
      result.x = result.x + Math.sin(yawRad) * groundDistance;
      result.y = result.y - Math.cos(yawRad) * groundDistance;
      result.z = result.z + altitude;
    } else if (projection.type === 1 /* Spherical */) {
      tangentSpace.z.copy(result).normalize();
      tangentSpace.y.set(0, 0, 1).projectOnPlane(tangentSpace.z).normalize();
      cache4.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);
      tangentSpace.y.applyQuaternion(cache4.quaternions[0]);
      tangentSpace.y.setLength(groundDistance);
      const height = distance * Math.cos(pitchRad);
      result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));
      const a = EarthConstants.EQUATORIAL_RADIUS + altitude;
      const b = Math.sin(pitchRad) * distance;
      const cameraHeight = Math.sqrt(a * a + b * b);
      result.setLength(cameraHeight);
    }
    return result;
  }
  MapViewUtils2.getCameraPositionFromTargetCoordinates = getCameraPositionFromTargetCoordinates;
  function wrapGeoPointsToScreen(points, startPosition) {
    let startIndex = 0;
    if (startPosition === void 0) {
      startPosition = GeoCoordinates.fromObject(points[0]);
      startIndex = 1;
    }
    let north = startPosition.latitude;
    let south = startPosition.latitude;
    let lonCenter = MathUtils3.normalizeLongitudeDeg(startPosition.longitude);
    let lonSpan = 0;
    let east = startPosition.longitude;
    let west = startPosition.longitude;
    const result = [];
    result.push(new GeoCoordinates(north, lonCenter));
    for (let i = startIndex; i < points.length; i++) {
      const p = GeoCoordinates.fromObject(points[i]);
      if (p.latitude > north) {
        north = p.latitude;
      } else if (p.latitude < south) {
        south = p.latitude;
      }
      let longitude = MathUtils3.normalizeLongitudeDeg(p.longitude);
      const relToCenter = MathUtils3.angleDistanceDeg(lonCenter, longitude);
      longitude = lonCenter - relToCenter;
      if (relToCenter < 0 && -relToCenter > lonSpan / 2) {
        east = Math.max(east, lonCenter - relToCenter);
        lonSpan = east - west;
        lonCenter = (east + west) / 2;
      } else if (relToCenter > 0 && relToCenter > lonSpan / 2) {
        west = Math.min(west, longitude);
        lonSpan = east - west;
        lonCenter = (east + west) / 2;
      }
      result.push(new GeoCoordinates(p.latitude, longitude));
    }
    return result;
  }
  MapViewUtils2.wrapGeoPointsToScreen = wrapGeoPointsToScreen;
  function wrapWorldPointsToView(points, cameraPos) {
    const cameraPosNormalized = cameraPos.clone().normalize();
    for (const point of points) {
      if (point.angleTo(cameraPos) > Math.PI / 2) {
        const pointLen = point.length();
        point.projectOnPlane(cameraPosNormalized).setLength(pointLen);
      }
    }
  }
  MapViewUtils2.wrapWorldPointsToView = wrapWorldPointsToView;
  function geoBoxToGeoPoints(box) {
    const center = box.center;
    return [
      new GeoCoordinates(box.north, box.west),
      new GeoCoordinates(box.north, box.east),
      new GeoCoordinates(center.latitude, box.west),
      new GeoCoordinates(center.latitude, box.east),
      new GeoCoordinates(box.south, box.west),
      new GeoCoordinates(box.south, box.east),
      new GeoCoordinates(box.north, center.longitude),
      new GeoCoordinates(box.south, center.longitude)
    ];
  }
  MapViewUtils2.geoBoxToGeoPoints = geoBoxToGeoPoints;
  function getFitBoundsDistance(points, worldTarget, camera) {
    const targetDist = cache4.vector3[0].copy(worldTarget).sub(camera.position).length();
    const ppalPoint = CameraUtils.getPrincipalPoint(camera);
    let newDistance = targetDist;
    const getDistanceFactor = (pointNDC, ppNDC) => {
      const maxNDC = 0.99;
      return Math.abs(pointNDC) > 1 ? Math.abs((pointNDC - ppNDC) / (maxNDC * Math.sign(pointNDC) - ppNDC)) : 1;
    };
    for (const point of points) {
      const pEyeZ = -cache4.vector3[0].copy(point).applyMatrix4(camera.matrixWorldInverse).z;
      const pointNDC = cache4.vector3[0].applyMatrix4(camera.projectionMatrix);
      const maxFactor = Math.max(getDistanceFactor(pointNDC.x, ppalPoint.x), getDistanceFactor(pointNDC.y, ppalPoint.y));
      if (maxFactor > 1) {
        const constDist = targetDist - pEyeZ;
        const newPEyeZ = Math.abs(pEyeZ) * maxFactor + constDist;
        newDistance = Math.max(newDistance, newPEyeZ);
      }
    }
    return newDistance;
  }
  MapViewUtils2.getFitBoundsDistance = getFitBoundsDistance;
  function getFitBoundsLookAtParams(geoTarget, worldTarget, worldPoints, params) {
    const { tilt, heading, projection } = params;
    const startDistance = params.minDistance;
    const tmpCamera2 = params.camera.clone();
    getCameraRotationAtTarget(projection, geoTarget, -heading, tilt, tmpCamera2.quaternion);
    getCameraPositionFromTargetCoordinates(geoTarget, startDistance, -heading, tilt, projection, tmpCamera2.position);
    tmpCamera2.updateMatrixWorld(true);
    if (projection.type === 1 /* Spherical */) {
      wrapWorldPointsToView(worldPoints, tmpCamera2.position);
    }
    const distance = getFitBoundsDistance(worldPoints, worldTarget, tmpCamera2);
    return {
      target: geoTarget,
      distance,
      heading,
      tilt
    };
  }
  MapViewUtils2.getFitBoundsLookAtParams = getFitBoundsLookAtParams;
  function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {
    return mapView.projection.unprojectPoint(getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView.projection, cache4.vector3[1]));
  }
  MapViewUtils2.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;
  function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {
    const pointInNDCPosition = cache4.vector3[0].set(pointOnScreenXinNDC, pointOnScreenYinNDC, 0);
    mapView.camera.updateMatrixWorld();
    const cameraPos = cache4.vector3[1].copy(mapView.camera.position);
    cache4.matrix4[0].extractRotation(mapView.camera.matrixWorld);
    cache4.matrix4[1].multiplyMatrices(cache4.matrix4[0], cache4.matrix4[1].copy(mapView.camera.projectionMatrix).invert());
    const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache4.matrix4[1]);
    rayCaster.set(cameraPos, pointInCameraSpace.normalize());
    if (elevation !== void 0) {
      groundPlane.constant -= elevation;
      groundSphere.radius += elevation;
    }
    const worldPosition = new THREE97.Vector3();
    const result = mapView.projection.type === 0 /* Planar */ ? rayCaster.ray.intersectPlane(groundPlane, worldPosition) : rayCaster.ray.intersectSphere(groundSphere, worldPosition);
    if (elevation !== void 0) {
      groundPlane.constant = 0;
      groundSphere.radius = EarthConstants.EQUATORIAL_RADIUS;
    }
    return result;
  }
  MapViewUtils2.rayCastWorldCoordinates = rayCastWorldCoordinates;
  function panCameraAboveFlatMap(mapView, offsetX, offsetY) {
    mapView.camera.position.x += offsetX;
    mapView.camera.position.y += offsetY;
  }
  MapViewUtils2.panCameraAboveFlatMap = panCameraAboveFlatMap;
  function panCameraAroundGlobe(mapView, fromWorld, toWorld) {
    cache4.quaternions[0].setFromUnitVectors(fromWorld.normalize(), toWorld.normalize()).invert();
    cache4.matrix4[0].makeRotationFromQuaternion(cache4.quaternions[0]);
    mapView.camera.applyMatrix4(cache4.matrix4[0]);
    mapView.camera.updateMatrixWorld();
  }
  MapViewUtils2.panCameraAroundGlobe = panCameraAroundGlobe;
  function rotate(mapView, deltaYawDeg, deltaPitchDeg = 0, maxTiltAngleRad = Math.PI / 4) {
    mapView.camera.rotateOnWorldAxis(mapView.projection.type === 1 /* Spherical */ ? cache4.vector3[0].copy(mapView.camera.position).normalize() : cache4.vector3[0].set(0, 0, 1), THREE97.MathUtils.degToRad(-deltaYawDeg));
    mapView.camera.updateMatrixWorld();
    if (deltaPitchDeg === 0) {
      return;
    }
    const pitch = MapViewUtils2.extractAttitude(mapView, mapView.camera).pitch;
    let newPitch = THREE97.MathUtils.clamp(pitch + THREE97.MathUtils.degToRad(deltaPitchDeg), 0, maxTiltAngleRad);
    if (mapView.projection.type === 1 /* Spherical */) {
      const maxPitch = Math.asin(EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad) / mapView.camera.position.length());
      newPitch = Math.min(newPitch, maxPitch);
    }
    mapView.camera.rotateX(newPitch - pitch);
  }
  MapViewUtils2.rotate = rotate;
  function getCameraRotationAtTarget(projection, target, yawDeg, pitchDeg, result = new THREE97.Quaternion()) {
    const transform = cache4.transforms[0];
    projection.localTangentSpace(target, transform);
    cache4.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
    result.setFromRotationMatrix(cache4.matrix4[0]);
    cache4.quaternions[0].setFromAxisAngle(cache4.vector3[1].set(0, 0, 1), THREE97.MathUtils.degToRad(yawDeg));
    cache4.quaternions[1].setFromAxisAngle(cache4.vector3[1].set(1, 0, 0), THREE97.MathUtils.degToRad(pitchDeg));
    result.multiply(cache4.quaternions[0]);
    result.multiply(cache4.quaternions[1]);
    return result;
  }
  MapViewUtils2.getCameraRotationAtTarget = getCameraRotationAtTarget;
  function setRotation(mapView, yawDeg, pitchDeg) {
    getCameraRotationAtTarget(mapView.projection, mapView.geoCenter, yawDeg, pitchDeg, mapView.camera.quaternion);
  }
  MapViewUtils2.setRotation = setRotation;
  function extractCameraTilt(camera, projection) {
    if (projection.type === 0 /* Planar */) {
      const lookAt = camera.getWorldDirection(cache4.vector3[0]).normalize();
      const normal = projection.surfaceNormal(camera.position, cache4.vector3[1]).negate();
      const cosTheta = lookAt.dot(normal);
      return Math.acos(THREE97.MathUtils.clamp(cosTheta, -1, 1));
    } else {
      assert(projection.type === 1 /* Spherical */);
      const targetGeoCoords = MapViewUtils2.getGeoTargetFromCamera(camera, projection);
      if (targetGeoCoords !== null) {
        return MapViewUtils2.extractTiltAngleFromLocation(projection, camera, targetGeoCoords);
      } else {
        logger28.warn("MapView camera is pointing in the void, using maxTilt: ", MapViewUtils2.MAX_TILT_RAD);
        return MapViewUtils2.MAX_TILT_RAD;
      }
    }
  }
  MapViewUtils2.extractCameraTilt = extractCameraTilt;
  function extractAttitude(mapView, object) {
    cache4.vector3[1].setFromMatrixPosition(object.matrixWorld);
    mapView.projection.localTangentSpace(cache4.vector3[1], {
      xAxis: tangentSpace.x,
      yAxis: tangentSpace.y,
      zAxis: tangentSpace.z,
      position: cache4.vector3[0]
    });
    cache4.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);
    cache4.matrix4[0].copy(cache4.matrix4[1]).invert().multiply(object.matrixWorld);
    space.x.setFromMatrixColumn(cache4.matrix4[0], 0);
    space.y.setFromMatrixColumn(cache4.matrix4[0], 1);
    space.z.setFromMatrixColumn(cache4.matrix4[0], 2);
    let yaw = 0;
    let pitch = 0;
    let roll = 0;
    const d = space.z.dot(cache4.vector3[1].set(0, 0, 1));
    if (d < 1 - Number.EPSILON) {
      if (d > -1 + Number.EPSILON) {
        yaw = Math.atan2(space.z.x, -space.z.y);
        pitch = Math.acos(space.z.z);
        roll = Math.atan2(space.x.z, space.y.z);
      } else {
        yaw = -Math.atan2(-space.y.x, space.x.x);
        pitch = 180;
        roll = 0;
      }
    } else {
      yaw = Math.atan2(-space.y.x, space.x.x);
      pitch = 0;
      roll = 0;
    }
    return {
      yaw,
      pitch,
      roll
    };
  }
  MapViewUtils2.extractAttitude = extractAttitude;
  function extractSphericalCoordinatesFromLocation(mapView, object, location) {
    mapView.projection.localTangentSpace(location, {
      xAxis: tangentSpace.x,
      yAxis: tangentSpace.y,
      zAxis: tangentSpace.z,
      position: cache4.vector3[0]
    });
    let tilt = 0;
    let azimuth = 0;
    cache4.vector3[1].copy(object.position).sub(cache4.vector3[0]).normalize();
    if (cache4.vector3[1].dot(tangentSpace.z) > 1 - Number.EPSILON) {
      azimuth = Math.PI - extractAttitude(mapView, object).yaw;
      azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));
      tilt = 0;
      return { tilt, azimuth };
    }
    tilt = cache4.vector3[1].angleTo(tangentSpace.z);
    cache4.vector3[1].copy(object.position).sub(cache4.vector3[0]).projectOnPlane(tangentSpace.z).normalize();
    azimuth = cache4.vector3[1].angleTo(tangentSpace.y);
    if (cache4.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {
      azimuth = -azimuth;
    }
    return { tilt, azimuth };
  }
  MapViewUtils2.extractSphericalCoordinatesFromLocation = extractSphericalCoordinatesFromLocation;
  function extractTiltAngleFromLocation(projection, object, location, tiltAxis) {
    projection.localTangentSpace(location, {
      xAxis: tangentSpace.x,
      yAxis: tangentSpace.y,
      zAxis: tangentSpace.z,
      position: cache4.vector3[0]
    });
    const dirVec = cache4.vector3[2].copy(object.position).sub(cache4.vector3[0]);
    if (tiltAxis) {
      dirVec.projectOnPlane(tiltAxis);
      tangentSpace.z.projectOnPlane(tiltAxis).normalize();
    }
    const dirLen = dirVec.length();
    if (dirLen < epsilon2) {
      logger28.error("Can not calculate tilt for the zero length vector!");
      return 0;
    }
    dirVec.divideScalar(dirLen);
    const cosTheta = dirVec.dot(tangentSpace.z);
    if (cosTheta >= 1 - Number.EPSILON) {
      return 0;
    }
    return Math.acos(THREE97.MathUtils.clamp(cosTheta, -1, 1));
  }
  MapViewUtils2.extractTiltAngleFromLocation = extractTiltAngleFromLocation;
  function getCameraFrustumPlanes(camera) {
    const near = camera.near;
    const far = camera.far;
    let top = near * Math.tan(THREE97.MathUtils.degToRad(0.5 * camera.fov)) / camera.zoom;
    let height = 2 * top;
    let width = camera.aspect * height;
    let left = -0.5 * width;
    const view = camera.view;
    if (view !== null && view.enabled) {
      const fullWidth = view.fullWidth;
      const fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    left += camera.filmOffset !== 0 ? near * camera.filmOffset / camera.getFilmWidth() : 0;
    return {
      left,
      right: left + width,
      top,
      bottom: top - height,
      near,
      far
    };
  }
  MapViewUtils2.getCameraFrustumPlanes = getCameraFrustumPlanes;
  function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {
    const worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);
    if (!worldCoordinates) {
      return null;
    }
    return mapView.projection.unprojectPoint(worldCoordinates);
  }
  MapViewUtils2.rayCastGeoCoordinates = rayCastGeoCoordinates;
  function calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel) {
    const cameraPitch = extractAttitude(mapView, mapView.camera).pitch;
    const tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
    return mapView.focalLength * tileSize / 256 * Math.cos(cameraPitch);
  }
  MapViewUtils2.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;
  function calculateDistanceFromZoomLevel(options, zoomLevel) {
    const tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
    return options.focalLength * tileSize / 256;
  }
  MapViewUtils2.calculateDistanceFromZoomLevel = calculateDistanceFromZoomLevel;
  function calculateZoomLevelFromDistance(options, distance) {
    const tileSize = 256 * distance / options.focalLength;
    const zoomLevel = THREE97.MathUtils.clamp(Math.log2(EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), options.minZoomLevel, options.maxZoomLevel);
    return snapToCeilingZoomLevel(zoomLevel);
  }
  MapViewUtils2.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;
  function calculateDepthFromClipDistance(clipDistance, camera) {
    const perspCam = camera;
    const cameraRange = perspCam.far - perspCam.near;
    const viewSpaceDistance = clipDistance * perspCam.far;
    return (1 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);
  }
  MapViewUtils2.calculateDepthFromClipDistance = calculateDepthFromClipDistance;
  function cameraToWorldDistance2(distance, camera) {
    const perspCam = camera;
    return distance * perspCam.far;
  }
  MapViewUtils2.cameraToWorldDistance = cameraToWorldDistance2;
  function calculateVerticalFovByHorizontalFov(hFov, aspect) {
    return 2 * Math.atan(Math.tan(hFov / 2) / aspect);
  }
  MapViewUtils2.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;
  function calculateHorizontalFovByVerticalFov(vFov, aspect) {
    tmpCamera.fov = THREE97.MathUtils.radToDeg(vFov);
    tmpCamera.aspect = aspect;
    return CameraUtils.getHorizontalFov(tmpCamera);
  }
  MapViewUtils2.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;
  function calculateFocalLengthByVerticalFov(vFov, height) {
    CameraUtils.setPrincipalPoint(tmpCamera, new THREE97.Vector2());
    CameraUtils.setVerticalFov(tmpCamera, vFov, height);
    return CameraUtils.getFocalLength(tmpCamera);
  }
  MapViewUtils2.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;
  function calculateFovByFocalLength(focalLength, height) {
    CameraUtils.setPrincipalPoint(tmpCamera, new THREE97.Vector2());
    CameraUtils.setFocalLength(tmpCamera, focalLength, height);
    return tmpCamera.fov;
  }
  MapViewUtils2.calculateFovByFocalLength = calculateFovByFocalLength;
  MapViewUtils2.calculateScreenSizeByFocalLength = CameraUtils.convertWorldToScreenSize;
  MapViewUtils2.calculateWorldSizeByFocalLength = CameraUtils.convertScreenToWorldSize;
  MapViewUtils2.estimateObject3dSize = Object3DUtils.estimateSize;
  function mapViewIsLoading(mapView) {
    let numTilesLoading = 0;
    for (const tileList of mapView.visibleTileSet.dataSourceTileList) {
      numTilesLoading += tileList.numTilesLoading;
      for (const tile of tileList.visibleTiles) {
        if (!tile.allGeometryLoaded) {
          numTilesLoading++;
        }
      }
    }
    let isLoading = numTilesLoading > 0;
    if (mapView.textElementsRenderer !== void 0) {
      isLoading = isLoading || mapView.textElementsRenderer.loading;
    }
    isLoading = isLoading || !mapView.poiTableManager.finishedLoading || !mapView.visibleTileSet.allVisibleTilesLoaded;
    return isLoading;
  }
  MapViewUtils2.mapViewIsLoading = mapViewIsLoading;
  function closeToFrustum(point, camera, eps = 1e-13) {
    const ndcPoint = new THREE97.Vector3().copy(point).project(camera);
    if (Math.abs(ndcPoint.x) - eps < 1 && Math.abs(ndcPoint.y) - eps < 1 && Math.abs(ndcPoint.z) - eps < 1) {
      return true;
    }
    return false;
  }
  MapViewUtils2.closeToFrustum = closeToFrustum;
  MapViewUtils2.getBrowserLanguages = DOMUtils.getBrowserLanguages;
})(MapViewUtils || (MapViewUtils = {}));
var TileOffsetUtils;
((TileOffsetUtils2) => {
  TileOffsetUtils2.getKeyForTileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset;
  TileOffsetUtils2.extractOffsetAndMortonKeyFromKey = TileKeyUtils.extractOffsetAndMortonKeyFromKey;
  TileOffsetUtils2.getParentKeyFromKey = TileKeyUtils.getParentKeyFromKey;
})(TileOffsetUtils || (TileOffsetUtils = {}));

// src/mapview/PlaneViewBounds.ts
var PlaneViewBounds = class {
  constructor(camera, projection, m_options) {
    this.camera = camera;
    this.projection = projection;
    this.m_options = m_options;
    assert(projection.type === 0 /* Planar */);
  }
  m_groundPlaneNormal = new import_three14.Vector3(0, 0, 1);
  m_groundPlane = new import_three14.Plane(this.m_groundPlaneNormal.clone());
  generate() {
    const coordinates = [];
    this.addCanvasCornerIntersection(coordinates);
    if (coordinates.length === 4) {
      return this.createPolygon(coordinates);
    }
    this.addHorizonIntersection(coordinates);
    const frustum = new import_three14.Frustum().setFromProjectionMatrix(new import_three14.Matrix4().multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse));
    const worldCorners = this.getWorldConers(this.projection);
    if (!this.m_options.tileWrappingEnabled) {
      ;
      [worldCorners.ne, worldCorners.nw, worldCorners.se, worldCorners.sw].forEach((corner) => {
        this.addPointInFrustum(corner, frustum, coordinates);
      });
    }
    if (!this.m_options.tileWrappingEnabled) {
      ;
      [
        new import_three14.Line3(worldCorners.sw, worldCorners.se),
        new import_three14.Line3(worldCorners.ne, worldCorners.nw),
        new import_three14.Line3(worldCorners.se, worldCorners.ne),
        new import_three14.Line3(worldCorners.nw, worldCorners.sw)
      ].forEach((edge) => {
        this.addFrustumIntersection(edge, frustum, coordinates);
      });
    } else {
      const directionEast = new import_three14.Vector3().subVectors(worldCorners.sw, worldCorners.se).normalize();
      const directionWest = new import_three14.Vector3().subVectors(worldCorners.se, worldCorners.sw).normalize();
      [
        new import_three14.Ray(worldCorners.se, directionEast),
        new import_three14.Ray(worldCorners.se, directionWest),
        new import_three14.Ray(worldCorners.ne, directionEast),
        new import_three14.Ray(worldCorners.ne, directionWest)
      ].forEach((ray) => {
        this.addFrustumIntersection(ray, frustum, coordinates);
      });
    }
    return this.createPolygon(coordinates);
  }
  createPolygon(coordinates) {
    if (coordinates.length > 2) {
      return new GeoPolygon(coordinates, true);
    }
    return void 0;
  }
  getWorldConers(projection) {
    const worldBox = projection.worldExtent(0, 0);
    return {
      sw: worldBox.min,
      se: new import_three14.Vector3(worldBox.max.x, worldBox.min.y, 0),
      nw: new import_three14.Vector3(worldBox.min.x, worldBox.max.y, 0),
      ne: worldBox.max
    };
  }
  addNDCRayIntersection(ndcPoints, geoPolygon) {
    ndcPoints.forEach((corner) => {
      const intersection = MapViewUtils.rayCastWorldCoordinates({ camera: this.camera, projection: this.projection }, corner[0], corner[1]);
      if (intersection) {
        this.validateAndAddToGeoPolygon(intersection, geoPolygon);
      }
    });
  }
  addHorizonIntersection(geoPolygon) {
    const verticalHorizonPosition = this.getVerticalHorizonPositionInNDC();
    if (!verticalHorizonPosition) {
      return;
    }
    this.addNDCRayIntersection([
      [-1, verticalHorizonPosition],
      [1, verticalHorizonPosition]
    ], geoPolygon);
  }
  addCanvasCornerIntersection(geoPolygon) {
    this.addNDCRayIntersection([
      [-1, -1],
      [1, -1],
      [1, 1],
      [-1, 1]
    ], geoPolygon);
  }
  validateAndAddToGeoPolygon(point, geoPolygon) {
    if (this.isInVisibleMap(point)) {
      geoPolygon.push(this.projection.unprojectPoint(point));
    }
  }
  isInVisibleMap(point) {
    if (point.y < 0 || point.y > EarthConstants.EQUATORIAL_CIRCUMFERENCE) {
      return false;
    }
    if (!this.m_options.tileWrappingEnabled && (point.x < 0 || point.x > EarthConstants.EQUATORIAL_CIRCUMFERENCE)) {
      return false;
    }
    return true;
  }
  addPointInFrustum(point, frustum, geoPolygon) {
    if (frustum.containsPoint(point)) {
      const geoPoint = this.projection.unprojectPoint(point);
      geoPoint.altitude = 0;
      geoPolygon.push(geoPoint);
    }
  }
  addFrustumIntersection(edge, frustum, geoPolygon) {
    frustum.planes.forEach((plane) => {
      let intersection = null;
      const target = new import_three14.Vector3();
      if (edge instanceof import_three14.Ray && edge.intersectsPlane(plane)) {
        intersection = edge.intersectPlane(plane, target);
      } else if (edge instanceof import_three14.Line3 && plane.intersectsLine(edge)) {
        intersection = plane.intersectLine(edge, target);
      }
      if (intersection) {
        if (MapViewUtils.closeToFrustum(intersection, this.camera)) {
          const geoIntersection = this.projection.unprojectPoint(intersection);
          geoIntersection.altitude = 0;
          geoPolygon.push(geoIntersection);
        }
      }
    });
  }
  getVerticalHorizonPositionInNDC() {
    const bottomMidFarPoint = new import_three14.Vector3(-1, -1, 1).unproject(this.camera).add(new import_three14.Vector3(1, -1, 1).unproject(this.camera)).multiplyScalar(0.5);
    const topMidFarPoint = new import_three14.Vector3(-1, 1, 1).unproject(this.camera).add(new import_three14.Vector3(1, 1, 1).unproject(this.camera)).multiplyScalar(0.5);
    const farPlaneVerticalCenterLine = new import_three14.Line3(bottomMidFarPoint, topMidFarPoint);
    const verticalHorizonPosition = new import_three14.Vector3();
    if (!this.m_groundPlane.intersectLine(farPlaneVerticalCenterLine, verticalHorizonPosition)) {
      return void 0;
    }
    return verticalHorizonPosition.project(this.camera).y;
  }
};

// src/mapview/SphereViewBounds.ts
var import_three15 = require("three");

// src/mapview/SphereHorizon.ts
var THREE98 = __toESM(require("three"));
var twoPi = Math.PI * 2;
function nextCanvasSide(side) {
  return (side + 1) % 4;
}
function previousCanvasSide(side) {
  return (side + 3) % 4;
}
var SphereHorizon = class {
  constructor(m_camera, m_cornerIntersects) {
    this.m_camera = m_camera;
    this.m_cornerIntersects = m_cornerIntersects;
    const earthRadiusSq = EarthConstants.EQUATORIAL_RADIUS * EarthConstants.EQUATORIAL_RADIUS;
    const xAxis = new THREE98.Vector3().setFromMatrixColumn(m_camera.matrixWorld, 0).normalize();
    const zAxis = m_camera.position.clone().normalize();
    const yAxis = new THREE98.Vector3().crossVectors(zAxis, xAxis);
    const cameraHeight = m_camera.position.length();
    this.m_normalToTangentAngle = Math.asin(EarthConstants.EQUATORIAL_RADIUS / cameraHeight);
    const tangentDistance = Math.sqrt(cameraHeight * cameraHeight - earthRadiusSq);
    this.m_distanceToHorizonCenter = tangentDistance * Math.cos(this.m_normalToTangentAngle);
    const horizonCenterLength = cameraHeight - this.m_distanceToHorizonCenter;
    this.m_radius = Math.sqrt(earthRadiusSq - horizonCenterLength * horizonCenterLength);
    this.m_cameraPitch = MapViewUtils.extractAttitude({ projection: sphereProjection }, this.m_camera).pitch;
    const horizonCenter = new THREE98.Vector3().copy(zAxis).setLength(horizonCenterLength);
    this.m_matrix = new THREE98.Matrix4().makeBasis(xAxis, yAxis, zAxis).setPosition(horizonCenter);
    this.computeIntersections();
  }
  m_matrix;
  m_radius;
  m_normalToTangentAngle;
  m_distanceToHorizonCenter;
  m_intersections = [];
  m_isFullyVisible = true;
  m_cameraPitch;
  getPoint(t, arcStart = 0, arcEnd = 1, target = new THREE98.Vector3()) {
    const startAngle = arcStart * twoPi;
    const endAngle = arcEnd >= arcStart ? arcEnd * twoPi : (arcEnd + 1) * twoPi;
    const deltaAngle = endAngle - startAngle;
    const angle = startAngle + t * deltaAngle;
    target.set(this.m_radius * Math.cos(angle), this.m_radius * Math.sin(angle), 0);
    target.applyMatrix4(this.m_matrix);
    return target;
  }
  getDivisionPoints(callback, tStart = 0, tEnd = 1, maxNumPoints = 10) {
    const numPoints = Math.max(Math.ceil(((tEnd < tStart ? 1 + tEnd : tEnd) - tStart) * maxNumPoints), 1);
    for (let d = 0; d < numPoints; d++) {
      callback(this.getPoint(d / numPoints, tStart, tEnd));
    }
  }
  get isFullyVisible() {
    return this.m_isFullyVisible;
  }
  getSideIntersections(side) {
    return this.m_intersections[side];
  }
  isTangentVisible(side) {
    switch (side) {
      case 2 /* Top */: {
        const eyeToTangentAngle = this.m_normalToTangentAngle - this.m_cameraPitch;
        return CameraUtils.getTopFov(this.m_camera) >= Math.abs(eyeToTangentAngle);
      }
      case 0 /* Bottom */: {
        const eyeToTangentAngle = this.m_normalToTangentAngle + this.m_cameraPitch;
        return CameraUtils.getBottomFov(this.m_camera) >= Math.abs(eyeToTangentAngle);
      }
      case 3 /* Left */: {
        const eyeToTangentAngle = this.m_normalToTangentAngle;
        return CameraUtils.getLeftFov(this.m_camera) >= Math.abs(eyeToTangentAngle) && this.m_cameraPitch <= CameraUtils.getBottomFov(this.m_camera);
      }
      case 1 /* Right */: {
        const eyeToTangentAngle = this.m_normalToTangentAngle;
        return CameraUtils.getRightFov(this.m_camera) >= Math.abs(eyeToTangentAngle) && this.m_cameraPitch <= CameraUtils.getBottomFov(this.m_camera);
      }
    }
  }
  getTangentOnSide(side) {
    switch (side) {
      case 0 /* Bottom */:
        return 0.75;
      case 1 /* Right */:
        return 0;
      case 2 /* Top */:
        return 0.25;
      case 3 /* Left */:
        return 0.5;
    }
  }
  computeIntersections() {
    const yBottom = this.m_distanceToHorizonCenter * Math.tan(this.m_cameraPitch - CameraUtils.getBottomFov(this.m_camera));
    let tTopRight;
    let tBottomRight;
    for (let side = 0 /* Bottom */; side < 4; side++) {
      if (this.isTangentVisible(side)) {
        this.m_intersections.push([this.getTangentOnSide(side)]);
        continue;
      }
      const sideIntersections = new Array();
      this.m_isFullyVisible = false;
      switch (side) {
        case 0 /* Bottom */: {
          sideIntersections.push(...this.computeTBIntersections(yBottom));
          break;
        }
        case 1 /* Right */: {
          const rightFov = CameraUtils.getRightFov(this.m_camera);
          const intersections = this.computeLRIntersections(yBottom, rightFov);
          if (intersections) {
            ;
            [tTopRight, tBottomRight] = intersections;
            sideIntersections.push(tBottomRight !== void 0 ? 1 + tBottomRight : void 0, tTopRight);
          }
          break;
        }
        case 2 /* Top */: {
          const yTop = this.m_distanceToHorizonCenter * Math.tan(this.m_cameraPitch + CameraUtils.getTopFov(this.m_camera));
          sideIntersections.push(...this.computeTBIntersections(yTop).reverse());
          break;
        }
        case 3 /* Left */: {
          const leftFov = CameraUtils.getLeftFov(this.m_camera);
          if (leftFov === CameraUtils.getRightFov(this.m_camera)) {
            sideIntersections.push(tTopRight !== void 0 ? 0.5 - tTopRight : void 0, tBottomRight !== void 0 ? 0.5 - tBottomRight : void 0);
          } else {
            const isections = this.computeLRIntersections(yBottom, leftFov);
            if (isections) {
              sideIntersections.push(0.5 - isections[0], isections[1] !== void 0 ? 0.5 - isections[1] : void 0);
            }
          }
          break;
        }
      }
      const hasCorners = [
        this.m_cornerIntersects[side],
        this.m_cornerIntersects[nextCanvasSide(side)]
      ];
      this.m_intersections.push(sideIntersections.filter((val, i) => val !== void 0 && !hasCorners[i]));
    }
  }
  computeTBIntersections(y) {
    const radiusSq = this.m_radius * this.m_radius;
    const x = Math.sqrt(radiusSq - y * y);
    const t = Math.atan2(y, x) / twoPi;
    return [0.5 - t, t > 0 ? t : 1 + t];
  }
  computeLRIntersections(yBottom, sideFov) {
    const eyeToHorizon = this.m_distanceToHorizonCenter / Math.cos(this.m_cameraPitch);
    const yMiddle = this.m_distanceToHorizonCenter * Math.tan(this.m_cameraPitch);
    const xMiddle = eyeToHorizon * Math.tan(sideFov);
    const bottomFov = CameraUtils.getBottomFov(this.m_camera);
    const eyeToBottom = this.m_distanceToHorizonCenter * Math.cos(bottomFov) / Math.cos(this.m_cameraPitch - bottomFov);
    const xBottom = xMiddle * eyeToBottom / eyeToHorizon;
    const intersections = Math2D.intersectLineAndCircle(xBottom, yBottom, xMiddle, yMiddle, this.m_radius);
    if (!intersections) {
      return void 0;
    }
    const yTopRight = intersections.y1;
    const tTop = Math.atan2(yTopRight, intersections.x1) / twoPi;
    const hasBottomIntersection = -yTopRight >= yBottom && intersections.x2 !== void 0;
    const tBottom = hasBottomIntersection ? Math.atan2(intersections.y2, intersections.x2) / twoPi : void 0;
    return [tTop, tBottom];
  }
};

// src/mapview/SphereViewBounds.ts
function computeEdgeDivisions(geoStart, geoEnd) {
  const maxLatitudeSpan = 20;
  const maxLongitudeSpan = 5;
  const latitudeSpan = Math.abs(geoEnd.latitude - geoStart.latitude);
  const longitudeSpan = geoStart.minLongitudeSpanTo(geoEnd);
  return Math.ceil(Math.max(latitudeSpan / maxLatitudeSpan, longitudeSpan / maxLongitudeSpan));
}
var ccwCanvasCornersNDC = [
  { x: -1, y: -1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 }
];
var SphereViewBounds = class {
  constructor(camera, projection) {
    this.camera = camera;
    this.projection = projection;
    assert(projection.type === 1 /* Spherical */);
  }
  generate() {
    const coordinates = this.findBoundsIntersections();
    this.wrapAroundPoles(coordinates);
    return coordinates.length > 2 ? new GeoPolygon(coordinates, false, true) : void 0;
  }
  addSideSegmentSubdivisions(coordinates, NDCStart, NDCEnd, geoStart, geoEnd) {
    coordinates.push(geoStart);
    const divisionCount = computeEdgeDivisions(geoStart, geoEnd);
    if (divisionCount <= 1) {
      return;
    }
    const NDCStep = new import_three15.Vector2(NDCEnd.x - NDCStart.x, NDCEnd.y - NDCStart.y).multiplyScalar(1 / divisionCount);
    const NDCDivision = new import_three15.Vector2(NDCStart.x, NDCStart.y);
    for (let i = 0; i < divisionCount - 1; i++) {
      NDCDivision.add(NDCStep);
      const intersection = MapViewUtils.rayCastWorldCoordinates({ camera: this.camera, projection: this.projection }, NDCDivision.x, NDCDivision.y);
      if (intersection) {
        coordinates.push(this.projection.unprojectPoint(intersection));
      }
    }
  }
  addSideIntersections(coordinates, side, geoStartCorner, geoEndCorner, horizon) {
    const startNDCCorner = ccwCanvasCornersNDC[side];
    const endNDCCorner = ccwCanvasCornersNDC[nextCanvasSide(side)];
    if (geoStartCorner && geoEndCorner) {
      this.addSideSegmentSubdivisions(coordinates, startNDCCorner, endNDCCorner, geoStartCorner, geoEndCorner);
      return;
    }
    if (!horizon) {
      return;
    }
    const horizonIntersections = horizon.getSideIntersections(side);
    if (horizonIntersections.length === 0) {
      return;
    }
    if (geoStartCorner) {
      const worldHorizonPoint = horizon.getPoint(horizonIntersections[horizonIntersections.length - 1]);
      const geoHorizonPoint = this.projection.unprojectPoint(worldHorizonPoint);
      this.addSideSegmentSubdivisions(coordinates, startNDCCorner, worldHorizonPoint.project(this.camera), geoStartCorner, geoHorizonPoint);
    } else {
      const prevSide = previousCanvasSide(side);
      let prevSideIntersections = horizon.getSideIntersections(prevSide);
      if (prevSideIntersections.length === 0) {
        prevSideIntersections = horizon.getSideIntersections(previousCanvasSide(prevSide));
      }
      assert(prevSideIntersections.length > 0);
      horizon.getDivisionPoints((point) => {
        coordinates.push(this.projection.unprojectPoint(point));
      }, prevSideIntersections[prevSideIntersections.length - 1], horizonIntersections[0]);
    }
    if (horizonIntersections.length > 1) {
      const worldHorizonStart = horizon.getPoint(horizonIntersections[0]);
      const worldHorizonEnd = horizon.getPoint(horizonIntersections[1]);
      const geoHorizonStart = this.projection.unprojectPoint(worldHorizonStart);
      const geoHorizonEnd = this.projection.unprojectPoint(worldHorizonEnd);
      this.addSideSegmentSubdivisions(coordinates, worldHorizonStart.project(this.camera), worldHorizonEnd.project(this.camera), geoHorizonStart, geoHorizonEnd);
    }
    if (geoEndCorner) {
      const worldHorizonPoint = horizon.getPoint(horizonIntersections[0]);
      const geoHorizonPoint = this.projection.unprojectPoint(worldHorizonPoint);
      this.addSideSegmentSubdivisions(coordinates, worldHorizonPoint.project(this.camera), endNDCCorner, geoHorizonPoint, geoEndCorner);
    }
  }
  findBoundsIntersections() {
    const coordinates = [];
    const [cornerCoordinates, numCorners] = this.addCanvasCornerIntersection();
    const horizon = numCorners < 4 ? new SphereHorizon(this.camera, cornerCoordinates.map((value2) => value2 !== void 0)) : void 0;
    if (numCorners === 0 && horizon.isFullyVisible) {
      horizon.getDivisionPoints((point) => {
        coordinates.push(this.projection.unprojectPoint(point));
      });
      return coordinates;
    }
    for (let side = 0 /* Bottom */; side < 4; side++) {
      const startCorner = cornerCoordinates[side];
      const endCorner = cornerCoordinates[nextCanvasSide(side)];
      this.addSideIntersections(coordinates, side, startCorner, endCorner, horizon);
    }
    return coordinates;
  }
  wrapAroundPoles(coordinates) {
    const northPoleCenter = new import_three15.Vector3(0, 0, EarthConstants.EQUATORIAL_RADIUS);
    const southPoleCenter = new import_three15.Vector3(0, 0, -EarthConstants.EQUATORIAL_RADIUS);
    const northPoleInView = MapViewUtils.closeToFrustum(northPoleCenter, this.camera);
    const southPoleInView = MapViewUtils.closeToFrustum(southPoleCenter, this.camera);
    if (!northPoleInView && !southPoleInView) {
      return;
    }
    const camLon = this.projection.unprojectPoint(this.camera.position).lng;
    const wrapLat = northPoleInView ? 90 : -90;
    const wrapLon = northPoleInView ? camLon + 180 : camLon - 180;
    const geoWrapTopRight = new GeoCoordinates(wrapLat, wrapLon);
    const geoWrapTopRightNorm = geoWrapTopRight.normalized();
    const crossLon = geoWrapTopRightNorm.lng;
    let prevLon = coordinates[coordinates.length - 1].lng;
    let isGwAntimerCross = false;
    const hSphereCrossEndIndex = coordinates.findIndex((value2) => {
      const crossesAntimer = isAntimeridianCrossing(prevLon, value2.lng);
      const sameSign = Math.sign(crossLon - value2.lng) === Math.sign(crossLon - prevLon);
      if (sameSign === crossesAntimer) {
        isGwAntimerCross = crossesAntimer;
        return true;
      }
      prevLon = value2.lng;
      return false;
    });
    if (hSphereCrossEndIndex < 0) {
      return;
    }
    const wrapSideOffset = northPoleInView ? 90 : -90;
    const wrapCornerOffset = northPoleInView ? 1e-5 : -1e-5;
    const geoWrapRight = new GeoCoordinates(wrapLat, camLon + wrapSideOffset).normalized();
    const geoWrapBottom = new GeoCoordinates(wrapLat, camLon).normalized();
    const geoWrapLeft = new GeoCoordinates(wrapLat, camLon - wrapSideOffset).normalized();
    const geoWrapTopLeft = new GeoCoordinates(wrapLat, wrapLon + wrapCornerOffset).normalized();
    const hSphereCrossStartIndex = (hSphereCrossEndIndex + coordinates.length - 1) % coordinates.length;
    const crossStart = coordinates[hSphereCrossStartIndex];
    const crossEnd = coordinates[hSphereCrossEndIndex];
    let crossLerp = GeoCoordinates.lerp(crossStart, crossEnd, 0.01, isGwAntimerCross);
    if (isGwAntimerCross && northPoleInView) {
      crossLerp.longitude -= 360;
    } else {
      crossLerp = crossLerp.normalized();
    }
    coordinates.splice(hSphereCrossEndIndex, 0, wrapLon < -180 ? geoWrapTopRight : geoWrapTopRightNorm, geoWrapRight, geoWrapBottom, geoWrapLeft, geoWrapTopLeft, crossLerp);
  }
  addCanvasCornerIntersection() {
    const geoCorners = new Array();
    let numIntersections = 0;
    ccwCanvasCornersNDC.forEach((corner) => {
      const intersection = MapViewUtils.rayCastWorldCoordinates({ camera: this.camera, projection: this.projection }, corner.x, corner.y);
      if (intersection) {
        geoCorners.push(this.projection.unprojectPoint(intersection));
        ++numIntersections;
      } else {
        geoCorners.push(void 0);
      }
    });
    return [geoCorners, numIntersections];
  }
};

// src/mapview/BoundsGenerator.ts
var BoundsGenerator = class {
  constructor(m_view) {
    this.m_view = m_view;
    this.createViewBounds();
  }
  m_viewBounds;
  generate() {
    if (this.m_view.projection !== this.m_viewBounds.projection) {
      this.createViewBounds();
    }
    return this.m_viewBounds.generate();
  }
  createViewBounds() {
    this.m_viewBounds = this.m_view.projection.type === 0 /* Planar */ ? new PlaneViewBounds(this.m_view.camera, this.m_view.projection, this.m_view) : new SphereViewBounds(this.m_view.camera, this.m_view.projection);
  }
};

// src/mapview/WorkerBasedTiler.ts
var nextUniqueServiceId2 = 0;
var WorkerBasedTiler = class {
  constructor(workerSet, tilerServiceType) {
    this.workerSet = workerSet;
    this.tilerServiceType = tilerServiceType;
    this.workerSet.addReference();
    this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId2++}`;
  }
  serviceId;
  m_serviceCreated = false;
  dispose() {
    if (this.m_serviceCreated) {
      this.workerSet.broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
        type: WorkerServiceProtocol.Requests.DestroyService,
        targetServiceId: this.serviceId
      }).catch(() => {
      });
    }
    this.workerSet.removeReference();
  }
  async connect() {
    await this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
    if (!this.m_serviceCreated) {
      await this.workerSet.broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
        type: WorkerServiceProtocol.Requests.CreateService,
        targetServiceType: this.tilerServiceType,
        targetServiceId: this.serviceId
      });
      this.m_serviceCreated = true;
    }
  }
  registerIndex(indexId, input) {
    const message = {
      type: WorkerTilerProtocol.Requests.RegisterIndex,
      id: indexId,
      input: input instanceof URL ? input.href : input
    };
    return this.workerSet.invokeRequest(this.serviceId, message);
  }
  updateIndex(indexId, input) {
    const message = {
      type: WorkerTilerProtocol.Requests.UpdateIndex,
      id: indexId,
      input: input instanceof URL ? input.href : input
    };
    return this.workerSet.invokeRequest(this.serviceId, message);
  }
  getTile(indexId, tileKey) {
    const tileKeyCode = tileKey.mortonCode();
    const message = {
      type: WorkerTilerProtocol.Requests.TileRequest,
      index: indexId,
      tileKey: tileKeyCode
    };
    return this.workerSet.invokeRequest(this.serviceId, message);
  }
};

// src/mapview/ConcurrentTilerFacade.ts
var _ConcurrentTilerFacade = class {
  static getTiler(tilerServiceType, scriptUrl, workerCount, workerConnectionTimeout) {
    const workerSet = this.getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout);
    return new WorkerBasedTiler(workerSet, tilerServiceType);
  }
  static getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout) {
    if (scriptUrl === void 0) {
      scriptUrl = this.defaultScriptUrl;
    }
    let workerSet = this.workerSets[scriptUrl];
    if (workerSet === void 0) {
      const workerConnectionTimeoutInMs = workerConnectionTimeout !== void 0 ? workerConnectionTimeout * 1e3 : void 0;
      workerSet = new ConcurrentWorkerSet({
        scriptUrl,
        workerCount: workerCount ?? this.defaultWorkerCount,
        workerConnectionTimeout: workerConnectionTimeoutInMs
      });
      this.workerSets[scriptUrl] = workerSet;
    }
    return workerSet;
  }
  static destroyWorkerSet(scriptUrl) {
    const workerSet = this.workerSets[scriptUrl];
    if (workerSet !== void 0) {
      workerSet.destroy();
      delete this.workerSets[scriptUrl];
    }
  }
  static destroy() {
    Object.keys(this.workerSets).forEach((name2) => {
      this.workerSets[name2].destroy();
    });
    this.workerSets = {};
  }
  static destroyIfTerminated() {
    let allWorkerSetsTerminated = true;
    Object.keys(this.workerSets).forEach((name2) => {
      if (!this.workerSets[name2].terminated) {
        allWorkerSetsTerminated = false;
      }
    });
    if (allWorkerSetsTerminated) {
      _ConcurrentTilerFacade.destroy();
    }
  }
};
var ConcurrentTilerFacade = _ConcurrentTilerFacade;
__publicField(ConcurrentTilerFacade, "defaultScriptUrl", "./decoder.bundle.js");
__publicField(ConcurrentTilerFacade, "defaultWorkerCount", 1);
__publicField(ConcurrentTilerFacade, "workerSets", {});

// src/mapview/copyrights/CopyrightElementHandler.ts
var CopyrightElementHandler = class {
  static install(element, mapView) {
    return new CopyrightElementHandler(element, mapView);
  }
  staticInfo;
  m_defaults = /* @__PURE__ */ new Map();
  m_element;
  m_mapViews = [];
  constructor(element, mapView) {
    if (typeof element === "string") {
      const htmlElement = document.getElementById(element);
      if (!htmlElement) {
        throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);
      }
      this.m_element = htmlElement;
    } else {
      this.m_element = element;
    }
    if (mapView !== void 0) {
      this.attach(mapView);
    }
  }
  destroy() {
    for (const mapView of this.m_mapViews) {
      mapView.removeEventListener("copyright-changed" /* CopyrightChanged */, this.update);
    }
  }
  attach(mapView) {
    this.m_mapViews.push(mapView);
    mapView.addEventListener("copyright-changed" /* CopyrightChanged */, this.update);
    this.update();
    return this;
  }
  detach(mapView) {
    mapView.removeEventListener("copyright-changed" /* CopyrightChanged */, this.update);
    this.m_mapViews = this.m_mapViews.filter((item) => item !== mapView);
    this.update();
    return this;
  }
  setDefaults(defaults) {
    this.m_defaults.clear();
    if (defaults !== void 0) {
      for (const item of defaults) {
        this.m_defaults.set(item.id, item);
      }
    }
    return this;
  }
  setStaticCopyightInfo(staticInfo) {
    this.staticInfo = staticInfo;
    return this;
  }
  update = () => {
    const mergedCopyrightInfo = this.m_mapViews.map((mapView) => mapView.copyrightInfo).reduce(CopyrightInfo.mergeArrays, this.staticInfo ?? []);
    if (mergedCopyrightInfo.length === 0) {
      this.m_element.style.display = "none";
      return;
    } else {
      this.m_element.style.display = "block";
    }
    if (this.m_defaults.size !== 0) {
      for (const sourceInfo of mergedCopyrightInfo) {
        const defaults = this.m_defaults.get(sourceInfo.id);
        if (defaults !== void 0) {
          sourceInfo.year = getOptionValue(sourceInfo.year, defaults.year);
          sourceInfo.label = getOptionValue(sourceInfo.label, defaults.label);
          sourceInfo.link = getOptionValue(sourceInfo.link, defaults.link);
        }
      }
    }
    const deduped = CopyrightInfo.mergeArrays(mergedCopyrightInfo);
    this.m_element.innerHTML = CopyrightInfo.formatAsHtml(deduped);
  };
};

// src/mapview/copyrights/CopyrightCoverageProvider.ts
var RBush2 = require("rbush");
var CopyrightCoverageProvider = class {
  logger = LoggerManager.instance.create("CopyrightCoverageProvider");
  m_cachedTreePromise;
  getTree() {
    if (this.m_cachedTreePromise !== void 0) {
      return this.m_cachedTreePromise;
    }
    this.m_cachedTreePromise = this.getCopyrightCoverageData().then((coverageInfo) => this.initRBush(coverageInfo)).catch((error) => {
      this.logger.error(error);
      return new RBush2();
    });
    return this.m_cachedTreePromise;
  }
  async getCopyrights(geoBox, level) {
    const tree = await this.getTree();
    const result = [];
    const matchingEntries = tree.search({
      minX: geoBox.west,
      minY: geoBox.south,
      maxX: geoBox.east,
      maxY: geoBox.north
    });
    for (const entry of matchingEntries) {
      const minLevel = getOptionValue(entry.minLevel, 0);
      const maxLevel = getOptionValue(entry.maxLevel, Infinity);
      if (level >= minLevel && level <= maxLevel) {
        if (result.find((item) => item.id === entry.label) === void 0) {
          result.push({ id: entry.label });
        }
      }
    }
    return result;
  }
  initRBush(entries) {
    const tree = new RBush2();
    if (!entries) {
      this.logger.warn("No copyright coverage data provided");
      return tree;
    }
    for (const entry of entries) {
      const { minLevel, maxLevel, label, alt } = entry;
      if (!entry.boxes) {
        tree.insert({
          minX: -180,
          minY: -90,
          maxX: 180,
          maxY: 180,
          minLevel,
          maxLevel,
          label,
          alt
        });
      } else {
        for (const box of entry.boxes) {
          const [minY, minX, maxY, maxX] = box;
          tree.insert({
            minX,
            minY,
            maxX,
            maxY,
            minLevel,
            maxLevel,
            label,
            alt
          });
        }
      }
    }
    return tree;
  }
};

// src/transfer-manager/DeferredPromise.ts
var DeferredPromise = class {
  constructor(executor) {
    this.executor = executor;
    this.promise = new Promise((resolve, reject) => {
      this.resolveFunc = resolve;
      this.rejectFunc = reject;
    });
  }
  promise;
  resolveFunc;
  rejectFunc;
  exec() {
    this.executor().then((result) => this.resolveFunc(result)).catch((error) => this.rejectFunc(error));
  }
};

// src/transfer-manager/TransferManager.ts
var _TransferManager = class {
  constructor(fetchFunction = fetch, maxRetries = 5) {
    this.fetchFunction = fetchFunction;
    this.maxRetries = maxRetries;
  }
  static instance() {
    return _TransferManager.defaultInstance;
  }
  static async fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {
    try {
      if (retryCount < maxRetries) {
        const response = await fetchFunction(url, init);
        if (response.status === 200 || response.status === 204) {
          return response;
        } else if (response.status >= 400 && response.status < 500) {
          retryCount = maxRetries;
          const responseText = await response.text();
          throw new Error(responseText);
        }
      } else {
        throw new Error("Max number of retries reached");
      }
    } catch (err) {
      if (err.hasOwnProperty("isCancelled") || err.name === "AbortError" || retryCount >= maxRetries) {
        throw err;
      }
    }
    return await _TransferManager.waitFor(_TransferManager.retryTimeout * retryCount).then(() => _TransferManager.fetchRepeatedly(fetchFunction, retryCount + 1, maxRetries, url, init));
  }
  static waitFor(milliseconds) {
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
  }
  activeDownloadCount = 0;
  downloadQueue = new Array();
  activeDownloads = /* @__PURE__ */ new Map();
  downloadJson(url, init) {
    return this.downloadAs((response) => response.json(), url, init);
  }
  downloadArrayBuffer(url, init) {
    return this.download(url, init).then((response) => response.arrayBuffer());
  }
  download(url, init) {
    if (this.activeDownloadCount >= _TransferManager.maxParallelDownloads) {
      const deferred = new DeferredPromise(() => this.doDownload(url, init));
      this.downloadQueue.push(deferred);
      return deferred.promise;
    }
    return this.doDownload(url, init);
  }
  async doDownload(url, init) {
    try {
      ++this.activeDownloadCount;
      const response = await _TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init);
      this.onDownloadDone();
      return response;
    } catch (error) {
      this.onDownloadDone();
      throw error;
    }
  }
  onDownloadDone() {
    --this.activeDownloadCount;
    this.execDeferredDownload();
  }
  execDeferredDownload() {
    const future = this.downloadQueue.pop();
    if (future === void 0) {
      return;
    }
    future.exec();
  }
  downloadAs(converter, url, init) {
    const cacheKey = url;
    const pendingFetch = this.activeDownloads.get(cacheKey);
    if (pendingFetch !== void 0) {
      return Promise.resolve(pendingFetch);
    }
    const newFetch = this.download(url, init).then((response) => {
      this.activeDownloads.delete(cacheKey);
      if (response.ok) {
        return converter(response);
      }
      throw new Error(JSON.stringify(response));
    }).catch((err) => {
      this.activeDownloads.delete(cacheKey);
      throw err;
    });
    this.activeDownloads.set(cacheKey, newFetch);
    return newFetch;
  }
};
var TransferManager = _TransferManager;
__publicField(TransferManager, "retryTimeout", 500);
__publicField(TransferManager, "maxParallelDownloads", 16);
__publicField(TransferManager, "defaultInstance", new _TransferManager());

// src/mapview/copyrights/UrlCopyrightProvider.ts
var UrlCopyrightProvider = class extends CopyrightCoverageProvider {
  constructor(m_fetchURL, m_baseScheme, m_requestHeaders, m_transferManager = TransferManager.instance()) {
    super();
    this.m_fetchURL = m_fetchURL;
    this.m_baseScheme = m_baseScheme;
    this.m_requestHeaders = m_requestHeaders;
    this.m_transferManager = m_transferManager;
  }
  m_cachedCopyrightResponse;
  setRequestHeaders(headers) {
    this.m_requestHeaders = headers;
  }
  getCopyrightCoverageData(abortSignal) {
    if (this.m_cachedCopyrightResponse !== void 0) {
      return this.m_cachedCopyrightResponse;
    }
    this.m_cachedCopyrightResponse = this.m_transferManager.downloadJson(this.m_fetchURL, {
      headers: this.m_requestHeaders,
      signal: abortSignal
    }).then((json) => json[this.m_baseScheme]).catch((error) => {
      this.logger.error(error);
      return [];
    });
    return this.m_cachedCopyrightResponse;
  }
};

// src/mapview/FixedClipPlanesEvaluator.ts
var FixedClipPlanesEvaluator = class {
  constructor(minNear = 1, minFarOffset = 10) {
    this.minNear = minNear;
    this.minFarOffset = minFarOffset;
    this.minFar = minNear + minFarOffset;
    this.m_nearPlane = minNear;
    this.m_farPlane = this.minFar;
  }
  minFar;
  m_nearPlane;
  m_farPlane;
  get nearPlane() {
    return this.m_nearPlane;
  }
  set nearPlane(fixedNear) {
    this.invalidatePlanes(fixedNear, this.m_farPlane);
  }
  get farPlane() {
    return this.m_farPlane;
  }
  set farPlane(fixedFar) {
    this.invalidatePlanes(this.m_nearPlane, fixedFar);
  }
  set minElevation(elevation) {
  }
  get minElevation() {
    return 0;
  }
  set maxElevation(elevation) {
  }
  get maxElevation() {
    return 0;
  }
  evaluateClipPlanes(camera, projection, elevationProvider) {
    const viewRanges = {
      near: this.m_nearPlane,
      far: this.m_farPlane,
      minimum: this.minNear,
      maximum: this.m_farPlane
    };
    return viewRanges;
  }
  invalidatePlanes(near, far) {
    const nearDist = Math.max(this.minNear, near);
    const farDist = Math.max(this.minFar, far, nearDist + this.minFarOffset);
    this.m_nearPlane = nearDist;
    this.m_farPlane = farDist;
  }
};

// src/mapview/MapViewAtmosphere.ts
var THREE99 = __toESM(require("three"));
var AtmosphereLightMode = /* @__PURE__ */ ((AtmosphereLightMode2) => {
  AtmosphereLightMode2[AtmosphereLightMode2["LightOverhead"] = 0] = "LightOverhead";
  AtmosphereLightMode2[AtmosphereLightMode2["LightDynamic"] = 1] = "LightDynamic";
  return AtmosphereLightMode2;
})(AtmosphereLightMode || {});
var SKY_ATMOSPHERE_ALTITUDE_FACTOR = 0.025;
var GROUND_ATMOSPHERE_ALTITUDE_FACTOR = 1e-4;
var cache5 = {
  clipPlanes: { near: 0, far: 0 }
};
var _MapViewAtmosphere = class {
  constructor(m_mapAnchors, m_sceneCamera, m_projection, m_rendererCapabilities, m_updateCallback, m_atmosphereVariant = 3 /* SkyAndGround */, m_materialVariant = 0 /* ScatteringShader */) {
    this.m_mapAnchors = m_mapAnchors;
    this.m_sceneCamera = m_sceneCamera;
    this.m_projection = m_projection;
    this.m_rendererCapabilities = m_rendererCapabilities;
    this.m_updateCallback = m_updateCallback;
    this.m_atmosphereVariant = m_atmosphereVariant;
    this.m_materialVariant = m_materialVariant;
    if (this.m_atmosphereVariant & 2 /* Sky */) {
      this.createSkyGeometry();
    }
    if (this.m_atmosphereVariant & 1 /* Ground */) {
      this.createGroundGeometry();
    }
    this.addToMapAnchors(this.m_mapAnchors);
  }
  static isPresent(mapAnchors) {
    for (const mapAnchor of mapAnchors.children) {
      if (mapAnchor.name === _MapViewAtmosphere.SkyAtmosphereUserName || mapAnchor.name === _MapViewAtmosphere.GroundAtmosphereUserName) {
        return true;
      }
    }
    return false;
  }
  m_enabled = true;
  m_skyGeometry;
  m_skyMaterial;
  m_skyMesh;
  m_groundGeometry;
  m_groundMaterial;
  m_groundMesh;
  m_clipPlanesEvaluator = new TiltViewClipPlanesEvaluator(EarthConstants.EQUATORIAL_RADIUS * SKY_ATMOSPHERE_ALTITUDE_FACTOR, 0, 1, 0.05, 1e7);
  m_lightDirection = new THREE99.Vector3(0, 1, 0);
  get skyMesh() {
    return this.m_skyMesh;
  }
  get groundMesh() {
    return this.m_groundMesh;
  }
  set enabled(enable) {
    if (this.disposed) {
      return;
    }
    if (this.m_enabled === enable) {
      return;
    }
    this.m_enabled = enable;
    const isAdded = _MapViewAtmosphere.isPresent(this.m_mapAnchors);
    if (enable && !isAdded) {
      this.addToMapAnchors(this.m_mapAnchors);
    } else if (!enable && isAdded) {
      this.removeFromMapAnchors(this.m_mapAnchors);
    }
  }
  get enabled() {
    return this.m_enabled;
  }
  set lightMode(lightMode) {
    if (this.m_materialVariant !== 0 /* ScatteringShader */) {
      return;
    }
    const dynamicLight = lightMode === 1 /* LightDynamic */;
    if (this.m_groundMaterial !== void 0) {
      const groundMat = this.m_groundMaterial;
      groundMat.setDynamicLighting(dynamicLight);
    }
    if (this.m_skyMaterial !== void 0) {
      const skyMat = this.m_skyMaterial;
      skyMat.setDynamicLighting(dynamicLight);
    }
  }
  dispose() {
    var _a, _b, _c, _d;
    if (this.enabled) {
      this.enabled = false;
    }
    (_a = this.m_skyMaterial) == null ? void 0 : _a.dispose();
    (_b = this.m_groundMaterial) == null ? void 0 : _b.dispose();
    (_c = this.m_skyGeometry) == null ? void 0 : _c.dispose();
    (_d = this.m_groundGeometry) == null ? void 0 : _d.dispose();
    this.m_skyGeometry = void 0;
    this.m_groundGeometry = void 0;
    this.m_skyMaterial = void 0;
    this.m_groundMaterial = void 0;
    this.m_skyMesh = void 0;
    this.m_groundMesh = void 0;
  }
  reset(theme) {
  }
  get disposed() {
    return this.m_skyMesh === void 0 && this.m_groundMesh === void 0;
  }
  addToMapAnchors(mapAnchors) {
    assert(!_MapViewAtmosphere.isPresent(mapAnchors), "Atmosphere already added");
    if (this.m_skyMesh !== void 0) {
      mapAnchors.add(createMapAnchor(this.m_skyMesh, Number.MIN_SAFE_INTEGER));
    }
    if (this.m_groundMesh !== void 0) {
      mapAnchors.add(createMapAnchor(this.m_groundMesh, Number.MAX_SAFE_INTEGER));
    }
    if (this.m_updateCallback) {
      this.m_updateCallback();
    }
  }
  removeFromMapAnchors(mapAnchors) {
    if (!_MapViewAtmosphere.isPresent(mapAnchors)) {
      return;
    }
    let update = false;
    if (this.m_skyMesh !== void 0) {
      mapAnchors.remove(this.m_skyMesh);
      update = true;
    }
    if (this.m_groundMesh !== void 0) {
      mapAnchors.remove(this.m_groundMesh);
      update = true;
    }
    if (update && this.m_updateCallback) {
      this.m_updateCallback();
    }
  }
  createSkyGeometry() {
    switch (this.m_projection.type) {
      case 1 /* Spherical */:
        this.m_skyGeometry = new THREE99.SphereGeometry(EarthConstants.EQUATORIAL_RADIUS * (1 + SKY_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);
        break;
      default: {
        this.m_skyGeometry = new THREE99.PlaneGeometry(200, 200);
        break;
      }
    }
    this.m_skyGeometry.translate(0, 0, 0);
    if (this.m_materialVariant === 0 /* ScatteringShader */) {
      this.m_skyMaterial = new SkyAtmosphereMaterial({
        rendererCapabilities: this.m_rendererCapabilities
      });
    } else if (this.m_materialVariant === 1 /* SimpleColor */) {
      this.m_skyMaterial = new THREE99.MeshBasicMaterial({
        color: new THREE99.Color(12908781),
        opacity: 0.4,
        transparent: false,
        depthTest: true,
        depthWrite: false,
        side: THREE99.BackSide,
        blending: THREE99.NormalBlending,
        fog: false
      });
    } else {
      this.m_skyMaterial = new THREE99.MeshStandardMaterial({
        color: 8388607,
        depthTest: false,
        depthWrite: false,
        normalScale: new THREE99.Vector2(-1, -1),
        side: THREE99.BackSide,
        wireframe: true
      });
    }
    this.m_skyMesh = new THREE99.Mesh(this.m_skyGeometry, this.m_skyMaterial);
    this.m_skyMesh.name = _MapViewAtmosphere.SkyAtmosphereUserName;
    this.setupSkyForRendering();
  }
  createGroundGeometry() {
    switch (this.m_projection.type) {
      case 1 /* Spherical */:
        this.m_groundGeometry = new THREE99.SphereGeometry(EarthConstants.EQUATORIAL_RADIUS * (1 + GROUND_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);
        break;
      default: {
        this.m_groundGeometry = new THREE99.PlaneGeometry(200, 200);
        break;
      }
    }
    this.m_groundGeometry.translate(0, 0, 0);
    if (this.m_materialVariant === 0 /* ScatteringShader */) {
      this.m_groundMaterial = new GroundAtmosphereMaterial({
        rendererCapabilities: this.m_rendererCapabilities
      });
    } else if (this.m_materialVariant === 1 /* SimpleColor */) {
      this.m_groundMaterial = new THREE99.MeshBasicMaterial({
        color: new THREE99.Color(50687),
        opacity: 0.4,
        transparent: true,
        depthTest: false,
        depthWrite: false,
        side: THREE99.FrontSide,
        blending: THREE99.NormalBlending,
        fog: false
      });
    } else {
      this.m_groundMaterial = new THREE99.MeshStandardMaterial({
        color: 1149338,
        depthTest: true,
        depthWrite: false,
        side: THREE99.FrontSide,
        wireframe: true
      });
    }
    this.m_groundMesh = new THREE99.Mesh(this.m_groundGeometry, this.m_groundMaterial);
    this.m_groundMesh.name = _MapViewAtmosphere.GroundAtmosphereUserName;
    this.setupGroundForRendering();
  }
  setupSkyForRendering() {
    if (this.m_skyMesh === void 0) {
      return;
    }
    let onBeforeCallback;
    if (this.m_materialVariant !== 0 /* ScatteringShader */) {
      onBeforeCallback = (camera, _material) => {
        this.overrideClipPlanes(camera);
      };
    } else {
      onBeforeCallback = (camera, material) => {
        this.overrideClipPlanes(camera);
        assert(material instanceof SkyAtmosphereMaterial);
        const mat = this.m_skyMaterial;
        mat.updateUniforms(mat, this.m_skyMesh, camera, this.m_lightDirection);
      };
    }
    assert(this.m_skyMaterial !== void 0);
    this.m_skyMesh.onBeforeRender = (_renderer, _scene, camera, _geometry, material, _group) => {
      onBeforeCallback(camera, material);
    };
    this.m_skyMesh.onAfterRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
      this.revertClipPlanes(camera);
    };
  }
  setupGroundForRendering() {
    if (this.m_groundMesh === void 0) {
      return;
    }
    if (this.m_materialVariant !== 0 /* ScatteringShader */) {
      return;
    }
    assert(this.m_groundMaterial !== void 0);
    this.m_groundMesh.onBeforeRender = (_renderer, _scene, camera, _geometry, material, _group) => {
      assert(material instanceof GroundAtmosphereMaterial);
      const mat = this.m_groundMaterial;
      mat.updateUniforms(mat, this.m_groundMesh, camera, this.m_lightDirection);
    };
  }
  overrideClipPlanes(rteCamera) {
    const sceneCam = this.m_sceneCamera;
    cache5.clipPlanes.near = sceneCam.near;
    cache5.clipPlanes.far = sceneCam.far;
    const viewRanges = this.m_clipPlanesEvaluator.evaluateClipPlanes(this.m_sceneCamera, this.m_projection);
    assert(rteCamera instanceof THREE99.PerspectiveCamera);
    const c = rteCamera;
    c.near = viewRanges.near;
    c.far = viewRanges.far + EarthConstants.EQUATORIAL_RADIUS * 0.1;
    c.updateProjectionMatrix();
  }
  revertClipPlanes(rteCamera) {
    assert(rteCamera instanceof THREE99.PerspectiveCamera);
    const c = rteCamera;
    c.near = cache5.clipPlanes.near;
    c.far = cache5.clipPlanes.far;
    c.updateProjectionMatrix();
  }
};
var MapViewAtmosphere = _MapViewAtmosphere;
__publicField(MapViewAtmosphere, "SkyAtmosphereUserName", "SkyAtmosphere");
__publicField(MapViewAtmosphere, "GroundAtmosphereUserName", "GroundAtmosphere");
function createMapAnchor(mesh, renderOrder) {
  const anchor = mesh;
  anchor.renderOrder = renderOrder;
  anchor.pickable = false;
  anchor.anchor = new THREE99.Vector3(0, 0, 0);
  return anchor;
}

// src/mapview/TextureLoader.ts
var THREE100 = __toESM(require("three"));
var TextureLoader5 = class {
  m_textureLoader = new THREE100.TextureLoader();
  async load(url, requestHeaders, abortSignal, crossOrigin = true) {
    if (requestHeaders === void 0) {
      return await this.loadWithThreeLoader(url);
    }
    const response = await fetch(url, {
      headers: requestHeaders,
      signal: abortSignal,
      mode: crossOrigin ? "cors" : "no-cors"
    });
    const blob = await response.blob();
    const texture = await this.loadWithThreeLoader(URL.createObjectURL(blob));
    const isJPEG = blob.type === "image/jpeg/" || url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
    texture.format = isJPEG ? THREE100.RGBFormat : THREE100.RGBAFormat;
    return texture;
  }
  loadWithThreeLoader(url) {
    return new Promise((resolve, reject) => {
      this.m_textureLoader.setCrossOrigin("");
      this.m_textureLoader.load(url, (texture) => resolve(texture), void 0, () => reject(new Error("failed to load texture")));
    });
  }
};

// src/lines/HighPrecisionLines.ts
var THREE103 = __toESM(require("three"));

// src/lines/HighPrecisionUtils.ts
var import_three16 = require("three");

// src/lines/HighPrecisionPoints.ts
var THREE101 = __toESM(require("three"));
var HighPrecisionPoints = class extends THREE101.Points {
  matrixWorldInverse;
  dimensionality;
  constructor(geometry, material, positions, color, opacity) {
    if (material === void 0) {
      material = new HighPrecisionPointMaterial({
        color: color ? color : HighPrecisionPointMaterial.DEFAULT_COLOR,
        opacity: opacity !== void 0 ? opacity : 1
      });
    }
    super(geometry === void 0 ? new THREE101.BufferGeometry() : geometry, material);
    this.matrixWorldInverse = new THREE101.Matrix4();
    if (positions) {
      this.setPositions(positions);
    }
  }
  get bufferGeometry() {
    return this.geometry;
  }
  clearGeometry() {
    return this.geometry = new THREE101.BufferGeometry();
  }
  get shaderMaterial() {
    return this.material;
  }
  setPositions(positions) {
    HighPrecisionUtils.setPositions(this, positions);
  }
  setupForRendering() {
    if (this.material.isHighPrecisionPointsMaterial && this.dimensionality !== void 0) {
      ;
      this.material.setDimensionality(this.dimensionality);
    }
    this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
      HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
    };
  }
  updateMatrixWorld(force) {
    const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
    super.updateMatrixWorld(force);
    if (doUpdateMatrixWorldInverse) {
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }
};

// src/lines/TriangulateLines.ts
var THREE102 = __toESM(require("three"));
var UNIT_Z = new THREE102.Vector3(0, 0, 1);
var POINTS = [0, 1, 2, 1, 3, 2];
var BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];
var SECTORS_IN_CIRCLE = 8;
var STEP = Math.PI / SECTORS_IN_CIRCLE;
function addCircle(x, y, lineAngle, radius, vertices, indices) {
  const baseVertex = vertices.length / 3;
  vertices.push(x, y, 0);
  for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {
    const angle = STEP * i + Math.PI / 2 + lineAngle;
    vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);
    indices.push(baseVertex, baseVertex + i + 1, baseVertex + (i + 1) % (SECTORS_IN_CIRCLE + 1) + 1);
  }
}
function triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {
  if (points.length < 3) {
    return;
  }
  const angleVec = new THREE102.Vector2();
  if (startWithCircle) {
    const lineAngle = points.length !== 3 ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle() : 0;
    addCircle(points[0], points[1], lineAngle, width, vertices, indices);
  }
  const baseVertex = vertices.length / 3;
  const prevBt = new THREE102.Vector3();
  const p = new THREE102.Vector3();
  const n = new THREE102.Vector3();
  const bt = new THREE102.Vector3();
  const averageBt = new THREE102.Vector3();
  const p0 = new THREE102.Vector3();
  const p1 = new THREE102.Vector3();
  const p2 = new THREE102.Vector3();
  const p3 = new THREE102.Vector3();
  const N = points.length / 3;
  let vertexOffset = 0;
  for (let i = 0; i < N; ++i) {
    let useBevel = false;
    p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);
    if (i + 1 < N) {
      n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);
      bt.copy(n).sub(p).normalize().cross(UNIT_Z);
      averageBt.copy(bt);
      if (i > 0) {
        averageBt.add(prevBt).multiplyScalar(1 - 0.5 * bt.dot(prevBt));
        useBevel = prevBt.angleTo(bt) > Math.PI / 2;
        if (useBevel) {
          const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);
          p0.copy(bt).add(prevBt).normalize().multiplyScalar(-inclineWidth).add(p);
          p1.copy(prevBt).multiplyScalar(width).add(p);
          p2.copy(bt).add(prevBt).normalize().multiplyScalar(inclineWidth).add(p);
          p3.copy(bt).multiplyScalar(width).add(p);
        }
      }
      if (useBevel) {
        vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
      } else {
        p0.copy(averageBt).multiplyScalar(-width).add(p);
        p1.copy(averageBt).multiplyScalar(width).add(p);
        vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
      }
      prevBt.copy(bt);
    } else {
      p0.copy(prevBt).multiplyScalar(-width).add(p);
      p1.copy(prevBt).multiplyScalar(width).add(p);
      vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
    }
    if (i !== N - 1) {
      ;
      (useBevel ? BEVEL_POINTS : POINTS).forEach((o) => indices.push(baseVertex + vertexOffset + o));
      vertexOffset += useBevel ? 4 : 2;
    }
  }
  if (endWithCircle) {
    const lineAngle = points.length !== 2 ? angleVec.set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1]).angle() : Math.PI;
    addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);
  }
}
function reconstructLineWidth(inBuffer, startIndex) {
  const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];
  const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];
  const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];
  return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;
}

// src/lines/HighPrecisionUtils.ts
var HighPrecisionUtils;
((HighPrecisionUtils2) => {
  function doubleToFloatVec(v) {
    return new import_three16.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));
  }
  HighPrecisionUtils2.doubleToFloatVec = doubleToFloatVec;
  function makeFloatVec(v) {
    const majorX = Math.fround(v.x);
    const majorY = Math.fround(v.y);
    const majorZ = Math.fround(v.z);
    const minorVec = new import_three16.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);
    v.x = Math.fround(majorX);
    v.y = Math.fround(majorY);
    v.z = Math.fround(majorZ);
    return minorVec;
  }
  HighPrecisionUtils2.makeFloatVec = makeFloatVec;
  function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {
    const _projScreenMatrix = new import_three16.Matrix4().copy(camera.projectionMatrix);
    const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);
    const eyePos = new import_three16.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);
    const eyePosFloat = doubleToFloatVec(eyePos);
    const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));
    return {
      viewProjection: mvp,
      eyePosHi: eyePosFloat,
      eyePosLo
    };
  }
  HighPrecisionUtils2.createHighPrecisionCameraPos = createHighPrecisionCameraPos;
  function updateHpUniforms(object, camera, shaderMaterial) {
    const highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);
    const mvp = highPrecisionCameraInfo.viewProjection;
    if (shaderMaterial !== void 0 && shaderMaterial.isMaterial) {
      if (shaderMaterial.uniforms && shaderMaterial.uniforms.u_mvp && shaderMaterial.uniforms.u_eyepos && shaderMaterial.uniforms.u_eyepos_lowpart) {
        shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);
        shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());
        shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());
      } else {
        throw Error("High pecision material has missing uniforms");
      }
    } else {
      throw Error("High pecision line has no high precision material");
    }
  }
  HighPrecisionUtils2.updateHpUniforms = updateHpUniforms;
  function createAttributes(positions) {
    if (positions.length > 0) {
      const v = positions[0];
      if (v === void 0 || v === null) {
        throw Error("Empty element in positions");
      }
      const positionVec = new Array();
      const positionVecLow = new Array();
      const addHPValue = (...values) => {
        for (const value2 of values) {
          const major = Math.fround(value2);
          positionVecLow.push(value2 - major);
          positionVec.push(major);
        }
      };
      const addHPVector = (vec) => {
        addHPValue(vec.x, vec.y, vec.z);
      };
      const vAny = v;
      if (vAny.z !== void 0) {
        ;
        positions.forEach((vec) => {
          addHPVector(vec);
        });
      } else {
        if (positionVec.length % 3 !== 0) {
          throw Error("Positions must be 3D, not 2D");
        }
        ;
        positions.forEach((n) => {
          addHPValue(n);
        });
      }
      return {
        positionHigh: new import_three16.Float32BufferAttribute(positionVec, 3),
        positionLow: new import_three16.Float32BufferAttribute(positionVecLow, 3)
      };
    } else {
      return {
        positionHigh: new import_three16.Float32BufferAttribute([], 3),
        positionLow: new import_three16.Float32BufferAttribute([], 3)
      };
    }
  }
  HighPrecisionUtils2.createAttributes = createAttributes;
  function addInterleavedAttributes3(positions, stride, positionOffset = 0) {
    const newPositions = new Array();
    const end = positions.length;
    for (let i = 0; i < end; i += stride) {
      for (let j = 0; j < positionOffset; j++) {
        newPositions.push(positions[i + j]);
      }
      const x = positions[i + positionOffset];
      const y = positions[i + positionOffset + 1];
      const z = positions[i + positionOffset + 2];
      const majorX = Math.fround(x);
      const minorX = x - majorX;
      const majorY = Math.fround(y);
      const minorY = y - majorY;
      const majorZ = Math.fround(z);
      const minorZ = z - majorZ;
      newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);
      for (let j = positionOffset + 3; j < stride; j++) {
        newPositions.push(positions[i + j]);
      }
    }
    return newPositions;
  }
  HighPrecisionUtils2.addInterleavedAttributes3 = addInterleavedAttributes3;
  function setPositions(object, positions) {
    const attributes = createAttributes(positions);
    object.bufferGeometry.setAttribute("position", attributes.positionHigh);
    object.bufferGeometry.setAttribute("positionLow", attributes.positionLow);
    return attributes.positionHigh.itemSize;
  }
  HighPrecisionUtils2.setPositions = setPositions;
  function convertPositions(positions) {
    if (positions.length <= 0) {
      return { positions: [] };
    }
    const v = positions[0];
    if (v === void 0 || v === null) {
      throw Error("Empty element in positions");
    }
    const vAny = v;
    if (vAny.y === void 0 && vAny.z === void 0) {
      return { positions };
    }
    const returnPositions = new Array();
    positions.forEach((vec) => {
      returnPositions.push(vec.x, vec.y, vec.z);
    });
    return { positions: returnPositions };
  }
  HighPrecisionUtils2.convertPositions = convertPositions;
  function createLine(linePositions, params) {
    const lineWidth = params.lineWidth !== void 0 ? params.lineWidth : 5;
    const addCircles = params.addCircles !== void 0 ? params.addCircles : false;
    const wireFrame = params.wireFrame !== void 0 ? params.wireFrame : false;
    const positions = [];
    const indices = [];
    triangulateLine(linePositions, lineWidth, positions, indices, addCircles);
    const hpLineGeometry = new import_three16.BufferGeometry();
    const hpPositions = addInterleavedAttributes3(positions, 3);
    const buffer = new import_three16.InterleavedBuffer(new Float32Array(hpPositions), 6);
    const positionAttribute = new import_three16.InterleavedBufferAttribute(buffer, 3, 0, false);
    const positionLowAttribute = new import_three16.InterleavedBufferAttribute(buffer, 3, 3, false);
    hpLineGeometry.setAttribute("position", positionAttribute);
    hpLineGeometry.setAttribute("positionLow", positionLowAttribute);
    hpLineGeometry.setIndex(new import_three16.BufferAttribute(new Uint32Array(indices), 1));
    const hpSolidMaterial = new HighPrecisionLineMaterial(params);
    const lineObject = wireFrame ? new HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial) : new HighPrecisionLine(hpLineGeometry, hpSolidMaterial);
    lineObject.setupForRendering();
    return lineObject;
  }
  HighPrecisionUtils2.createLine = createLine;
  function createPoints(pointPositions, materialParameters) {
    const indices = [];
    for (let i = 0; i < pointPositions.length; i++) {
      indices.push(indices.length / 3);
    }
    const hpPointsGeometry = new import_three16.BufferGeometry();
    const hpPointsMaterial = isHighPrecisionPointMaterial(materialParameters) ? materialParameters : new HighPrecisionPointMaterial(materialParameters);
    const pointsObject = new HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);
    setPositions(pointsObject, pointPositions);
    pointsObject.setupForRendering();
    return pointsObject;
  }
  HighPrecisionUtils2.createPoints = createPoints;
})(HighPrecisionUtils || (HighPrecisionUtils = {}));

// src/lines/HighPrecisionLines.ts
var HighPrecisionWireFrameLine = class extends THREE103.Line {
  matrixWorldInverse;
  constructor(geometry, material, positions) {
    super(geometry, material);
    this.matrixWorldInverse = new THREE103.Matrix4();
    if (positions) {
      this.setPositions(positions);
    }
  }
  get bufferGeometry() {
    return this.geometry;
  }
  get shaderMaterial() {
    return this.material;
  }
  setPositions(positions) {
    HighPrecisionUtils.setPositions(this, positions);
  }
  setupForRendering() {
    this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
      HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
    };
  }
  updateMatrixWorld(force) {
    const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
    super.updateMatrixWorld(force);
    if (doUpdateMatrixWorldInverse) {
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }
};
var HighPrecisionLine = class extends THREE103.Mesh {
  matrixWorldInverse;
  constructor(geometry, material, positions) {
    super(geometry, material);
    this.matrixWorldInverse = new THREE103.Matrix4();
    if (positions) {
      this.setPositions(positions);
    }
  }
  get bufferGeometry() {
    return this.geometry;
  }
  get shaderMaterial() {
    return this.material;
  }
  setPositions(positions) {
    HighPrecisionUtils.setPositions(this, positions);
  }
  setupForRendering() {
    this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
      HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
    };
  }
  updateMatrixWorld(force) {
    const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
    super.updateMatrixWorld(force);
    if (doUpdateMatrixWorldInverse) {
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }
};

// src/lines/Lines.ts
var THREE104 = __toESM(require("three"));
var tmpV5 = new THREE104.Vector3();
var tmpNormal = new THREE104.Vector3();
var tmpTangent0 = new THREE104.Vector3();
var tmpTangent1 = new THREE104.Vector3();
var tmpBitangent = new THREE104.Vector3();
var LINE_VERTEX_ATTRIBUTES = {
  attributes: [
    { name: "extrusionCoord", itemSize: 3, offset: 0 },
    { name: "position", itemSize: 3, offset: 3 },
    { name: "tangent", itemSize: 3, offset: 6 },
    { name: "biTangent", itemSize: 4, offset: 9 }
  ],
  stride: 13
};
var NORMAL_UV_VERTEX_ATTRIBUTES = {
  attributes: [
    { name: "uv", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },
    {
      name: "normal",
      itemSize: 3,
      offset: LINE_VERTEX_ATTRIBUTES.stride + 2
    }
  ],
  stride: 5
};
var LINE_VERTEX_ATTRIBUTES_NUV = {
  attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],
  stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
var HP_LINE_VERTEX_ATTRIBUTES = {
  attributes: [
    { name: "extrusionCoord", itemSize: 2, offset: 0 },
    { name: "position", itemSize: 3, offset: 2 },
    { name: "positionLow", itemSize: 3, offset: 5 },
    { name: "tangent", itemSize: 3, offset: 8 },
    { name: "biTangent", itemSize: 4, offset: 11 }
  ],
  stride: 15
};
var HP_LINE_VERTEX_ATTRIBUTES_NUV = {
  attributes: [...HP_LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],
  stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};

// src/mapview/geometry/TileGeometry.ts
var logger29 = LoggerManager.instance.create("TileGeometry");
function isLineAccessor(arg) {
  return typeof arg.isLineAccessor === "function" && arg.isLineAccessor() === true;
}
function isObject3dAccessor(arg) {
  return typeof arg.isObject3dAccessor === "function" && arg.isObject3dAccessor() === true;
}
var BufferedGeometryAccessorBase = class {
  constructor(object, geometryType, bufferGeometry) {
    this.object = object;
    this.geometryType = geometryType;
    this.bufferGeometry = bufferGeometry;
    assert(!!object);
    if (bufferGeometry.type !== "BufferGeometry") {
      logger29.error("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
    }
    assert(bufferGeometry.type === "BufferGeometry", "IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
    this.position = this.bufferGeometry.getAttribute("position");
    this.itemSize = this.position.itemSize;
    if (!this.position) {
      logger29.warn("BufferedGeometryAccessor#constructor: BufferGeometry has no position attribute");
    }
    if (this.position.array.constructor !== Float32Array) {
      logger29.warn("BufferedGeometryAccessor#constructor: BufferGeometry.position: unsupported ArrayBuffer");
    }
  }
  start = -1;
  end = -1;
  startCapSize = 0;
  endCapSize = 0;
  position;
  itemSize;
  getCount() {
    return this.position.count;
  }
  get renderOrder() {
    return this.object.renderOrder;
  }
  setRange(start, end, startCapSize = 0, endCapSize = 0) {
    assert(start >= 0);
    assert(end >= 0);
    assert(start <= end);
    this.start = start;
    this.end = end;
    this.startCapSize = startCapSize;
    this.endCapSize = endCapSize;
  }
  get color() {
    const getColor = (material) => {
      const meshMaterial = material;
      if (meshMaterial.type === "MeshBasicMaterial" || meshMaterial.type === "MeshStandardMaterial") {
        return meshMaterial.color;
      } else if (meshMaterial.type === "RawShaderMaterial") {
        const rawShaderMaterial = material;
        if (rawShaderMaterial.name === "SolidLineMaterial") {
          return rawShaderMaterial.uniforms.diffuseColor.value;
        }
        logger29.warn("BufferedGeometryAccessor#color: unknown shader material name", rawShaderMaterial.name);
      } else {
        logger29.warn("BufferedGeometryAccessor#color: unknown material type", meshMaterial.type);
      }
      return void 0;
    };
    if (Array.isArray(this.object.material)) {
      const results = new Array();
      const materials = this.object.material;
      for (const material of materials) {
        results.push(getColor(material));
      }
      return results;
    } else {
      return getColor(this.object.material);
    }
  }
};
var BufferedGeometryAccessor = class extends BufferedGeometryAccessorBase {
  constructor(object, geometryType, bufferGeometry, stride) {
    super(object, geometryType, bufferGeometry);
    this.object = object;
    this.geometryType = geometryType;
    this.bufferGeometry = bufferGeometry;
    this.stride = stride;
  }
  clear() {
    assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
    const positionsArray = this.position.array;
    const start = this.start * this.itemSize;
    const end = this.end * this.itemSize;
    for (let i = start; i < end; i++) {
      positionsArray[i] = 0;
    }
    this.position.needsUpdate = true;
  }
  getVertices() {
    assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
    const start = this.start;
    const end = this.end;
    return this.position.array.subarray(start * this.itemSize, end * this.itemSize);
  }
  checkSetUp() {
    return this.position !== void 0 && this.start !== void 0 && this.end !== void 0 && this.start >= 0 && this.end <= this.position.count && this.start <= this.end;
  }
};
var BufferedGeometryLineAccessor = class extends BufferedGeometryAccessor {
  constructor(object, geometryType, bufferGeometry) {
    super(object, geometryType, bufferGeometry, 3);
    this.object = object;
    this.geometryType = geometryType;
    this.bufferGeometry = bufferGeometry;
  }
  isLineAccessor() {
    return true;
  }
  get width() {
    assert(this.checkSetUp(), "RoBufferedGeometryLineAccessor not setup");
    return void 0;
  }
};
var BufferedGeometryObject3dAccessor = class extends BufferedGeometryAccessor {
  constructor(object, geometryType, bufferGeometry) {
    super(object, geometryType, bufferGeometry, 1);
    this.object = object;
    this.geometryType = geometryType;
    this.bufferGeometry = bufferGeometry;
  }
  isObject3dAccessor() {
    return true;
  }
  getVertices() {
    return super.getVertices();
  }
};
var IndexedBufferedGeometryAccessor = class extends BufferedGeometryAccessorBase {
  constructor(object, geometryType, bufferGeometry, start, end) {
    super(object, geometryType, bufferGeometry);
    this.object = object;
    this.geometryType = geometryType;
    this.bufferGeometry = bufferGeometry;
    this.indices = this.bufferGeometry.index !== null ? this.bufferGeometry.index.array : void 0;
    if (!this.indices) {
      logger29.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no index");
      assert(!!this.indices);
    } else {
      if (!(this.indices instanceof Uint32Array)) {
        logger29.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry index has wrong type");
        assert(this.indices instanceof Uint32Array);
      }
    }
  }
  indices;
  getCount() {
    return this.indices.length;
  }
  checkSetUp() {
    return !!this.indices && this.start !== void 0 && this.end !== void 0 && this.start >= 0 && this.end <= this.indices.length && this.start <= this.end;
  }
};
var IndexedBufferedGeometryLineAccessor = class extends IndexedBufferedGeometryAccessor {
  constructor(object, geometryType, bufferGeometry) {
    super(object, geometryType, bufferGeometry, 3);
    this.object = object;
    this.geometryType = geometryType;
    this.bufferGeometry = bufferGeometry;
  }
  isLineAccessor() {
    return true;
  }
  get width() {
    assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
    if (this.geometryType === 6 /* ExtrudedLine */) {
      const start = this.start + this.startCapSize;
      const positionArray = this.position.array;
      return reconstructLineWidth(positionArray, start);
    }
    return void 0;
  }
  clear() {
    assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
    const start = this.start;
    const end = this.end;
    for (let i = start; i < end; i++) {
      this.indices[i] = 0;
    }
    if (this.bufferGeometry.index !== null) {
      this.bufferGeometry.index.needsUpdate = true;
    }
  }
  getVertices() {
    assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
    const itemSize = this.itemSize;
    const start = this.start;
    const end = this.end;
    const result = new Float32Array((end - start) * itemSize);
    const positionArray = this.position.array;
    if (itemSize === 2) {
      for (let i = start, j = 0; i < end; i++, j += itemSize) {
        const index = this.indices[i];
        result[j + 0] = positionArray[index * itemSize + 0];
        result[j + 1] = positionArray[index * itemSize + 1];
      }
    }
    if (itemSize === 3) {
      for (let i = start, j = 0; i < end; i++, j += itemSize) {
        const index = this.indices[i];
        result[j + 0] = positionArray[index * itemSize + 0];
        result[j + 1] = positionArray[index * itemSize + 1];
        result[j + 2] = positionArray[index * itemSize + 2];
      }
    } else {
      for (let i = start, j = 0; i < end; i++, j++) {
        const index = this.indices[i];
        for (let k = 0; k < itemSize; k++) {
          result[j * itemSize + k] = positionArray[index * itemSize + k];
        }
      }
    }
    return result;
  }
};

// src/mapview/geometry/TileDataAccessor.ts
var logger30 = LoggerManager.instance.create("TileDataAccessor");
var TileDataAccessor = class {
  constructor(tile, visitor, options) {
    this.tile = tile;
    this.visitor = visitor;
    const wantsAll = options.wantsAll === true;
    this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);
    this.m_wantsLines = wantsAll || !(options.wantsLines === false);
    this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);
    this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);
  }
  m_wantsPoints;
  m_wantsLines;
  m_wantsAreas;
  m_wantsObject3D;
  visitAll() {
    const objects = this.tile.objects;
    for (const object of objects) {
      this.visitObject(object);
    }
  }
  visitObject(object) {
    const featureData = object.userData !== void 0 ? object.userData.feature : void 0;
    if (featureData === void 0 || featureData.objInfos !== void 0 && featureData.objInfos.length === 1 && !this.visitor.wantsFeature(getFeatureId(featureData.objInfos[0]))) {
      return;
    }
    const geometryType = featureData.geometryType;
    if (geometryType === void 0) {
      logger30.warn("#visitObject: visiting object failed, no geometryType", object);
      return;
    }
    assert(featureData.objInfos !== void 0, "featureData.ids missing");
    assert(featureData.starts !== void 0, "featureData.starts missing");
    assert(Array.isArray(featureData.starts), "featureData.starts is not an array");
    if (featureData.objInfos !== void 0 && featureData.starts !== void 0) {
      assert(featureData.objInfos.length === featureData.starts.length, "featureData.ids and featureData.starts have unequal length");
    }
    switch (geometryType) {
      case 1 /* Point */:
      case 4 /* Text */:
        if (!this.m_wantsPoints) {
          return;
        }
        break;
      case 3 /* SolidLine */:
      case 6 /* ExtrudedLine */:
      case 5 /* TextPath */:
        if (!this.m_wantsLines) {
          return;
        }
        break;
      case 7 /* Polygon */:
      case 8 /* ExtrudedPolygon */:
        if (!this.m_wantsAreas) {
          return;
        }
        break;
      case 9 /* Object3D */:
        if (!this.m_wantsObject3D) {
          return;
        }
        break;
      default:
        logger30.warn("#visitObject: invalid geometryType");
    }
    if (object.type !== "Mesh") {
      logger30.warn("#visitObject: visiting object failed, not of type 'Mesh'", object);
      return;
    }
    const mesh = object;
    this.visitMesh(mesh, featureData);
  }
  getBufferGeometry(object) {
    const geometry = object.geometry;
    if (geometry.type !== "BufferGeometry") {
      logger30.warn("#visitObject: object does not have BufferGeometry");
      return void 0;
    }
    const bufferGeometry = geometry;
    const position = bufferGeometry.getAttribute("position");
    if (!position) {
      logger30.warn("#visitLines: BufferGeometry has no position attribute");
      return void 0;
    }
    return bufferGeometry;
  }
  getGeometryAccessor(geometryType, object, bufferGeometry) {
    switch (geometryType) {
      case 1 /* Point */:
      case 4 /* Text */:
        return void 0;
      case 3 /* SolidLine */:
      case 6 /* ExtrudedLine */:
      case 5 /* TextPath */:
        return new BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
      case 7 /* Polygon */:
      case 8 /* ExtrudedPolygon */:
        return void 0;
      case 9 /* Object3D */:
        return new BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);
      default:
        logger30.warn("#getGeometryAccessor: invalid geometryType");
    }
    return void 0;
  }
  getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {
    switch (geometryType) {
      case 1 /* Point */:
      case 4 /* Text */:
        return void 0;
      case 3 /* SolidLine */:
      case 6 /* ExtrudedLine */:
      case 5 /* TextPath */:
        return new IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
      case 7 /* Polygon */:
      case 8 /* ExtrudedPolygon */:
        return void 0;
      case 9 /* Object3D */:
        return void 0;
      default:
        logger30.warn("#getIndexedGeometryAccessor: invalid geometryType");
    }
    return void 0;
  }
  visitMesh(meshObject, featureData) {
    const { objInfos, starts } = featureData;
    const geometryType = featureData.geometryType;
    if (objInfos === void 0 || starts === void 0 || geometryType === void 0) {
      return;
    }
    let geometryAccessor;
    for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {
      const featureId = getFeatureId(objInfos[featureIndex]);
      if (!this.visitor.wantsFeature(featureId)) {
        continue;
      }
      const featureStart = starts[featureIndex];
      let featureEnd = -1;
      if (geometryAccessor === void 0) {
        const bufferGeometry = this.getBufferGeometry(meshObject);
        if (bufferGeometry === void 0) {
          continue;
        }
        if (bufferGeometry.index !== null) {
          geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);
        } else {
          geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);
        }
        if (geometryAccessor === void 0) {
          logger30.warn("#visitObject: no accessor geometryType", geometryType);
          continue;
        }
      }
      featureEnd = featureIndex < starts.length - 1 ? starts[featureIndex + 1] : geometryAccessor.getCount();
      geometryAccessor.setRange(featureStart, featureEnd);
      switch (geometryType) {
        case 1 /* Point */:
        case 4 /* Text */:
          this.visitor.visitPoint(featureId);
          break;
        case 3 /* SolidLine */:
        case 6 /* ExtrudedLine */:
        case 5 /* TextPath */:
          assert(isLineAccessor(geometryAccessor));
          this.visitor.visitLine(featureId, geometryAccessor);
          break;
        case 7 /* Polygon */:
        case 8 /* ExtrudedPolygon */:
          this.visitor.visitArea(featureId);
          break;
        case 9 /* Object3D */:
          assert(isObject3dAccessor(geometryAccessor));
          this.visitor.visitObject3D(featureId, geometryAccessor);
          break;
        default:
          logger30.warn("#visitObject: invalid geometryType");
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AnimatedExtrusionHandler,
  AnimatedExtrusionState,
  ArcadeMap,
  AtmosphereLightMode,
  BASE_TECHNIQUE_NON_MATERIAL_PROPS,
  BaseTileLoader,
  BoundsGenerator,
  BufferedGeometryAccessor,
  BufferedGeometryAccessorBase,
  BufferedGeometryLineAccessor,
  BufferedGeometryObject3dAccessor,
  CalculationStatus,
  CameraMovementDetector,
  CameraUtils,
  Circles,
  ColorCache,
  ConcurrentDecoderFacade,
  ConcurrentTilerFacade,
  CopyrightCoverageProvider,
  CopyrightElementHandler,
  CopyrightInfo,
  DEFAULT_FONT_CATALOG_NAME,
  DEFAULT_FOV_CALCULATION,
  DEFAULT_MAX_THEME_INTHERITANCE_DEPTH,
  DEFAULT_TEXT_DISTANCE_SCALE,
  DEPTH_PRE_PASS_STENCIL_MASK,
  DataSource,
  DebugContext,
  ElevationBasedClipPlanesEvaluator,
  EventDispatcher,
  FixedClipPlanesEvaluator,
  FrameStats,
  FrameStatsArray,
  ImageCache,
  ImageItem,
  IndexedBufferedGeometryAccessor,
  IndexedBufferedGeometryLineAccessor,
  LoadingState,
  MAX_FOV_DEG,
  MAX_FOV_RAD,
  MIN_FOV_DEG,
  MIN_FOV_RAD,
  MSAARenderPass,
  MSAASampling,
  MapAnchors,
  MapRenderingManager,
  MapView,
  MapViewAtmosphere,
  MapViewEventNames,
  MapViewFog,
  MapViewImageCache,
  MapViewPoints,
  MapViewUtils,
  MultiStageTimer,
  Pass,
  PerformanceStatistics,
  PickHandler,
  PickObjectType,
  PoiManager,
  PoiTable,
  PoiTableManager,
  PolarTileDataSource,
  ResourceComputationType,
  RingBuffer,
  SampledTimer,
  SimpleTimer,
  Squares,
  Statistics,
  TextElement,
  TextElementType,
  TextElementsRenderer,
  TextStyleCache,
  TextureLoader,
  ThemeLoader,
  Tile,
  TileDataAccessor,
  TileGeometryCreator,
  TileLoaderState,
  TileOffsetUtils,
  TileTaskGroups,
  TiltViewClipPlanesEvaluator,
  TopViewClipPlanesEvaluator,
  UrlCopyrightProvider,
  VisibleTileSet,
  WorkerBasedDecoder,
  WorkerBasedTiler,
  WorkerLoader,
  applyBaseColorToMaterial,
  applySecondaryColorToMaterial,
  buildMetricValueEvaluator,
  buildObject,
  computeArrayAverage,
  computeArrayStats,
  createDefaultClipPlanesEvaluator,
  createDepthPrePassMaterial,
  createDepthPrePassMesh,
  createMaterial,
  debugContext,
  evaluateBaseColorProperty,
  evaluateColorProperty,
  getBufferAttribute,
  getFeatureDataSize,
  getMaterialConstructor,
  isDepthPrePassMesh,
  isLineAccessor,
  isObject3dAccessor,
  isRenderDepthPrePassEnabled,
  poiIsRenderable,
  setDepthPrePassStencil,
  usesObject3D
});
//!!!!!!!ALTITUDE IS NOT TAKEN INTO ACCOUNT!!!!!!!!!
