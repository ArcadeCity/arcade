"use strict";
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _assertThisInitialized(self1) {
    if (self1 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self1;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function _construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpreadProps(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _possibleConstructorReturn(self1, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self1);
}
function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
        set = Reflect.set;
    } else {
        set = function set(target, property, value, receiver) {
            var base = _superPropBase(target, property);
            var desc;
            if (base) {
                desc = Object.getOwnPropertyDescriptor(base, property);
                if (desc.set) {
                    desc.set.call(receiver, value);
                    return true;
                } else if (!desc.writable) {
                    return false;
                }
            }
            desc = Object.getOwnPropertyDescriptor(receiver, property);
            if (desc) {
                if (!desc.writable) {
                    return false;
                }
                desc.value = value;
                Object.defineProperty(receiver, property, desc);
            } else {
                _defineProperty(receiver, property, value);
            }
            return true;
        };
    }
    return set(target, property, value, receiver);
}
function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
        throw new Error("failed to set property");
    }
    return value;
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _superPropBase(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _getPrototypeOf(object);
        if (object === null) break;
    }
    return object;
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
var _typeof = function(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
};
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
import regeneratorRuntime from "regenerator-runtime";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = function(obj, key, value2) {
    return key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value2
    }) : obj[key] = value2;
};
var __export = function(target, all) {
    for(var name2 in all)__defProp(target, name2, {
        get: all[name2],
        enumerable: true
    });
};
var __copyProps = function(to, from, except, desc) {
    if (from && typeof from === "object" || typeof from === "function") {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            var _loop = function(_iterator, _step) {
                var key = _step.value;
                if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
                    get: function() {
                        return from[key];
                    },
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                });
            };
            for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return to;
};
var __toESM = function(mod2, isNodeMode, target) {
    return target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", {
        value: mod2,
        enumerable: true
    }) : target, mod2);
};
var __toCommonJS = function(mod2) {
    return __copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod2);
};
var __publicField = function(obj, key, value2) {
    __defNormalProp(obj, (typeof key === "undefined" ? "undefined" : _typeof(key)) !== "symbol" ? key + "" : key, value2);
    return value2;
};
// src/index.tsx
var src_exports = {};
__export(src_exports, {
    AnimatedExtrusionHandler: function() {
        return AnimatedExtrusionHandler;
    },
    AnimatedExtrusionState: function() {
        return AnimatedExtrusionState;
    },
    ArcadeMap: function() {
        return ArcadeMap;
    },
    AtmosphereLightMode: function() {
        return AtmosphereLightMode;
    },
    BASE_TECHNIQUE_NON_MATERIAL_PROPS: function() {
        return BASE_TECHNIQUE_NON_MATERIAL_PROPS;
    },
    BaseTileLoader: function() {
        return BaseTileLoader;
    },
    BoundsGenerator: function() {
        return BoundsGenerator;
    },
    BufferedGeometryAccessor: function() {
        return BufferedGeometryAccessor;
    },
    BufferedGeometryAccessorBase: function() {
        return BufferedGeometryAccessorBase;
    },
    BufferedGeometryLineAccessor: function() {
        return BufferedGeometryLineAccessor;
    },
    BufferedGeometryObject3dAccessor: function() {
        return BufferedGeometryObject3dAccessor;
    },
    CalculationStatus: function() {
        return CalculationStatus;
    },
    CameraMovementDetector: function() {
        return CameraMovementDetector;
    },
    CameraUtils: function() {
        return CameraUtils;
    },
    Circles: function() {
        return Circles;
    },
    ColorCache: function() {
        return ColorCache;
    },
    ConcurrentDecoderFacade: function() {
        return ConcurrentDecoderFacade;
    },
    ConcurrentTilerFacade: function() {
        return ConcurrentTilerFacade;
    },
    CopyrightCoverageProvider: function() {
        return CopyrightCoverageProvider;
    },
    CopyrightElementHandler: function() {
        return CopyrightElementHandler;
    },
    CopyrightInfo: function() {
        return CopyrightInfo;
    },
    DEFAULT_FONT_CATALOG_NAME: function() {
        return DEFAULT_FONT_CATALOG_NAME;
    },
    DEFAULT_FOV_CALCULATION: function() {
        return DEFAULT_FOV_CALCULATION;
    },
    DEFAULT_MAX_THEME_INTHERITANCE_DEPTH: function() {
        return DEFAULT_MAX_THEME_INTHERITANCE_DEPTH;
    },
    DEFAULT_TEXT_DISTANCE_SCALE: function() {
        return DEFAULT_TEXT_DISTANCE_SCALE;
    },
    DEPTH_PRE_PASS_STENCIL_MASK: function() {
        return DEPTH_PRE_PASS_STENCIL_MASK;
    },
    DataSource: function() {
        return DataSource;
    },
    DebugContext: function() {
        return DebugContext;
    },
    ElevationBasedClipPlanesEvaluator: function() {
        return ElevationBasedClipPlanesEvaluator;
    },
    EventDispatcher: function() {
        return EventDispatcher;
    },
    FixedClipPlanesEvaluator: function() {
        return FixedClipPlanesEvaluator;
    },
    FrameStats: function() {
        return FrameStats;
    },
    FrameStatsArray: function() {
        return FrameStatsArray;
    },
    ImageCache: function() {
        return ImageCache;
    },
    ImageItem: function() {
        return ImageItem;
    },
    IndexedBufferedGeometryAccessor: function() {
        return IndexedBufferedGeometryAccessor;
    },
    IndexedBufferedGeometryLineAccessor: function() {
        return IndexedBufferedGeometryLineAccessor;
    },
    LoadingState: function() {
        return LoadingState;
    },
    MAX_FOV_DEG: function() {
        return MAX_FOV_DEG;
    },
    MAX_FOV_RAD: function() {
        return MAX_FOV_RAD;
    },
    MIN_FOV_DEG: function() {
        return MIN_FOV_DEG;
    },
    MIN_FOV_RAD: function() {
        return MIN_FOV_RAD;
    },
    MSAARenderPass: function() {
        return MSAARenderPass;
    },
    MSAASampling: function() {
        return MSAASampling;
    },
    MapAnchors: function() {
        return MapAnchors;
    },
    MapRenderingManager: function() {
        return MapRenderingManager;
    },
    MapView: function() {
        return MapView3;
    },
    MapViewAtmosphere: function() {
        return MapViewAtmosphere;
    },
    MapViewEventNames: function() {
        return MapViewEventNames;
    },
    MapViewFog: function() {
        return MapViewFog;
    },
    MapViewImageCache: function() {
        return MapViewImageCache;
    },
    MapViewPoints: function() {
        return MapViewPoints;
    },
    MapViewUtils: function() {
        return MapViewUtils;
    },
    MultiStageTimer: function() {
        return MultiStageTimer;
    },
    Pass: function() {
        return Pass;
    },
    PerformanceStatistics: function() {
        return PerformanceStatistics;
    },
    PickHandler: function() {
        return PickHandler;
    },
    PickObjectType: function() {
        return PickObjectType;
    },
    PoiManager: function() {
        return PoiManager;
    },
    PoiTable: function() {
        return PoiTable;
    },
    PoiTableManager: function() {
        return PoiTableManager;
    },
    PolarTileDataSource: function() {
        return PolarTileDataSource;
    },
    ResourceComputationType: function() {
        return ResourceComputationType;
    },
    RingBuffer: function() {
        return RingBuffer;
    },
    SampledTimer: function() {
        return SampledTimer;
    },
    SimpleTimer: function() {
        return SimpleTimer;
    },
    Squares: function() {
        return Squares;
    },
    Statistics: function() {
        return Statistics;
    },
    TextElement: function() {
        return TextElement;
    },
    TextElementType: function() {
        return TextElementType;
    },
    TextElementsRenderer: function() {
        return TextElementsRenderer;
    },
    TextStyleCache: function() {
        return TextStyleCache;
    },
    TextureLoader: function() {
        return TextureLoader5;
    },
    ThemeLoader: function() {
        return ThemeLoader;
    },
    Tile: function() {
        return Tile;
    },
    TileDataAccessor: function() {
        return TileDataAccessor;
    },
    TileGeometryCreator: function() {
        return TileGeometryCreator;
    },
    TileLoaderState: function() {
        return TileLoaderState;
    },
    TileOffsetUtils: function() {
        return TileOffsetUtils;
    },
    TileTaskGroups: function() {
        return TileTaskGroups;
    },
    TiltViewClipPlanesEvaluator: function() {
        return TiltViewClipPlanesEvaluator;
    },
    TopViewClipPlanesEvaluator: function() {
        return TopViewClipPlanesEvaluator;
    },
    UrlCopyrightProvider: function() {
        return UrlCopyrightProvider;
    },
    VisibleTileSet: function() {
        return VisibleTileSet;
    },
    WorkerBasedDecoder: function() {
        return WorkerBasedDecoder;
    },
    WorkerBasedTiler: function() {
        return WorkerBasedTiler;
    },
    WorkerLoader: function() {
        return WorkerLoader;
    },
    applyBaseColorToMaterial: function() {
        return applyBaseColorToMaterial;
    },
    applySecondaryColorToMaterial: function() {
        return applySecondaryColorToMaterial;
    },
    buildMetricValueEvaluator: function() {
        return buildMetricValueEvaluator;
    },
    buildObject: function() {
        return buildObject;
    },
    computeArrayAverage: function() {
        return computeArrayAverage;
    },
    computeArrayStats: function() {
        return computeArrayStats;
    },
    createDefaultClipPlanesEvaluator: function() {
        return createDefaultClipPlanesEvaluator;
    },
    createDepthPrePassMaterial: function() {
        return createDepthPrePassMaterial;
    },
    createDepthPrePassMesh: function() {
        return createDepthPrePassMesh;
    },
    createMaterial: function() {
        return createMaterial;
    },
    debugContext: function() {
        return debugContext;
    },
    evaluateBaseColorProperty: function() {
        return evaluateBaseColorProperty;
    },
    evaluateColorProperty: function() {
        return evaluateColorProperty;
    },
    getBufferAttribute: function() {
        return getBufferAttribute;
    },
    getFeatureDataSize: function() {
        return getFeatureDataSize;
    },
    getMaterialConstructor: function() {
        return getMaterialConstructor;
    },
    isDepthPrePassMesh: function() {
        return isDepthPrePassMesh;
    },
    isLineAccessor: function() {
        return isLineAccessor;
    },
    isObject3dAccessor: function() {
        return isObject3dAccessor;
    },
    isRenderDepthPrePassEnabled: function() {
        return isRenderDepthPrePassEnabled;
    },
    poiIsRenderable: function() {
        return poiIsRenderable;
    },
    setDepthPrePassStencil: function() {
        return setDepthPrePassStencil;
    },
    usesObject3D: function() {
        return usesObject3D;
    }
});
module.exports = __toCommonJS(src_exports);
// src/ArcadeMap/ArcadeMap.tsx
var import_react = __toESM(require("react"));
var ArcadeMap = function() {
    console.log("Hello from ArcadeMap");
    return /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null);
};
// src/datasource-protocol/ColorUtils.ts
var THREE = __toESM(require("three"));
// src/utils/assert.ts
var isProduction = process.env.NODE_ENV === "production";
function assert(condition, message) {
    if (!isProduction) {
        if (!condition) {
            throw new Error(message !== void 0 ? message : "ASSERTION failed");
        }
    }
}
function assertExists(element, message) {
    if (!isProduction) {
        if (element === void 0 || element === null) {
            throw new Error(message !== void 0 ? message : "ASSERTION failed: Element is undefined or null");
        }
    }
    return element;
}
// src/utils/ContextLogger.ts
var ContextLogger = /*#__PURE__*/ function() {
    function ContextLogger(m_logger, headerMessage) {
        _classCallCheck(this, ContextLogger);
        this.m_logger = m_logger;
        this.headerMessage = headerMessage;
        __publicField(this, "context", []);
        __publicField(this, "m_headerLogged", false);
        __publicField(this, "warn", this.createLogMethod("warn"));
        __publicField(this, "info", this.createLogMethod("info"));
        __publicField(this, "error", this.createLogMethod("error"));
    }
    _createClass(ContextLogger, [
        {
            key: "pushAttr",
            value: function pushAttr(name2) {
                this.context.push("".concat(this.context.length > 0 ? "." : "").concat(name2));
            }
        },
        {
            key: "pushIndex",
            value: function pushIndex(index) {
                this.context.push("[".concat(index, "]"));
            }
        },
        {
            key: "pop",
            value: function pop() {
                this.context.pop();
            }
        },
        {
            key: "createLogMethod",
            value: function createLogMethod(severity) {
                var _this = this;
                return function(message) {
                    for(var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        rest[_key - 1] = arguments[_key];
                    }
                    var _m_logger;
                    if (!_this.m_headerLogged) {
                        _this.m_logger.info(_this.headerMessage);
                        _this.m_headerLogged = true;
                    }
                    (_m_logger = _this.m_logger)[severity].apply(_m_logger, [
                        "".concat(_this.context.join(""), ": ").concat(message)
                    ].concat(_toConsumableArray(rest)));
                };
            }
        }
    ]);
    return ContextLogger;
}();
// src/utils/DOMUtils.ts
var DOMUtils;
(function(DOMUtils2) {
    var getBrowserLanguages = function getBrowserLanguages() {
        if (navigator.languages !== void 0 && navigator.languages.length > 0) {
            var languageList = [];
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = navigator.languages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var lang = _step.value;
                    languageList.push(getIsoLanguageCode(lang));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return languageList;
        }
        if (navigator.language !== void 0) {
            return [
                getIsoLanguageCode(navigator.language)
            ];
        }
        return void 0;
    };
    var getIsoLanguageCode = function getIsoLanguageCode(language) {
        return language.substring(0, 2);
    };
    DOMUtils2.getBrowserLanguages = getBrowserLanguages;
})(DOMUtils || (DOMUtils = {}));
// src/utils/Functions.ts
function chainCallbacks(f1, f2) {
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (f1) {
            f1.apply(this, args);
        }
        return f2.apply(this, args);
    };
}
// src/utils/GlslUtils.ts
function convertVertexShaderToWebGL2(vertexShader2) {
    return [
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
    ].join("\n") + "\n" + vertexShader2;
}
function convertFragmentShaderToWebGL2(fragmentShader3) {
    return [
        "#define varying in",
        "out highp vec4 pc_fragColor;",
        "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + fragmentShader3;
}
// src/utils/GroupedPriorityList.ts
var PriorityListGroup = /*#__PURE__*/ function() {
    function PriorityListGroup(priority) {
        var elements = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Array();
        _classCallCheck(this, PriorityListGroup);
        this.priority = priority;
        this.elements = elements;
    }
    _createClass(PriorityListGroup, [
        {
            key: "clone",
            value: function clone() {
                return new PriorityListGroup(this.priority, this.elements.slice());
            }
        },
        {
            key: "remove",
            value: function remove(element) {
                var foundIndex = this.elements.indexOf(element);
                if (foundIndex === -1) {
                    return false;
                }
                this.elements.splice(foundIndex, 1);
                return true;
            }
        }
    ]);
    return PriorityListGroup;
}();
var GroupedPriorityList = /*#__PURE__*/ function() {
    function GroupedPriorityList() {
        _classCallCheck(this, GroupedPriorityList);
        __publicField(this, "groups", /* @__PURE__ */ new Map());
    }
    _createClass(GroupedPriorityList, [
        {
            key: "add",
            value: function add(element) {
                this.getGroup(element.priority).elements.push(element);
            }
        },
        {
            key: "remove",
            value: function remove(element) {
                var group = this.findGroup(element.priority);
                if (group !== void 0 && group.remove(element)) {
                    if (group.elements.length === 0) {
                        this.groups.delete(group.priority);
                    }
                    return true;
                }
                return false;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.groups.clear();
            }
        },
        {
            key: "merge",
            value: function merge(other) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = other.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var otherGroup = _step.value;
                        var group = this.findGroup(otherGroup[1].priority);
                        if (group === void 0) {
                            this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());
                            continue;
                        }
                        group.elements = group.elements.concat(otherGroup[1].elements);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return this;
            }
        },
        {
            key: "clone",
            value: function clone() {
                var clone1 = new GroupedPriorityList();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), priority = _value[0], group = _value[1];
                        clone1.groups.set(priority, group.clone());
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return clone1;
            }
        },
        {
            key: "forEach",
            value: function forEach(fun) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var group = _step.value;
                        group[1].elements.forEach(fun);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "count",
            value: function count() {
                var n = 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var group = _step.value;
                        n += group[1].elements.length;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return n;
            }
        },
        {
            key: "findGroup",
            value: function findGroup(priority) {
                var normalizedPriority = Math.floor(priority);
                var group = this.groups.get(normalizedPriority);
                return group;
            }
        },
        {
            key: "getGroup",
            value: function getGroup(priority) {
                var group = this.findGroup(priority);
                if (group === void 0) {
                    var normalizedPriority = Math.floor(priority);
                    group = new PriorityListGroup(normalizedPriority);
                    this.groups.set(group.priority, group);
                }
                return group;
            }
        }
    ]);
    return GroupedPriorityList;
}();
// src/utils/Logger/ConsoleChannel.ts
var ConsoleChannel = /*#__PURE__*/ function() {
    function ConsoleChannel() {
        _classCallCheck(this, ConsoleChannel);
    }
    _createClass(ConsoleChannel, [
        {
            key: "error",
            value: function error(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var _console;
                (_console = console).error.apply(_console, [
                    message
                ].concat(_toConsumableArray(optionalParams)));
            }
        },
        {
            key: "debug",
            value: function debug(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var _console;
                (_console = console).debug.apply(_console, [
                    message
                ].concat(_toConsumableArray(optionalParams)));
            }
        },
        {
            key: "info",
            value: function info(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var _console;
                (_console = console).info.apply(_console, [
                    message
                ].concat(_toConsumableArray(optionalParams)));
            }
        },
        {
            key: "log",
            value: function log(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var _console;
                (_console = console).log.apply(_console, [
                    message
                ].concat(_toConsumableArray(optionalParams)));
            }
        },
        {
            key: "trace",
            value: function trace(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var _console;
                (_console = console).trace.apply(_console, [
                    message
                ].concat(_toConsumableArray(optionalParams)));
            }
        },
        {
            key: "warn",
            value: function warn(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var _console;
                (_console = console).warn.apply(_console, [
                    message
                ].concat(_toConsumableArray(optionalParams)));
            }
        }
    ]);
    return ConsoleChannel;
}();
// src/utils/Logger/Logger.ts
var Logger = /*#__PURE__*/ function() {
    function Logger(name2, m_channel, options) {
        _classCallCheck(this, Logger);
        this.name = name2;
        this.m_channel = m_channel;
        __publicField(this, "enabled", true);
        __publicField(this, "level", 0 /* Trace */ );
        if (options !== void 0) {
            this.update(options);
        }
    }
    _createClass(Logger, [
        {
            key: "error",
            value: function error(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                if (this.enabled && this.level <= 5 /* Error */ ) {
                    var _m_channel;
                    (_m_channel = this.m_channel).error.apply(_m_channel, [
                        this.prefix,
                        message
                    ].concat(_toConsumableArray(optionalParams)));
                }
            }
        },
        {
            key: "debug",
            value: function debug(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                if (this.enabled && this.level <= 1 /* Debug */ ) {
                    var _m_channel;
                    (_m_channel = this.m_channel).debug.apply(_m_channel, [
                        this.prefix,
                        message
                    ].concat(_toConsumableArray(optionalParams)));
                }
            }
        },
        {
            key: "info",
            value: function info(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                if (this.enabled && this.level <= 3 /* Info */ ) {
                    var _m_channel;
                    (_m_channel = this.m_channel).info.apply(_m_channel, [
                        this.prefix,
                        message
                    ].concat(_toConsumableArray(optionalParams)));
                }
            }
        },
        {
            key: "log",
            value: function log(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                if (this.enabled && this.level <= 2 /* Log */ ) {
                    var _m_channel;
                    (_m_channel = this.m_channel).log.apply(_m_channel, [
                        this.prefix,
                        message
                    ].concat(_toConsumableArray(optionalParams)));
                }
            }
        },
        {
            key: "trace",
            value: function trace(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                if (this.enabled && this.level <= 0 /* Trace */ ) {
                    var _m_channel;
                    (_m_channel = this.m_channel).trace.apply(_m_channel, [
                        this.prefix,
                        message
                    ].concat(_toConsumableArray(optionalParams)));
                }
            }
        },
        {
            key: "warn",
            value: function warn(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                if (this.enabled && this.level <= 4 /* Warn */ ) {
                    var _m_channel;
                    (_m_channel = this.m_channel).warn.apply(_m_channel, [
                        this.prefix,
                        message
                    ].concat(_toConsumableArray(optionalParams)));
                }
            }
        },
        {
            key: "update",
            value: function update(options) {
                this.enabled = options.enabled === void 0 ? this.enabled : options.enabled;
                this.level = options.level === void 0 ? this.level : options.level;
            }
        },
        {
            key: "prefix",
            get: function get() {
                return this.name + ":";
            }
        }
    ]);
    return Logger;
}();
// src/utils/Logger/WorkerChannel.ts
var WORKERCHANNEL_MSG_TYPE = "worker-channel-message";
var WorkerChannel = /*#__PURE__*/ function() {
    function WorkerChannel() {
        _classCallCheck(this, WorkerChannel);
    }
    _createClass(WorkerChannel, [
        {
            key: "error",
            value: function error(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var workerMessage = {
                    message: [
                        message
                    ].concat(_toConsumableArray(optionalParams)),
                    type: WORKERCHANNEL_MSG_TYPE,
                    level: 5 /* Error */ 
                };
                self.postMessage(workerMessage);
            }
        },
        {
            key: "debug",
            value: function debug(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var workerMessage = {
                    message: [
                        message
                    ].concat(_toConsumableArray(optionalParams)),
                    type: WORKERCHANNEL_MSG_TYPE,
                    level: 1 /* Debug */ 
                };
                self.postMessage(workerMessage);
            }
        },
        {
            key: "info",
            value: function info(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var workerMessage = {
                    message: [
                        message
                    ].concat(_toConsumableArray(optionalParams)),
                    type: WORKERCHANNEL_MSG_TYPE,
                    level: 3 /* Info */ 
                };
                self.postMessage(workerMessage);
            }
        },
        {
            key: "log",
            value: function log(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var workerMessage = {
                    message: [
                        message
                    ].concat(_toConsumableArray(optionalParams)),
                    type: WORKERCHANNEL_MSG_TYPE,
                    level: 2 /* Log */ 
                };
                self.postMessage(workerMessage);
            }
        },
        {
            key: "trace",
            value: function trace(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var workerMessage = {
                    message: [
                        message
                    ].concat(_toConsumableArray(optionalParams)),
                    type: WORKERCHANNEL_MSG_TYPE,
                    level: 0 /* Trace */ 
                };
                self.postMessage(workerMessage);
            }
        },
        {
            key: "warn",
            value: function warn(message) {
                for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    optionalParams[_key - 1] = arguments[_key];
                }
                var workerMessage = {
                    message: [
                        message
                    ].concat(_toConsumableArray(optionalParams)),
                    type: WORKERCHANNEL_MSG_TYPE,
                    level: 4 /* Warn */ 
                };
                self.postMessage(workerMessage);
            }
        }
    ]);
    return WorkerChannel;
}();
// src/utils/Logger/LoggerManagerImpl.ts
var LoggerManagerImpl = /*#__PURE__*/ function() {
    function LoggerManagerImpl() {
        _classCallCheck(this, LoggerManagerImpl);
        __publicField(this, "channel");
        __publicField(this, "m_loggers", []);
        __publicField(this, "m_levelSetForAll");
        this.channel = typeof self === "undefined" || typeof self.document !== "undefined" ? new ConsoleChannel() : new WorkerChannel();
    }
    _createClass(LoggerManagerImpl, [
        {
            key: "getLoggerNames",
            value: function getLoggerNames() {
                return this.m_loggers.map(function(logger31) {
                    return logger31.name;
                });
            }
        },
        {
            key: "getLogger",
            value: function getLogger(name2) {
                return this.m_loggers.find(function(logger31) {
                    return logger31.name === name2;
                });
            }
        },
        {
            key: "create",
            value: function create(loggerName) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (this.m_levelSetForAll !== void 0 && (options.level === void 0 || options.level < this.m_levelSetForAll)) {
                    options.level = this.m_levelSetForAll;
                }
                var logger31 = new Logger(loggerName, this.channel, options);
                this.m_loggers.push(logger31);
                return logger31;
            }
        },
        {
            key: "dispose",
            value: function dispose(logger31) {
                var found = this.m_loggers.indexOf(logger31);
                if (found < 0) {
                    throw new Error('Cannot unregister "'.concat(logger31, '" : no such logger registered.'));
                }
                this.m_loggers.splice(found, 1);
            }
        },
        {
            key: "updateAll",
            value: function updateAll(options) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_loggers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var logger31 = _step.value;
                        logger31.update(options);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "update",
            value: function update(loggerName, config) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_loggers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var logger31 = _step.value;
                        if (logger31.name === loggerName) {
                            logger31.update(config);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "enableAll",
            value: function enableAll(enabled) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_loggers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var logger31 = _step.value;
                        logger31.enabled = enabled;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "enable",
            value: function enable(loggerName, value2) {
                this.update(loggerName, {
                    enabled: value2
                });
            }
        },
        {
            key: "setLogLevelForAll",
            value: function setLogLevelForAll(level) {
                this.m_levelSetForAll = level;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_loggers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var logger31 = _step.value;
                        logger31.level = level;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "setLogLevel",
            value: function setLogLevel(loggerName, level) {
                this.update(loggerName, {
                    level: level
                });
            }
        },
        {
            key: "setChannel",
            value: function setChannel(channel) {
                this.channel = channel;
            }
        }
    ]);
    return LoggerManagerImpl;
}();
// src/utils/Logger/LoggerManager.ts
var LoggerManager = /*#__PURE__*/ function() {
    function LoggerManager() {
        _classCallCheck(this, LoggerManager);
    }
    _createClass(LoggerManager, null, [
        {
            key: "instance",
            get: function get() {
                return this.m_instance || (this.m_instance = new LoggerManagerImpl());
            }
        }
    ]);
    return LoggerManager;
}();
__publicField(LoggerManager, "m_instance");
// src/utils/LRUCache.ts
var Entry = function Entry(key, value2, size, newer, older) {
    _classCallCheck(this, Entry);
    this.key = key;
    this.value = value2;
    this.size = size;
    this.newer = newer;
    this.older = older;
};
var LRUCache = /*#__PURE__*/ function() {
    function LRUCache(cacheCapacity) {
        var sizeFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
            return 1;
        };
        _classCallCheck(this, LRUCache);
        __publicField(this, "evictionCallback");
        __publicField(this, "canEvict");
        __publicField(this, "m_capacity");
        __publicField(this, "m_size", 0);
        __publicField(this, "m_map", /* @__PURE__ */ new Map());
        __publicField(this, "m_newest", null);
        __publicField(this, "m_oldest", null);
        __publicField(this, "m_sizeFunction");
        this.m_capacity = cacheCapacity;
        this.m_sizeFunction = sizeFunction;
    }
    _createClass(LRUCache, [
        {
            key: "forEach",
            value: function forEach(callbackfn, thisArg) {
                var entry = this.m_newest;
                while(entry !== null){
                    var older = entry.older;
                    callbackfn.call(thisArg, entry.value, entry.key, this);
                    entry = older;
                }
            }
        },
        {
            key: "size",
            get: function get() {
                return this.m_size;
            }
        },
        {
            key: "capacity",
            get: function get() {
                return this.m_capacity;
            }
        },
        {
            key: "map",
            get: function get() {
                return this.m_map;
            }
        },
        {
            key: "newest",
            get: function get() {
                return this.m_newest;
            }
        },
        {
            key: "oldest",
            get: function get() {
                return this.m_oldest;
            }
        },
        {
            key: "setCapacity",
            value: function setCapacity(newCapacity) {
                this.m_capacity = newCapacity;
                this.evict();
            }
        },
        {
            key: "setCapacityAndMeasure",
            value: function setCapacityAndMeasure(newCapacity) {
                var sizeMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
                    return 1;
                };
                this.m_capacity = newCapacity;
                this.m_sizeFunction = sizeMeasure;
                this.shrinkToCapacity();
            }
        },
        {
            key: "shrinkToCapacity",
            value: function shrinkToCapacity() {
                var size = 0;
                var sizeFunction = this.m_sizeFunction;
                var entry = this.m_newest;
                while(entry !== null){
                    var entrySize = sizeFunction(entry.value);
                    entry.size = entrySize;
                    size += entrySize;
                    entry = entry.older;
                }
                this.m_size = size;
                this.evict();
            }
        },
        {
            key: "set",
            value: function set(key, value2) {
                var valueSize = this.m_sizeFunction(value2);
                var entry = this.m_map.get(key);
                if (entry !== void 0) {
                    this.m_size = this.m_size - entry.size + valueSize;
                    entry.value = value2;
                    entry.size = valueSize;
                    this.promoteEntry(entry);
                    this.evict();
                } else {
                    if (valueSize > this.m_capacity) {
                        return;
                    }
                    entry = new Entry(key, value2, valueSize, null, null);
                    if (this.m_map.size === 0) {
                        this.m_newest = this.m_oldest = entry;
                    } else {
                        assert(this.m_newest !== null);
                        var newest = this.m_newest;
                        entry.older = this.m_newest;
                        newest.newer = entry;
                        this.m_newest = entry;
                    }
                    this.m_map.set(key, entry);
                    this.m_size += valueSize;
                    this.evict();
                }
            }
        },
        {
            key: "get",
            value: function get(key) {
                var entry = this.m_map.get(key);
                if (entry === void 0) {
                    return void 0;
                }
                this.promoteEntry(entry);
                return entry.value;
            }
        },
        {
            key: "has",
            value: function has(key) {
                return this.m_map.has(key);
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_newest = this.m_oldest = null;
                this.m_size = 0;
                this.m_map.clear();
            }
        },
        {
            key: "evictAll",
            value: function evictAll() {
                var cb = this.evictionCallback;
                if (cb !== void 0) {
                    this.forEach(function(value2, key) {
                        return cb(key, value2);
                    });
                }
                this.clear();
            }
        },
        {
            key: "evictSelected",
            value: function evictSelected(selector, thisArg) {
                var cb = this.evictionCallback;
                var entry = this.m_newest;
                while(entry !== null){
                    var entryOlder = entry.older;
                    if (selector.call(thisArg, entry.value, entry.key)) {
                        if (cb !== void 0) {
                            cb(entry.key, entry.value);
                        }
                        this.deleteEntry(entry);
                        this.m_map.delete(entry.key);
                    }
                    entry = entryOlder;
                }
            }
        },
        {
            key: "delete",
            value: function _delete(key) {
                var entry = this.m_map.get(key);
                if (entry === void 0) {
                    return false;
                }
                this.deleteEntry(entry);
                return this.m_map.delete(key);
            }
        },
        {
            key: "evict",
            value: function evict() {
                while(this.m_oldest !== null && this.m_size > this.m_capacity){
                    var evicted = this.evictOldest();
                    if (evicted === void 0) {
                        return;
                    }
                }
            }
        },
        {
            key: "evictOldest",
            value: function evictOldest() {
                assert(this.m_oldest !== null);
                var oldest = this.m_oldest;
                assert(oldest.older === null);
                var itemToRemove = oldest;
                if (this.canEvict !== void 0) {
                    while(!this.canEvict(itemToRemove.key, itemToRemove.value)){
                        if (itemToRemove.newer === null) {
                            return void 0;
                        }
                        itemToRemove = itemToRemove.newer;
                    }
                }
                if (itemToRemove === oldest) {
                    this.m_oldest = itemToRemove.newer;
                    if (itemToRemove.newer !== null) {
                        assert(itemToRemove.newer.older === itemToRemove);
                        itemToRemove.newer.older = null;
                    }
                } else {
                    if (itemToRemove.newer !== null) {
                        assert(itemToRemove.newer.older === itemToRemove);
                        itemToRemove.newer.older = itemToRemove.older;
                        if (itemToRemove.older !== null) {
                            itemToRemove.older.newer = itemToRemove.newer;
                        }
                    } else {
                        return void 0;
                    }
                }
                var isOk = this.m_map.delete(itemToRemove.key);
                assert(isOk === true);
                if (isOk && this.evictionCallback !== void 0) {
                    this.evictionCallback(itemToRemove.key, itemToRemove.value);
                }
                this.m_size -= itemToRemove.size;
                return itemToRemove;
            }
        },
        {
            key: "deleteEntry",
            value: function deleteEntry(entry) {
                if (entry === this.m_newest) {
                    this.m_newest = entry.older;
                } else if (entry.newer) {
                    entry.newer.older = entry.older;
                } else {
                    assert(false);
                }
                if (entry === this.m_oldest) {
                    this.m_oldest = entry.newer;
                } else if (entry.older) {
                    entry.older.newer = entry.newer;
                } else {
                    assert(false);
                }
                this.m_size -= entry.size;
            }
        },
        {
            key: "promoteEntry",
            value: function promoteEntry(entry) {
                if (entry === this.m_newest) {
                    return;
                }
                if (entry.newer) {
                    assert(entry.newer.older === entry);
                    entry.newer.older = entry.older;
                }
                if (entry.older) {
                    assert(entry.older.newer === entry);
                    entry.older.newer = entry.newer;
                }
                if (entry === this.m_oldest) {
                    this.m_oldest = entry.newer;
                }
                entry.newer = null;
                entry.older = this.m_newest;
                assert(this.m_newest !== null);
                var newest = this.m_newest;
                assert(newest.newer === null);
                newest.newer = entry;
                this.m_newest = entry;
            }
        }
    ]);
    return LRUCache;
}();
// src/utils/Math2D.ts
var Math2D;
(function(Math2D3) {
    var distSquared = function distSquared(ax, ay, bx, by) {
        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
    };
    var computeSquaredLineLength = function computeSquaredLineLength(line) {
        var squaredLineLength = 0;
        var length = line.length - 4;
        for(var i = 0; i < length; i += 3){
            var xDiff = line[i + 3] - line[i];
            var yDiff = line[i + 4] - line[i + 1];
            squaredLineLength += xDiff * xDiff + yDiff * yDiff;
        }
        return squaredLineLength;
    };
    var distToSegmentSquared = function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {
        var lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);
        if (lineLengthSuared === 0) {
            return distSquared(px, py, l0x, l0y);
        }
        var t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;
        t = Math.max(0, Math.min(1, t));
        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));
    };
    var intersectLineAndCircle = function intersectLineAndCircle(xLine1, yLine1, xLine2, yLine2, radius) {
        var xCenter = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, yCenter = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
        var epsilon3 = 1e-10;
        var dx = xLine2 - xLine1;
        var dy = yLine2 - yLine1;
        var dSq = dx * dx + dy * dy;
        var rSq = radius * radius;
        var c = xLine1 * yLine2 - xLine2 * yLine1;
        var cp = c - dy * xCenter + dx * yCenter;
        var discriminantSquared = rSq * dSq - cp * cp;
        if (discriminantSquared < -epsilon3) {
            return void 0;
        }
        var xMid = cp * dy;
        var yMid = -cp * dx;
        if (discriminantSquared < epsilon3) {
            return {
                x1: xCenter + xMid / dSq,
                y1: yCenter + yMid / dSq
            };
        }
        var discriminant = Math.sqrt(discriminantSquared);
        var signDy = dy < 0 ? -1 : 1;
        var absDy = Math.abs(dy);
        var xDist = signDy * dx * discriminant;
        var yDist = absDy * discriminant;
        return {
            x1: xCenter + (xMid + xDist) / dSq,
            y1: yCenter + (yMid + yDist) / dSq,
            x2: xCenter + (xMid - xDist) / dSq,
            y2: yCenter + (yMid - yDist) / dSq
        };
    };
    var intersectLines = function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {
        var result = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : {
            x: 0,
            y: 0
        };
        var d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (d === 0) {
            return void 0;
        }
        var px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;
        var py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;
        result.x = px;
        result.y = py;
        return result;
    };
    var Box = /*#__PURE__*/ function() {
        function Box() {
            var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            _classCallCheck(this, Box);
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        _createClass(Box, [
            {
                key: "set",
                value: function set(x, y, w, h) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                }
            },
            {
                key: "copy",
                value: function copy(box) {
                    this.x = box.x;
                    this.y = box.y;
                    this.w = box.w;
                    this.h = box.h;
                }
            },
            {
                key: "contains",
                value: function contains(x, y) {
                    return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;
                }
            },
            {
                key: "containsBox",
                value: function containsBox(other) {
                    var xmax = other.x + other.w;
                    var ymax = other.y + other.h;
                    return this.contains(other.x, other.y) && this.contains(xmax, other.y) && this.contains(other.x, ymax) && this.contains(xmax, ymax);
                }
            },
            {
                key: "intersects",
                value: function intersects(other) {
                    return this.x <= other.x + other.w && this.x + this.w >= other.x && this.y <= other.y + other.h && this.y + this.h >= other.y;
                }
            }
        ]);
        return Box;
    }();
    Math2D3.Box = Box;
    Math2D3.distSquared = distSquared;
    Math2D3.computeSquaredLineLength = computeSquaredLineLength;
    Math2D3.distToSegmentSquared = distToSegmentSquared;
    Math2D3.intersectLineAndCircle = intersectLineAndCircle;
    Math2D3.intersectLines = intersectLines;
})(Math2D || (Math2D = {}));
// src/utils/MathUtils.ts
var MathUtils;
(function(MathUtils38) {
    var clamp = function clamp(value2, min, max) {
        return value2 < min ? min : value2 > max ? max : value2;
    };
    var smoothStep = function smoothStep(edge0, edge1, x) {
        x = clamp((x - edge0) / (edge1 - edge0), 0, 1);
        return x * x * (3 - 2 * x);
    };
    var smootherStep = function smootherStep(edge0, edge1, x) {
        x = clamp((x - edge0) / (edge1 - edge0), 0, 1);
        return x * x * x * (x * (x * 6 - 15) + 10);
    };
    var map = function map(val, inMin, inMax, outMin, outMax) {
        return (val - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    };
    var min2 = function min2(a, b) {
        var result;
        if (a !== void 0) {
            result = a;
        }
        if (b !== void 0) {
            result = result === void 0 ? b : Math.min(result, b);
        }
        return result;
    };
    var max2 = function max2(a, b) {
        var result;
        if (a !== void 0) {
            result = a;
        }
        if (b !== void 0) {
            result = result === void 0 ? b : Math.max(result, b);
        }
        return result;
    };
    var isClamped = function isClamped(value2, lowerBound, upperBound) {
        if (lowerBound !== void 0 && value2 < lowerBound) {
            return false;
        }
        if (upperBound !== void 0 && value2 > upperBound) {
            return false;
        }
        return true;
    };
    var easeInOutCubic = function easeInOutCubic(startValue, endValue, time) {
        var timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        return startValue + (endValue - startValue) * timeValue;
    };
    MathUtils38.clamp = clamp;
    MathUtils38.smoothStep = smoothStep;
    MathUtils38.smootherStep = smootherStep;
    MathUtils38.map = map;
    MathUtils38.min2 = min2;
    MathUtils38.max2 = max2;
    MathUtils38.isClamped = isClamped;
    MathUtils38.easeInOutCubic = easeInOutCubic;
})(MathUtils || (MathUtils = {}));
// src/utils/Mixins.ts
function applyMixinsWithoutProperties(derivedCtor, baseCtors) {
    baseCtors.forEach(function(baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function(name2) {
            var descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name2);
            if (descriptor !== void 0 && descriptor.get === void 0 && name2 !== "constructor") {
                derivedCtor.prototype[name2] = baseCtor.prototype[name2];
            }
        });
    });
}
// src/utils/ObjectUtils.ts
function pick(object, props) {
    var result = {};
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var propName = _step.value;
            if (object.hasOwnProperty(propName)) {
                result[propName] = object[propName];
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return result;
}
// src/utils/OptionsUtils.ts
function getOptionValue() {
    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){
        values[_key] = arguments[_key];
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var candidate = _step.value;
            if (candidate !== void 0 && candidate !== null) {
                return candidate;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return void 0;
}
// src/utils/PerformanceTimer.ts
var _PerformanceTimer = /*#__PURE__*/ function() {
    function _PerformanceTimer() {
        _classCallCheck(this, _PerformanceTimer);
    }
    _createClass(_PerformanceTimer, null, [
        {
            key: "now",
            value: function now() {
                return _PerformanceTimer.nowFunc();
            }
        },
        {
            key: "getNowFunc",
            value: function getNowFunc() {
                if (typeof performance !== "undefined" && typeof performance.now !== "undefined") {
                    return function() {
                        return performance.now();
                    };
                }
                return function() {
                    return new Date().getTime();
                };
            }
        }
    ]);
    return _PerformanceTimer;
}();
var PerformanceTimer = _PerformanceTimer;
__publicField(PerformanceTimer, "instance", new _PerformanceTimer());
__publicField(PerformanceTimer, "nowFunc", _PerformanceTimer.getNowFunc());
// src/utils/SampleBilinear.ts
function sampleBilinear(texture, width, height, u, v) {
    var maxXIndex = width - 1;
    var maxYIndex = height - 1;
    var xIndex = u * maxXIndex;
    var xIndexFloor = Math.floor(xIndex);
    var yIndex = v * maxYIndex;
    var yIndexFloor = Math.floor(yIndex);
    var swIndex = yIndexFloor * width + xIndexFloor;
    var seIndex = xIndexFloor < maxXIndex ? swIndex + 1 : swIndex;
    var nwIndex = yIndexFloor < maxYIndex ? swIndex + width : swIndex;
    var neIndex = xIndexFloor < maxXIndex ? nwIndex + 1 : nwIndex;
    var swElevation = texture[swIndex];
    var seElevation = texture[seIndex];
    var nwElevation = texture[nwIndex];
    var neElevation = texture[neIndex];
    var xFrac = Number.isInteger(xIndex) ? 0 : xIndex - xIndexFloor;
    var xFracInverse = 1 - xFrac;
    var yFrac = Number.isInteger(yIndex) ? 0 : yIndex - yIndexFloor;
    var yFracInverse = 1 - yFrac;
    var result = swElevation * xFracInverse * yFracInverse + seElevation * xFrac * yFracInverse + nwElevation * xFracInverse * yFrac + neElevation * xFrac * yFrac;
    return result;
}
// src/utils/TaskQueue.ts
var TaskQueue = /*#__PURE__*/ function() {
    function TaskQueue(m_options) {
        var _this = this;
        _classCallCheck(this, TaskQueue);
        var ref;
        this.m_options = m_options;
        __publicField(this, "m_taskLists", /* @__PURE__ */ new Map());
        (ref = this.m_options.groups) === null || ref === void 0 ? void 0 : ref.forEach(function(group) {
            _this.m_taskLists.set(group, []);
        });
        if (this.m_options.prioSortFn) {
            this.sort = this.m_options.prioSortFn;
        }
    }
    _createClass(TaskQueue, [
        {
            key: "update",
            value: function update(group) {
                var _this = this;
                if (group === void 0) {
                    this.m_taskLists.forEach(function(taskList) {
                        _this.updateTaskList(taskList);
                    });
                } else {
                    var taskList = this.getTaskList(group);
                    if (taskList) {
                        this.updateTaskList(taskList);
                    }
                }
            }
        },
        {
            key: "add",
            value: function add(task) {
                if (this.m_taskLists.has(task.group)) {
                    var taskList = this.m_taskLists.get(task.group);
                    if (!(taskList === null || taskList === void 0 ? void 0 : taskList.includes(task))) {
                        var ref;
                        (ref = this.m_taskLists.get(task.group)) === null || ref === void 0 ? void 0 : ref.push(task);
                        return true;
                    }
                }
                return false;
            }
        },
        {
            key: "remove",
            value: function remove(task) {
                if (this.m_taskLists.has(task.group)) {
                    var ref;
                    var index = (ref = this.m_taskLists.get(task.group)) === null || ref === void 0 ? void 0 : ref.indexOf(task);
                    if (index !== -1) {
                        var ref1;
                        (ref1 = this.m_taskLists.get(task.group)) === null || ref1 === void 0 ? void 0 : ref1.splice(index, 1);
                        return true;
                    }
                }
                return false;
            }
        },
        {
            key: "numItemsLeft",
            value: function numItemsLeft(group) {
                var numLeft = 0;
                if (group === void 0) {
                    this.m_taskLists.forEach(function(tasklist) {
                        numLeft += tasklist.length;
                    });
                } else {
                    var ref;
                    var ref1;
                    numLeft += (ref1 = (ref = this.getTaskList(group)) === null || ref === void 0 ? void 0 : ref.length) !== null && ref1 !== void 0 ? ref1 : 0;
                }
                return numLeft;
            }
        },
        {
            key: "processNext",
            value: function processNext(group, shouldProcess) {
                var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
                if (!this.getTaskList(group) || this.numItemsLeft(group) <= 0) {
                    return false;
                }
                for(var i = 0; i < n && this.numItemsLeft(group) > 0; i++){
                    var nextTask = this.pull(group, true);
                    if (nextTask !== void 0) {
                        if (!shouldProcess || (shouldProcess === null || shouldProcess === void 0 ? void 0 : shouldProcess(nextTask))) {
                            nextTask.execute();
                        } else {
                            this.add(nextTask);
                        }
                    }
                }
                return true;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_taskLists.clear();
            }
        },
        {
            key: "pull",
            value: function pull(group) {
                var checkIfExpired = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                var taskList = this.getTaskList(group);
                var nextTask;
                if (taskList) {
                    var ref, ref1;
                    nextTask = (ref = this.getTaskList(group)) === null || ref === void 0 ? void 0 : ref.pop();
                    if (checkIfExpired && nextTask && ((ref1 = nextTask.isExpired) === null || ref1 === void 0 ? void 0 : ref1.call(nextTask))) {
                        return this.pull(group, checkIfExpired);
                    }
                }
                return nextTask;
            }
        },
        {
            key: "sort",
            value: function sort(a, b) {
                return b.getPriority() - a.getPriority();
            }
        },
        {
            key: "getTaskList",
            value: function getTaskList(group) {
                return this.m_taskLists.get(group);
            }
        },
        {
            key: "updateTaskList",
            value: function updateTaskList(taskList) {
                for(var i = 0; i < taskList.length; i++){
                    var ref;
                    var task = taskList[i];
                    if (task === null || task === void 0 ? void 0 : (ref = task.isExpired) === null || ref === void 0 ? void 0 : ref.call(task)) {
                        taskList.splice(i, 1);
                        i--;
                    }
                }
                taskList.sort(this.sort);
            }
        }
    ]);
    return TaskQueue;
}();
// src/utils/UrlUtils.ts
function resolveReferenceUri(parentUri, childUri) {
    if (absoluteUrlWithOriginRe.test(childUri)) {
        return childUri;
    } else if (childUri.startsWith("/")) {
        var origin = getUrlOrigin(parentUri);
        return origin + childUri;
    } else {
        if (childUri.startsWith("./")) {
            childUri = childUri.substr(2);
        }
        var parentBaseUrl = baseUrl(parentUri);
        return parentBaseUrl + childUri;
    }
}
var absoluteUrlWithOriginRe = new RegExp("^(((?:[a-z]+:)?//)|(file:/)|(data:))", "i");
function baseUrl(url) {
    if (url === void 0) {
        return "./";
    }
    var idx = url.indexOf("#");
    if (idx !== -1) {
        url = url.slice(0, idx);
    }
    idx = url.indexOf("?");
    if (idx !== -1) {
        url = url.slice(0, idx);
    }
    idx = url.lastIndexOf("/");
    if (idx === -1) {
        return "./";
    } else {
        return url.substring(0, idx + 1);
    }
}
function getUrlOrigin(url) {
    if (url === void 0) {
        return "";
    }
    var parsed = getUrlHostAndProtocol(url);
    if (parsed.protocol === "file:") {
        return "file://";
    } else if (parsed.host && parsed.protocol) {
        return parsed.protocol + "//" + parsed.host;
    } else if (parsed.host) {
        return "//" + parsed.host;
    } else if (parsed.protocol) {
        return parsed.protocol + "//";
    } else {
        return "";
    }
}
function getUrlHostAndProtocol(url) {
    var urlOriginRe = new RegExp(/^(?:([a-z]+:))?\/\/([^\/]*)/, "i");
    var match = url.match(urlOriginRe);
    if (!match) {
        throw new Error("getUrlHostAndProtocol: unable to parse URL '".concat(url, "'"));
    }
    return {
        protocol: match[1],
        host: match[2]
    };
}
// src/utils/UrlPlatformUtils.ts
function getAppBaseUrl() {
    if (typeof window === "undefined") {
        return "file://".concat(process.cwd(), "/");
    }
    return baseUrl(window.location.href);
}
// src/utils/UriResolver.ts
var RelativeUriResolver = /*#__PURE__*/ function() {
    function RelativeUriResolver(parentUri) {
        _classCallCheck(this, RelativeUriResolver);
        this.parentUri = parentUri;
    }
    _createClass(RelativeUriResolver, [
        {
            key: "resolveUri",
            value: function resolveUri(uri) {
                return resolveReferenceUri(this.parentUri, uri);
            }
        }
    ]);
    return RelativeUriResolver;
}();
function composeUriResolvers() {
    for(var _len = arguments.length, resolvers = new Array(_len), _key = 0; _key < _len; _key++){
        resolvers[_key] = arguments[_key];
    }
    return {
        resolveUri: function resolveUri(originalUrl) {
            return resolvers.reduce(function(url, resolver) {
                if (resolver !== void 0) {
                    return resolver.resolveUri(url);
                } else {
                    return url;
                }
            }, originalUrl);
        }
    };
}
// src/datasource-protocol/RGBA.ts
var import_three = require("three");
// src/datasource-protocol/StringEncodedNumeral.ts
var import_csscolorparser = require("csscolorparser");
var StringEncodedMeters = {
    type: 0 /* Meters */ ,
    size: 1,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))m$/,
    decoder: function(encodedValue, target) {
        var match = StringEncodedMeters.regExp.exec(encodedValue);
        return match ? (target[0] = Number(match[1])) !== void 0 : false;
    }
};
var StringEncodedPixels = {
    type: 1 /* Pixels */ ,
    size: 1,
    mask: 1,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/,
    decoder: function(encodedValue, target) {
        var match = StringEncodedPixels.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        target[0] = Number(match[1]);
        return true;
    }
};
var StringEncodedHex = {
    type: 2 /* Hex */ ,
    size: 4,
    regExp: /^\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,
    decoder: function(encodedValue, target) {
        var match = StringEncodedHex.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        var hex = match[1];
        var size = hex.length;
        assert(size === 4 || size === 8, "Matched incorrect hex color format");
        if (size === 4) {
            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;
        } else if (size === 8) {
            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;
        }
        return true;
    }
};
var StringEncodedMetricFormats = [
    StringEncodedMeters,
    StringEncodedPixels
];
var StringEncodedMetricFormatMaxSize = StringEncodedMetricFormats.reduce(function(a, b) {
    return Math.max(a, b.size);
}, 0);
var StringEncodedColorFormats = [
    StringEncodedHex
];
var StringEncodedColorFormatMaxSize = StringEncodedColorFormats.reduce(function(a, b) {
    return Math.max(a, b.size);
}, 0);
var StringEncodedNumeralFormats = _toConsumableArray(StringEncodedMetricFormats).concat(_toConsumableArray(StringEncodedColorFormats));
var StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);
var tmpBuffer = new Array(StringEncodedNumeralFormatMaxSize);
function parseStringEncodedNumeral(numeral) {
    var pixelToMeters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return parseStringLiteral(numeral, StringEncodedNumeralFormats, pixelToMeters);
}
function parseStringEncodedColor(color) {
    return parseStringLiteral(color, StringEncodedColorFormats);
}
function parseStringLiteral(text, formats) {
    var pixelToMeters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    var matchedFormat = formats.find(function(format) {
        return format.decoder(text, tmpBuffer) ? true : false;
    });
    if (matchedFormat === void 0) {
        var components = (0, import_csscolorparser.parseCSSColor)(text);
        return Array.isArray(components) && !components.some(function(c) {
            return isNaN(c);
        }) ? ColorUtils.getHexFromRgba(components[0] / 255, components[1] / 255, components[2] / 255, components[3]) : void 0;
    }
    switch(matchedFormat === null || matchedFormat === void 0 ? void 0 : matchedFormat.type){
        case 1 /* Pixels */ :
            return tmpBuffer[0] * pixelToMeters;
        case 2 /* Hex */ :
            return ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);
        default:
            return tmpBuffer[0];
    }
}
// src/datasource-protocol/RGBA.ts
var RGBA = /*#__PURE__*/ function() {
    function RGBA() {
        var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
        _classCallCheck(this, RGBA);
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    _createClass(RGBA, [
        {
            key: "clone",
            value: function clone() {
                return new RGBA(this.r, this.g, this.b, this.a);
            }
        },
        {
            key: "getHex",
            value: function getHex() {
                return ColorUtils.getHexFromRgba(this.r, this.g, this.b, this.a);
            }
        },
        {
            key: "lerp",
            value: function lerp(target, t) {
                this.r = import_three.MathUtils.lerp(this.r, target.r, t);
                this.g = import_three.MathUtils.lerp(this.g, target.g, t);
                this.b = import_three.MathUtils.lerp(this.b, target.b, t);
                this.a = import_three.MathUtils.lerp(this.a, target.a, t);
                return this;
            }
        },
        {
            key: "toJSON",
            value: function toJSON() {
                return "rgba(".concat(this.r * 255 << 0, ", ").concat(this.g * 255 << 0, ", ").concat(this.b * 255 << 0, ", ").concat(this.a, ")");
            }
        }
    ], [
        {
            key: "parse",
            value: function parse(text) {
                var color = parseStringEncodedColor(text);
                if (color === void 0) {
                    return void 0;
                }
                return ColorUtils.getRgbaFromHex(color);
            }
        }
    ]);
    return RGBA;
}();
// src/datasource-protocol/ColorUtils.ts
var SHIFT_TRANSPARENCY = 24;
var SHIFT_RED = 16;
var SHIFT_GREEN = 8;
var SHIFT_BLUE = 0;
var HEX_FULL_CHANNEL = 255;
var HEX_RGB_MASK = 16777215;
var HEX_TRGB_MASK = 4294967295;
var tmpColor = new THREE.Color();
var ColorUtils;
(function(ColorUtils2) {
    var getHexFromRgba = function getHexFromRgba(r, g, b, a) {
        assert(a >= 0 && a <= 1);
        var t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);
        return t << SHIFT_TRANSPARENCY ^ r * HEX_FULL_CHANNEL << SHIFT_RED ^ g * HEX_FULL_CHANNEL << SHIFT_GREEN ^ b * HEX_FULL_CHANNEL << SHIFT_BLUE;
    };
    var getHexFromRgb = function getHexFromRgb(r, g, b) {
        assert(r >= 0 && r <= 1);
        assert(g >= 0 && g <= 1);
        assert(b >= 0 && b <= 1);
        return r * HEX_FULL_CHANNEL << SHIFT_RED ^ g * HEX_FULL_CHANNEL << SHIFT_GREEN ^ b * HEX_FULL_CHANNEL << SHIFT_BLUE;
    };
    var getHexFromHsl = function getHexFromHsl(h, s, l) {
        assert(h >= 0 && h <= 1);
        assert(s >= 0 && s <= 1);
        assert(l >= 0 && l <= 1);
        return tmpColor.setHSL(h, s, l).getHex();
    };
    var getRgbaFromHex = function getRgbaFromHex(hex) {
        var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new RGBA();
        assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        target.r = (hex >> SHIFT_RED & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.g = (hex >> SHIFT_GREEN & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.b = (hex >> SHIFT_BLUE & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.a = (HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY & HEX_FULL_CHANNEL)) / HEX_FULL_CHANNEL;
        return target;
    };
    var hasAlphaInHex = function hasAlphaInHex(hex) {
        assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return hex >> SHIFT_TRANSPARENCY !== 0;
    };
    var getAlphaFromHex = function getAlphaFromHex(hex) {
        assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return (HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
    };
    var removeAlphaFromHex = function removeAlphaFromHex(hex) {
        assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return hex & HEX_RGB_MASK;
    };
    ColorUtils2.getHexFromRgba = getHexFromRgba;
    ColorUtils2.getHexFromRgb = getHexFromRgb;
    ColorUtils2.getHexFromHsl = getHexFromHsl;
    ColorUtils2.getRgbaFromHex = getRgbaFromHex;
    ColorUtils2.hasAlphaInHex = hasAlphaInHex;
    ColorUtils2.getAlphaFromHex = getAlphaFromHex;
    ColorUtils2.removeAlphaFromHex = removeAlphaFromHex;
})(ColorUtils || (ColorUtils = {}));
// src/geoutils/coordinates/GeoBox.ts
var THREE3 = __toESM(require("three"));
// src/geoutils/coordinates/GeoCoordinates.ts
var THREE2 = __toESM(require("three"));
// src/geoutils/coordinates/GeoCoordinatesLike.ts
function isGeoCoordinatesLike(object) {
    return object && typeof object.latitude === "number" && typeof object.longitude === "number" && (typeof object.altitude === "number" || typeof object.altitude === "undefined");
}
// src/geoutils/coordinates/GeoPointLike.ts
function isGeoPointLike(geoPoint) {
    if (Array.isArray(geoPoint)) {
        var _geoPoint = _slicedToArray(geoPoint, 3), longitude = _geoPoint[0], latitude = _geoPoint[1], altitude = _geoPoint[2];
        return typeof longitude === "number" && typeof latitude === "number" && (altitude === void 0 || typeof altitude === "number");
    }
    return false;
}
// src/geoutils/coordinates/LatLngLike.ts
function isLatLngLike(object) {
    return object && typeof object.lat === "number" && typeof object.lng === "number";
}
// src/geoutils/coordinates/GeoCoordinates.ts
var MAX_LATITUDE = 90;
var MIN_LATITUDE = -90;
var MAX_LONGITUDE = 180;
var tmpV0 = new THREE2.Vector3();
var tmpV1 = new THREE2.Vector3();
function mod(dividend, divisor) {
    var modulo = dividend % divisor;
    var modulo_sign = modulo < 0;
    var divisor_sign = divisor < 0;
    return modulo_sign === divisor_sign ? modulo : modulo + divisor;
}
var GeoCoordinates = /*#__PURE__*/ function() {
    function GeoCoordinates(latitude, longitude, altitude) {
        _classCallCheck(this, GeoCoordinates);
        this.latitude = latitude;
        this.longitude = longitude;
        this.altitude = altitude;
    }
    _createClass(GeoCoordinates, [
        {
            key: "latitudeInRadians",
            get: function get() {
                return THREE2.MathUtils.degToRad(this.latitude);
            }
        },
        {
            key: "longitudeInRadians",
            get: function get() {
                return THREE2.MathUtils.degToRad(this.longitude);
            }
        },
        {
            key: "latitudeInDegrees",
            get: function get() {
                return this.latitude;
            }
        },
        {
            key: "longitudeInDegrees",
            get: function get() {
                return this.longitude;
            }
        },
        {
            key: "lat",
            get: function get() {
                return this.latitude;
            }
        },
        {
            key: "lng",
            get: function get() {
                return this.longitude;
            }
        },
        {
            key: "isValid",
            value: function isValid() {
                return !isNaN(this.latitude) && !isNaN(this.longitude);
            }
        },
        {
            key: "normalized",
            value: function normalized() {
                var ref = this, latitude = ref.latitude, longitude = ref.longitude;
                if (isNaN(latitude) || isNaN(longitude)) {
                    return this;
                }
                if (longitude < -180 || longitude > 180) {
                    longitude = mod(longitude + 180, 360) - 180;
                }
                latitude = THREE2.MathUtils.clamp(latitude, -90, 90);
                return new GeoCoordinates(latitude, longitude, this.altitude);
            }
        },
        {
            key: "equals",
            value: function equals(other) {
                return this.latitude === other.latitude && this.longitude === other.longitude && this.altitude === other.altitude;
            }
        },
        {
            key: "copy",
            value: function copy(other) {
                this.latitude = other.latitude;
                this.longitude = other.longitude;
                this.altitude = other.altitude;
                return this;
            }
        },
        {
            key: "clone",
            value: function clone() {
                return new GeoCoordinates(this.latitude, this.longitude, this.altitude);
            }
        },
        {
            key: "toLatLng",
            value: function toLatLng() {
                return {
                    lat: this.latitude,
                    lng: this.longitude
                };
            }
        },
        {
            key: "toGeoPoint",
            value: function toGeoPoint() {
                return this.altitude !== void 0 ? [
                    this.longitude,
                    this.latitude,
                    this.altitude
                ] : [
                    this.longitude,
                    this.latitude
                ];
            }
        },
        {
            key: "minLongitudeSpanTo",
            value: function minLongitudeSpanTo(other) {
                var minLongitude = Math.min(this.longitude, other.longitude);
                var maxLongitude = Math.max(this.longitude, other.longitude);
                return Math.min(maxLongitude - minLongitude, 360 + minLongitude - maxLongitude);
            }
        }
    ], [
        {
            key: "fromDegrees",
            value: function fromDegrees(latitude, longitude, altitude) {
                return new GeoCoordinates(latitude, longitude, altitude);
            }
        },
        {
            key: "fromRadians",
            value: function fromRadians(latitude, longitude, altitude) {
                return new GeoCoordinates(THREE2.MathUtils.radToDeg(latitude), THREE2.MathUtils.radToDeg(longitude), altitude);
            }
        },
        {
            key: "fromLatLng",
            value: function fromLatLng(latLng) {
                return new GeoCoordinates(latLng.lat, latLng.lng);
            }
        },
        {
            key: "fromGeoPoint",
            value: function fromGeoPoint(geoPoint) {
                return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);
            }
        },
        {
            key: "fromObject",
            value: function fromObject(geoPoint) {
                if (isGeoPointLike(geoPoint)) {
                    return GeoCoordinates.fromGeoPoint(geoPoint);
                } else if (isGeoCoordinatesLike(geoPoint)) {
                    return GeoCoordinates.fromDegrees(geoPoint.latitude, geoPoint.longitude, geoPoint.altitude);
                } else if (isLatLngLike(geoPoint)) {
                    return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);
                }
                throw new Error("Invalid input coordinate format.");
            }
        },
        {
            key: "lerp",
            value: function lerp(geoCoords0, geoCoords1, factor) {
                var wrap = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, normalize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                if (wrap) {
                    if (geoCoords0.lng < geoCoords1.lng) {
                        var geoCoordsEnd = geoCoords0.clone();
                        geoCoordsEnd.longitude += 360;
                        return this.lerp(geoCoords1, geoCoordsEnd, 1 - factor);
                    } else {
                        var geoCoordsEnd1 = geoCoords1.clone();
                        geoCoordsEnd1.longitude += 360;
                        return this.lerp(geoCoords0, geoCoordsEnd1, factor);
                    }
                }
                var _altitude;
                var v0 = tmpV0.set(geoCoords0.lat, geoCoords0.lng, (_altitude = geoCoords0.altitude) !== null && _altitude !== void 0 ? _altitude : 0);
                var _altitude1;
                var v1 = tmpV1.set(geoCoords1.lat, geoCoords1.lng, (_altitude1 = geoCoords1.altitude) !== null && _altitude1 !== void 0 ? _altitude1 : 0);
                v0.lerp(v1, factor);
                var result = new GeoCoordinates(v0.x, v0.y, v0.z);
                return normalize ? result.normalized() : result;
            }
        }
    ]);
    return GeoCoordinates;
}();
// src/geoutils/coordinates/GeoBox.ts
var GeoBox = /*#__PURE__*/ function() {
    function GeoBox(southWest, northEast) {
        _classCallCheck(this, GeoBox);
        this.southWest = southWest;
        this.northEast = northEast;
        if (this.west > this.east) {
            this.northEast.longitude += 360;
        }
    }
    _createClass(GeoBox, [
        {
            key: "minAltitude",
            get: function get() {
                if (this.southWest.altitude === void 0 || this.northEast.altitude === void 0) {
                    return void 0;
                }
                return Math.min(this.southWest.altitude, this.northEast.altitude);
            }
        },
        {
            key: "maxAltitude",
            get: function get() {
                if (this.southWest.altitude === void 0 || this.northEast.altitude === void 0) {
                    return void 0;
                }
                return Math.max(this.southWest.altitude, this.northEast.altitude);
            }
        },
        {
            key: "south",
            get: function get() {
                return this.southWest.latitude;
            }
        },
        {
            key: "north",
            get: function get() {
                return this.northEast.latitude;
            }
        },
        {
            key: "west",
            get: function get() {
                return this.southWest.longitude;
            }
        },
        {
            key: "east",
            get: function get() {
                return this.northEast.longitude;
            }
        },
        {
            key: "center",
            get: function get() {
                var latitude = (this.south + this.north) * 0.5;
                var ref = this, west = ref.west, east = ref.east;
                var ref1 = this, minAltitude = ref1.minAltitude, altitudeSpan = ref1.altitudeSpan;
                var altitude;
                if (minAltitude !== void 0 && altitudeSpan !== void 0) {
                    altitude = minAltitude + altitudeSpan * 0.5;
                }
                if (west <= east) {
                    return new GeoCoordinates(latitude, (west + east) * 0.5, altitude);
                }
                var longitude = (360 + east + west) * 0.5;
                if (longitude > 360) {
                    longitude -= 360;
                }
                return new GeoCoordinates(latitude, longitude, altitude);
            }
        },
        {
            key: "latitudeSpanInRadians",
            get: function get() {
                return THREE3.MathUtils.degToRad(this.latitudeSpan);
            }
        },
        {
            key: "longitudeSpanInRadians",
            get: function get() {
                return THREE3.MathUtils.degToRad(this.longitudeSpan);
            }
        },
        {
            key: "latitudeSpan",
            get: function get() {
                return this.north - this.south;
            }
        },
        {
            key: "altitudeSpan",
            get: function get() {
                if (this.maxAltitude === void 0 || this.minAltitude === void 0) {
                    return void 0;
                }
                return this.maxAltitude - this.minAltitude;
            }
        },
        {
            key: "longitudeSpan",
            get: function get() {
                var width = this.northEast.longitude - this.southWest.longitude;
                if (width < 0) {
                    width += 360;
                }
                return width;
            }
        },
        {
            key: "latitudeSpanInDegrees",
            get: function get() {
                return this.latitudeSpan;
            }
        },
        {
            key: "longitudeSpanInDegrees",
            get: function get() {
                return this.longitudeSpan;
            }
        },
        {
            key: "contains",
            value: function contains(point) {
                if (point.altitude === void 0 || this.minAltitude === void 0 || this.maxAltitude === void 0) {
                    return this.containsHelper(point);
                }
                var isFlat = this.minAltitude === this.maxAltitude;
                var isSameAltitude = this.minAltitude === point.altitude;
                var isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;
                if (isFlat ? isSameAltitude : isWithinAltitudeRange) {
                    return this.containsHelper(point);
                }
                return false;
            }
        },
        {
            key: "clone",
            value: function clone() {
                return new GeoBox(this.southWest.clone(), this.northEast.clone());
            }
        },
        {
            key: "growToContain",
            value: function growToContain(point) {
                this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);
                this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);
                this.southWest.altitude = this.southWest.altitude !== void 0 && point.altitude !== void 0 ? Math.min(this.southWest.altitude, point.altitude) : this.southWest.altitude !== void 0 ? this.southWest.altitude : point.altitude !== void 0 ? point.altitude : void 0;
                this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);
                this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);
                this.northEast.altitude = this.northEast.altitude !== void 0 && point.altitude !== void 0 ? Math.max(this.northEast.altitude, point.altitude) : this.northEast.altitude !== void 0 ? this.northEast.altitude : point.altitude !== void 0 ? point.altitude : void 0;
            }
        },
        {
            key: "containsHelper",
            value: function containsHelper(point) {
                if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {
                    return false;
                }
                var ref = this, west = ref.west, east = ref.east;
                var longitude = point.longitude;
                if (east > MAX_LONGITUDE) {
                    while(longitude < west){
                        longitude = longitude + 360;
                    }
                }
                if (longitude > east) {
                    while(longitude > west + 360){
                        longitude = longitude - 360;
                    }
                }
                return longitude >= west && longitude < east;
            }
        }
    ], [
        {
            key: "fromCoordinates",
            value: function fromCoordinates(southWest, northEast) {
                return new GeoBox(southWest, northEast);
            }
        },
        {
            key: "fromCenterAndExtents",
            value: function fromCenterAndExtents(center, extent) {
                return new GeoBox(new GeoCoordinates(center.latitude - extent.latitudeSpan / 2, center.longitude - extent.longitudeSpan / 2), new GeoCoordinates(center.latitude + extent.latitudeSpan / 2, center.longitude + extent.longitudeSpan / 2));
            }
        }
    ]);
    return GeoBox;
}();
// src/geoutils/coordinates/GeoBoxExtentLike.ts
function isGeoBoxExtentLike(obj) {
    return obj && typeof obj === "object" && typeof obj.latitudeSpan === "number" && typeof obj.longitudeSpan === "number";
}
// src/geoutils/coordinates/GeoCoordLike.ts
function geoCoordLikeToGeoCoordinatesLike(coord) {
    return isGeoCoordinatesLike(coord) ? coord : isLatLngLike(coord) ? {
        latitude: coord.lat,
        longitude: coord.lng
    } : {
        latitude: coord[1],
        longitude: coord[0]
    };
}
// src/geoutils/coordinates/GeoPolygon.ts
var import_three2 = require("three");
function computeLonSpanAcrossGreewich(lonA, lonB) {
    return Math.max(lonA, lonB) - Math.min(lonA, lonB);
}
function isLeftToRightAntimeridianCrossing(lonStart, lonEnd) {
    return lonStart > 0 && lonEnd < 0 && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;
}
function isRightToLeftAntimeridianCrossing(lonStart, lonEnd) {
    return isLeftToRightAntimeridianCrossing(lonEnd, lonStart);
}
function isAntimeridianCrossing(lonStart, lonEnd) {
    return Math.sign(lonStart) === -Math.sign(lonEnd) && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;
}
var GeoPolygon = /*#__PURE__*/ function() {
    function GeoPolygon(coordinates) {
        var needsSort = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, needsWrapping = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        _classCallCheck(this, GeoPolygon);
        __publicField(this, "m_coordinates");
        this.m_coordinates = coordinates.map(function(coord) {
            return geoCoordLikeToGeoCoordinatesLike(coord);
        });
        if (needsSort) {
            this.sortCCW();
        }
        if (needsWrapping) {
            this.wrapCoordinatesAround();
        }
    }
    _createClass(GeoPolygon, [
        {
            key: "coordinates",
            get: function get() {
                return this.m_coordinates;
            }
        },
        {
            key: "getGeoBoundingBox",
            value: function getGeoBoundingBox() {
                var centroid = this.getCentroid();
                if (centroid === void 0) {
                    return GeoBox.fromCoordinates(this.coordinates[0], this.coordinates[0]);
                }
                var ref = this.getEastAndWest(centroid), east = ref.east, west = ref.west;
                var ref1 = this.getNorthAndSouth(), north = ref1.north, south = ref1.south;
                return GeoBox.fromCoordinates(new GeoCoordinates(south, west), new GeoCoordinates(north, east));
            }
        },
        {
            key: "getCentroid",
            value: function getCentroid() {
                var _this = this;
                var area = this.getArea();
                if (area === 0) {
                    return void 0;
                }
                var latitude = 0;
                var longitude = 0;
                var f;
                var previousIndex = this.m_coordinates.length - 1;
                this.m_coordinates.forEach(function(coordinate, index) {
                    var previousCoordinate = _this.m_coordinates[previousIndex];
                    f = coordinate.latitude * previousCoordinate.longitude - previousCoordinate.latitude * coordinate.longitude;
                    latitude += (coordinate.latitude + previousCoordinate.latitude) * f;
                    longitude += (coordinate.longitude + previousCoordinate.longitude) * f;
                    previousIndex = index;
                });
                f = area * 6;
                return new GeoCoordinates(latitude / f, area < 0 ? -180 + longitude / f : longitude / f);
            }
        },
        {
            key: "sortCCW",
            value: function sortCCW() {
                var polyCenter = this.getPolyAverageCenter();
                if (!polyCenter) {
                    return;
                }
                this.m_coordinates.sort(function(a, b) {
                    var veca = new import_three2.Vector2(a.latitude - polyCenter.latitude, a.longitude - polyCenter.longitude).normalize();
                    var vecb = new import_three2.Vector2(b.latitude - polyCenter.latitude, b.longitude - polyCenter.longitude).normalize();
                    return vecb.angle() - veca.angle();
                });
            }
        },
        {
            key: "wrapCoordinatesAround",
            value: function wrapCoordinatesAround() {
                var _this = this;
                var firstAntimerCrossIndex = this.m_coordinates.findIndex(function(val, index) {
                    var prevLonIndex = index === 0 ? _this.m_coordinates.length - 1 : index - 1;
                    var prevLon = _this.m_coordinates[prevLonIndex].longitude;
                    var lon = val.longitude;
                    return isLeftToRightAntimeridianCrossing(prevLon, lon);
                });
                if (firstAntimerCrossIndex < 0) {
                    return;
                }
                var wrapAround = true;
                for(var i = 0; i < this.m_coordinates.length; i++){
                    var index = (firstAntimerCrossIndex + i) % this.m_coordinates.length;
                    var currentLon = this.m_coordinates[index].longitude;
                    var nextLon = this.m_coordinates[(index + 1) % this.m_coordinates.length].longitude;
                    if (wrapAround) {
                        this.m_coordinates[index].longitude += 360;
                    }
                    if (isRightToLeftAntimeridianCrossing(currentLon, nextLon)) {
                        wrapAround = false;
                    } else if (isLeftToRightAntimeridianCrossing(currentLon, nextLon)) {
                        wrapAround = true;
                    }
                }
            }
        },
        {
            key: "getPolyAverageCenter",
            value: function getPolyAverageCenter() {
                var polySum = this.m_coordinates.reduce(function(prev, curr) {
                    return new GeoCoordinates(prev.latitude + curr.latitude, prev.longitude + curr.longitude);
                });
                return new GeoCoordinates(polySum.latitude / this.m_coordinates.length, polySum.longitude / this.m_coordinates.length);
            }
        },
        {
            key: "getArea",
            value: function getArea() {
                var _this = this;
                var area = 0;
                var previousIndex = this.m_coordinates.length - 1;
                this.m_coordinates.forEach(function(coordinate, index) {
                    var previousCoordinate = _this.m_coordinates[previousIndex];
                    area += coordinate.latitude * previousCoordinate.longitude;
                    area -= coordinate.longitude * previousCoordinate.latitude;
                    previousIndex = index;
                });
                return area /= 2;
            }
        },
        {
            key: "getEastAndWest",
            value: function getEastAndWest(center) {
                var _this = this;
                var west = center.longitude;
                var east = center.longitude;
                var previousIndex = this.m_coordinates.length - 1;
                this.m_coordinates.forEach(function(coordinate, index) {
                    var previousCoordinate = _this.m_coordinates[previousIndex];
                    previousIndex = index;
                    var veca = new import_three2.Vector2(coordinate.latitude - center.latitude, coordinate.longitude - center.longitude).normalize();
                    var vecb = new import_three2.Vector2(previousCoordinate.latitude - center.latitude, previousCoordinate.longitude - center.longitude).normalize();
                    var ccw = Math.sign(vecb.angle() - veca.angle()) === 1;
                    if (vecb.y >= 0 && veca.y < 0) {
                        ccw = true;
                    }
                    var long = coordinate.longitude;
                    if (long < center.longitude) {
                        if (ccw) {
                            west = Math.min(west, long);
                        } else {
                            east = Math.min(east, long);
                        }
                    } else {
                        if (ccw) {
                            east = Math.max(east, long);
                        } else {
                            west = Math.max(west, long);
                        }
                    }
                });
                return {
                    east: east,
                    west: west
                };
            }
        },
        {
            key: "getNorthAndSouth",
            value: function getNorthAndSouth() {
                var north = MIN_LATITUDE;
                var south = MAX_LATITUDE;
                this.m_coordinates.forEach(function(coordinate, index) {
                    north = Math.max(north, coordinate.latitude);
                    south = Math.min(south, coordinate.latitude);
                });
                return {
                    north: north,
                    south: south
                };
            }
        }
    ]);
    return GeoPolygon;
}();
// src/geoutils/math/Box3Like.ts
function isBox3Like(object) {
    var box3 = object;
    return box3.min !== void 0 && box3.max !== void 0;
}
// src/geoutils/math/MathUtils.ts
var THREE4 = __toESM(require("three"));
var MathUtils6;
(function(MathUtils38) {
    var newEmptyBox3 = function newEmptyBox3() {
        return {
            min: {
                x: Infinity,
                y: Infinity,
                z: Infinity
            },
            max: {
                x: -Infinity,
                y: -Infinity,
                z: -Infinity
            }
        };
    };
    var newVector3 = function newVector3(x, y, z, v) {
        if (v === void 0) {
            return {
                x: x,
                y: y,
                z: z
            };
        }
        v.x = x;
        v.y = y;
        v.z = z;
        return v;
    };
    var copyVector3 = function copyVector3(from, to) {
        to.x = from.x;
        to.y = from.y;
        to.z = from.z;
        return to;
    };
    var normalizeAngleDeg = function normalizeAngleDeg(a) {
        a = a % 360;
        if (a < 0) {
            a = a + 360;
        }
        return a;
    };
    var normalizeLongitudeDeg = function normalizeLongitudeDeg(a) {
        a = normalizeAngleDeg(a);
        if (a > 180) {
            a = a - 360;
        }
        return a;
    };
    var angleDistanceDeg = function angleDistanceDeg(a, b) {
        a = normalizeAngleDeg(a);
        b = normalizeAngleDeg(b);
        var d = a - b;
        if (d > 180) {
            return d - 360;
        } else if (d <= -180) {
            return d + 360;
        } else {
            return d;
        }
    };
    var interpolateAnglesDeg = function interpolateAnglesDeg(p0, p1, t) {
        var d = angleDistanceDeg(p1, p0);
        var r = (p0 + d * t) % 360;
        return r;
    };
    MathUtils38.newEmptyBox3 = newEmptyBox3;
    MathUtils38.newVector3 = newVector3;
    MathUtils38.copyVector3 = copyVector3;
    MathUtils38.degToRad = THREE4.MathUtils.degToRad;
    MathUtils38.radToDeg = THREE4.MathUtils.radToDeg;
    MathUtils38.clamp = THREE4.MathUtils.clamp;
    MathUtils38.normalizeAngleDeg = normalizeAngleDeg;
    MathUtils38.normalizeLongitudeDeg = normalizeLongitudeDeg;
    MathUtils38.angleDistanceDeg = angleDistanceDeg;
    MathUtils38.interpolateAnglesDeg = interpolateAnglesDeg;
})(MathUtils6 || (MathUtils6 = {}));
// src/geoutils/math/OrientedBox3.ts
var import_three3 = require("three");
function intersectsSlab(rayDir, p, axis, extent, t) {
    var epsilon3 = 1e-20;
    var e = axis.dot(p);
    var f = axis.dot(rayDir);
    if (Math.abs(f) < epsilon3) {
        return Math.abs(e) <= extent;
    }
    var finv = 1 / f;
    var t1 = (e + extent) * finv;
    var t2 = (e - extent) * finv;
    if (t1 > t2) {
        if (t2 > t.min) {
            t.min = t2;
        }
        if (t1 < t.max) {
            t.max = t1;
        }
    } else {
        if (t1 > t.min) {
            t.min = t1;
        }
        if (t2 < t.max) {
            t.max = t2;
        }
    }
    return t.min <= t.max && t.max >= 0;
}
var tmpVec = new import_three3.Vector3();
var tmpT = {
    min: -Infinity,
    max: Infinity
};
var OrientedBox3 = /*#__PURE__*/ function() {
    function OrientedBox3(position, rotationMatrix, extents) {
        _classCallCheck(this, OrientedBox3);
        __publicField(this, "position", new import_three3.Vector3());
        __publicField(this, "xAxis", new import_three3.Vector3(1, 0, 0));
        __publicField(this, "yAxis", new import_three3.Vector3(0, 1, 0));
        __publicField(this, "zAxis", new import_three3.Vector3(0, 0, 1));
        __publicField(this, "extents", new import_three3.Vector3());
        if (position !== void 0) {
            this.position.copy(position);
        }
        if (rotationMatrix !== void 0) {
            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);
        }
        if (extents !== void 0) {
            this.extents.copy(extents);
        }
    }
    _createClass(OrientedBox3, [
        {
            key: "clone",
            value: function clone() {
                var newBox = new OrientedBox3();
                newBox.copy(this);
                return newBox;
            }
        },
        {
            key: "copy",
            value: function copy(other) {
                this.position.copy(other.position);
                this.xAxis.copy(other.xAxis);
                this.yAxis.copy(other.yAxis);
                this.zAxis.copy(other.zAxis);
                this.extents.copy(other.extents);
            }
        },
        {
            key: "getCenter",
            value: function getCenter() {
                var center = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new import_three3.Vector3();
                return center.copy(this.position);
            }
        },
        {
            key: "getSize",
            value: function getSize() {
                var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new import_three3.Vector3();
                return size.copy(this.extents).multiplyScalar(2);
            }
        },
        {
            key: "getRotationMatrix",
            value: function getRotationMatrix() {
                var matrix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new import_three3.Matrix4();
                return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);
            }
        },
        {
            key: "intersects",
            value: function intersects(frustumOrPlanes) {
                var planes = Array.isArray(frustumOrPlanes) ? frustumOrPlanes : frustumOrPlanes.planes;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = planes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var plane = _step.value;
                        var r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) + Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) + Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);
                        var d = plane.distanceToPoint(this.position);
                        if (d + r < 0) {
                            return false;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return true;
            }
        },
        {
            key: "intersectsRay",
            value: function intersectsRay(ray) {
                tmpT.min = -Infinity;
                tmpT.max = Infinity;
                tmpVec.copy(this.position).sub(ray.origin);
                if (!intersectsSlab(ray.direction, tmpVec, this.xAxis, this.extents.x, tmpT)) {
                    return void 0;
                }
                if (!intersectsSlab(ray.direction, tmpVec, this.yAxis, this.extents.y, tmpT)) {
                    return void 0;
                }
                if (!intersectsSlab(ray.direction, tmpVec, this.zAxis, this.extents.z, tmpT)) {
                    return void 0;
                }
                return tmpT.min > 0 ? tmpT.min : tmpT.max;
            }
        },
        {
            key: "contains",
            value: function contains(point) {
                var dx = point.x - this.position.x;
                var dy = point.y - this.position.y;
                var dz = point.z - this.position.z;
                var x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);
                var y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);
                var z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);
                if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {
                    return false;
                }
                return true;
            }
        },
        {
            key: "distanceToPoint",
            value: function distanceToPoint(point) {
                return Math.sqrt(this.distanceToPointSquared(point));
            }
        },
        {
            key: "distanceToPointSquared",
            value: function distanceToPointSquared(point) {
                var d = new import_three3.Vector3();
                d.subVectors(point, this.position);
                var lengths = [
                    d.dot(this.xAxis),
                    d.dot(this.yAxis),
                    d.dot(this.zAxis)
                ];
                var result = 0;
                for(var i = 0; i < 3; ++i){
                    var length = lengths[i];
                    var extent = this.extents.getComponent(i);
                    if (length < -extent) {
                        var dd = extent + length;
                        result += dd * dd;
                    } else if (length > extent) {
                        var dd1 = length - extent;
                        result += dd1 * dd1;
                    }
                }
                return result;
            }
        }
    ]);
    return OrientedBox3;
}();
// src/geoutils/math/Vector3Like.ts
function isVector3Like(v) {
    return v && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number";
}
// src/geoutils/projection/EarthConstants.ts
var EarthConstants = function EarthConstants() {
    _classCallCheck(this, EarthConstants);
};
__publicField(EarthConstants, "EQUATORIAL_CIRCUMFERENCE", 4007501668557849e-8);
__publicField(EarthConstants, "EQUATORIAL_RADIUS", 6378137);
__publicField(EarthConstants, "MIN_ELEVATION", -433);
__publicField(EarthConstants, "MAX_ELEVATION", 8848);
__publicField(EarthConstants, "MAX_BUILDING_HEIGHT", 828);
// src/geoutils/projection/EquirectangularProjection.ts
var THREE5 = __toESM(require("three"));
// src/geoutils/math/OrientedBox3Like.ts
function isOrientedBox3Like(object) {
    var obb = object;
    return obb.position !== void 0 && obb.xAxis !== void 0 && obb.yAxis !== void 0 && obb.zAxis !== void 0 && obb.extents !== void 0;
}
// src/geoutils/projection/Projection.ts
var Projection = /*#__PURE__*/ function() {
    function Projection(unitScale) {
        _classCallCheck(this, Projection);
        this.unitScale = unitScale;
    }
    _createClass(Projection, [
        {
            key: "localTangentSpace",
            value: function localTangentSpace(point, result) {
                if (isGeoCoordinatesLike(point)) {
                    this.projectPoint(point, result.position);
                } else {
                    MathUtils6.copyVector3(point, result.position);
                }
                MathUtils6.newVector3(1, 0, 0, result.xAxis);
                MathUtils6.newVector3(0, 1, 0, result.yAxis);
                MathUtils6.newVector3(0, 0, 1, result.zAxis);
                return result;
            }
        },
        {
            key: "reprojectPoint",
            value: function reprojectPoint(sourceProjection, worldPos, result) {
                if (sourceProjection === this) {
                    if (result === void 0) {
                        return {
                            x: worldPos.x,
                            y: worldPos.y,
                            z: worldPos.z
                        };
                    }
                    result.x = worldPos.x;
                    result.y = worldPos.y;
                    result.z = worldPos.z;
                    return result;
                }
                return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);
            }
        }
    ]);
    return Projection;
}();
// src/geoutils/projection/EquirectangularProjection.ts
var _EquirectangularProjection = /*#__PURE__*/ function(Projection) {
    _inherits(_EquirectangularProjection, Projection);
    var _super = _createSuper(_EquirectangularProjection);
    function _EquirectangularProjection() {
        _classCallCheck(this, _EquirectangularProjection);
        var _this;
        _this = _super.call.apply(_super, [
            this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assertThisInitialized(_this), "type", 0 /* Planar */ );
        return _this;
    }
    _createClass(_EquirectangularProjection, [
        {
            key: "getScaleFactor",
            value: function getScaleFactor(_worldPoint) {
                return 1;
            }
        },
        {
            key: "worldExtent",
            value: function worldExtent(minAltitude, maxAltitude, result) {
                if (!result) {
                    result = new THREE5.Box3();
                }
                result.min.x = 0;
                result.min.y = 0;
                result.min.z = minAltitude;
                result.max.x = this.unitScale;
                result.max.y = this.unitScale / 2;
                result.max.z = maxAltitude;
                return result;
            }
        },
        {
            key: "projectPoint",
            value: function projectPoint(geoPoint, result) {
                if (result === void 0) {
                    result = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                }
                result.x = (THREE5.MathUtils.degToRad(geoPoint.longitude) + Math.PI) * _EquirectangularProjection.geoToWorldScale * this.unitScale;
                result.y = (THREE5.MathUtils.degToRad(geoPoint.latitude) + Math.PI * 0.5) * _EquirectangularProjection.geoToWorldScale * this.unitScale;
                var _altitude;
                result.z = (_altitude = geoPoint.altitude) !== null && _altitude !== void 0 ? _altitude : 0;
                return result;
            }
        },
        {
            key: "unprojectPoint",
            value: function unprojectPoint(worldPoint) {
                var geoPoint = GeoCoordinates.fromRadians(worldPoint.y * _EquirectangularProjection.worldToGeoScale / this.unitScale - Math.PI * 0.5, worldPoint.x * _EquirectangularProjection.worldToGeoScale / this.unitScale - Math.PI, worldPoint.z);
                return geoPoint;
            }
        },
        {
            key: "unprojectAltitude",
            value: function unprojectAltitude(worldPoint) {
                return worldPoint.z;
            }
        },
        {
            key: "projectBox",
            value: function projectBox(geoBox, result) {
                var worldCenter = this.projectPoint(new GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));
                var latitudeSpanInRadians = geoBox.latitudeSpanInRadians, longitudeSpanInRadians = geoBox.longitudeSpanInRadians, altitudeSpan = geoBox.altitudeSpan;
                var sizeX = longitudeSpanInRadians * _EquirectangularProjection.geoToWorldScale;
                var sizeY = latitudeSpanInRadians * _EquirectangularProjection.geoToWorldScale;
                if (!result) {
                    result = new THREE5.Box3();
                }
                if (isBox3Like(result)) {
                    result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;
                    result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;
                    result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;
                    result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;
                    if (altitudeSpan !== void 0) {
                        result.min.z = worldCenter.z - altitudeSpan * 0.5;
                        result.max.z = worldCenter.z + altitudeSpan * 0.5;
                    } else {
                        result.min.z = 0;
                        result.max.z = 0;
                    }
                } else if (isOrientedBox3Like(result)) {
                    MathUtils6.newVector3(1, 0, 0, result.xAxis);
                    MathUtils6.newVector3(0, 1, 0, result.yAxis);
                    MathUtils6.newVector3(0, 0, 1, result.zAxis);
                    result.position.x = worldCenter.x;
                    result.position.y = worldCenter.y;
                    result.position.z = worldCenter.z;
                    result.extents.x = sizeX * 0.5 * this.unitScale;
                    result.extents.y = sizeY * 0.5 * this.unitScale;
                    result.extents.z = Math.max(Number.EPSILON, (altitudeSpan !== null && altitudeSpan !== void 0 ? altitudeSpan : 0) * 0.5);
                }
                return result;
            }
        },
        {
            key: "unprojectBox",
            value: function unprojectBox(worldBox) {
                var minGeo = this.unprojectPoint(worldBox.min);
                var maxGeo = this.unprojectPoint(worldBox.max);
                return GeoBox.fromCoordinates(minGeo, maxGeo);
            }
        },
        {
            key: "groundDistance",
            value: function groundDistance(worldPoint) {
                return worldPoint.z;
            }
        },
        {
            key: "scalePointToSurface",
            value: function scalePointToSurface(worldPoint) {
                worldPoint.z = 0;
                return worldPoint;
            }
        },
        {
            key: "surfaceNormal",
            value: function surfaceNormal(_worldPoint, normal) {
                if (normal === void 0) {
                    normal = {
                        x: 0,
                        y: 0,
                        z: 1
                    };
                } else {
                    normal.x = 0;
                    normal.y = 0;
                    normal.z = 1;
                }
                return normal;
            }
        }
    ]);
    return _EquirectangularProjection;
}(Projection);
var EquirectangularProjection = _EquirectangularProjection;
__publicField(EquirectangularProjection, "geoToWorldScale", 1 / (2 * Math.PI));
__publicField(EquirectangularProjection, "worldToGeoScale", 2 * Math.PI / 1);
var normalizedEquirectangularProjection = new EquirectangularProjection(1);
var equirectangularProjection = new EquirectangularProjection(EarthConstants.EQUATORIAL_CIRCUMFERENCE);
// src/geoutils/projection/MercatorProjection.ts
var THREE6 = __toESM(require("three"));
var MercatorProjection = /*#__PURE__*/ function(Projection) {
    _inherits(MercatorProjection, Projection);
    var _super = _createSuper(MercatorProjection);
    function MercatorProjection() {
        _classCallCheck(this, MercatorProjection);
        var _this;
        _this = _super.call.apply(_super, [
            this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assertThisInitialized(_this), "type", 0 /* Planar */ );
        return _this;
    }
    _createClass(MercatorProjection, [
        {
            key: "getScaleFactor",
            value: function getScaleFactor(worldPoint) {
                return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));
            }
        },
        {
            key: "worldExtent",
            value: function worldExtent(minAltitude, maxAltitude, result) {
                if (!result) {
                    result = new THREE6.Box3();
                }
                result.min.x = 0;
                result.min.y = 0;
                result.min.z = minAltitude;
                result.max.x = this.unitScale;
                result.max.y = this.unitScale;
                result.max.z = maxAltitude;
                return result;
            }
        },
        {
            key: "projectPoint",
            value: function projectPoint(geoPointLike, result) {
                var geoPoint;
                if (_instanceof(geoPointLike, GeoCoordinates)) {
                    geoPoint = geoPointLike;
                } else {
                    geoPoint = new GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
                }
                if (!result) {
                    result = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                }
                result.x = (geoPoint.longitude + 180) / 360 * this.unitScale;
                result.y = (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) * this.unitScale;
                var _altitude;
                result.z = (_altitude = geoPoint.altitude) !== null && _altitude !== void 0 ? _altitude : 0;
                return result;
            }
        },
        {
            key: "unprojectPoint",
            value: function unprojectPoint(worldPoint) {
                var geoPoint = GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2), worldPoint.x / this.unitScale * 2 * Math.PI - Math.PI, worldPoint.z);
                return geoPoint;
            }
        },
        {
            key: "unprojectAltitude",
            value: function unprojectAltitude(worldPoint) {
                return worldPoint.z;
            }
        },
        {
            key: "projectBox",
            value: function projectBox(geoBox, result) {
                var worldCenter = this.projectPoint(geoBox.center);
                var worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 + 0.5) * this.unitScale;
                var worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 + 0.5) * this.unitScale;
                var worldYCenter = (worldNorth + worldSouth) * 0.5;
                worldCenter.y = worldYCenter;
                var latitudeSpan = worldNorth - worldSouth;
                var longitudeSpan = geoBox.longitudeSpan / 360 * this.unitScale;
                if (!result) {
                    result = new THREE6.Box3();
                }
                if (isBox3Like(result)) {
                    result.min.x = worldCenter.x - longitudeSpan * 0.5;
                    result.min.y = worldCenter.y - latitudeSpan * 0.5;
                    result.max.x = worldCenter.x + longitudeSpan * 0.5;
                    result.max.y = worldCenter.y + latitudeSpan * 0.5;
                    var altitudeSpan = geoBox.altitudeSpan;
                    if (altitudeSpan !== void 0) {
                        result.min.z = worldCenter.z - altitudeSpan * 0.5;
                        result.max.z = worldCenter.z + altitudeSpan * 0.5;
                    } else {
                        result.min.z = 0;
                        result.max.z = 0;
                    }
                } else if (isOrientedBox3Like(result)) {
                    MathUtils6.newVector3(1, 0, 0, result.xAxis);
                    MathUtils6.newVector3(0, 1, 0, result.yAxis);
                    MathUtils6.newVector3(0, 0, 1, result.zAxis);
                    result.position.x = worldCenter.x;
                    result.position.y = worldCenter.y;
                    result.position.z = worldCenter.z;
                    result.extents.x = longitudeSpan * 0.5;
                    result.extents.y = latitudeSpan * 0.5;
                    var _altitudeSpan;
                    result.extents.z = Math.max(Number.EPSILON, ((_altitudeSpan = geoBox.altitudeSpan) !== null && _altitudeSpan !== void 0 ? _altitudeSpan : 0) * 0.5);
                } else {
                    throw new Error("invalid bounding box");
                }
                return result;
            }
        },
        {
            key: "unprojectBox",
            value: function unprojectBox(worldBox) {
                var minGeo = this.unprojectPoint(worldBox.min);
                var maxGeo = this.unprojectPoint(worldBox.max);
                var geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);
                return geoBox;
            }
        },
        {
            key: "groundDistance",
            value: function groundDistance(worldPoint) {
                return worldPoint.z;
            }
        },
        {
            key: "scalePointToSurface",
            value: function scalePointToSurface(worldPoint) {
                worldPoint.z = 0;
                return worldPoint;
            }
        },
        {
            key: "surfaceNormal",
            value: function surfaceNormal(_worldPoint, normal) {
                if (normal === void 0) {
                    normal = {
                        x: 0,
                        y: 0,
                        z: 1
                    };
                } else {
                    normal.x = 0;
                    normal.y = 0;
                    normal.z = 1;
                }
                return normal;
            }
        },
        {
            key: "reprojectPoint",
            value: function reprojectPoint(sourceProjection, worldPos, result) {
                if (sourceProjection !== this && (sourceProjection === webMercatorProjection || sourceProjection === mercatorProjection)) {
                    if (result === void 0) {
                        result = {};
                    }
                    result.x = worldPos.x;
                    result.y = this.unitScale - worldPos.y;
                    result.z = worldPos.z;
                    return result;
                }
                return _get(_getPrototypeOf(MercatorProjection.prototype), "reprojectPoint", this).call(this, sourceProjection, worldPos, result);
            }
        }
    ], [
        {
            key: "clamp",
            value: function clamp(val, min, max) {
                return Math.min(Math.max(min, val), max);
            }
        },
        {
            key: "latitudeClamp",
            value: function latitudeClamp(latitude) {
                return MercatorProjection.clamp(latitude, -MercatorConstants.MAXIMUM_LATITUDE, MercatorConstants.MAXIMUM_LATITUDE);
            }
        },
        {
            key: "latitudeProject",
            value: function latitudeProject(latitude) {
                return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;
            }
        },
        {
            key: "latitudeClampProject",
            value: function latitudeClampProject(latitude) {
                return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));
            }
        },
        {
            key: "unprojectLatitude",
            value: function unprojectLatitude(y) {
                return 2 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;
            }
        }
    ]);
    return MercatorProjection;
}(Projection);
var WebMercatorProjection = /*#__PURE__*/ function(MercatorProjection1) {
    _inherits(WebMercatorProjection, MercatorProjection1);
    var _super = _createSuper(WebMercatorProjection);
    function WebMercatorProjection() {
        _classCallCheck(this, WebMercatorProjection);
        return _super.apply(this, arguments);
    }
    _createClass(WebMercatorProjection, [
        {
            key: "projectPoint",
            value: function projectPoint(geoPointLike, result) {
                var geoPoint;
                if (_instanceof(geoPointLike, GeoCoordinates)) {
                    geoPoint = geoPointLike;
                } else {
                    geoPoint = new GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
                }
                if (!result) {
                    result = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                }
                result.x = (geoPoint.longitude + 180) / 360 * this.unitScale;
                var sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));
                result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;
                var _altitude;
                result.z = (_altitude = geoPoint.altitude) !== null && _altitude !== void 0 ? _altitude : 0;
                return result;
            }
        },
        {
            key: "unprojectPoint",
            value: function unprojectPoint(worldPoint) {
                var x = worldPoint.x / this.unitScale - 0.5;
                var y = 0.5 - worldPoint.y / this.unitScale;
                var longitude = 360 * x;
                var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
                return new GeoCoordinates(latitude, longitude, worldPoint.z);
            }
        },
        {
            key: "projectBox",
            value: function projectBox(geoBox, result) {
                var r = _get(_getPrototypeOf(WebMercatorProjection.prototype), "projectBox", this).call(this, geoBox, result);
                if (isBox3Like(r)) {
                    var maxY = r.max.y;
                    r.max.y = this.unitScale - r.min.y;
                    r.min.y = this.unitScale - maxY;
                } else if (isOrientedBox3Like(r)) {
                    MathUtils6.newVector3(1, 0, 0, r.xAxis);
                    MathUtils6.newVector3(0, -1, 0, r.yAxis);
                    MathUtils6.newVector3(0, 0, -1, r.zAxis);
                    r.position.y = this.unitScale - r.position.y;
                }
                return r;
            }
        },
        {
            key: "unprojectBox",
            value: function unprojectBox(worldBox) {
                var minGeo = this.unprojectPoint(worldBox.min);
                var maxGeo = this.unprojectPoint(worldBox.max);
                var geoBox = new GeoBox(new GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));
                return geoBox;
            }
        },
        {
            key: "surfaceNormal",
            value: function surfaceNormal(_worldPoint, normal) {
                if (normal === void 0) {
                    normal = {
                        x: 0,
                        y: 0,
                        z: -1
                    };
                } else {
                    normal.x = 0;
                    normal.y = 0;
                    normal.z = -1;
                }
                return normal;
            }
        },
        {
            key: "localTangentSpace",
            value: function localTangentSpace(point, result) {
                if (isGeoCoordinatesLike(point)) {
                    this.projectPoint(point, result.position);
                } else {
                    MathUtils6.copyVector3(point, result.position);
                }
                MathUtils6.newVector3(1, 0, 0, result.xAxis);
                MathUtils6.newVector3(0, -1, 0, result.yAxis);
                MathUtils6.newVector3(0, 0, -1, result.zAxis);
                return result;
            }
        }
    ]);
    return WebMercatorProjection;
}(MercatorProjection);
var MercatorConstants = function MercatorConstants() {
    _classCallCheck(this, MercatorConstants);
};
__publicField(MercatorConstants, "MAXIMUM_LATITUDE", 1.4844222297453322);
var mercatorProjection = new MercatorProjection(EarthConstants.EQUATORIAL_CIRCUMFERENCE);
var webMercatorProjection = new WebMercatorProjection(EarthConstants.EQUATORIAL_CIRCUMFERENCE);
// src/geoutils/projection/SphereProjection.ts
var THREE7 = __toESM(require("three"));
function apply(xAxis, yAxis, zAxis, v) {
    var x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;
    var y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;
    var z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}
function getLongitudeQuadrant(longitude) {
    var oneOverPI = 1 / Math.PI;
    var quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));
    return THREE7.MathUtils.clamp(quadrantIndex, 0, 4);
}
function lengthOfVector3(worldPoint) {
    var d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);
    return d;
}
function makeBox3(geoBox, worldBox, unitScale) {
    var _maxAltitude;
    var halfEquatorialRadius = (unitScale + ((_maxAltitude = geoBox.maxAltitude) !== null && _maxAltitude !== void 0 ? _maxAltitude : 0)) * 0.5;
    var minLongitude = THREE7.MathUtils.degToRad(geoBox.west);
    var maxLongitude = THREE7.MathUtils.degToRad(geoBox.east);
    var minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);
    var maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);
    var xMin = Math.cos(minLongitude);
    var xMax = xMin;
    var yMin = Math.sin(minLongitude);
    var yMax = yMin;
    for(var quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++){
        var x = (quadrantIndex + 1 & 1) * ((quadrantIndex & 2) - 1);
        xMin = Math.min(x, xMin);
        xMax = Math.max(x, xMax);
        var y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);
        yMin = Math.min(y, yMin);
        yMax = Math.max(y, yMax);
    }
    var cosMaxLongitude = Math.cos(maxLongitude);
    xMin = Math.min(cosMaxLongitude, xMin);
    xMax = Math.max(cosMaxLongitude, xMax);
    var sinMaxLongitude = Math.sin(maxLongitude);
    yMin = Math.min(sinMaxLongitude, yMin);
    yMax = Math.max(sinMaxLongitude, yMax);
    var xCenter = (xMax + xMin) * halfEquatorialRadius;
    var xExtent = (xMax - xMin) * halfEquatorialRadius;
    var yCenter = (yMax + yMin) * halfEquatorialRadius;
    var yExtent = (yMax - yMin) * halfEquatorialRadius;
    var minLatitude = THREE7.MathUtils.degToRad(geoBox.south);
    var maxLatutide = THREE7.MathUtils.degToRad(geoBox.north);
    var zMax = Math.sin(maxLatutide);
    var zMin = Math.sin(minLatitude);
    var zCenter = (zMax + zMin) * halfEquatorialRadius;
    var zExtent = (zMax - zMin) * halfEquatorialRadius;
    worldBox.min.x = xCenter - xExtent;
    worldBox.min.y = yCenter - yExtent;
    worldBox.min.z = zCenter - zExtent;
    worldBox.max.x = xCenter + xExtent;
    worldBox.max.y = yCenter + yExtent;
    worldBox.max.z = zCenter + zExtent;
    return worldBox;
}
function project(geoPoint, worldpoint, unitScale) {
    var _altitude;
    var radius = unitScale + ((_altitude = geoPoint.altitude) !== null && _altitude !== void 0 ? _altitude : 0);
    var latitude = THREE7.MathUtils.degToRad(geoPoint.latitude);
    var longitude = THREE7.MathUtils.degToRad(geoPoint.longitude);
    var cosLatitude = Math.cos(latitude);
    worldpoint.x = radius * cosLatitude * Math.cos(longitude);
    worldpoint.y = radius * cosLatitude * Math.sin(longitude);
    worldpoint.z = radius * Math.sin(latitude);
    return worldpoint;
}
var SphereProjection = /*#__PURE__*/ function(Projection) {
    _inherits(SphereProjection, Projection);
    var _super = _createSuper(SphereProjection);
    function SphereProjection() {
        _classCallCheck(this, SphereProjection);
        var _this;
        _this = _super.call.apply(_super, [
            this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assertThisInitialized(_this), "type", 1 /* Spherical */ );
        return _this;
    }
    _createClass(SphereProjection, [
        {
            key: "worldExtent",
            value: function worldExtent(_minElevation, maxElevation) {
                var result = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new THREE7.Box3();
                var radius = this.unitScale + maxElevation;
                result.min.x = -radius;
                result.min.y = -radius;
                result.min.z = -radius;
                result.max.x = radius;
                result.max.y = radius;
                result.max.z = radius;
                return result;
            }
        },
        {
            key: "projectPoint",
            value: function projectPoint(geoPoint) {
                var result = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : MathUtils6.newVector3(0, 0, 0);
                return project(geoPoint, result, this.unitScale);
            }
        },
        {
            key: "unprojectPoint",
            value: function unprojectPoint(point) {
                var parallelRadiusSq = point.x * point.x + point.y * point.y;
                var parallelRadius = Math.sqrt(parallelRadiusSq);
                var v = point.z / parallelRadius;
                if (isNaN(v)) {
                    return GeoCoordinates.fromRadians(0, 0, -this.unitScale);
                }
                var radius = Math.sqrt(parallelRadiusSq + point.z * point.z);
                return GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);
            }
        },
        {
            key: "unprojectAltitude",
            value: function unprojectAltitude(point) {
                var parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;
                return Math.sqrt(parallelRadiusSq) - EarthConstants.EQUATORIAL_RADIUS;
            }
        },
        {
            key: "projectBox",
            value: function projectBox(geoBox) {
                var result = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new THREE7.Box3();
                if (isBox3Like(result)) {
                    return makeBox3(geoBox, result, this.unitScale);
                } else if (isOrientedBox3Like(result)) {
                    if (geoBox.longitudeSpan >= 90) {
                        var bounds = makeBox3(geoBox, new THREE7.Box3(), this.unitScale);
                        MathUtils6.newVector3(1, 0, 0, result.xAxis);
                        MathUtils6.newVector3(0, 1, 0, result.yAxis);
                        MathUtils6.newVector3(0, 0, 1, result.zAxis);
                        result.position.x = (bounds.max.x + bounds.min.x) * 0.5;
                        result.position.y = (bounds.max.y + bounds.min.y) * 0.5;
                        result.position.z = (bounds.max.z + bounds.min.z) * 0.5;
                        result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;
                        result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;
                        result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;
                        return result;
                    }
                    var south = geoBox.south, west = geoBox.west, north = geoBox.north, east = geoBox.east, mid = geoBox.center;
                    var midX = mid.longitude;
                    var midY = mid.latitude;
                    var cosSouth = Math.cos(THREE7.MathUtils.degToRad(south));
                    var sinSouth = Math.sin(THREE7.MathUtils.degToRad(south));
                    var cosWest = Math.cos(THREE7.MathUtils.degToRad(west));
                    var sinWest = Math.sin(THREE7.MathUtils.degToRad(west));
                    var cosNorth = Math.cos(THREE7.MathUtils.degToRad(north));
                    var sinNorth = Math.sin(THREE7.MathUtils.degToRad(north));
                    var cosEast = Math.cos(THREE7.MathUtils.degToRad(east));
                    var sinEast = Math.sin(THREE7.MathUtils.degToRad(east));
                    var cosMidX = Math.cos(THREE7.MathUtils.degToRad(midX));
                    var sinMidX = Math.sin(THREE7.MathUtils.degToRad(midX));
                    var cosMidY = Math.cos(THREE7.MathUtils.degToRad(midY));
                    var sinMidY = Math.sin(THREE7.MathUtils.degToRad(midY));
                    MathUtils6.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);
                    MathUtils6.newVector3(-sinMidX, cosMidX, 0, result.xAxis);
                    MathUtils6.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);
                    var width;
                    var minY;
                    var maxY;
                    if (south >= 0) {
                        width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                        minY = cosMidY * sinSouth - sinMidY * cosSouth;
                        maxY = cosMidY * sinNorth - sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);
                    } else {
                        if (north <= 0) {
                            width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                            maxY = cosMidY * sinNorth - sinMidY * cosNorth;
                        } else {
                            width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));
                            maxY = cosMidY * sinNorth - sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);
                        }
                        minY = cosMidY * sinSouth - sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);
                    }
                    var _maxAltitude;
                    var rMax = (this.unitScale + ((_maxAltitude = geoBox.maxAltitude) !== null && _maxAltitude !== void 0 ? _maxAltitude : 0)) * 0.5;
                    var _minAltitude;
                    var rMin = (this.unitScale + ((_minAltitude = geoBox.minAltitude) !== null && _minAltitude !== void 0 ? _minAltitude : 0)) * 0.5;
                    var d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);
                    var minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);
                    MathUtils6.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);
                    MathUtils6.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);
                    apply(result.xAxis, result.yAxis, result.zAxis, result.position);
                    result.position.x = result.position.x - result.zAxis.x * result.extents.z;
                    result.position.y = result.position.y - result.zAxis.y * result.extents.z;
                    result.position.z = result.position.z - result.zAxis.z * result.extents.z;
                    return result;
                }
                throw new Error("Invalid bounding box");
            }
        },
        {
            key: "unprojectBox",
            value: function unprojectBox(_worldBox) {
                throw new Error("Method not implemented.");
            }
        },
        {
            key: "getScaleFactor",
            value: function getScaleFactor(_worldPoint) {
                return 1;
            }
        },
        {
            key: "groundDistance",
            value: function groundDistance(worldPoint) {
                return lengthOfVector3(worldPoint) - this.unitScale;
            }
        },
        {
            key: "scalePointToSurface",
            value: function scalePointToSurface(worldPoint) {
                var scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);
                worldPoint.x *= scale;
                worldPoint.y *= scale;
                worldPoint.z *= scale;
                return worldPoint;
            }
        },
        {
            key: "surfaceNormal",
            value: function surfaceNormal(worldPoint, normal) {
                if (normal === void 0) {
                    normal = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                }
                var scale = 1 / (lengthOfVector3(worldPoint) || 1);
                normal.x = worldPoint.x * scale;
                normal.y = worldPoint.y * scale;
                normal.z = worldPoint.z * scale;
                return normal;
            }
        },
        {
            key: "reprojectPoint",
            value: function reprojectPoint(sourceProjection, worldPos, result) {
                if (sourceProjection === mercatorProjection || sourceProjection === webMercatorProjection) {
                    var x = worldPos.x, y = worldPos.y, z = worldPos.z;
                    var r = this.unitScale;
                    var mx = x / r - Math.PI;
                    var my = y / r - Math.PI;
                    var w = Math.exp(my);
                    var d = w * w;
                    var gx = 2 * w / (d + 1);
                    var gy = (d - 1) / (d + 1);
                    var scale = r + z;
                    if (result === void 0) {
                        result = {};
                    }
                    result.x = Math.cos(mx) * gx * scale;
                    result.y = Math.sin(mx) * gx * scale;
                    result.z = gy * scale;
                    if (sourceProjection === webMercatorProjection) {
                        result.z = -result.z;
                    }
                    return result;
                }
                return _get(_getPrototypeOf(SphereProjection.prototype), "reprojectPoint", this).call(this, sourceProjection, worldPos, result);
            }
        },
        {
            key: "localTangentSpace",
            value: function localTangentSpace(point, result) {
                var geoPoint;
                if (isGeoCoordinatesLike(point)) {
                    this.projectPoint(point, result.position);
                    geoPoint = point;
                } else {
                    MathUtils6.copyVector3(point, result.position);
                    geoPoint = this.unprojectPoint(point);
                }
                var latitude = THREE7.MathUtils.degToRad(geoPoint.latitude);
                var longitude = THREE7.MathUtils.degToRad(geoPoint.longitude);
                var cosLongitude = Math.cos(longitude);
                var sinLongitude = Math.sin(longitude);
                var cosLatitude = Math.cos(latitude);
                var sinLatitude = Math.sin(latitude);
                MathUtils6.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);
                MathUtils6.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);
                MathUtils6.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);
                return result;
            }
        }
    ]);
    return SphereProjection;
}(Projection);
var sphereProjection = new SphereProjection(EarthConstants.EQUATORIAL_RADIUS);
// src/geoutils/projection/TransverseMercatorProjection.ts
var THREE8 = __toESM(require("three"));
var TransverseMercatorProjection = /*#__PURE__*/ function(Projection) {
    _inherits(TransverseMercatorProjection, Projection);
    var _super = _createSuper(TransverseMercatorProjection);
    function TransverseMercatorProjection(unitScale) {
        _classCallCheck(this, TransverseMercatorProjection);
        var _this;
        _this = _super.call(this, unitScale);
        _this.unitScale = unitScale;
        __publicField(_assertThisInitialized(_this), "type", 0 /* Planar */ );
        __publicField(_assertThisInitialized(_this), "m_phi0", 0);
        __publicField(_assertThisInitialized(_this), "m_lambda0", 0);
        return _this;
    }
    _createClass(TransverseMercatorProjection, [
        {
            key: "getScaleFactor",
            value: function getScaleFactor(worldPoint) {
                return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);
            }
        },
        {
            key: "worldExtent",
            value: function worldExtent(minAltitude, maxAltitude, result) {
                if (!result) {
                    result = new THREE8.Box3();
                }
                result.min.x = 0;
                result.min.y = 0;
                result.min.z = minAltitude;
                result.max.x = this.unitScale;
                result.max.y = this.unitScale;
                result.max.z = maxAltitude;
                return result;
            }
        },
        {
            key: "projectPoint",
            value: function projectPoint(geoPoint, result) {
                if (!result) {
                    result = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                }
                var clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);
                var normalLon = clamped.longitude / 360 + 0.5;
                var offset = normalLon === 1 ? 0 : Math.floor(normalLon);
                var phi = THREE8.MathUtils.degToRad(clamped.latitude);
                var lambda = THREE8.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;
                var B = Math.cos(phi) * Math.sin(lambda);
                result.x = Math.atanh(B);
                result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;
                var outScale = 0.5 / Math.PI;
                result.x = this.unitScale * (THREE8.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);
                result.y = this.unitScale * THREE8.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);
                var _altitude;
                result.z = (_altitude = geoPoint.altitude) !== null && _altitude !== void 0 ? _altitude : 0;
                return result;
            }
        },
        {
            key: "unprojectPoint",
            value: function unprojectPoint(worldPoint) {
                var tau = Math.PI * 2;
                var nx = worldPoint.x / this.unitScale;
                var ny = worldPoint.y / this.unitScale;
                var offset = nx === 1 ? 0 : Math.floor(nx);
                var x = tau * (nx - 0.5 - offset);
                var y = tau * (ny - 0.5);
                var z = worldPoint.z || 0;
                var D = y + this.m_phi0;
                var phi = Math.asin(Math.sin(D) / Math.cosh(x));
                var lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;
                var geoPoint = GeoCoordinates.fromRadians(phi, lambda, z);
                return geoPoint;
            }
        },
        {
            key: "projectBox",
            value: function projectBox(geoBox, result) {
                var _this = this;
                var _Math, _Math1, _Math2, _Math3, _Math4, _Math5;
                var north = geoBox.north, south = geoBox.south, east = geoBox.east, west = geoBox.west;
                var pointsToCheck = [
                    geoBox.center,
                    geoBox.northEast,
                    geoBox.southWest,
                    new GeoCoordinates(south, east),
                    new GeoCoordinates(north, west)
                ];
                var E = TransverseMercatorUtils.POLE_EDGE_DEG;
                var containsWestCut = west < -90 && east > -90;
                var containsEastCut = west < 90 && east > 90;
                var containsCenterX = west < 0 && east > 0;
                var containsCenterY = west < E && east > -E && north > 0 && south < 0;
                if (containsWestCut) {
                    pointsToCheck.push(new GeoCoordinates(north, -90));
                    pointsToCheck.push(new GeoCoordinates(south, -90));
                }
                if (containsEastCut) {
                    pointsToCheck.push(new GeoCoordinates(north, 90));
                    pointsToCheck.push(new GeoCoordinates(south, 90));
                }
                if (containsCenterX) {
                    pointsToCheck.push(new GeoCoordinates(north, 0));
                    pointsToCheck.push(new GeoCoordinates(south, 0));
                }
                if (containsCenterY) {
                    pointsToCheck.push(new GeoCoordinates(0, west));
                    pointsToCheck.push(new GeoCoordinates(0, east));
                }
                TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);
                var projected = pointsToCheck.map(function(p) {
                    return _this.projectPoint(p);
                });
                var vx = projected.map(function(p) {
                    return p.x;
                });
                var vy = projected.map(function(p) {
                    return p.y;
                });
                var vz = projected.map(function(p) {
                    return p.z;
                });
                var minX = (_Math = Math).min.apply(_Math, _toConsumableArray(vx));
                var minY = (_Math1 = Math).min.apply(_Math1, _toConsumableArray(vy));
                var minZ = (_Math2 = Math).min.apply(_Math2, _toConsumableArray(vz));
                var maxX = (_Math3 = Math).max.apply(_Math3, _toConsumableArray(vx));
                var maxY = (_Math4 = Math).max.apply(_Math4, _toConsumableArray(vy));
                var maxZ = (_Math5 = Math).max.apply(_Math5, _toConsumableArray(vz));
                if (!result) {
                    result = new THREE8.Box3();
                }
                if (isBox3Like(result)) {
                    result.min.x = minX;
                    result.min.y = minY;
                    result.min.z = minZ;
                    result.max.x = maxX;
                    result.max.y = maxY;
                    result.max.z = maxZ;
                } else if (isOrientedBox3Like(result)) {
                    MathUtils6.newVector3(1, 0, 0, result.xAxis);
                    MathUtils6.newVector3(0, 1, 0, result.yAxis);
                    MathUtils6.newVector3(0, 0, 1, result.zAxis);
                    result.position.x = (minX + maxX) / 2;
                    result.position.y = (minY + maxY) / 2;
                    result.position.z = (minZ + maxZ) / 2;
                    result.extents.x = (maxX - minX) / 2;
                    result.extents.y = (maxY - minY) / 2;
                    result.extents.z = (maxZ - minZ) / 2;
                } else {
                    throw new Error("invalid bounding box");
                }
                return result;
            }
        },
        {
            key: "unprojectBox",
            value: function unprojectBox(worldBox) {
                var _this = this;
                var _Math, _Math1, _Math2, _Math3, _Math4, _Math5;
                var s = this.unitScale;
                var min = worldBox.min;
                var max = worldBox.max;
                var pointsToCheck = [
                    {
                        x: (min.x + max.x) / 2,
                        y: (min.y + max.y) / 2,
                        z: 0
                    },
                    min,
                    max,
                    {
                        x: min.x,
                        y: max.y,
                        z: 0
                    },
                    {
                        x: max.x,
                        y: min.y,
                        z: 0
                    }
                ];
                var center = 0.5 * s;
                var lowerQ = 0.25 * s;
                var upperQ = 0.75 * s;
                var containsCenterX = min.x < center && max.x > center;
                var containsCenterY = min.y < center && max.y > center;
                var containsLowerQY = min.y < lowerQ && max.y > lowerQ;
                var containsUpperQY = min.y < upperQ && max.y > upperQ;
                if (containsCenterY) {
                    pointsToCheck.push({
                        x: min.x,
                        y: center,
                        z: 0
                    });
                    pointsToCheck.push({
                        x: max.x,
                        y: center,
                        z: 0
                    });
                    if (containsCenterX) {
                        pointsToCheck.push({
                            x: center,
                            y: center,
                            z: 0
                        });
                    }
                }
                if (containsLowerQY) {
                    pointsToCheck.push({
                        x: min.x,
                        y: lowerQ,
                        z: 0
                    });
                    pointsToCheck.push({
                        x: max.x,
                        y: lowerQ,
                        z: 0
                    });
                    if (containsCenterX) {
                        pointsToCheck.push({
                            x: center,
                            y: lowerQ,
                            z: 0
                        });
                    }
                }
                if (containsUpperQY) {
                    pointsToCheck.push({
                        x: min.x,
                        y: upperQ,
                        z: 0
                    });
                    pointsToCheck.push({
                        x: max.x,
                        y: upperQ,
                        z: 0
                    });
                    if (containsCenterX) {
                        pointsToCheck.push({
                            x: center,
                            y: upperQ,
                            z: 0
                        });
                    }
                }
                var geoPoints = pointsToCheck.map(function(p) {
                    return _this.unprojectPoint(p);
                });
                TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);
                var latitudes = geoPoints.map(function(g) {
                    return g.latitude;
                });
                var longitudes = geoPoints.filter(function(g) {
                    return Math.abs(g.latitude) < 90;
                }).map(function(g) {
                    return g.longitude;
                });
                var _altitude;
                var altitudes = geoPoints.map(function(g) {
                    return (_altitude = g.altitude) !== null && _altitude !== void 0 ? _altitude : 0;
                });
                var minGeo = new GeoCoordinates((_Math = Math).min.apply(_Math, _toConsumableArray(latitudes)), (_Math1 = Math).min.apply(_Math1, _toConsumableArray(longitudes)), (_Math2 = Math).min.apply(_Math2, _toConsumableArray(altitudes)));
                var maxGeo = new GeoCoordinates((_Math3 = Math).max.apply(_Math3, _toConsumableArray(latitudes)), (_Math4 = Math).max.apply(_Math4, _toConsumableArray(longitudes)), (_Math5 = Math).max.apply(_Math5, _toConsumableArray(altitudes)));
                var geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);
                return geoBox;
            }
        },
        {
            key: "unprojectAltitude",
            value: function unprojectAltitude(worldPoint) {
                return worldPoint.z;
            }
        },
        {
            key: "groundDistance",
            value: function groundDistance(worldPoint) {
                return worldPoint.z;
            }
        },
        {
            key: "scalePointToSurface",
            value: function scalePointToSurface(worldPoint) {
                worldPoint.z = 0;
                return worldPoint;
            }
        },
        {
            key: "surfaceNormal",
            value: function surfaceNormal(_worldPoint, normal) {
                if (normal === void 0) {
                    normal = {
                        x: 0,
                        y: 0,
                        z: -1
                    };
                } else {
                    normal.x = 0;
                    normal.y = 0;
                    normal.z = -1;
                }
                return normal;
            }
        }
    ], [
        {
            key: "clampGeoPoint",
            value: function clampGeoPoint(geoPoint, _unitScale) {
                var lat = geoPoint.latitude;
                var lon = geoPoint.longitude;
                var r = TransverseMercatorUtils.POLE_RADIUS;
                var rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;
                var nearestQuarter = Math.round(lon / 90);
                var deltaLon = nearestQuarter * 90 - lon;
                if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {
                    return geoPoint;
                }
                var deltaLat = lat - 0;
                var distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;
                if (distanceToPoleSq < rsq) {
                    var distanceToPole = Math.sqrt(distanceToPoleSq);
                    var scale = (r - distanceToPole) / distanceToPole;
                    var dir = 1;
                    var offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;
                    return new GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);
                }
                return geoPoint;
            }
        }
    ]);
    return TransverseMercatorProjection;
}(Projection);
var _TransverseMercatorUtils = /*#__PURE__*/ function() {
    function _TransverseMercatorUtils() {
        _classCallCheck(this, _TransverseMercatorUtils);
    }
    _createClass(_TransverseMercatorUtils, null, [
        {
            key: "alignLatitude",
            value: function alignLatitude(points, referencePoint) {
                var EPSILON = 1e-9;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var point = _step.value;
                        if (point.latitude === 0) {
                            point.latitude = referencePoint.latitude * EPSILON;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "alignLongitude",
            value: function alignLongitude(points, referencePoint) {
                var bad = referencePoint.longitude < 0 ? 180 : -180;
                var good = referencePoint.longitude < 0 ? -180 : 180;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var point = _step.value;
                        if (point.longitude === bad) {
                            point.longitude = good;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        }
    ]);
    return _TransverseMercatorUtils;
}();
var TransverseMercatorUtils = _TransverseMercatorUtils;
__publicField(TransverseMercatorUtils, "POLE_EDGE", 1.4844222297453322);
__publicField(TransverseMercatorUtils, "POLE_EDGE_DEG", THREE8.MathUtils.radToDeg(_TransverseMercatorUtils.POLE_EDGE));
__publicField(TransverseMercatorUtils, "POLE_RADIUS", 90 - _TransverseMercatorUtils.POLE_EDGE_DEG);
__publicField(TransverseMercatorUtils, "POLE_RADIUS_SQ", Math.pow(_TransverseMercatorUtils.POLE_RADIUS, 2));
var transverseMercatorProjection = new TransverseMercatorProjection(EarthConstants.EQUATORIAL_CIRCUMFERENCE);
// src/geoutils/tiling/QuadTreeSubdivisionScheme.ts
var QuadTreeSubdivisionScheme = /*#__PURE__*/ function() {
    function QuadTreeSubdivisionScheme() {
        _classCallCheck(this, QuadTreeSubdivisionScheme);
    }
    _createClass(QuadTreeSubdivisionScheme, [
        {
            key: "getSubdivisionX",
            value: function getSubdivisionX() {
                return 2;
            }
        },
        {
            key: "getSubdivisionY",
            value: function getSubdivisionY() {
                return 2;
            }
        },
        {
            key: "getLevelDimensionX",
            value: function getLevelDimensionX(level) {
                return 1 << level;
            }
        },
        {
            key: "getLevelDimensionY",
            value: function getLevelDimensionY(level) {
                return 1 << level;
            }
        }
    ]);
    return QuadTreeSubdivisionScheme;
}();
var quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();
// src/geoutils/tiling/FlatTileBoundingBoxGenerator.ts
var THREE9 = __toESM(require("three"));
var FlatTileBoundingBoxGenerator = /*#__PURE__*/ function() {
    function FlatTileBoundingBoxGenerator(tilingScheme) {
        var minElevation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, maxElevation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        _classCallCheck(this, FlatTileBoundingBoxGenerator);
        this.tilingScheme = tilingScheme;
        this.minElevation = minElevation;
        this.maxElevation = maxElevation;
        __publicField(this, "m_tilingScheme");
        __publicField(this, "m_worldDimensions");
        __publicField(this, "m_worldBox");
        this.m_tilingScheme = tilingScheme;
        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);
        var _m_worldBox = this.m_worldBox, min = _m_worldBox.min, max = _m_worldBox.max;
        this.m_worldDimensions = {
            x: max.x - min.x,
            y: max.y - min.y,
            z: max.z - min.z
        };
    }
    _createClass(FlatTileBoundingBoxGenerator, [
        {
            key: "projection",
            get: function get() {
                return this.m_tilingScheme.projection;
            }
        },
        {
            key: "subdivisionScheme",
            get: function get() {
                return this.m_tilingScheme.subdivisionScheme;
            }
        },
        {
            key: "getWorldBox",
            value: function getWorldBox(tileKey, result) {
                var level = tileKey.level;
                var levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);
                var levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);
                var sizeX = this.m_worldDimensions.x / levelDimensionX;
                var sizeY = this.m_worldDimensions.y / levelDimensionY;
                var originX = this.m_worldBox.min.x + sizeX * tileKey.column;
                var originY = this.m_worldBox.min.y + sizeY * tileKey.row;
                if (!result) {
                    result = new THREE9.Box3();
                }
                result.min.x = originX;
                result.min.y = originY;
                result.min.z = this.m_worldBox.min.z;
                result.max.x = originX + sizeX;
                result.max.y = originY + sizeY;
                result.max.z = this.m_worldBox.max.z;
                return result;
            }
        },
        {
            key: "getGeoBox",
            value: function getGeoBox(tileKey) {
                var worldBox = this.getWorldBox(tileKey);
                return this.projection.unprojectBox(worldBox);
            }
        }
    ]);
    return FlatTileBoundingBoxGenerator;
}();
// src/geoutils/tiling/TileKey.ts
var powerOfTwo = [
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    256,
    512,
    1024,
    2048,
    4096,
    8192,
    16384,
    32768,
    65536,
    131072,
    262144,
    524288,
    1048576,
    2097152,
    4194304,
    8388608,
    16777216,
    33554432,
    67108864,
    134217728,
    268435456,
    536870912,
    1073741824,
    2147483648,
    4294967296,
    8589934592,
    17179869184,
    34359738368,
    68719476736,
    137438953472,
    274877906944,
    549755813888,
    1099511627776,
    2199023255552,
    4398046511104,
    8796093022208,
    17592186044416,
    35184372088832,
    70368744177664,
    140737488355328,
    281474976710656,
    562949953421312,
    1125899906842624,
    2251799813685248,
    4503599627370496
];
var TileKey = /*#__PURE__*/ function() {
    function TileKey(row, column, level) {
        _classCallCheck(this, TileKey);
        this.row = row;
        this.column = column;
        this.level = level;
        __publicField(this, "m_mortonCode");
        __publicField(this, "m_hereTile");
    }
    _createClass(TileKey, [
        {
            key: "parent",
            value: function parent() {
                if (this.level === 0) {
                    throw new Error("Cannot get the parent of the root tile key");
                }
                return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);
            }
        },
        {
            key: "changedLevelBy",
            value: function changedLevelBy(delta) {
                var level = Math.max(0, this.level + delta);
                var row = this.row;
                var column = this.column;
                if (delta >= 0) {
                    row <<= delta;
                    column <<= delta;
                } else {
                    row >>>= -delta;
                    column >>>= -delta;
                }
                return TileKey.fromRowColumnLevel(row, column, level);
            }
        },
        {
            key: "changedLevelTo",
            value: function changedLevelTo(level) {
                return this.changedLevelBy(level - this.level);
            }
        },
        {
            key: "mortonCode",
            value: function mortonCode() {
                if (this.m_mortonCode === void 0) {
                    var column = this.column;
                    var row = this.row;
                    var result = powerOfTwo[this.level << 1];
                    for(var i = 0; i < this.level; ++i){
                        if (column & 1) {
                            result += powerOfTwo[2 * i];
                        }
                        if (row & 1) {
                            result += powerOfTwo[2 * i + 1];
                        }
                        column >>>= 1;
                        row >>>= 1;
                    }
                    this.m_mortonCode = result;
                }
                return this.m_mortonCode;
            }
        },
        {
            key: "toHereTile",
            value: function toHereTile() {
                if (this.m_hereTile === void 0) {
                    this.m_hereTile = this.mortonCode().toString();
                }
                return this.m_hereTile;
            }
        },
        {
            key: "toQuadKey",
            value: function toQuadKey() {
                var result = "";
                for(var i = this.level; i > 0; --i){
                    var mask = 1 << i - 1;
                    var col = (this.column & mask) !== 0;
                    var row = (this.row & mask) !== 0;
                    if (col && row) {
                        result += "3";
                    } else if (row) {
                        result += "2";
                    } else if (col) {
                        result += "1";
                    } else {
                        result += "0";
                    }
                }
                return result;
            }
        },
        {
            key: "equals",
            value: function equals(qnr) {
                return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;
            }
        },
        {
            key: "addedSubKey",
            value: function addedSubKey(sub) {
                var subQuad = TileKey.fromQuadKey(sub.length === 0 ? "-" : sub);
                var child = this.changedLevelBy(subQuad.level);
                return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
            }
        },
        {
            key: "addedSubHereTile",
            value: function addedSubHereTile(sub) {
                var subQuad = TileKey.fromHereTile(sub);
                var child = this.changedLevelBy(subQuad.level);
                return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
            }
        },
        {
            key: "getSubHereTile",
            value: function getSubHereTile(delta) {
                var key = this.mortonCode();
                var msb = 1 << delta * 2;
                var mask = msb - 1;
                var result = key & mask | msb;
                return result.toString();
            }
        },
        {
            key: "rowCount",
            value: function rowCount() {
                return TileKey.rowsAtLevel(this.level);
            }
        },
        {
            key: "columnCount",
            value: function columnCount() {
                return TileKey.columnsAtLevel(this.level);
            }
        }
    ], [
        {
            key: "fromRowColumnLevel",
            value: function fromRowColumnLevel(row, column, level) {
                return new TileKey(row, column, level);
            }
        },
        {
            key: "fromQuadKey",
            value: function fromQuadKey(quadkey) {
                var level = quadkey.length;
                var row = 0;
                var column = 0;
                for(var i = 0; i < quadkey.length; ++i){
                    var mask = 1 << i;
                    var d = parseInt(quadkey.charAt(level - i - 1), 10);
                    if (d & 1) {
                        column |= mask;
                    }
                    if (d & 2) {
                        row |= mask;
                    }
                }
                return TileKey.fromRowColumnLevel(row, column, level);
            }
        },
        {
            key: "fromMortonCode",
            value: function fromMortonCode(quadKey64) {
                var level = 0;
                var row = 0;
                var column = 0;
                var quadKey = quadKey64;
                while(quadKey > 1){
                    var mask = 1 << level;
                    if (quadKey & 1) {
                        column |= mask;
                    }
                    if (quadKey & 2) {
                        row |= mask;
                    }
                    level++;
                    quadKey = (quadKey - (quadKey & 3)) / 4;
                }
                var result = TileKey.fromRowColumnLevel(row, column, level);
                result.m_mortonCode = quadKey64;
                return result;
            }
        },
        {
            key: "fromHereTile",
            value: function fromHereTile(quadkey64) {
                var result = TileKey.fromMortonCode(parseInt(quadkey64, 10));
                result.m_hereTile = quadkey64;
                return result;
            }
        },
        {
            key: "columnsAtLevel",
            value: function columnsAtLevel(level) {
                return Math.pow(2, level);
            }
        },
        {
            key: "rowsAtLevel",
            value: function rowsAtLevel(level) {
                return Math.pow(2, level);
            }
        },
        {
            key: "atCoords",
            value: function atCoords(level, coordX, coordY, totalWidth, totalHeight) {
                return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);
            }
        },
        {
            key: "parentMortonCode",
            value: function parentMortonCode(mortonCode) {
                return Math.floor(mortonCode / 4);
            }
        }
    ]);
    return TileKey;
}();
// src/geoutils/tiling/TileKeyUtils.ts
var powerOfTwo2 = function() {
    var val = 0.5;
    return new Array(53).fill(0).map(function() {
        return val *= 2;
    });
}();
var TileKeyUtils;
(function(TileKeyUtils2) {
    var geoCoordinatesToTileKey = function geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {
        var projection = tilingScheme.projection;
        var worldPoint = projection.projectPoint(geoPoint);
        return worldCoordinatesToTileKey(tilingScheme, worldPoint, level);
    };
    var worldCoordinatesToTileKey = function worldCoordinatesToTileKey(tilingScheme, worldPoint, level) {
        var projection = tilingScheme.projection;
        var subdivisionScheme = tilingScheme.subdivisionScheme;
        var cx = subdivisionScheme.getLevelDimensionX(level);
        var cy = subdivisionScheme.getLevelDimensionY(level);
        var ref = projection.worldExtent(0, 0), min = ref.min, max = ref.max;
        var worldSizeX = max.x - min.x;
        var worldSizeY = max.y - min.y;
        if (worldPoint.x < min.x || worldPoint.x > max.x) {
            return null;
        }
        if (worldPoint.y < min.y || worldPoint.y > max.y) {
            return null;
        }
        var column = Math.min(cx - 1, Math.floor(cx * (worldPoint.x - min.x) / worldSizeX));
        var row = Math.min(cy - 1, Math.floor(cy * (worldPoint.y - min.y) / worldSizeY));
        return TileKey.fromRowColumnLevel(row, column, level);
    };
    var geoRectangleToTileKeys = function geoRectangleToTileKeys(tilingScheme, geoBox, level) {
        var wrap = function(value2, lower, upper) {
            if (value2 < lower) {
                return upper - (lower - value2) % (upper - lower);
            }
            return lower + (value2 - lower) % (upper - lower);
        };
        var clamp = function(x, minVal, maxVal) {
            return Math.min(Math.max(x, minVal), maxVal);
        };
        var southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);
        var southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        var northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);
        var northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        var minTileKey = TileKeyUtils2.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);
        var maxTileKey = TileKeyUtils2.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);
        var columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);
        if (!minTileKey || !maxTileKey) {
            throw new Error("Invalid coordinates");
        }
        var minColumn = minTileKey.column;
        var maxColumn = maxTileKey.column;
        if (southWestLongitude > northEastLongitude) {
            if (maxColumn !== minColumn) {
                maxColumn += columnCount;
            } else {
                maxColumn += columnCount - 1;
            }
        }
        var minRow = Math.min(minTileKey.row, maxTileKey.row);
        var maxRow = Math.max(minTileKey.row, maxTileKey.row);
        var keys = new Array();
        for(var row = minRow; row <= maxRow; ++row){
            for(var column = minColumn; column <= maxColumn; ++column){
                keys.push(TileKey.fromRowColumnLevel(row, column % columnCount, level));
            }
        }
        return keys;
    };
    var getKeyForTileKeyAndOffset = function getKeyForTileKeyAndOffset(tileKey, offset) {
        var bitshift = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4;
        var shiftedOffset = getShiftedOffset(offset, bitshift);
        return tileKey.mortonCode() + shiftedOffset;
    };
    var extractOffsetAndMortonKeyFromKey = function extractOffsetAndMortonKeyFromKey(key) {
        var bitshift = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
        var offset = 0;
        var mortonCode = key;
        var i = 0;
        for(; i < bitshift; i++){
            var num = powerOfTwo2[52 - i];
            if (mortonCode >= num) {
                mortonCode -= num;
                offset += powerOfTwo2[bitshift - 1 - i];
            }
        }
        offset -= powerOfTwo2[bitshift - 1];
        return {
            offset: offset,
            mortonCode: mortonCode
        };
    };
    var getParentKeyFromKey = function getParentKeyFromKey(calculatedKey) {
        var bitshift = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
        var ref = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift), offset = ref.offset, mortonCode = ref.mortonCode;
        var parentTileKey = TileKey.fromMortonCode(TileKey.parentMortonCode(mortonCode));
        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);
    };
    var getShiftedOffset = function getShiftedOffset(offset) {
        var offsetBits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
        var result = 0;
        var totalOffsetsToStore = powerOfTwo2[offsetBits];
        offset += totalOffsetsToStore / 2;
        while(offset < 0){
            offset += totalOffsetsToStore;
        }
        while(offset >= totalOffsetsToStore){
            offset -= totalOffsetsToStore;
        }
        for(var i = 0; i < offsetBits && offset > 0; i++){
            if (offset & 1) {
                result += powerOfTwo2[53 - offsetBits + i];
            }
            offset >>>= 1;
        }
        return result;
    };
    TileKeyUtils2.geoCoordinatesToTileKey = geoCoordinatesToTileKey;
    TileKeyUtils2.worldCoordinatesToTileKey = worldCoordinatesToTileKey;
    TileKeyUtils2.geoRectangleToTileKeys = geoRectangleToTileKeys;
    TileKeyUtils2.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;
    TileKeyUtils2.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;
    TileKeyUtils2.getParentKeyFromKey = getParentKeyFromKey;
})(TileKeyUtils || (TileKeyUtils = {}));
// src/geoutils/tiling/SubTiles.ts
var SubTiles = /*#__PURE__*/ function() {
    function SubTiles(tileKey, sizeX, sizeY) {
        _classCallCheck(this, SubTiles);
        this.tileKey = tileKey;
        this.sizeX = sizeX;
        this.sizeY = sizeY;
    }
    _createClass(SubTiles, [
        {
            key: Symbol.iterator,
            value: function value() {
                return this.sizeX === 2 && this.sizeY === 2 ? SubTiles.ZCurveIterator(this.tileKey) : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);
            }
        }
    ]);
    return SubTiles;
}();
(function(SubTiles2) {
    var RowColumnIterator = regeneratorRuntime.mark(function RowColumnIterator(parentKey, sizeX, sizeY) {
        var y, x;
        return regeneratorRuntime.wrap(function RowColumnIterator$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    y = 0;
                case 1:
                    if (!(y < sizeY)) {
                        _ctx.next = 12;
                        break;
                    }
                    x = 0;
                case 3:
                    if (!(x < sizeX)) {
                        _ctx.next = 9;
                        break;
                    }
                    _ctx.next = 6;
                    return TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);
                case 6:
                    x++;
                    _ctx.next = 3;
                    break;
                case 9:
                    y++;
                    _ctx.next = 1;
                    break;
                case 12:
                case "end":
                    return _ctx.stop();
            }
        }, RowColumnIterator);
    });
    var ZCurveIterator = regeneratorRuntime.mark(function ZCurveIterator(parentKey) {
        var i;
        return regeneratorRuntime.wrap(function ZCurveIterator$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    i = 0;
                case 1:
                    if (!(i < 4)) {
                        _ctx.next = 7;
                        break;
                    }
                    _ctx.next = 4;
                    return TileKey.fromRowColumnLevel(parentKey.row << 1 | i >> 1, parentKey.column << 1 | i & 1, parentKey.level + 1);
                case 4:
                    i++;
                    _ctx.next = 1;
                    break;
                case 7:
                case "end":
                    return _ctx.stop();
            }
        }, ZCurveIterator);
    });
    SubTiles2.RowColumnIterator = RowColumnIterator;
    SubTiles2.ZCurveIterator = ZCurveIterator;
})(SubTiles || (SubTiles = {}));
// src/geoutils/tiling/TileTreeTraverse.ts
var TileTreeTraverse = /*#__PURE__*/ function() {
    function TileTreeTraverse(subdivisionScheme) {
        _classCallCheck(this, TileTreeTraverse);
        __publicField(this, "m_subdivisionScheme");
        this.m_subdivisionScheme = subdivisionScheme;
    }
    _createClass(TileTreeTraverse, [
        {
            key: "subTiles",
            value: function subTiles(tileKey) {
                var divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);
                var divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);
                return new SubTiles(tileKey, divX, divY);
            }
        }
    ]);
    return TileTreeTraverse;
}();
// src/geoutils/tiling/TilingScheme.ts
var TilingScheme = /*#__PURE__*/ function() {
    function TilingScheme(subdivisionScheme, projection) {
        _classCallCheck(this, TilingScheme);
        this.subdivisionScheme = subdivisionScheme;
        this.projection = projection;
        __publicField(this, "boundingBoxGenerator");
        __publicField(this, "tileTreeTraverse");
        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator(this);
        this.tileTreeTraverse = new TileTreeTraverse(subdivisionScheme);
    }
    _createClass(TilingScheme, [
        {
            key: "getSubTileKeys",
            value: function getSubTileKeys(tileKey) {
                return this.tileTreeTraverse.subTiles(tileKey);
            }
        },
        {
            key: "getTileKey",
            value: function getTileKey(geoPoint, level) {
                return TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);
            }
        },
        {
            key: "getTileKeys",
            value: function getTileKeys(geoBox, level) {
                return TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);
            }
        },
        {
            key: "getGeoBox",
            value: function getGeoBox(tileKey) {
                return this.boundingBoxGenerator.getGeoBox(tileKey);
            }
        },
        {
            key: "getWorldBox",
            value: function getWorldBox(tileKey, result) {
                return this.boundingBoxGenerator.getWorldBox(tileKey, result);
            }
        }
    ]);
    return TilingScheme;
}();
// src/geoutils/tiling/PolarTilingScheme.ts
var polarTilingScheme = new TilingScheme(quadTreeSubdivisionScheme, transverseMercatorProjection);
// src/geoutils/tiling/WebMercatorTilingScheme.ts
var webMercatorTilingScheme = new TilingScheme(quadTreeSubdivisionScheme, webMercatorProjection);
// src/datasource-protocol/Expr.ts
var THREE14 = __toESM(require("three"));
// src/datasource-protocol/ExprEvaluator.ts
var THREE13 = __toESM(require("three"));
// src/datasource-protocol/operators/ArrayOperators.ts
var VALID_ELEMENT_TYPES = [
    "boolean",
    "number",
    "string"
];
function checkElementTypes(arg, array) {
    if (!_instanceof(arg, StringLiteralExpr) || !VALID_ELEMENT_TYPES.includes(arg.value)) {
        throw new Error('expected "boolean", "number" or "string" instead of \''.concat(JSON.stringify(arg), "'"));
    }
    var ty = arg.value;
    array.forEach(function(element, index) {
        if ((typeof element === "undefined" ? "undefined" : _typeof(element)) !== ty) {
            throw new Error("expected array element at index ".concat(index, " to have type '").concat(ty, "'"));
        }
    });
}
function checkArrayLength(arg, array) {
    if (!_instanceof(arg, NumberLiteralExpr)) {
        throw new Error("missing expected number of elements");
    }
    var length = arg.value;
    if (array.length !== length) {
        throw new Error("the array must have ".concat(length, " element(s)"));
    }
}
function checkArray(context, arg) {
    var value2 = context.evaluate(arg);
    if (!Array.isArray(value2)) {
        throw new Error("'".concat(value2, "' is not an array"));
    }
    return value2;
}
var operators = {
    array: {
        call: function(context, call) {
            switch(call.args.length){
                case 0:
                    throw new Error("not enough arguments");
                case 1:
                    return checkArray(context, call.args[0]);
                case 2:
                    {
                        var array = checkArray(context, call.args[1]);
                        checkElementTypes(call.args[0], array);
                        return array;
                    }
                case 3:
                    {
                        var array1 = checkArray(context, call.args[2]);
                        checkArrayLength(call.args[1], array1);
                        checkElementTypes(call.args[0], array1);
                        return array1;
                    }
                default:
                    throw new Error("too many arguments");
            }
        }
    },
    "make-array": {
        call: function(context, call) {
            if (call.args.length === 0) {
                throw new Error("not enough arguments");
            }
            return _toConsumableArray(call.args.map(function(arg) {
                return context.evaluate(arg);
            }));
        }
    },
    at: {
        call: function(context, call) {
            var args = call.args;
            var index = context.evaluate(args[0]);
            if (typeof index !== "number") {
                throw new Error("expected the index of the element to retrieve");
            }
            var value2 = context.evaluate(args[1]);
            if (!Array.isArray(value2)) {
                throw new Error("expected an array");
            }
            return index >= 0 && index < value2.length ? value2[index] : null;
        }
    },
    slice: {
        call: function(context, call) {
            if (call.args.length < 2) {
                throw new Error("not enough arguments");
            }
            var input = context.evaluate(call.args[0]);
            if (!(typeof input === "string" || Array.isArray(input))) {
                throw new Error("input must be a string or an array");
            }
            var start = context.evaluate(call.args[1]);
            if (typeof start !== "number") {
                throw new Error("expected an index");
            }
            var end;
            if (call.args.length > 2) {
                end = context.evaluate(call.args[2]);
                if (typeof end !== "number") {
                    throw new Error("expected an index");
                }
            }
            return input.slice(start, end);
        }
    }
};
var ArrayOperators = operators;
// src/datasource-protocol/operators/CastOperators.ts
var operators2 = {
    "to-boolean": {
        call: function(context, call) {
            return Boolean(context.evaluate(call.args[0]));
        }
    },
    "to-string": {
        call: function(context, call) {
            return String(context.evaluate(call.args[0]));
        }
    },
    "to-number": {
        call: function(context, call) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = call.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var arg = _step.value;
                    var value2 = Number(context.evaluate(arg));
                    if (!isNaN(value2)) {
                        return value2;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            throw new Error("cannot convert the value to a number");
        }
    }
};
var CastOperators = operators2;
// src/datasource-protocol/operators/ColorOperators.ts
var THREE10 = __toESM(require("three"));
var operators3 = {
    alpha: {
        call: function(context, call) {
            var color = context.evaluate(call.args[0]);
            if (typeof color === "string") {
                color = parseStringEncodedColor(color);
            }
            var alpha = typeof color === "number" ? ColorUtils.getAlphaFromHex(color) : 1;
            return alpha;
        }
    },
    rgba: {
        call: function(context, call) {
            var r = context.evaluate(call.args[0]);
            var g = context.evaluate(call.args[1]);
            var b = context.evaluate(call.args[2]);
            var a = context.evaluate(call.args[3]);
            if (typeof r === "number" && typeof g === "number" && typeof b === "number" && typeof a === "number" && r >= 0 && g >= 0 && b >= 0 && a >= 0 && a <= 1) {
                return rgbaToHex(r, g, b, a);
            }
            throw new Error("unknown color 'rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")'"));
        }
    },
    rgb: {
        call: function(context, call) {
            var r = context.evaluate(call.args[0]);
            var g = context.evaluate(call.args[1]);
            var b = context.evaluate(call.args[2]);
            if (typeof r === "number" && typeof g === "number" && typeof b === "number" && r >= 0 && g >= 0 && b >= 0) {
                return rgbToHex(r, g, b);
            }
            throw new Error("unknown color 'rgb(".concat(r, ",").concat(g, ",").concat(b, ")'"));
        }
    },
    hsl: {
        call: function(context, call) {
            var h = context.evaluate(call.args[0]);
            var s = context.evaluate(call.args[1]);
            var l = context.evaluate(call.args[2]);
            if (typeof h === "number" && typeof s === "number" && typeof l === "number" && h >= 0 && s >= 0 && l >= 0) {
                return hslToHex(h, s, l);
            }
            throw new Error("unknown color 'hsl(".concat(h, ",").concat(s, "%,").concat(l, "%)'"));
        }
    }
};
function rgbaToHex(r, g, b, a) {
    return ColorUtils.getHexFromRgba(THREE10.MathUtils.clamp(r, 0, 255) / 255, THREE10.MathUtils.clamp(g, 0, 255) / 255, THREE10.MathUtils.clamp(b, 0, 255) / 255, THREE10.MathUtils.clamp(a, 0, 1));
}
function rgbToHex(r, g, b) {
    return ColorUtils.getHexFromRgb(THREE10.MathUtils.clamp(r, 0, 255) / 255, THREE10.MathUtils.clamp(g, 0, 255) / 255, THREE10.MathUtils.clamp(b, 0, 255) / 255);
}
function hslToHex(h, s, l) {
    return ColorUtils.getHexFromHsl(THREE10.MathUtils.euclideanModulo(h, 360) / 360, THREE10.MathUtils.clamp(s, 0, 100) / 100, THREE10.MathUtils.clamp(l, 0, 100) / 100);
}
var ColorOperators = operators3;
// src/datasource-protocol/operators/ComparisonOperators.ts
function compare(context, call) {
    var strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var left = context.evaluate(call.args[0]);
    var right = context.evaluate(call.args[1]);
    if (!(typeof left === "number" && typeof right === "number" || typeof left === "string" && typeof right === "string")) {
        if (strict) {
            throw new Error("invalid operands '".concat(left, "' and '").concat(right, "' for operator '").concat(call.op, "'"));
        }
    }
    switch(call.op){
        case "<":
            return left < right;
        case ">":
            return left > right;
        case "<=":
            return left <= right;
        case ">=":
            return left >= right;
        default:
            throw new Error("invalid comparison operator '".concat(call.op, "'"));
    }
}
var operators4 = {
    "!": {
        call: function(context, call) {
            return !context.evaluate(call.args[0]);
        }
    },
    "==": {
        call: function(context, call) {
            var left = context.evaluate(call.args[0]);
            var right = context.evaluate(call.args[1]);
            return left === right;
        }
    },
    "!=": {
        call: function(context, call) {
            var left = context.evaluate(call.args[0]);
            var right = context.evaluate(call.args[1]);
            return left !== right;
        }
    },
    "<": {
        call: function(context, call) {
            return compare(context, call);
        }
    },
    ">": {
        call: function(context, call) {
            return compare(context, call);
        }
    },
    "<=": {
        call: function(context, call) {
            return compare(context, call);
        }
    },
    ">=": {
        call: function(context, call) {
            return compare(context, call);
        }
    }
};
var ComparisonOperators = operators4;
// src/datasource-protocol/Env.ts
var Env = /*#__PURE__*/ function() {
    function Env() {
        _classCallCheck(this, Env);
    }
    _createClass(Env, [
        {
            key: "lookup",
            value: function lookup(name2) {
                return void 0;
            }
        },
        {
            key: "unmap",
            value: function unmap() {
                return {};
            }
        }
    ], [
        {
            key: "isEnv",
            value: function isEnv(object) {
                return _instanceof(object, Env);
            }
        }
    ]);
    return Env;
}();
var MapEnv = /*#__PURE__*/ function(Env) {
    _inherits(MapEnv, Env);
    var _super = _createSuper(MapEnv);
    function MapEnv(entries, parent) {
        _classCallCheck(this, MapEnv);
        var _this;
        _this = _super.call(this);
        _this.entries = entries;
        _this.parent = parent;
        return _this;
    }
    _createClass(MapEnv, [
        {
            key: "lookup",
            value: function lookup(name2) {
                if (this.entries.hasOwnProperty(name2)) {
                    var value2 = this.entries[name2];
                    if (value2 !== void 0) {
                        return value2;
                    }
                }
                return this.parent ? this.parent.lookup(name2) : void 0;
            }
        },
        {
            key: "unmap",
            value: function unmap() {
                var obj = this.parent ? this.parent.unmap() : {};
                for(var key in this.entries){
                    if (this.entries.hasOwnProperty(key)) {
                        obj[key] = this.entries[key];
                    }
                }
                return obj;
            }
        }
    ]);
    return MapEnv;
}(Env);
// src/datasource-protocol/operators/FeatureOperators.ts
var operators5 = {
    "geometry-type": {
        call: function(context, call) {
            var geometryType = context.env.lookup("$geometryType");
            switch(geometryType){
                case "point":
                    return "Point";
                case "line":
                    return "LineString";
                case "polygon":
                    return "Polygon";
                default:
                    return null;
            }
        }
    },
    "feature-state": {
        isDynamicOperator: function() {
            return true;
        },
        call: function(context, call) {
            if (context.scope !== 2 /* Dynamic */ ) {
                throw new Error("feature-state cannot be used in this context");
            }
            var property = context.evaluate(call.args[0]);
            if (typeof property !== "string") {
                throw new Error("expected the name of the property of the feature state");
            }
            var state = context.env.lookup("$state");
            if (Env.isEnv(state)) {
                var ref;
                return (ref = state.lookup(property)) !== null && ref !== void 0 ? ref : null;
            } else if (_instanceof(state, Map)) {
                var ref1;
                return (ref1 = state.get(property)) !== null && ref1 !== void 0 ? ref1 : null;
            }
            return null;
        }
    },
    id: {
        call: function(context, call) {
            var ref;
            return (ref = context.env.lookup("$id")) !== null && ref !== void 0 ? ref : null;
        }
    }
};
var FeatureOperators = operators5;
// src/datasource-protocol/operators/FlowOperators.ts
function conditionalCast(context, type, args) {
    switch(type){
        case "boolean":
        case "number":
        case "string":
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var childExpr = _step.value;
                    var value2 = context.evaluate(childExpr);
                    if ((typeof value2 === "undefined" ? "undefined" : _typeof(value2)) === type) {
                        return value2;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            throw new Error("expected a '".concat(type, "'"));
        default:
            throw new Error("invalid type '".concat(type, "'"));
    }
}
var operators6 = {
    all: {
        call: function(context, call) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = call.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var childExpr = _step.value;
                    if (!context.evaluate(childExpr)) {
                        return false;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return true;
        }
    },
    any: {
        call: function(context, call) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = call.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var childExpr = _step.value;
                    if (context.evaluate(childExpr)) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return false;
        }
    },
    none: {
        call: function(context, call) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = call.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var childExpr = _step.value;
                    if (context.evaluate(childExpr)) {
                        return false;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return true;
        }
    },
    boolean: {
        call: function(context, call) {
            return conditionalCast(context, "boolean", call.args);
        }
    },
    number: {
        call: function(context, call) {
            return conditionalCast(context, "number", call.args);
        }
    },
    string: {
        call: function(context, call) {
            return conditionalCast(context, "string", call.args);
        }
    }
};
var FlowOperators = operators6;
// src/datasource-protocol/operators/MapOperators.ts
var operators7 = {
    "ppi-scale": {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            var scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            return value2 * scaleFactor;
        }
    },
    "world-ppi-scale": {
        isDynamicOperator: function() {
            return true;
        },
        call: function(context, call) {
            var pixels = context.evaluate(call.args[0]);
            var scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            var zoom = context.env.lookup("$zoom");
            var zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);
            var v = pixels * zoomWidth * scaleFactor;
            return v;
        }
    },
    "world-discrete-ppi-scale": {
        isDynamicOperator: function() {
            return true;
        },
        call: function(context, call) {
            var pixels = context.evaluate(call.args[0]);
            var scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            var zoom = context.env.lookup("$zoom");
            var zoomWidthDiscrete = Math.pow(2, 17) / Math.pow(2, Math.floor(zoom));
            var v = pixels * zoomWidthDiscrete * scaleFactor;
            return v;
        }
    },
    ppi: {
        call: function(context) {
            var ppi = context.env.lookup("$ppi");
            if (typeof ppi === "number") {
                return ppi;
            }
            return 72;
        }
    },
    zoom: {
        isDynamicOperator: function() {
            return true;
        },
        call: function(context, call) {
            if (context.scope === 0 /* Value */ ) {
                return call;
            }
            var ref;
            return (ref = context.env.lookup("$zoom")) !== null && ref !== void 0 ? ref : null;
        }
    }
};
var MapOperators = operators7;
// src/datasource-protocol/operators/MathOperators.ts
var THREE11 = __toESM(require("three"));
var operators8 = {
    "^": {
        call: function(context, call) {
            var a = context.evaluate(call.args[0]);
            var b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error("invalid operands '".concat(typeof a === "undefined" ? "undefined" : _typeof(a), "' and '").concat(typeof b === "undefined" ? "undefined" : _typeof(b), "' for operator '^'"));
            }
            return Math.pow(a, b);
        }
    },
    "-": {
        call: function(context, call) {
            if (call.args.length === 1) {
                var value2 = context.evaluate(call.args[0]);
                if (typeof value2 !== "number") {
                    throw new Error("\xecnvalid operand '".concat(typeof value2 === "undefined" ? "undefined" : _typeof(value2), " for operator '-'"));
                }
                return -value2;
            }
            var a = context.evaluate(call.args[0]);
            var b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error("invalid operands '".concat(typeof a === "undefined" ? "undefined" : _typeof(a), "' and '").concat(typeof b === "undefined" ? "undefined" : _typeof(b), "' for operator '-'"));
            }
            return a - b;
        }
    },
    "/": {
        call: function(context, call) {
            var a = context.evaluate(call.args[0]);
            var b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error("invalid operands '".concat(typeof a === "undefined" ? "undefined" : _typeof(a), "' and '").concat(typeof b === "undefined" ? "undefined" : _typeof(b), "' for operator '/'"));
            }
            return a / b;
        }
    },
    "%": {
        call: function(context, call) {
            var a = context.evaluate(call.args[0]);
            var b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error("invalid operands '".concat(typeof a === "undefined" ? "undefined" : _typeof(a), "' and '").concat(typeof b === "undefined" ? "undefined" : _typeof(b), "' for operator '%'"));
            }
            return a % b;
        }
    },
    "+": {
        call: function(context, call) {
            return call.args.reduce(function(a, b) {
                return Number(a) + Number(context.evaluate(b));
            }, 0);
        }
    },
    "*": {
        call: function(context, call) {
            return call.args.reduce(function(a, b) {
                return Number(a) * Number(context.evaluate(b));
            }, 1);
        }
    },
    abs: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'abs'"));
            }
            return Math.abs(value2);
        }
    },
    acos: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'acos'"));
            }
            return Math.acos(value2);
        }
    },
    asin: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'asin'"));
            }
            return Math.asin(value2);
        }
    },
    atan: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'atan'"));
            }
            return Math.atan(value2);
        }
    },
    ceil: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'ceil'"));
            }
            return Math.ceil(value2);
        }
    },
    cos: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'cos'"));
            }
            return Math.cos(value2);
        }
    },
    e: {
        call: function() {
            return Math.E;
        }
    },
    floor: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'floor'"));
            }
            return Math.floor(value2);
        }
    },
    ln: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'ln'"));
            }
            return Math.log(value2);
        }
    },
    ln2: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'ln2'"));
            }
            return Math.log2(value2);
        }
    },
    log10: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'log10'"));
            }
            return Math.log10(value2);
        }
    },
    max: {
        call: function(context, call) {
            var _Math;
            return (_Math = Math).max.apply(_Math, _toConsumableArray(call.args.map(function(v) {
                return Number(context.evaluate(v));
            })));
        }
    },
    min: {
        call: function(context, call) {
            var _Math;
            return (_Math = Math).min.apply(_Math, _toConsumableArray(call.args.map(function(v) {
                return Number(context.evaluate(v));
            })));
        }
    },
    clamp: {
        call: function(context, call) {
            var v = context.evaluate(call.args[0]);
            var min = context.evaluate(call.args[1]);
            var max = context.evaluate(call.args[2]);
            if (typeof v !== "number" || typeof min !== "number" || typeof max !== "number") {
                throw new Error("invalid operands '".concat(v, "', ").concat(min, ", ").concat(max, " for operator 'clamp'"));
            }
            return THREE11.MathUtils.clamp(v, min, max);
        }
    },
    pi: {
        call: function() {
            return Math.PI;
        }
    },
    round: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'round'"));
            }
            return Math.round(value2);
        }
    },
    sin: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'sin'"));
            }
            return Math.sin(value2);
        }
    },
    sqrt: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'sqrt'"));
            }
            return Math.sqrt(value2);
        }
    },
    tan: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (typeof value2 !== "number") {
                throw new Error("invalid operand '".concat(value2, "' for operator 'tan'"));
            }
            return Math.tan(value2);
        }
    }
};
var MathOperators = operators8;
// src/datasource-protocol/operators/MiscOperators.ts
function joinKeyValues(keys) {
    return keys.join("&");
}
function stringifyKeyValue(key, value2) {
    return key + "=" + JSON.stringify(value2);
}
function joinCombinations(combinations) {
    combinations.sort(function(lhs, rhs) {
        return rhs.length - lhs.length;
    });
    var result = combinations.map(function(keys) {
        return joinKeyValues(keys);
    });
    result.push("");
    return result;
}
function getAllCombinations(input) {
    var index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (index >= input.length) {
        return [];
    }
    var combinations = getAllCombinations(input, index + 1);
    var initLength = combinations.length;
    for(var i = 0; i < initLength; i += 1){
        combinations.push(_toConsumableArray(combinations[i]).concat([
            input[index]
        ]));
    }
    combinations.push([
        input[index]
    ]);
    return combinations;
}
function getKeyCombinations(lookupExpr, context) {
    var keys = lookupExpr.args.slice(1);
    var result = [];
    for(var i = 0; i < keys.length; i += 2){
        var value2 = context.evaluate(keys[i + 1]);
        if (value2 === null) {
            continue;
        }
        var key = context.evaluate(keys[i]);
        result.push(stringifyKeyValue(key, value2));
    }
    result.sort().reverse();
    return joinCombinations(getAllCombinations(result));
}
function createLookupMap(lookupArray) {
    var map = /* @__PURE__ */ new Map();
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        var _loop = function(_iterator, _step) {
            var entry = _step.value;
            if (typeof entry !== "object") {
                throw new Error("Invalid lookup table entry type (".concat(typeof entry === "undefined" ? "undefined" : _typeof(entry), ")"));
            }
            if (!entry.keys) {
                throw new Error("Lookup table entry has no 'keys' property.");
            }
            if (!entry.attributes) {
                throw new Error("Lookup table entry has no 'attributes' property.");
            }
            var key = joinKeyValues(Object.getOwnPropertyNames(entry.keys).sort().map(function(key2) {
                return stringifyKeyValue(key2, entry.keys[key2]);
            }));
            map.set(key, entry.attributes);
        };
        for(var _iterator = lookupArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return map;
}
function searchLookupMap(keys, map) {
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var key = _step.value;
            var matchAttributes = map.get(key);
            if (matchAttributes) {
                return matchAttributes;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return null;
}
var operators9 = {
    length: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            if (Array.isArray(value2) || typeof value2 === "string") {
                return value2.length;
            }
            throw new Error("invalid operand '".concat(value2, "' for operator 'length'"));
        }
    },
    coalesce: {
        call: function(context, call) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = call.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var childExpr = _step.value;
                    var value2 = context.evaluate(childExpr);
                    if (value2 !== null) {
                        return value2;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
            return null;
        }
    },
    lookup: {
        call: function(context, lookup) {
            assert(lookup.args.length > 0, "missing lookup table");
            var keyCombinations = getKeyCombinations(lookup, context);
            var table = context.evaluate(lookup.args[0]);
            assert(Array.isArray(table) || _instanceof(table, Map), "wrong lookup table type");
            if (Array.isArray(table)) {
                table = createLookupMap(table);
                var lookupMapExpr = new ObjectLiteralExpr(table);
                lookup.args[0] = lookupMapExpr;
            }
            return searchLookupMap(keyCombinations, table);
        }
    }
};
var MiscOperators = operators9;
// src/datasource-protocol/operators/ObjectOperators.ts
var hasOwnProperty = Object.prototype.hasOwnProperty;
function lookupMember(context, args, lookupMode) {
    var memberName = context.evaluate(args[0]);
    if (typeof memberName !== "string") {
        throw new Error("expected the name of an attribute");
    }
    var object = context.evaluate(args[1]);
    if (object && typeof object === "object") {
        if (Env.isEnv(object)) {
            var ref;
            var value2 = (ref = object.lookup(memberName)) !== null && ref !== void 0 ? ref : null;
            return lookupMode === 0 /* get */  ? value2 : value2 !== null;
        }
        if (hasOwnProperty.call(object, memberName)) {
            return lookupMode === 0 /* get */  ? object[memberName] : true;
        }
    }
    return lookupMode === 0 /* get */  ? null : false;
}
var operators10 = {
    in: {
        call: function(context, call) {
            var value2 = context.evaluate(call.args[0]);
            var object = context.evaluate(call.args[1]);
            if (typeof value2 === "string" && typeof object === "string") {
                return object.includes(value2);
            } else if (Array.isArray(object)) {
                return object.includes(value2);
            }
            return false;
        }
    },
    get: {
        call: function(context, call) {
            return lookupMember(context, call.args, 0 /* get */ );
        }
    },
    has: {
        call: function(context, call) {
            return lookupMember(context, call.args, 1 /* has */ );
        }
    },
    "dynamic-properties": {
        isDynamicOperator: function() {
            return true;
        },
        call: function(context, call) {
            if (context.scope === 2 /* Dynamic */ ) {
                return context.env;
            }
            return call;
        }
    }
};
var ObjectOperators = operators10;
// src/datasource-protocol/operators/StringOperators.ts
var operators11 = {
    concat: {
        call: function(context, call) {
            var _instance;
            return (_instance = "").concat.apply(_instance, _toConsumableArray(call.args.map(function(a) {
                return String(context.evaluate(a));
            })));
        }
    },
    downcase: {
        call: function(context, call) {
            return String(context.evaluate(call.args[0])).toLocaleLowerCase();
        }
    },
    upcase: {
        call: function(context, call) {
            return String(context.evaluate(call.args[0])).toLocaleUpperCase();
        }
    },
    "~=": {
        call: function(context, call) {
            var left = context.evaluate(call.args[0]);
            var right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.includes(right);
            }
            return false;
        }
    },
    "^=": {
        call: function(context, call) {
            var left = context.evaluate(call.args[0]);
            var right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.startsWith(right);
            }
            return false;
        }
    },
    "$=": {
        call: function(context, call) {
            var left = context.evaluate(call.args[0]);
            var right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.endsWith(right);
            }
            return false;
        }
    }
};
var StringOperators = operators11;
// src/datasource-protocol/operators/TypeOperators.ts
var operators12 = {
    typeof: {
        call: function(context, call) {
            return _typeof(context.evaluate(call.args[0]));
        }
    }
};
var TypeOperators = operators12;
// src/datasource-protocol/operators/VectorOperators.ts
var THREE12 = __toESM(require("three"));
function isVector(context, call, type) {
    var ctor;
    switch(type){
        case "vector2":
            ctor = THREE12.Vector2;
            break;
        case "vector3":
            ctor = THREE12.Vector3;
            break;
        case "vector4":
            ctor = THREE12.Vector4;
            break;
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = call.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var childExpr = _step.value;
            var value2 = context.evaluate(childExpr);
            if (_instanceof(value2, ctor)) {
                return value2;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    throw new Error('expected a "'.concat(type, '"'));
}
function toVector(context, call, type) {
    var VectorCtor;
    var components;
    switch(type){
        case "vector2":
            VectorCtor = THREE12.Vector2;
            components = 2;
            break;
        case "vector3":
            VectorCtor = THREE12.Vector3;
            components = 3;
            break;
        case "vector4":
            VectorCtor = THREE12.Vector4;
            components = 4;
            break;
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = call.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var childExpr = _step.value;
            var value2 = context.evaluate(childExpr);
            if (_instanceof(value2, VectorCtor)) {
                return value2;
            } else if (Array.isArray(value2) && value2.length === components && value2.every(function(v) {
                return typeof v === "number";
            })) {
                return new VectorCtor().fromArray(value2);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    throw new Error('expected a "'.concat(type, '"'));
}
var operators13 = {
    "make-vector": {
        call: function(context, call) {
            if (call._value !== void 0) {
                return call._value;
            }
            if (call.args.length < 2) {
                throw new Error("not enough arguments");
            } else if (call.args.length > 4) {
                throw new Error("too many arguments");
            }
            var components = call.args.map(function(arg) {
                return context.evaluate(arg);
            });
            components.forEach(function(element, index) {
                if (typeof element !== "number") {
                    throw new Error("expected vector component at index ".concat(index, ' to have type "number"'));
                }
            });
            var result;
            switch(components.length){
                case 2:
                    result = new THREE12.Vector2().fromArray(components);
                    break;
                case 3:
                    result = new THREE12.Vector3().fromArray(components);
                    break;
                case 4:
                    result = new THREE12.Vector4().fromArray(components);
                    break;
                default:
                    throw new Error("too many arguments");
            }
            if (call.args.every(function(arg) {
                return _instanceof(arg, NumberLiteralExpr);
            })) {
                call._value = result;
            }
            return result;
        }
    },
    vector2: {
        call: function(context, call) {
            return isVector(context, call, "vector2");
        }
    },
    vector3: {
        call: function(context, call) {
            return isVector(context, call, "vector3");
        }
    },
    vector4: {
        call: function(context, call) {
            return isVector(context, call, "vector4");
        }
    },
    "to-vector2": {
        call: function(context, call) {
            return toVector(context, call, "vector2");
        }
    },
    "to-vector3": {
        call: function(context, call) {
            return toVector(context, call, "vector3");
        }
    },
    "to-vector4": {
        call: function(context, call) {
            return toVector(context, call, "vector4");
        }
    }
};
var VectorOperators = operators13;
// src/datasource-protocol/Pixels.ts
var RX = /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/;
var Pixels = /*#__PURE__*/ function() {
    function Pixels(value2) {
        _classCallCheck(this, Pixels);
        this.value = value2;
    }
    _createClass(Pixels, [
        {
            key: "toJSON",
            value: function toJSON() {
                return "".concat(this.value, "px");
            }
        }
    ], [
        {
            key: "parse",
            value: function parse(text) {
                var match = RX.exec(text);
                if (match === null) {
                    return void 0;
                }
                return new Pixels(Number(match[1]));
            }
        }
    ]);
    return Pixels;
}();
// src/datasource-protocol/ExprEvaluator.ts
var operatorDescriptors = /* @__PURE__ */ new Map();
function promoteValue(context, expr) {
    if (_instanceof(expr, StringLiteralExpr)) {
        var _promotedValue;
        return (_promotedValue = expr.promotedValue) !== null && _promotedValue !== void 0 ? _promotedValue : expr.value;
    }
    var value2 = context.evaluate(expr);
    if (typeof value2 === "string") {
        var ref, ref1;
        return (ref1 = (ref = RGBA.parse(value2)) !== null && ref !== void 0 ? ref : Pixels.parse(value2)) !== null && ref1 !== void 0 ? ref1 : value2;
    }
    return value2;
}
function cubicInterpolate(context, interp, t) {
    if (t < interp.stops[0][0]) {
        return promoteValue(context, interp.stops[0][1]);
    } else if (t >= interp.stops[interp.stops.length - 1][0]) {
        return promoteValue(context, interp.stops[interp.stops.length - 1][1]);
    }
    var i1 = interp.stops.findIndex(function(stop) {
        return stop[0] > t;
    });
    var i0 = Math.max(0, i1 - 1);
    var iP = i0 === 0 ? i1 : i0 - 1;
    var iN = i1 < interp.stops.length - 1 ? i1 + 1 : i1 - 1;
    var tP = interp.stops[iP][0];
    var t0 = interp.stops[i0][0];
    var t1 = interp.stops[i1][0];
    var tN = interp.stops[iN][0];
    var dt = (t1 - t0) * 0.5;
    var wP = dt / (t0 - tP);
    var wN = dt / (tN - t1);
    var p = (t - t0) / (t1 - t0);
    var pp = p * p;
    var ppp = pp * p;
    var cP = -wP * ppp + 2 * wP * pp - wP * p;
    var c0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    var c1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    var cN = wN * ppp - wN * pp;
    var vP = promoteValue(context, interp.stops[iP][1]);
    var v0 = promoteValue(context, interp.stops[i0][1]);
    var v1 = promoteValue(context, interp.stops[i1][1]);
    var vN = promoteValue(context, interp.stops[iN][1]);
    if (typeof vP === "number" && typeof v0 === "number" && typeof v1 === "number" && typeof vN === "number") {
        return cP * vP + c0 * v0 + c1 * v1 + cN * vN;
    } else if (_instanceof(vP, RGBA) && _instanceof(v0, RGBA) && _instanceof(v1, RGBA) && _instanceof(vN, RGBA)) {
        return new RGBA(THREE13.MathUtils.clamp(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, 0, 1), THREE13.MathUtils.clamp(cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, 0, 1), THREE13.MathUtils.clamp(cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b, 0, 1), THREE13.MathUtils.clamp(cP * vP.a + c0 * v0.a + c1 * v1.a + cN * vN.a, 0, 1));
    } else if (_instanceof(vP, Pixels) && _instanceof(v0, Pixels) && _instanceof(v1, Pixels) && _instanceof(vN, Pixels)) {
        return new Pixels(cP * vP.value + c0 * v0.value + c1 * v1.value + cN * vN.value);
    } else if (_instanceof(vP, THREE13.Color) && _instanceof(v0, THREE13.Color) && _instanceof(v1, THREE13.Color) && _instanceof(vN, THREE13.Color)) {
        return new THREE13.Color(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b);
    } else if (_instanceof(vP, THREE13.Vector2) && _instanceof(v0, THREE13.Vector2) && _instanceof(v1, THREE13.Vector2) && _instanceof(vN, THREE13.Vector2)) {
        return new THREE13.Vector2(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y);
    } else if (_instanceof(vP, THREE13.Vector3) && _instanceof(v0, THREE13.Vector3) && _instanceof(v1, THREE13.Vector3) && _instanceof(vN, THREE13.Vector3)) {
        return new THREE13.Vector3(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z);
    } else if (_instanceof(vP, THREE13.Vector4) && _instanceof(v0, THREE13.Vector4) && _instanceof(v1, THREE13.Vector4) && _instanceof(vN, THREE13.Vector4)) {
        return new THREE13.Vector4(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z, cP * vP.w + c0 * v0.w + c1 * v1.w + cN * vN.w);
    } else if (Array.isArray(vP) && Array.isArray(v0) && Array.isArray(v1) && Array.isArray(vN)) {
        var N = vP.length;
        var r = [];
        for(var i = 0; i < N; ++i){
            r[i] = cP * vP[i] + c0 * v0[i] + c1 * v1[i] + cN * vN[i];
        }
        return r;
    }
    throw new Error("failed to interpolate values");
}
var ExprEvaluatorContext = /*#__PURE__*/ function() {
    function ExprEvaluatorContext(evaluator, env, scope, cache6) {
        _classCallCheck(this, ExprEvaluatorContext);
        this.evaluator = evaluator;
        this.env = env;
        this.scope = scope;
        this.cache = cache6;
    }
    _createClass(ExprEvaluatorContext, [
        {
            key: "evaluate",
            value: function evaluate(expr) {
                var ref, ref1;
                if (expr === void 0) {
                    throw new Error("Failed to evaluate expression");
                }
                var cachedResult = (ref = this.cache) === null || ref === void 0 ? void 0 : ref.get(expr);
                if (cachedResult !== void 0) {
                    return cachedResult;
                }
                var result = expr.accept(this.evaluator, this);
                (ref1 = this.cache) === null || ref1 === void 0 ? void 0 : ref1.set(expr, result);
                return result;
            }
        },
        {
            key: "wrapValue",
            value: function wrapValue(value2) {
                return Expr3.isExpr(value2) ? value2 : LiteralExpr.fromValue(value2);
            }
        }
    ]);
    return ExprEvaluatorContext;
}();
var ExprEvaluator = /*#__PURE__*/ function() {
    function ExprEvaluator() {
        _classCallCheck(this, ExprEvaluator);
    }
    _createClass(ExprEvaluator, [
        {
            key: "visitVarExpr",
            value: function visitVarExpr(expr, context) {
                var value2 = context.env.lookup(expr.name);
                return value2 !== void 0 ? value2 : null;
            }
        },
        {
            key: "visitNullLiteralExpr",
            value: function visitNullLiteralExpr(expr, context) {
                return null;
            }
        },
        {
            key: "visitBooleanLiteralExpr",
            value: function visitBooleanLiteralExpr(expr, context) {
                return expr.value;
            }
        },
        {
            key: "visitNumberLiteralExpr",
            value: function visitNumberLiteralExpr(expr, context) {
                return expr.value;
            }
        },
        {
            key: "visitStringLiteralExpr",
            value: function visitStringLiteralExpr(expr, context) {
                return expr.value;
            }
        },
        {
            key: "visitObjectLiteralExpr",
            value: function visitObjectLiteralExpr(expr, context) {
                return expr.value;
            }
        },
        {
            key: "visitHasAttributeExpr",
            value: function visitHasAttributeExpr(expr, context) {
                return context.env.lookup(expr.name) !== void 0;
            }
        },
        {
            key: "visitMatchExpr",
            value: function visitMatchExpr(match, context) {
                var r = context.evaluate(match.value);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = match.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), label = _value[0], body = _value[1];
                        if (Array.isArray(label) && label.includes(r)) {
                            return context.evaluate(body);
                        } else if (label === r) {
                            return context.evaluate(body);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return context.evaluate(match.fallback);
            }
        },
        {
            key: "visitCaseExpr",
            value: function visitCaseExpr(match, context) {
                if (context.scope === 0 /* Value */ ) {
                    var firstDynamicCondition = match.branches.findIndex(function(param) {
                        var _param = _slicedToArray(param, 2), condition = _param[0], _ = _param[1];
                        return condition.isDynamic();
                    });
                    if (firstDynamicCondition !== -1) {
                        var branches;
                        for(var i = 0; i < match.branches.length; ++i){
                            var _i = _slicedToArray(match.branches[i], 2), condition = _i[0], body = _i[1];
                            var evaluatedCondition = context.evaluate(condition);
                            var evaluatedBody = context.evaluate(body);
                            if (i < firstDynamicCondition && Boolean(evaluatedCondition)) {
                                return evaluatedBody;
                            }
                            if (!Expr3.isExpr(evaluatedCondition) && !Boolean(evaluatedCondition)) {
                                continue;
                            }
                            if (branches === void 0) {
                                branches = [];
                            }
                            branches === null || branches === void 0 ? void 0 : branches.push([
                                context.wrapValue(evaluatedCondition),
                                context.wrapValue(evaluatedBody)
                            ]);
                            if (!Expr3.isExpr(evaluatedCondition) && Boolean(evaluatedCondition)) {
                                return new CaseExpr(branches, LiteralExpr.fromValue(null));
                            }
                        }
                        var fallback = context.evaluate(match.fallback);
                        return branches === void 0 ? fallback : new CaseExpr(branches, context.wrapValue(fallback));
                    }
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = match.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), condition1 = _value[0], body1 = _value[1];
                        if (context.evaluate(condition1)) {
                            return context.evaluate(body1);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return context.evaluate(match.fallback);
            }
        },
        {
            key: "visitCallExpr",
            value: function visitCallExpr(expr, context) {
                var _descriptor;
                var descriptor = (_descriptor = expr.descriptor) !== null && _descriptor !== void 0 ? _descriptor : operatorDescriptors.get(expr.op);
                if (descriptor) {
                    expr.descriptor = descriptor;
                    var result;
                    if (context.scope === 0 /* Value */  && expr.isDynamic()) {
                        if (expr.descriptor.partialEvaluate) {
                            return expr.descriptor.partialEvaluate(context, expr);
                        }
                        var args = expr.args.map(function(arg) {
                            return context.wrapValue(context.evaluate(arg));
                        });
                        if (args.every(function(arg, i) {
                            return arg === expr.args[i];
                        })) {
                            return expr;
                        }
                        result = new CallExpr7(expr.op, args);
                    } else {
                        result = descriptor.call(context, expr);
                    }
                    return result;
                }
                throw new Error("undefined operator '".concat(expr.op, "'"));
            }
        },
        {
            key: "visitLookupExpr",
            value: function visitLookupExpr(expr, context) {
                return this.visitCallExpr(expr, context);
            }
        },
        {
            key: "visitStepExpr",
            value: function visitStepExpr(expr, context) {
                if (context.scope === 0 /* Value */ ) {
                    var input = context.evaluate(expr.input);
                    var defaultValue = context.evaluate(expr.defaultValue);
                    return new StepExpr(context.wrapValue(input), context.wrapValue(defaultValue), expr.stops.map(function(param) {
                        var _param = _slicedToArray(param, 2), key = _param[0], value2 = _param[1];
                        var v = context.evaluate(value2);
                        return [
                            key,
                            context.wrapValue(v)
                        ];
                    }));
                } else {
                    var input1 = context.evaluate(expr.input);
                    if (typeof input1 !== "number") {
                        throw new Error("input '".concat(input1, "' must be a number"));
                    }
                    if (input1 < expr.stops[0][0]) {
                        return context.evaluate(expr.defaultValue);
                    }
                    var index = expr.stops.findIndex(function(s) {
                        return s[0] > input1;
                    });
                    if (index === -1) {
                        index = expr.stops.length;
                    }
                    return context.evaluate(expr.stops[index - 1][1]);
                }
            }
        },
        {
            key: "visitInterpolateExpr",
            value: function visitInterpolateExpr(expr, context) {
                if (context.scope === 0 /* Value */ ) {
                    var input = context.evaluate(expr.input);
                    return new InterpolateExpr(expr.mode, context.wrapValue(input), expr.stops.map(function(param) {
                        var _param = _slicedToArray(param, 2), key = _param[0], value2 = _param[1];
                        var v = context.evaluate(value2);
                        return [
                            key,
                            context.wrapValue(v)
                        ];
                    }));
                } else {
                    var param = context.evaluate(expr.input);
                    if (typeof param !== "number") {
                        throw new Error("input must be a number");
                    }
                    if (expr.mode[0] === "cubic") {
                        return cubicInterpolate(context, expr, param);
                    }
                    var keyIndex = expr.stops.findIndex(function(stop) {
                        return stop[0] > param;
                    });
                    if (keyIndex === -1) {
                        return context.evaluate(expr.stops[expr.stops.length - 1][1]);
                    } else if (keyIndex === 0) {
                        return context.evaluate(expr.stops[0][1]);
                    }
                    var _keyIndex = _slicedToArray(expr.stops[keyIndex], 2), key = _keyIndex[0], value2 = _keyIndex[1];
                    var ref = _slicedToArray(expr.stops[keyIndex - 1], 2), prevKey = ref[0], prevValue = ref[1];
                    var v0 = promoteValue(context, prevValue);
                    var t = 0;
                    switch(expr.mode[0]){
                        case "discrete":
                            return v0;
                        case "linear":
                            t = (param - prevKey) / (key - prevKey);
                            break;
                        case "exponential":
                            {
                                var base = expr.mode[1];
                                t = base === 1 ? (param - prevKey) / (key - prevKey) : (Math.pow(base, param - prevKey) - 1) / (Math.pow(base, key - prevKey) - 1);
                                break;
                            }
                        default:
                            throw new Error("interpolation mode ".concat(JSON.stringify(expr.mode), " is not supported"));
                    }
                    var v1 = promoteValue(context, value2);
                    if (typeof v0 === "number" && typeof v1 === "number") {
                        return THREE13.MathUtils.lerp(v0, v1, t);
                    } else if (_instanceof(v0, RGBA) && _instanceof(v1, RGBA)) {
                        return v0.clone().lerp(v1, t);
                    } else if (_instanceof(v0, Pixels) && _instanceof(v1, Pixels)) {
                        return new Pixels(THREE13.MathUtils.lerp(v0.value, v1.value, t));
                    } else if (_instanceof(v0, THREE13.Color) && _instanceof(v1, THREE13.Color)) {
                        return v0.clone().lerp(v1, t);
                    } else if (_instanceof(v0, THREE13.Vector2) && _instanceof(v1, THREE13.Vector2)) {
                        return v0.clone().lerp(v1, t);
                    } else if (_instanceof(v0, THREE13.Vector3) && _instanceof(v1, THREE13.Vector3)) {
                        return v0.clone().lerp(v1, t);
                    } else if (_instanceof(v0, THREE13.Vector4) && _instanceof(v1, THREE13.Vector4)) {
                        return v0.clone().lerp(v1, t);
                    } else if (Array.isArray(v0) && Array.isArray(v1) && v0.length === v1.length) {
                        return v0.map(function(x, i) {
                            return THREE13.MathUtils.lerp(x, v1[i], t);
                        });
                    }
                    throw new Error("todo: mix(".concat(JSON.stringify(v0), ", ").concat(JSON.stringify(v1), ", ").concat(t, ")"));
                }
            }
        }
    ], [
        {
            key: "defineOperator",
            value: function defineOperator(op, builtin) {
                operatorDescriptors.set(op, builtin);
            }
        },
        {
            key: "defineOperators",
            value: function defineOperators(builtins) {
                var _this = this;
                Object.getOwnPropertyNames(builtins).forEach(function(p) {
                    _this.defineOperator(p, builtins[p]);
                });
            }
        },
        {
            key: "getOperator",
            value: function getOperator(op) {
                return operatorDescriptors.get(op);
            }
        }
    ]);
    return ExprEvaluator;
}();
ExprEvaluator.defineOperators(CastOperators);
ExprEvaluator.defineOperators(ComparisonOperators);
ExprEvaluator.defineOperators(MathOperators);
ExprEvaluator.defineOperators(StringOperators);
ExprEvaluator.defineOperators(ColorOperators);
ExprEvaluator.defineOperators(TypeOperators);
ExprEvaluator.defineOperators(MiscOperators);
ExprEvaluator.defineOperators(FlowOperators);
ExprEvaluator.defineOperators(ArrayOperators);
ExprEvaluator.defineOperators(ObjectOperators);
ExprEvaluator.defineOperators(FeatureOperators);
ExprEvaluator.defineOperators(MapOperators);
ExprEvaluator.defineOperators(VectorOperators);
// src/datasource-protocol/ExprInstantiator.ts
var emptyEnv = new Env();
var ExprInstantiator = /*#__PURE__*/ function() {
    function ExprInstantiator() {
        _classCallCheck(this, ExprInstantiator);
    }
    _createClass(ExprInstantiator, [
        {
            key: "visitNullLiteralExpr",
            value: function visitNullLiteralExpr(expr, _context) {
                return expr;
            }
        },
        {
            key: "visitBooleanLiteralExpr",
            value: function visitBooleanLiteralExpr(expr, _context) {
                return expr;
            }
        },
        {
            key: "visitNumberLiteralExpr",
            value: function visitNumberLiteralExpr(expr, _context) {
                return expr;
            }
        },
        {
            key: "visitStringLiteralExpr",
            value: function visitStringLiteralExpr(expr, _context) {
                return expr;
            }
        },
        {
            key: "visitObjectLiteralExpr",
            value: function visitObjectLiteralExpr(expr, _context) {
                return expr;
            }
        },
        {
            key: "visitVarExpr",
            value: function visitVarExpr(expr, context) {
                if (context.preserve && context.preserve.has(expr.name)) {
                    return expr;
                }
                var value2 = context.env.lookup(expr.name);
                return LiteralExpr.fromValue(value2 !== void 0 ? value2 : null);
            }
        },
        {
            key: "visitHasAttributeExpr",
            value: function visitHasAttributeExpr(expr, context) {
                if (context.preserve && context.preserve.has(expr.name)) {
                    return expr;
                }
                var value2 = context.env.lookup(expr.name) !== void 0;
                return LiteralExpr.fromValue(value2);
            }
        },
        {
            key: "visitCallExprImpl",
            value: function visitCallExprImpl(expr, context, constructor) {
                var _this = this;
                var args = expr.args.map(function(arg) {
                    return arg.accept(_this, context);
                });
                if (args.some(function(a, i) {
                    return a !== expr.args[i];
                })) {
                    return constructor(expr.op, args);
                }
                return expr;
            }
        },
        {
            key: "visitCallExpr",
            value: function visitCallExpr(expr, context) {
                return this.visitCallExprImpl(expr, context, function(op, args) {
                    return new CallExpr7(op, args);
                });
            }
        },
        {
            key: "visitLookupExpr",
            value: function visitLookupExpr(expr, context) {
                return this.visitCallExprImpl(expr, context, function(op, args) {
                    return new LookupExpr3(args);
                });
            }
        },
        {
            key: "visitMatchExpr",
            value: function visitMatchExpr(match, context) {
                var _this = this;
                var value2 = match.value.accept(this, context);
                if (_instanceof(value2, LiteralExpr)) {
                    var r = value2.value;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = match.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _value = _slicedToArray(_step.value, 2), label = _value[0], body = _value[1];
                            if (Array.isArray(label) && label.includes(r)) {
                                return body.accept(this, context);
                            } else if (label === r) {
                                return body.accept(this, context);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    return match.fallback.accept(this, context);
                }
                var changed = match.value !== value2;
                var branches = match.branches.map(function(param) {
                    var _param = _slicedToArray(param, 2), label = _param[0], branch = _param[1];
                    var newBranch = branch.accept(_this, context);
                    if (newBranch !== branch) {
                        changed = true;
                    }
                    return [
                        label,
                        newBranch
                    ];
                });
                var fallback = match.fallback.accept(this, context);
                if (fallback !== match.fallback) {
                    changed = true;
                }
                return changed ? new MatchExpr2(value2, branches, fallback) : match;
            }
        },
        {
            key: "visitCaseExpr",
            value: function visitCaseExpr(expr, context) {
                var _this = this;
                var branches = [];
                var changed = false;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = expr.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), condition = _value[0], branch = _value[1];
                        var newCondition = condition.accept(this, context);
                        var deps = newCondition.dependencies();
                        if (!condition.isDynamic() && deps.properties.size === 0) {
                            if (Boolean(newCondition.evaluate(emptyEnv, 1 /* Condition */ ))) {
                                return branch.accept(this, context);
                            }
                        } else {
                            if (newCondition !== condition) {
                                changed = true;
                            }
                            branches.push([
                                newCondition,
                                branch
                            ]);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (branches.length === 0) {
                    return expr.fallback.accept(this, context);
                }
                if (branches.length !== expr.branches.length) {
                    changed = true;
                }
                branches.forEach(function(branch) {
                    var instantiatedBranch = branch[1].accept(_this, context);
                    if (instantiatedBranch !== branch[1]) {
                        changed = true;
                    }
                    branch[1] = instantiatedBranch;
                });
                var fallback = expr.fallback.accept(this, context);
                if (fallback !== expr.fallback) {
                    changed = true;
                }
                if (!changed) {
                    return expr;
                }
                return new CaseExpr(branches, fallback);
            }
        },
        {
            key: "visitStepExpr",
            value: function visitStepExpr(expr, context) {
                var _this = this;
                var input = expr.input.accept(this, context);
                var defaultValue = expr.defaultValue.accept(this, context);
                var stops = expr.stops.map(function(param) {
                    var _param = _slicedToArray(param, 2), key = _param[0], value2 = _param[1];
                    return [
                        key,
                        value2.accept(_this, context)
                    ];
                });
                return new StepExpr(input, defaultValue, stops);
            }
        },
        {
            key: "visitInterpolateExpr",
            value: function visitInterpolateExpr(expr, context) {
                var _this = this;
                var input = expr.input.accept(this, context);
                var stops = expr.stops.map(function(param) {
                    var _param = _slicedToArray(param, 2), key = _param[0], value2 = _param[1];
                    return [
                        key,
                        value2.accept(_this, context)
                    ];
                });
                return new InterpolateExpr(expr.mode, input, stops);
            }
        }
    ]);
    return ExprInstantiator;
}();
// src/datasource-protocol/ExprParser.ts
function isSpace(codepoint) {
    switch(codepoint){
        case 9 /* Tab */ :
        case 10 /* Lf */ :
        case 13 /* Cr */ :
        case 32 /* Space */ :
            return true;
        default:
            return false;
    }
}
function isNumber(codepoint) {
    return codepoint >= 48 /* _0 */  && codepoint <= 57 /* _9 */ ;
}
function isLetter(codepoint) {
    return codepoint >= 97 /* a */  && codepoint <= 122 /* z */  || codepoint >= 64 /* A */  && codepoint <= 90 /* Z */ ;
}
function isLetterOrNumber(codepoint) {
    return isLetter(codepoint) || isNumber(codepoint);
}
function isIdentChar(codepoint) {
    return isLetterOrNumber(codepoint) || codepoint === 95 /* _ */  || codepoint === 36 /* Dollar */  || codepoint === 46 /* Dot */  || codepoint === 91 /* LBracket */  || codepoint === 93 /* RBracket */ ;
}
function tokenSpell(token) {
    switch(token){
        case 0 /* Eof */ :
            return "eof";
        case 1 /* Error */ :
            return "error";
        case 2 /* Identifier */ :
            return "identifier";
        case 3 /* Number */ :
            return "number";
        case 4 /* String */ :
            return "string";
        case 5 /* Comma */ :
            return ",";
        case 6 /* LParen */ :
            return "(";
        case 7 /* RParen */ :
            return ")";
        case 8 /* LBracket */ :
            return "[";
        case 9 /* RBracket */ :
            return "]";
        case 10 /* Exclaim */ :
            return "!";
        case 11 /* TildeEqual */ :
            return "~=";
        case 12 /* CaretEqual */ :
            return "^=";
        case 13 /* DollarEqual */ :
            return "$=";
        case 14 /* EqualEqual */ :
            return "==";
        case 15 /* ExclaimEqual */ :
            return "!=";
        case 16 /* Less */ :
            return "<";
        case 17 /* Greater */ :
            return ">";
        case 18 /* LessEqual */ :
            return "<=";
        case 19 /* GreaterEqual */ :
            return ">=";
        case 20 /* BarBar */ :
            return "||";
        case 21 /* AmpAmp */ :
            return "&&";
        default:
            throw new Error("invalid token ".concat(token));
    }
}
var Lexer = /*#__PURE__*/ function() {
    function Lexer(code) {
        _classCallCheck(this, Lexer);
        this.code = code;
        __publicField(this, "m_token", 1 /* Error */ );
        __publicField(this, "m_index", 0);
        __publicField(this, "m_char", 10 /* Lf */ );
        __publicField(this, "m_text");
    }
    _createClass(Lexer, [
        {
            key: "token",
            value: function token() {
                return this.m_token;
            }
        },
        {
            key: "text",
            value: function text() {
                var _m_text;
                return (_m_text = this.m_text) !== null && _m_text !== void 0 ? _m_text : "";
            }
        },
        {
            key: "next",
            value: function next() {
                this.m_token = this.yylex();
                if (this.m_token === 1 /* Error */ ) {
                    throw new Error("unexpected character ".concat(this.m_char));
                }
                return this.m_token;
            }
        },
        {
            key: "yyinp",
            value: function yyinp() {
                var ref;
                this.m_char = (ref = this.code.codePointAt(this.m_index++)) !== null && ref !== void 0 ? ref : 0;
            }
        },
        {
            key: "yylex",
            value: function yylex() {
                this.m_text = void 0;
                while(isSpace(this.m_char)){
                    this.yyinp();
                }
                if (this.m_char === 0) {
                    return 0 /* Eof */ ;
                }
                var ch = this.m_char;
                this.yyinp();
                switch(ch){
                    case 40 /* LParen */ :
                        return 6 /* LParen */ ;
                    case 41 /* RParen */ :
                        return 7 /* RParen */ ;
                    case 91 /* LBracket */ :
                        return 8 /* LBracket */ ;
                    case 93 /* RBracket */ :
                        return 9 /* RBracket */ ;
                    case 44 /* Comma */ :
                        return 5 /* Comma */ ;
                    case 39 /* SingleQuote */ :
                    case 34 /* DoubleQuote */ :
                        {
                            var start = this.m_index - 1;
                            while(this.m_char && this.m_char !== ch){
                                this.yyinp();
                            }
                            if (this.m_char !== ch) {
                                throw new Error("Unfinished string literal");
                            }
                            this.yyinp();
                            this.m_text = this.code.substring(start, this.m_index - 2);
                            return 4 /* String */ ;
                        }
                    case 33 /* Exclaim */ :
                        if (this.m_char === 61 /* Equal */ ) {
                            this.yyinp();
                            return 15 /* ExclaimEqual */ ;
                        }
                        return 10 /* Exclaim */ ;
                    case 94 /* Caret */ :
                        if (this.m_char === 61 /* Equal */ ) {
                            this.yyinp();
                            return 12 /* CaretEqual */ ;
                        }
                        return 1 /* Error */ ;
                    case 126 /* Tilde */ :
                        if (this.m_char === 61 /* Equal */ ) {
                            this.yyinp();
                            return 11 /* TildeEqual */ ;
                        }
                        return 1 /* Error */ ;
                    case 61 /* Equal */ :
                        if (this.m_char === 61 /* Equal */ ) {
                            this.yyinp();
                            return 14 /* EqualEqual */ ;
                        }
                        return 1 /* Error */ ;
                    case 60 /* Less */ :
                        if (this.m_char === 61 /* Equal */ ) {
                            this.yyinp();
                            return 18 /* LessEqual */ ;
                        }
                        return 16 /* Less */ ;
                    case 62 /* Greater */ :
                        if (this.m_char === 61 /* Equal */ ) {
                            this.yyinp();
                            return 19 /* GreaterEqual */ ;
                        }
                        return 17 /* Greater */ ;
                    case 124 /* Bar */ :
                        if (this.m_char === 124 /* Bar */ ) {
                            this.yyinp();
                            return 20 /* BarBar */ ;
                        }
                        return 1 /* Error */ ;
                    case 38 /* Amp */ :
                        if (this.m_char === 38 /* Amp */ ) {
                            this.yyinp();
                            return 21 /* AmpAmp */ ;
                        }
                        return 1 /* Error */ ;
                    default:
                        {
                            var start1 = this.m_index - 2;
                            if (isLetter(ch) || ch === 95 /* _ */  || ch === 36 /* Dollar */  && isIdentChar(this.m_char)) {
                                while(isIdentChar(this.m_char)){
                                    this.yyinp();
                                }
                                this.m_text = this.code.substring(start1, this.m_index - 1);
                                return 2 /* Identifier */ ;
                            } else if (isNumber(ch)) {
                                while(isNumber(this.m_char)){
                                    this.yyinp();
                                }
                                if (this.m_char === 46 /* Dot */ ) {
                                    this.yyinp();
                                    while(isNumber(this.m_char)){
                                        this.yyinp();
                                    }
                                }
                                this.m_text = this.code.substring(start1, this.m_index - 1);
                                return 3 /* Number */ ;
                            } else if (ch === 36 /* Dollar */ ) {
                                if (this.m_char === 61 /* Equal */ ) {
                                    this.yyinp();
                                    return 13 /* DollarEqual */ ;
                                }
                                return 1 /* Error */ ;
                            }
                        }
                }
                return 1 /* Error */ ;
            }
        }
    ]);
    return Lexer;
}();
function getEqualityOp(token) {
    switch(token){
        case 11 /* TildeEqual */ :
            return "~=";
        case 12 /* CaretEqual */ :
            return "^=";
        case 13 /* DollarEqual */ :
            return "$=";
        case 14 /* EqualEqual */ :
            return "==";
        case 15 /* ExclaimEqual */ :
            return "!=";
        default:
            return void 0;
    }
}
function getRelationalOp(token) {
    switch(token){
        case 16 /* Less */ :
            return "<";
        case 17 /* Greater */ :
            return ">";
        case 18 /* LessEqual */ :
            return "<=";
        case 19 /* GreaterEqual */ :
            return ">=";
        default:
            return void 0;
    }
}
var ExprParser = /*#__PURE__*/ function() {
    function ExprParser(code) {
        _classCallCheck(this, ExprParser);
        __publicField(this, "lex");
        this.lex = new Lexer(code);
        this.lex.next();
    }
    _createClass(ExprParser, [
        {
            key: "parse",
            value: function parse() {
                return this.parseLogicalOr();
            }
        },
        {
            key: "yyexpect",
            value: function yyexpect(token) {
                if (this.lex.token() !== token) {
                    throw new Error("Syntax error: Expected token '".concat(tokenSpell(token), "' but found '").concat(tokenSpell(this.lex.token()), "'"));
                }
                this.lex.next();
            }
        },
        {
            key: "parsePrimary",
            value: function parsePrimary() {
                switch(this.lex.token()){
                    case 2 /* Identifier */ :
                        {
                            var text = this.lex.text();
                            switch(text){
                                case "has":
                                    this.lex.next();
                                    this.yyexpect(6 /* LParen */ );
                                    var hasAttribute = this.lex.text();
                                    this.yyexpect(2 /* Identifier */ );
                                    this.yyexpect(7 /* RParen */ );
                                    return new HasAttributeExpr3(hasAttribute);
                                case "length":
                                    this.lex.next();
                                    this.yyexpect(6 /* LParen */ );
                                    var value2 = this.parseLogicalOr();
                                    this.yyexpect(7 /* RParen */ );
                                    return new CallExpr7("length", [
                                        value2
                                    ]);
                                default:
                                    var expr = new VarExpr3(text);
                                    this.lex.next();
                                    return expr;
                            }
                        }
                    case 6 /* LParen */ :
                        {
                            this.lex.next();
                            var expr1 = this.parseLogicalOr();
                            this.yyexpect(7 /* RParen */ );
                            return expr1;
                        }
                    default:
                        return this.parseLiteral();
                }
            }
        },
        {
            key: "parseLiteral",
            value: function parseLiteral() {
                switch(this.lex.token()){
                    case 3 /* Number */ :
                        {
                            var expr = new NumberLiteralExpr(parseFloat(this.lex.text()));
                            this.lex.next();
                            return expr;
                        }
                    case 4 /* String */ :
                        {
                            var expr1 = new StringLiteralExpr(this.lex.text());
                            this.lex.next();
                            return expr1;
                        }
                    default:
                        throw new Error("Syntax error");
                }
            }
        },
        {
            key: "parseUnary",
            value: function parseUnary() {
                if (this.lex.token() === 10 /* Exclaim */ ) {
                    this.lex.next();
                    return new CallExpr7("!", [
                        this.parseUnary()
                    ]);
                }
                return this.parsePrimary();
            }
        },
        {
            key: "parseRelational",
            value: function parseRelational() {
                var expr = this.parseUnary();
                while(true){
                    if (this.lex.token() === 2 /* Identifier */  && this.lex.text() === "in") {
                        this.lex.next();
                        this.yyexpect(8 /* LBracket */ );
                        var elements = [
                            this.parseLiteral()
                        ];
                        while(this.lex.token() === 5 /* Comma */ ){
                            this.lex.next();
                            elements.push(this.parseLiteral());
                        }
                        this.yyexpect(9 /* RBracket */ );
                        expr = new CallExpr7("in", [
                            expr,
                            LiteralExpr.fromValue(elements.map(function(param) {
                                var value2 = param.value;
                                return value2;
                            }))
                        ]);
                    } else {
                        var op = getRelationalOp(this.lex.token());
                        if (op === void 0) {
                            break;
                        }
                        this.lex.next();
                        var right = this.parseUnary();
                        expr = new CallExpr7(op, [
                            expr,
                            right
                        ]);
                    }
                }
                return expr;
            }
        },
        {
            key: "parseEquality",
            value: function parseEquality() {
                var expr = this.parseRelational();
                while(true){
                    var op = getEqualityOp(this.lex.token());
                    if (op === void 0) {
                        break;
                    }
                    if (op === "~=") {
                        op = "in";
                    }
                    this.lex.next();
                    var right = this.parseRelational();
                    expr = new CallExpr7(op, [
                        expr,
                        right
                    ]);
                }
                return expr;
            }
        },
        {
            key: "parseLogicalAnd",
            value: function parseLogicalAnd() {
                var expr = this.parseEquality();
                if (this.lex.token() !== 21 /* AmpAmp */ ) {
                    return expr;
                }
                var expressions = [
                    expr
                ];
                do {
                    this.lex.next();
                    expressions.push(this.parseEquality());
                }while (this.lex.token() === 21 /* AmpAmp */ );
                return new CallExpr7("all", expressions);
            }
        },
        {
            key: "parseLogicalOr",
            value: function parseLogicalOr() {
                var expr = this.parseLogicalAnd();
                if (this.lex.token() !== 20 /* BarBar */ ) {
                    return expr;
                }
                var expressions = [
                    expr
                ];
                do {
                    this.lex.next();
                    expressions.push(this.parseLogicalAnd());
                }while (this.lex.token() === 20 /* BarBar */ );
                return new CallExpr7("any", expressions);
            }
        }
    ]);
    return ExprParser;
}();
// src/datasource-protocol/InterpolatedPropertyDefs.ts
function isInterpolatedPropertyDefinition(p) {
    if (p && p.interpolationMode === void 0 && Array.isArray(p.values) && p.values.length > 0 && p.values[0] !== void 0 && Array.isArray(p.zoomLevels) && p.zoomLevels.length > 0 && p.zoomLevels[0] !== void 0 && p.values.length === p.zoomLevels.length) {
        return true;
    }
    return false;
}
function interpolatedPropertyDefinitionToJsonExpr(property) {
    if (property.interpolation === void 0 || property.interpolation === "Discrete") {
        var step = [
            "step",
            [
                "zoom"
            ],
            property.values[0]
        ];
        for(var i = 1; i < property.zoomLevels.length; ++i){
            step.push(property.zoomLevels[i], property.values[i]);
        }
        return step;
    }
    var interpolation = [
        "interpolate"
    ];
    switch(property.interpolation){
        case "Linear":
            interpolation.push([
                "linear"
            ]);
            break;
        case "Cubic":
            interpolation.push([
                "cubic"
            ]);
            break;
        case "Exponential":
            interpolation.push([
                "exponential",
                property.exponent !== void 0 ? property.exponent : 2
            ]);
            break;
        default:
            throw new Error("interpolation mode '".concat(property.interpolation, "' is not supported"));
    }
    interpolation.push([
        "zoom"
    ]);
    for(var i1 = 0; i1 < property.zoomLevels.length; ++i1){
        interpolation.push(property.zoomLevels[i1], property.values[i1]);
    }
    return interpolation;
}
// src/datasource-protocol/Theme.ts
function isVerboseDefinition(definition) {
    return (definition === null || definition === void 0 ? void 0 : definition.value) !== void 0;
}
function getDefinitionValue(definition) {
    return isVerboseDefinition(definition) ? definition.value : definition;
}
function isJsonExprReference(value2) {
    return Array.isArray(value2) && value2.length === 2 && value2[0] === "ref" && typeof value2[1] === "string";
}
function convertDictionaryToStyles(stylesDict) {
    var _loop = function(styleSetName) {
        stylesDict[styleSetName].forEach(function(style) {
            if (style.styleSet === void 0) {
                style.styleSet = styleSetName;
            }
            styles.push(style);
        });
    };
    var styles = [];
    for(var styleSetName in stylesDict)_loop(styleSetName);
    return styles;
}
function isStylesDictionary(styles) {
    return styles !== void 0 && !Array.isArray(styles);
}
function getStyles(styles) {
    if (styles === void 0) {
        return [];
    } else if (isStylesDictionary(styles)) {
        return convertDictionaryToStyles(styles);
    } else {
        return styles;
    }
}
// src/datasource-protocol/Expr.ts
var exprEvaluator = new ExprEvaluator();
var exprInstantiator = new ExprInstantiator();
var ExprDependencies = function ExprDependencies() {
    _classCallCheck(this, ExprDependencies);
    __publicField(this, "properties", /* @__PURE__ */ new Set());
    __publicField(this, "featureState");
    __publicField(this, "volatile");
};
var _ComputeExprDependencies = /*#__PURE__*/ function() {
    function _ComputeExprDependencies() {
        _classCallCheck(this, _ComputeExprDependencies);
    }
    _createClass(_ComputeExprDependencies, [
        {
            key: "visitNullLiteralExpr",
            value: function visitNullLiteralExpr(expr, context) {}
        },
        {
            key: "visitBooleanLiteralExpr",
            value: function visitBooleanLiteralExpr(expr, context) {}
        },
        {
            key: "visitNumberLiteralExpr",
            value: function visitNumberLiteralExpr(expr, context) {}
        },
        {
            key: "visitStringLiteralExpr",
            value: function visitStringLiteralExpr(expr, context) {}
        },
        {
            key: "visitObjectLiteralExpr",
            value: function visitObjectLiteralExpr(expr, context) {}
        },
        {
            key: "visitVarExpr",
            value: function visitVarExpr(expr, context) {
                context.properties.add(expr.name);
            }
        },
        {
            key: "visitHasAttributeExpr",
            value: function visitHasAttributeExpr(expr, context) {
                context.properties.add(expr.name);
            }
        },
        {
            key: "visitCallExpr",
            value: function visitCallExpr(expr, context) {
                var _this = this;
                expr.args.forEach(function(childExpr) {
                    return childExpr.accept(_this, context);
                });
                switch(expr.op){
                    case "dynamic-properties":
                        context.volatile = true;
                        break;
                    case "feature-state":
                        context.featureState = true;
                        context.properties.add("$state");
                        context.properties.add("$id");
                        break;
                    case "id":
                        context.properties.add("$id");
                        break;
                    case "zoom":
                    case "world-ppi-scale":
                    case "world-discrete-ppi-scale":
                        context.properties.add("$zoom");
                        break;
                    case "geometry-type":
                        context.properties.add("$geometryType");
                        break;
                    default:
                        break;
                }
            }
        },
        {
            key: "visitLookupExpr",
            value: function visitLookupExpr(expr, context) {
                return this.visitCallExpr(expr, context);
            }
        },
        {
            key: "visitMatchExpr",
            value: function visitMatchExpr(expr, context) {
                var _this = this;
                expr.value.accept(this, context);
                expr.branches.forEach(function(param) {
                    var _param = _slicedToArray(param, 2), _ = _param[0], branch = _param[1];
                    return branch.accept(_this, context);
                });
                expr.fallback.accept(this, context);
            }
        },
        {
            key: "visitCaseExpr",
            value: function visitCaseExpr(expr, context) {
                var _this = this;
                expr.branches.forEach(function(param) {
                    var _param = _slicedToArray(param, 2), condition = _param[0], branch = _param[1];
                    condition.accept(_this, context);
                    branch.accept(_this, context);
                });
                expr.fallback.accept(this, context);
            }
        },
        {
            key: "visitStepExpr",
            value: function visitStepExpr(expr, context) {
                var _this = this;
                expr.input.accept(this, context);
                expr.defaultValue.accept(this, context);
                expr.stops.forEach(function(param) {
                    var _param = _slicedToArray(param, 2), _ = _param[0], value2 = _param[1];
                    return value2.accept(_this, context);
                });
            }
        },
        {
            key: "visitInterpolateExpr",
            value: function visitInterpolateExpr(expr, context) {
                var _this = this;
                expr.input.accept(this, context);
                expr.stops.forEach(function(param) {
                    var _param = _slicedToArray(param, 2), _ = _param[0], value2 = _param[1];
                    return value2.accept(_this, context);
                });
            }
        }
    ], [
        {
            key: "of",
            value: function of(expr) {
                var dependencies = new ExprDependencies();
                expr.accept(this.instance, dependencies);
                return dependencies;
            }
        }
    ]);
    return _ComputeExprDependencies;
}();
var ComputeExprDependencies = _ComputeExprDependencies;
__publicField(ComputeExprDependencies, "instance", new _ComputeExprDependencies());
function isJsonExpr(v) {
    return Array.isArray(v) && v.length > 0 && typeof v[0] === "string";
}
var Expr3 = /*#__PURE__*/ function() {
    function Expr3() {
        _classCallCheck(this, Expr3);
        __publicField(this, "m_dependencies");
        __publicField(this, "m_isDynamic");
    }
    _createClass(Expr3, [
        {
            key: "evaluate",
            value: function evaluate(env) {
                var scope = arguments.length > 1 && arguments[1] !== void 0 /* Value */  ? arguments[1] : 0, cache6 = arguments.length > 2 ? arguments[2] : void 0;
                return this.accept(exprEvaluator, new ExprEvaluatorContext(exprEvaluator, env, scope, cache6));
            }
        },
        {
            key: "instantiate",
            value: function instantiate(context) {
                return this.accept(exprInstantiator, context);
            }
        },
        {
            key: "dependencies",
            value: function dependencies() {
                if (!this.m_dependencies) {
                    this.m_dependencies = ComputeExprDependencies.of(this);
                }
                return this.m_dependencies;
            }
        },
        {
            key: "intern",
            value: function intern(pool) {
                return pool.add(this);
            }
        },
        {
            key: "toJSON",
            value: function toJSON() {
                return new ExprSerializer().serialize(this);
            }
        },
        {
            key: "isDynamic",
            value: function isDynamic() {
                if (this.m_isDynamic === void 0) {
                    this.m_isDynamic = this.exprIsDynamic();
                }
                return this.m_isDynamic;
            }
        }
    ], [
        {
            key: "isExpr",
            value: function isExpr(value2) {
                return _instanceof(value2, Expr3);
            }
        },
        {
            key: "parse",
            value: function parse(code) {
                var parser = new ExprParser(code);
                var expr = parser.parse();
                return expr;
            }
        },
        {
            key: "fromJSON",
            value: function fromJSON(json, definitions, definitionExprCache) {
                var referenceResolverState = definitions !== void 0 ? {
                    definitions: definitions,
                    lockedNames: /* @__PURE__ */ new Set(),
                    cache: definitionExprCache !== null && definitionExprCache !== void 0 ? definitionExprCache : /* @__PURE__ */ new Map()
                } : void 0;
                return parseNode(json, referenceResolverState);
            }
        }
    ]);
    return Expr3;
}();
var VarExpr3 = /*#__PURE__*/ function(Expr3) {
    _inherits(VarExpr3, Expr3);
    var _super = _createSuper(VarExpr3);
    function VarExpr3(name2) {
        _classCallCheck(this, VarExpr3);
        var _this;
        _this = _super.call(this);
        _this.name = name2;
        return _this;
    }
    _createClass(VarExpr3, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitVarExpr(this, context);
            }
        },
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                return false;
            }
        }
    ]);
    return VarExpr3;
}(Expr3);
var LiteralExpr = /*#__PURE__*/ function(Expr3) {
    _inherits(LiteralExpr, Expr3);
    var _super = _createSuper(LiteralExpr);
    function LiteralExpr() {
        _classCallCheck(this, LiteralExpr);
        return _super.apply(this, arguments);
    }
    _createClass(LiteralExpr, [
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                return false;
            }
        }
    ], [
        {
            key: "fromValue",
            value: function fromValue(value2) {
                switch(typeof value2 === "undefined" ? "undefined" : _typeof(value2)){
                    case "boolean":
                        return new BooleanLiteralExpr3(value2);
                    case "number":
                        return new NumberLiteralExpr(value2);
                    case "string":
                        return new StringLiteralExpr(value2);
                    case "object":
                        return value2 === null ? NullLiteralExpr3.instance : new ObjectLiteralExpr(value2);
                    default:
                        throw new Error("failed to create a literal from '".concat(value2, "'"));
                }
            }
        }
    ]);
    return LiteralExpr;
}(Expr3);
var _NullLiteralExpr = /*#__PURE__*/ function(LiteralExpr) {
    _inherits(_NullLiteralExpr, LiteralExpr);
    var _super = _createSuper(_NullLiteralExpr);
    function _NullLiteralExpr() {
        _classCallCheck(this, _NullLiteralExpr);
        var _this;
        _this = _super.call(this);
        __publicField(_assertThisInitialized(_this), "value", null);
        return _this;
    }
    _createClass(_NullLiteralExpr, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitNullLiteralExpr(this, context);
            }
        },
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                return false;
            }
        }
    ]);
    return _NullLiteralExpr;
}(LiteralExpr);
var NullLiteralExpr3 = _NullLiteralExpr;
__publicField(NullLiteralExpr3, "instance", new _NullLiteralExpr());
var BooleanLiteralExpr3 = /*#__PURE__*/ function(LiteralExpr) {
    _inherits(BooleanLiteralExpr3, LiteralExpr);
    var _super = _createSuper(BooleanLiteralExpr3);
    function BooleanLiteralExpr3(value2) {
        _classCallCheck(this, BooleanLiteralExpr3);
        var _this;
        _this = _super.call(this);
        _this.value = value2;
        return _this;
    }
    _createClass(BooleanLiteralExpr3, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitBooleanLiteralExpr(this, context);
            }
        }
    ]);
    return BooleanLiteralExpr3;
}(LiteralExpr);
var NumberLiteralExpr = /*#__PURE__*/ function(LiteralExpr) {
    _inherits(NumberLiteralExpr, LiteralExpr);
    var _super = _createSuper(NumberLiteralExpr);
    function NumberLiteralExpr(value2) {
        _classCallCheck(this, NumberLiteralExpr);
        var _this;
        _this = _super.call(this);
        _this.value = value2;
        return _this;
    }
    _createClass(NumberLiteralExpr, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitNumberLiteralExpr(this, context);
            }
        }
    ]);
    return NumberLiteralExpr;
}(LiteralExpr);
var StringLiteralExpr = /*#__PURE__*/ function(LiteralExpr) {
    _inherits(StringLiteralExpr, LiteralExpr);
    var _super = _createSuper(StringLiteralExpr);
    function StringLiteralExpr(value2) {
        _classCallCheck(this, StringLiteralExpr);
        var _this;
        _this = _super.call(this);
        _this.value = value2;
        __publicField(_assertThisInitialized(_this), "m_promotedValue");
        return _this;
    }
    _createClass(StringLiteralExpr, [
        {
            key: "promotedValue",
            get: function get() {
                if (this.m_promotedValue === void 0) {
                    var ref, ref1;
                    this.m_promotedValue = (ref1 = (ref = RGBA.parse(this.value)) !== null && ref !== void 0 ? ref : Pixels.parse(this.value)) !== null && ref1 !== void 0 ? ref1 : null;
                }
                var _m_promotedValue;
                return (_m_promotedValue = this.m_promotedValue) !== null && _m_promotedValue !== void 0 ? _m_promotedValue : void 0;
            }
        },
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitStringLiteralExpr(this, context);
            }
        }
    ]);
    return StringLiteralExpr;
}(LiteralExpr);
var ObjectLiteralExpr = /*#__PURE__*/ function(LiteralExpr) {
    _inherits(ObjectLiteralExpr, LiteralExpr);
    var _super = _createSuper(ObjectLiteralExpr);
    function ObjectLiteralExpr(value2) {
        _classCallCheck(this, ObjectLiteralExpr);
        var _this;
        _this = _super.call(this);
        _this.value = value2;
        return _this;
    }
    _createClass(ObjectLiteralExpr, [
        {
            key: "isArrayLiteral",
            get: function get() {
                return Array.isArray(this.value);
            }
        },
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitObjectLiteralExpr(this, context);
            }
        }
    ]);
    return ObjectLiteralExpr;
}(LiteralExpr);
var HasAttributeExpr3 = /*#__PURE__*/ function(Expr3) {
    _inherits(HasAttributeExpr3, Expr3);
    var _super = _createSuper(HasAttributeExpr3);
    function HasAttributeExpr3(name2) {
        _classCallCheck(this, HasAttributeExpr3);
        var _this;
        _this = _super.call(this);
        _this.name = name2;
        return _this;
    }
    _createClass(HasAttributeExpr3, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitHasAttributeExpr(this, context);
            }
        },
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                return false;
            }
        }
    ]);
    return HasAttributeExpr3;
}(Expr3);
var CallExpr7 = /*#__PURE__*/ function(Expr3) {
    _inherits(CallExpr7, Expr3);
    var _super = _createSuper(CallExpr7);
    function CallExpr7(op, args) {
        _classCallCheck(this, CallExpr7);
        var _this;
        _this = _super.call(this);
        _this.op = op;
        _this.args = args;
        __publicField(_assertThisInitialized(_this), "descriptor");
        return _this;
    }
    _createClass(CallExpr7, [
        {
            key: "children",
            get: function get() {
                return this.args;
            }
        },
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitCallExpr(this, context);
            }
        },
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                var _descriptor;
                var descriptor = (_descriptor = this.descriptor) !== null && _descriptor !== void 0 ? _descriptor : ExprEvaluator.getOperator(this.op);
                if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {
                    return true;
                }
                return this.args.some(function(e) {
                    return e.isDynamic();
                });
            }
        }
    ]);
    return CallExpr7;
}(Expr3);
var LookupExpr3 = /*#__PURE__*/ function(CallExpr7) {
    _inherits(LookupExpr3, CallExpr7);
    var _super = _createSuper(LookupExpr3);
    function LookupExpr3(args) {
        _classCallCheck(this, LookupExpr3);
        var _this;
        _this = _super.call(this, "lookup", args);
        _this.args = args;
        return _this;
    }
    _createClass(LookupExpr3, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitLookupExpr(this, context);
            }
        }
    ], [
        {
            key: "parseArray",
            value: function parseArray(node, referenceResolverState) {
                var lookupTableNode = node[1];
                if (lookupTableNode === void 0) {
                    throw new Error("missing lookup table in 'lookup' expression");
                }
                var lookupTableExpr = parseNode(lookupTableNode, referenceResolverState);
                if (!Array.isArray(lookupTableNode) || !_instanceof(lookupTableExpr, ObjectLiteralExpr)) {
                    throw new Error("Invalid lookup table expression for operator 'lookup'. It must be a literal or a ref to one.");
                }
                var lookupTable = lookupTableExpr.value;
                if (!Array.isArray(lookupTable)) {
                    throw new Error("Invalid lookup table type (".concat(typeof lookupTable === "undefined" ? "undefined" : _typeof(lookupTable), ") for operator 'lookup'"));
                }
                var args = node.slice(2).map(function(childExpr) {
                    return parseNode(childExpr, referenceResolverState);
                });
                args.unshift(lookupTableExpr);
                return new LookupExpr3(args);
            }
        }
    ]);
    return LookupExpr3;
}(CallExpr7);
var MatchExpr2 = /*#__PURE__*/ function(Expr3) {
    _inherits(MatchExpr2, Expr3);
    var _super = _createSuper(MatchExpr2);
    function MatchExpr2(value2, branches, fallback) {
        _classCallCheck(this, MatchExpr2);
        var _this;
        _this = _super.call(this);
        _this.value = value2;
        _this.branches = branches;
        _this.fallback = fallback;
        return _this;
    }
    _createClass(MatchExpr2, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitMatchExpr(this, context);
            }
        },
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                return this.value.isDynamic() || this.branches.some(function(param) {
                    var _param = _slicedToArray(param, 2), _ = _param[0], branch = _param[1];
                    return branch.isDynamic();
                }) || this.fallback.isDynamic();
            }
        }
    ], [
        {
            key: "isValidMatchLabel",
            value: function isValidMatchLabel(node) {
                switch(typeof node === "undefined" ? "undefined" : _typeof(node)){
                    case "number":
                    case "string":
                        return true;
                    case "object":
                        if (!Array.isArray(node) || node.length === 0) {
                            return false;
                        }
                        var elementTy = _typeof(node[0]);
                        if (elementTy === "number" || elementTy === "string") {
                            return node.every(function(t) {
                                return (typeof t === "undefined" ? "undefined" : _typeof(t)) === elementTy;
                            });
                        }
                        return false;
                    default:
                        return false;
                }
            }
        }
    ]);
    return MatchExpr2;
}(Expr3);
var CaseExpr = /*#__PURE__*/ function(Expr3) {
    _inherits(CaseExpr, Expr3);
    var _super = _createSuper(CaseExpr);
    function CaseExpr(branches, fallback) {
        _classCallCheck(this, CaseExpr);
        var _this;
        _this = _super.call(this);
        _this.branches = branches;
        _this.fallback = fallback;
        return _this;
    }
    _createClass(CaseExpr, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitCaseExpr(this, context);
            }
        },
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                return this.branches.some(function(param) {
                    var _param = _slicedToArray(param, 2), cond = _param[0], branch = _param[1];
                    return cond.isDynamic() || branch.isDynamic();
                }) || this.fallback.isDynamic();
            }
        }
    ]);
    return CaseExpr;
}(Expr3);
var StepExpr = /*#__PURE__*/ function(Expr3) {
    _inherits(StepExpr, Expr3);
    var _super = _createSuper(StepExpr);
    function StepExpr(input, defaultValue, stops) {
        _classCallCheck(this, StepExpr);
        var _this;
        _this = _super.call(this);
        _this.input = input;
        _this.defaultValue = defaultValue;
        _this.stops = stops;
        return _this;
    }
    _createClass(StepExpr, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitStepExpr(this, context);
            }
        },
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                return this.input.isDynamic() || this.defaultValue.isDynamic() || this.stops.some(function(param) {
                    var _param = _slicedToArray(param, 2), _ = _param[0], value2 = _param[1];
                    return value2.isDynamic();
                });
            }
        }
    ]);
    return StepExpr;
}(Expr3);
var InterpolateExpr = /*#__PURE__*/ function(Expr3) {
    _inherits(InterpolateExpr, Expr3);
    var _super = _createSuper(InterpolateExpr);
    function InterpolateExpr(mode, input, stops) {
        _classCallCheck(this, InterpolateExpr);
        var _this;
        _this = _super.call(this);
        _this.mode = mode;
        _this.input = input;
        _this.stops = stops;
        return _this;
    }
    _createClass(InterpolateExpr, [
        {
            key: "accept",
            value: function accept(visitor, context) {
                return visitor.visitInterpolateExpr(this, context);
            }
        },
        {
            key: "exprIsDynamic",
            value: function exprIsDynamic() {
                return this.input.isDynamic() || this.stops.some(function(param) {
                    var _param = _slicedToArray(param, 2), _ = _param[0], value2 = _param[1];
                    return value2.isDynamic();
                });
            }
        }
    ]);
    return InterpolateExpr;
}(Expr3);
var ExprSerializer = /*#__PURE__*/ function() {
    function ExprSerializer() {
        _classCallCheck(this, ExprSerializer);
    }
    _createClass(ExprSerializer, [
        {
            key: "serialize",
            value: function serialize(expr) {
                return expr.accept(this, void 0);
            }
        },
        {
            key: "visitNullLiteralExpr",
            value: function visitNullLiteralExpr(expr, context) {
                return null;
            }
        },
        {
            key: "visitBooleanLiteralExpr",
            value: function visitBooleanLiteralExpr(expr, context) {
                return expr.value;
            }
        },
        {
            key: "visitNumberLiteralExpr",
            value: function visitNumberLiteralExpr(expr, context) {
                return expr.value;
            }
        },
        {
            key: "visitStringLiteralExpr",
            value: function visitStringLiteralExpr(expr, context) {
                return expr.value;
            }
        },
        {
            key: "visitObjectLiteralExpr",
            value: function visitObjectLiteralExpr(expr, context) {
                if (_instanceof(expr.value, THREE14.Vector2)) {
                    return [
                        "make-vector",
                        expr.value.x,
                        expr.value.y
                    ];
                } else if (_instanceof(expr.value, THREE14.Vector3)) {
                    return [
                        "make-vector",
                        expr.value.x,
                        expr.value.y,
                        expr.value.z
                    ];
                } else if (_instanceof(expr.value, THREE14.Vector4)) {
                    return [
                        "make-vector",
                        expr.value.x,
                        expr.value.y,
                        expr.value.z,
                        expr.value.w
                    ];
                }
                return [
                    "literal",
                    expr.value
                ];
            }
        },
        {
            key: "visitVarExpr",
            value: function visitVarExpr(expr, context) {
                return [
                    "get",
                    expr.name
                ];
            }
        },
        {
            key: "visitHasAttributeExpr",
            value: function visitHasAttributeExpr(expr, context) {
                return [
                    "has",
                    expr.name
                ];
            }
        },
        {
            key: "visitCallExpr",
            value: function visitCallExpr(expr, context) {
                var _this = this;
                return [
                    expr.op
                ].concat(_toConsumableArray(expr.args.map(function(childExpr) {
                    return _this.serialize(childExpr);
                })));
            }
        },
        {
            key: "visitLookupExpr",
            value: function visitLookupExpr(expr, context) {
                return this.visitCallExpr(expr, context);
            }
        },
        {
            key: "visitMatchExpr",
            value: function visitMatchExpr(expr, context) {
                var branches = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = expr.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), label = _value[0], body = _value[1];
                        branches.push(label, this.serialize(body));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return [
                    "match",
                    this.serialize(expr.value)
                ].concat(_toConsumableArray(branches), [
                    this.serialize(expr.fallback)
                ]);
            }
        },
        {
            key: "visitCaseExpr",
            value: function visitCaseExpr(expr, context) {
                var branches = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = expr.branches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), condition = _value[0], body = _value[1];
                        branches.push(this.serialize(condition), this.serialize(body));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return [
                    "case"
                ].concat(_toConsumableArray(branches), [
                    this.serialize(expr.fallback)
                ]);
            }
        },
        {
            key: "visitStepExpr",
            value: function visitStepExpr(expr, context) {
                var _this = this;
                var result = [
                    "step"
                ];
                result.push(this.serialize(expr.input));
                result.push(this.serialize(expr.defaultValue));
                expr.stops.forEach(function(param) {
                    var _param = _slicedToArray(param, 2), key = _param[0], value2 = _param[1];
                    result.push(key);
                    result.push(_this.serialize(value2));
                });
                return result;
            }
        },
        {
            key: "visitInterpolateExpr",
            value: function visitInterpolateExpr(expr, context) {
                var _this = this;
                var result = [
                    "interpolate",
                    expr.mode
                ];
                result.push(this.serialize(expr.input));
                expr.stops.forEach(function(param) {
                    var _param = _slicedToArray(param, 2), key = _param[0], value2 = _param[1];
                    result.push(key);
                    result.push(_this.serialize(value2));
                });
                return result;
            }
        }
    ]);
    return ExprSerializer;
}();
function parseNode(node, referenceResolverState) {
    if (Array.isArray(node)) {
        return parseCall(node, referenceResolverState);
    } else if (node === null) {
        return NullLiteralExpr3.instance;
    } else if (typeof node === "boolean") {
        return new BooleanLiteralExpr3(node);
    } else if (typeof node === "number") {
        return new NumberLiteralExpr(node);
    } else if (typeof node === "string") {
        return new StringLiteralExpr(node);
    }
    throw new Error("failed to create expression from: ".concat(JSON.stringify(node)));
}
function parseCall(node, referenceResolverState) {
    var op = node[0];
    if (typeof op !== "string") {
        throw new Error("expected a builtin function name");
    }
    switch(op){
        case "!has":
        case "!in":
            return new CallExpr7("!", [
                parseCall([
                    op.slice(1)
                ].concat(_toConsumableArray(node.slice(1))))
            ]);
        case "ref":
            return resolveReference(node, referenceResolverState);
        case "get":
            return parseGetExpr(node, referenceResolverState);
        case "has":
            return parseHasExpr(node, referenceResolverState);
        case "literal":
            return parseLiteralExpr(node);
        case "match":
            return parseMatchExpr(node, referenceResolverState);
        case "case":
            return parseCaseExpr(node, referenceResolverState);
        case "interpolate":
            return parseInterpolateExpr(node, referenceResolverState);
        case "step":
            return parseStepExpr(node, referenceResolverState);
        case "lookup":
            return LookupExpr3.parseArray(node, referenceResolverState);
        default:
            return makeCallExpr(op, node, referenceResolverState);
    }
}
function parseGetExpr(node, referenceResolverState) {
    if (node[2] !== void 0) {
        return makeCallExpr("get", node, referenceResolverState);
    }
    var name2 = node[1];
    if (typeof name2 !== "string") {
        throw new Error("expected the name of an attribute");
    }
    return new VarExpr3(name2);
}
function parseHasExpr(node, referenceResolverState) {
    if (node[2] !== void 0) {
        return makeCallExpr("has", node, referenceResolverState);
    }
    var name2 = node[1];
    if (typeof name2 !== "string") {
        throw new Error("expected the name of an attribute");
    }
    return new HasAttributeExpr3(name2);
}
function parseLiteralExpr(node) {
    var obj = node[1];
    if (obj === null || typeof obj !== "object") {
        throw new Error("expected an object or array literal");
    }
    return new ObjectLiteralExpr(obj);
}
function parseMatchExpr(node, referenceResolverState) {
    if (node.length < 4) {
        throw new Error("not enough arguments");
    }
    if (!(node.length % 2)) {
        throw new Error("fallback is missing in 'match' expression");
    }
    var value2 = parseNode(node[1], referenceResolverState);
    var conditions = [];
    for(var i = 2; i < node.length - 1; i += 2){
        var label = node[i];
        if (!MatchExpr2.isValidMatchLabel(label)) {
            throw new Error("'".concat(JSON.stringify(label), "' is not a valid label for 'match'"));
        }
        var expr = parseNode(node[i + 1], referenceResolverState);
        conditions.push([
            label,
            expr
        ]);
    }
    var fallback = parseNode(node[node.length - 1], referenceResolverState);
    return new MatchExpr2(value2, conditions, fallback);
}
function parseCaseExpr(node, referenceResolverState) {
    if (node.length < 3) {
        throw new Error("not enough arguments");
    }
    if (node.length % 2) {
        throw new Error("fallback is missing in 'case' expression");
    }
    var branches = [];
    for(var i = 1; i < node.length - 1; i += 2){
        var condition = parseNode(node[i], referenceResolverState);
        var expr = parseNode(node[i + 1], referenceResolverState);
        branches.push([
            condition,
            expr
        ]);
    }
    var caseFallback = parseNode(node[node.length - 1], referenceResolverState);
    return new CaseExpr(branches, caseFallback);
}
function isInterpolationMode(object) {
    if (!Array.isArray(object)) {
        return false;
    }
    switch(object[0]){
        case "discrete":
        case "linear":
        case "cubic":
        case "exponential":
            return true;
        default:
            return false;
    }
}
function parseInterpolateExpr(node, referenceResolverState) {
    var mode = node[1];
    if (!isInterpolationMode(mode)) {
        throw new Error("expected an interpolation type");
    }
    if (mode[0] === "exponential" && typeof mode[1] !== "number") {
        throw new Error("expected the base of the exponential interpolation");
    }
    var input = node[2] !== void 0 ? parseNode(node[2], referenceResolverState) : void 0;
    if (!Expr3.isExpr(input)) {
        throw new Error("expected the input of the interpolation");
    }
    if (node.length === 3 || !(node.length % 2)) {
        throw new Error("invalid number of samples");
    }
    var stops = [];
    for(var i = 3; i < node.length - 1; i += 2){
        var key = node[i];
        var value2 = parseNode(node[i + 1], referenceResolverState);
        stops.push([
            key,
            value2
        ]);
    }
    return new InterpolateExpr(mode, input, stops);
}
function parseStepExpr(node, referenceResolverState) {
    if (node.length < 2) {
        throw new Error("expected the input of the 'step' operator");
    }
    if (node.length < 3 || !(node.length % 2)) {
        throw new Error("not enough arguments");
    }
    var input = parseNode(node[1], referenceResolverState);
    var defaultValue = parseNode(node[2], referenceResolverState);
    var stops = [];
    for(var i = 3; i < node.length; i += 2){
        var key = node[i];
        var value2 = parseNode(node[i + 1], referenceResolverState);
        stops.push([
            key,
            value2
        ]);
    }
    return new StepExpr(input, defaultValue, stops);
}
function makeCallExpr(op, node, referenceResolverState) {
    return new CallExpr7(op, node.slice(1).map(function(childExpr) {
        return parseNode(childExpr, referenceResolverState);
    }));
}
function resolveReference(node, referenceResolverState) {
    if (typeof node[1] !== "string") {
        throw new Error("expected the name of an attribute");
    }
    if (referenceResolverState === void 0) {
        throw new Error("ref used with no definitions");
    }
    var name2 = node[1];
    if (referenceResolverState.lockedNames.has(name2)) {
        throw new Error("circular referene to '".concat(name2, "'"));
    }
    if (!(name2 in referenceResolverState.definitions)) {
        throw new Error("definition '".concat(name2, "' not found"));
    }
    var cachedEntry = referenceResolverState.cache.get(name2);
    if (cachedEntry !== void 0) {
        return cachedEntry;
    }
    var definitionEntry = referenceResolverState.definitions[name2];
    var result;
    var definitionValue = getDefinitionValue(definitionEntry);
    if (isInterpolatedPropertyDefinition(definitionValue)) {
        return Expr3.fromJSON(interpolatedPropertyDefinitionToJsonExpr(definitionEntry));
    } else if (isJsonExpr(definitionValue)) {
        definitionEntry = definitionValue;
    } else {
        return Expr3.fromJSON(definitionValue);
    }
    if (isJsonExpr(definitionEntry)) {
        referenceResolverState.lockedNames.add(name2);
        try {
            result = parseNode(definitionEntry, referenceResolverState);
        } finally{
            referenceResolverState.lockedNames.delete(name2);
        }
    } else {
        throw new Error("unsupported definition ".concat(name2));
    }
    referenceResolverState.cache.set(name2, result);
    return result;
}
// src/datasource-protocol/PropertyValue.ts
var logger = LoggerManager.instance.create("PropertyValue");
function getPropertyValue(property, env, cache6) {
    if (Expr3.isExpr(property)) {
        try {
            var r = property.evaluate(env, 2 /* Dynamic */ , cache6);
            if (typeof r === "string") {
                var ref, ref1;
                r = (ref1 = (ref = RGBA.parse(r)) !== null && ref !== void 0 ? ref : Pixels.parse(r)) !== null && ref1 !== void 0 ? ref1 : r;
            }
            if (_instanceof(r, RGBA)) {
                return r.getHex();
            } else if (_instanceof(r, Pixels)) {
                var ref2;
                return r.value * ((ref2 = Number(env.lookup("$pixelToMeters"))) !== null && ref2 !== void 0 ? ref2 : 1);
            }
            return r;
        } catch (error) {
            logger.error("failed to evaluate expression", JSON.stringify(property), "error", String(error));
            return null;
        }
    }
    if (property === null || typeof property === "undefined") {
        return null;
    } else if (typeof property !== "string") {
        return property;
    } else {
        var pixelToMeters = env.lookup("$pixelToMeters") || 1;
        var value2 = parseStringEncodedNumeral(property, pixelToMeters);
        return value2 !== void 0 ? value2 : property;
    }
}
// src/datasource-protocol/TechniqueParams.ts
var StandardGeometryKind = /* @__PURE__ */ function(StandardGeometryKind2) {
    StandardGeometryKind2["All"] = "_all_";
    StandardGeometryKind2["Background"] = "background";
    StandardGeometryKind2["Terrain"] = "terrain";
    StandardGeometryKind2["Area"] = "area";
    StandardGeometryKind2["Line"] = "line";
    StandardGeometryKind2["Water"] = "water";
    StandardGeometryKind2["Border"] = "border";
    StandardGeometryKind2["Road"] = "road";
    StandardGeometryKind2["Building"] = "building";
    StandardGeometryKind2["Label"] = "label";
    StandardGeometryKind2["Detail"] = "detail";
    return StandardGeometryKind2;
}(StandardGeometryKind || {});
var GeometryKind = StandardGeometryKind;
var GeometryKindSet = /*#__PURE__*/ function(Set1) {
    _inherits(GeometryKindSet, Set1);
    var _super = _createSuper(GeometryKindSet);
    function GeometryKindSet() {
        _classCallCheck(this, GeometryKindSet);
        return _super.apply(this, arguments);
    }
    _createClass(GeometryKindSet, [
        {
            key: "isSuperset",
            value: function isSuperset(subset) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = subset[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var elem = _step.value;
                        if (!this.has(elem)) {
                            return false;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return true;
            }
        },
        {
            key: "hasIntersection",
            value: function hasIntersection(set) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var elem = _step.value;
                        if (this.has(elem)) {
                            return true;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return false;
            }
        },
        {
            key: "hasOrIntersects",
            value: function hasOrIntersects(set) {
                if (_instanceof(set, Set)) {
                    return this.hasIntersection(set);
                }
                return this.has(set);
            }
        },
        {
            key: "hasOrIntersectsArray",
            value: function hasOrIntersectsArray(subset) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = subset[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var elem = _step.value;
                        if (this.has(elem)) {
                            return true;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return false;
            }
        }
    ]);
    return GeometryKindSet;
}(_wrapNativeSuper(Set));
function transientToPickability(transient) {
    var pickability = "only-visible" /* onlyVisible */ ;
    if (transient !== void 0 && transient !== null) {
        pickability = typeof transient === "string" ? transient : transient === true ? "transient" /* transient */  : "only-visible" /* onlyVisible */ ;
    }
    return pickability;
}
function isTextureBuffer(object) {
    return object && object.buffer && typeof object.type === "string";
}
// src/datasource-protocol/Techniques.ts
var TEXTURE_PROPERTY_KEYS = [
    "map",
    "normalMap",
    "displacementMap",
    "roughnessMap",
    "emissiveMap",
    "alphaMap",
    "metalnessMap",
    "bumpMap"
];
var TRANSPARENCY_PROPERTY_KEYS = [
    "opacity",
    "transparent"
];
function isCirclesTechnique(technique) {
    return technique.name === "circles";
}
function isSquaresTechnique(technique) {
    return technique.name === "squares";
}
function isPoiTechnique(technique) {
    return technique.name === "labeled-icon";
}
function isLineMarkerTechnique(technique) {
    return technique.name === "line-marker";
}
function isLineTechnique(technique) {
    return technique.name === "line";
}
function isSolidLineTechnique(technique) {
    return technique.name === "solid-line" || technique.name === "dashed-line";
}
function isSegmentsTechnique(technique) {
    return technique.name === "segments";
}
function isExtrudedLineTechnique(technique) {
    return technique.name === "extruded-line";
}
function isStandardExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "standard";
}
function isFillTechnique(technique) {
    return technique.name === "fill";
}
function isExtrudedPolygonTechnique(technique) {
    return technique.name === "extruded-polygon";
}
function isStandardTechnique(technique) {
    return technique.name === "standard";
}
function isTerrainTechnique(technique) {
    return technique.name === "terrain";
}
function isTextTechnique(technique) {
    return technique.name === "text";
}
function isShaderTechnique(technique) {
    return technique.name === "shader";
}
function needsVertexNormals(technique) {
    return isExtrudedPolygonTechnique(technique) || isFillTechnique(technique) || isStandardTechnique(technique) || isTerrainTechnique(technique) || isStandardExtrudedLineTechnique(technique);
}
function supportsTextures(technique) {
    return isFillTechnique(technique) || isStandardTechnique(technique) || isExtrudedPolygonTechnique(technique) || isTerrainTechnique(technique);
}
function composeTechniqueTextureName(imageName, technique) {
    var textureName = imageName;
    if (typeof technique.imageTexturePrefix === "string") {
        textureName = technique.imageTexturePrefix + textureName;
    }
    if (typeof technique.imageTexturePostfix === "string") {
        textureName = textureName + technique.imageTexturePostfix;
    }
    return textureName;
}
function setTechniqueRenderOrderOrPriority(technique, priorities, labelPriorities) {
    if (isTextTechnique(technique) || isPoiTechnique(technique) || isLineMarkerTechnique(technique)) {
        if (labelPriorities && typeof technique._category === "string") {
            var priority = labelPriorities.indexOf(technique._category);
            if (priority !== -1) {
                technique.priority = labelPriorities.length - priority;
            }
        }
    } else if (priorities && technique._styleSet !== void 0) {
        var computeRenderOrder = function(category) {
            var priority = priorities === null || priorities === void 0 ? void 0 : priorities.findIndex(function(entry) {
                return entry.group === technique._styleSet && entry.category === category;
            });
            return priority !== void 0 && priority !== -1 ? (priority + 1) * 10 : void 0;
        };
        if (typeof technique._category === "string") {
            var renderOrder = computeRenderOrder(technique._category);
            if (renderOrder !== void 0) {
                technique.renderOrder = renderOrder;
            }
        }
        if (typeof technique._secondaryCategory === "string") {
            var secondaryRenderOrder = computeRenderOrder(technique._secondaryCategory);
            if (secondaryRenderOrder !== void 0) {
                ;
                technique.secondaryRenderOrder = secondaryRenderOrder;
            }
        }
    }
}
// src/datasource-protocol/DecodedTile.ts
function getArrayConstructor(attr) {
    switch(attr){
        case "float":
            return Float32Array;
        case "uint8":
            return Uint8Array;
        case "uint16":
            return Uint16Array;
        case "uint32":
            return Uint32Array;
        case "int8":
            return Int8Array;
        case "int16":
            return Int16Array;
        case "int32":
            return Int32Array;
    }
}
function getProjectionName(projection) {
    if (projection === mercatorProjection) {
        return "mercator";
    } else if (projection === webMercatorProjection) {
        return "webMercator";
    } else if (projection === sphereProjection) {
        return "sphere";
    } else if (projection === normalizedEquirectangularProjection) {
        return "normalizedEquirectangular";
    } else if (projection === equirectangularProjection) {
        return "equirectangular";
    }
    throw new Error("Unknown projection");
}
function getFeatureId(attributeMap) {
    if (attributeMap === void 0) {
        return 0;
    }
    if (typeof attributeMap === "string" || typeof attributeMap === "number") {
        return attributeMap;
    } else if (attributeMap.hasOwnProperty("$id")) {
        var id = attributeMap.$id;
        if (typeof id === "string" || typeof id === "number") {
            return id;
        }
    }
    return 0;
}
// src/datasource-protocol/ExprPool.ts
var ExprPool = /*#__PURE__*/ function() {
    function ExprPool() {
        _classCallCheck(this, ExprPool);
        __publicField(this, "m_booleanLiterals", /* @__PURE__ */ new Map());
        __publicField(this, "m_numberLiterals", /* @__PURE__ */ new Map());
        __publicField(this, "m_stringLiterals", /* @__PURE__ */ new Map());
        __publicField(this, "m_objectLiterals", /* @__PURE__ */ new Map());
        __publicField(this, "m_arrayLiterals", []);
        __publicField(this, "m_varExprs", /* @__PURE__ */ new Map());
        __publicField(this, "m_hasAttributeExprs", /* @__PURE__ */ new Map());
        __publicField(this, "m_matchExprs", []);
        __publicField(this, "m_caseExprs", []);
        __publicField(this, "m_interpolateExprs", []);
        __publicField(this, "m_stepExprs", []);
        __publicField(this, "m_callExprs", /* @__PURE__ */ new Map());
    }
    _createClass(ExprPool, [
        {
            key: "add",
            value: function add(expr) {
                return expr.accept(this, void 0);
            }
        },
        {
            key: "visitNullLiteralExpr",
            value: function visitNullLiteralExpr(expr, context) {
                return NullLiteralExpr3.instance;
            }
        },
        {
            key: "visitBooleanLiteralExpr",
            value: function visitBooleanLiteralExpr(expr, context) {
                var e = this.m_booleanLiterals.get(expr.value);
                if (e) {
                    return e;
                }
                this.m_booleanLiterals.set(expr.value, expr);
                return expr;
            }
        },
        {
            key: "visitNumberLiteralExpr",
            value: function visitNumberLiteralExpr(expr, context) {
                var e = this.m_numberLiterals.get(expr.value);
                if (e) {
                    return e;
                }
                this.m_numberLiterals.set(expr.value, expr);
                return expr;
            }
        },
        {
            key: "visitStringLiteralExpr",
            value: function visitStringLiteralExpr(expr, context) {
                var e = this.m_stringLiterals.get(expr.value);
                if (e) {
                    return e;
                }
                this.m_stringLiterals.set(expr.value, expr);
                return expr;
            }
        },
        {
            key: "visitObjectLiteralExpr",
            value: function visitObjectLiteralExpr(expr, context) {
                var e = this.m_objectLiterals.get(expr.value);
                if (e) {
                    return e;
                }
                if (Array.isArray(expr.value)) {
                    var array = expr.value;
                    var r = this.m_arrayLiterals.find(function(literal) {
                        var elements = literal.value;
                        if (elements.length !== array.length) {
                            return false;
                        }
                        return array.every(function(x, i) {
                            return x === elements[i];
                        });
                    });
                    if (r !== void 0) {
                        return r;
                    }
                    this.m_arrayLiterals.push(expr);
                }
                this.m_objectLiterals.set(expr.value, expr);
                return expr;
            }
        },
        {
            key: "visitVarExpr",
            value: function visitVarExpr(expr, context) {
                var e = this.m_varExprs.get(expr.name);
                if (e) {
                    return e;
                }
                this.m_varExprs.set(expr.name, expr);
                return expr;
            }
        },
        {
            key: "visitHasAttributeExpr",
            value: function visitHasAttributeExpr(expr, context) {
                var e = this.m_hasAttributeExprs.get(expr.name);
                if (e) {
                    return e;
                }
                this.m_hasAttributeExprs.set(expr.name, expr);
                return expr;
            }
        },
        {
            key: "visitMatchExpr",
            value: function visitMatchExpr(expr, context) {
                var _this = this;
                var value2 = expr.value.accept(this, context);
                var branches = expr.branches.map(function(param) {
                    var _param = _slicedToArray(param, 2), label = _param[0], body = _param[1];
                    return [
                        label,
                        body.accept(_this, context)
                    ];
                });
                var fallback = expr.fallback.accept(this, context);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_matchExprs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var candidate = _step.value;
                        if (candidate.value !== value2) {
                            continue;
                        }
                        if (candidate.fallback !== fallback) {
                            continue;
                        }
                        if (candidate.branches.length !== branches.length) {
                            continue;
                        }
                        var branchesMatching = true;
                        for(var i = 0; i < branches.length; i++){
                            if (branches[i][0] !== candidate.branches[i][0] || branches[i][1] !== candidate.branches[i][1]) {
                                branchesMatching = false;
                                break;
                            }
                        }
                        if (branchesMatching) {
                            return candidate;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var r = new MatchExpr2(value2, branches, fallback);
                this.m_matchExprs.push(r);
                return r;
            }
        },
        {
            key: "visitCaseExpr",
            value: function visitCaseExpr(expr, context) {
                var _this = this;
                var branches = expr.branches.map(function(param) {
                    var _param = _slicedToArray(param, 2), condition = _param[0], body = _param[1];
                    return [
                        condition.accept(_this, context),
                        body.accept(_this, context)
                    ];
                });
                var fallback = expr.fallback.accept(this, context);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_caseExprs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var candidate = _step.value;
                        if (candidate.fallback !== fallback) {
                            continue;
                        }
                        if (candidate.branches.length !== branches.length) {
                            continue;
                        }
                        var branchesMatching = true;
                        for(var i = 0; i < branches.length; i++){
                            if (branches[i][0] !== candidate.branches[i][0] || branches[i][1] !== candidate.branches[i][1]) {
                                branchesMatching = false;
                                break;
                            }
                        }
                        if (branchesMatching) {
                            return candidate;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var r = new CaseExpr(branches, fallback);
                this.m_caseExprs.push(r);
                return r;
            }
        },
        {
            key: "visitCallExprImpl",
            value: function visitCallExprImpl(expr, context, constructor) {
                var _this = this;
                var expressions = expr.args.map(function(childExpr) {
                    return childExpr.accept(_this, context);
                });
                if (!this.m_callExprs.has(expr.op)) {
                    this.m_callExprs.set(expr.op, []);
                }
                var calls = this.m_callExprs.get(expr.op);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = calls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var call = _step.value;
                        if (call.args.length !== expressions.length) {
                            continue;
                        }
                        var index = 0;
                        for(; index < call.args.length; ++index){
                            if (call.args[index] !== expressions[index]) {
                                break;
                            }
                        }
                        if (index === call.args.length) {
                            return call;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var e = constructor(expr.op, expressions);
                e.descriptor = expr.descriptor;
                calls.push(e);
                return e;
            }
        },
        {
            key: "visitCallExpr",
            value: function visitCallExpr(expr, context) {
                return this.visitCallExprImpl(expr, context, function(op, args) {
                    return new CallExpr7(op, args);
                });
            }
        },
        {
            key: "visitLookupExpr",
            value: function visitLookupExpr(expr, context) {
                return this.visitCallExprImpl(expr, context, function(op, args) {
                    return new LookupExpr3(args);
                });
            }
        },
        {
            key: "visitStepExpr",
            value: function visitStepExpr(expr, context) {
                var _this = this;
                if (this.m_stepExprs.includes(expr)) {
                    return expr;
                }
                var input = expr.input.accept(this, context);
                var defaultValue = expr.defaultValue.accept(this, context);
                var stops = expr.stops.map(function(stop) {
                    var key = stop[0];
                    var value2 = stop[1].accept(_this, context);
                    return value2 === stop[1] ? stop : [
                        key,
                        value2
                    ];
                });
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    var _loop = function(_iterator, _step) {
                        var step = _step.value;
                        if (step.input === input && step.defaultValue === defaultValue && stops.length === step.stops.length && stops.every(function(param, i) {
                            var _param = _slicedToArray(param, 2), key = _param[0], value2 = _param[1];
                            return key === step.stops[i][0] && value2 === step.stops[i][1];
                        })) {
                            return {
                                v: step
                            };
                        }
                    };
                    for(var _iterator = this.m_stepExprs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _ret = _loop(_iterator, _step);
                        if (_typeof(_ret) === "object") return _ret.v;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var e = new StepExpr(input, defaultValue, stops);
                this.m_stepExprs.push(e);
                return e;
            }
        },
        {
            key: "visitInterpolateExpr",
            value: function visitInterpolateExpr(expr, context) {
                var _this = this;
                if (this.m_interpolateExprs.includes(expr)) {
                    return expr;
                }
                var input = expr.input.accept(this, context);
                var stops = expr.stops.map(function(stop) {
                    var key = stop[0];
                    var value2 = stop[1].accept(_this, context);
                    return value2 === stop[1] ? stop : [
                        key,
                        value2
                    ];
                });
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    var _loop = function(_iterator, _step) {
                        var interp = _step.value;
                        if (interp.input === input && interp.mode[0] === expr.mode[0] && interp.mode[1] === expr.mode[1] && stops.length === interp.stops.length && stops.every(function(param, i) {
                            var _param = _slicedToArray(param, 2), key = _param[0], value2 = _param[1];
                            return key === interp.stops[i][0] && value2 === interp.stops[i][1];
                        })) {
                            return {
                                v: interp
                            };
                        }
                    };
                    for(var _iterator = this.m_interpolateExprs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _ret = _loop(_iterator, _step);
                        if (_typeof(_ret) === "object") return _ret.v;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var e = new InterpolateExpr(expr.mode, input, stops);
                this.m_interpolateExprs.push(e);
                return e;
            }
        }
    ]);
    return ExprPool;
}();
// src/datasource-protocol/TechniqueDescriptors.ts
function mergeTechniqueDescriptor() {
    for(var _len = arguments.length, descriptors = new Array(_len), _key = 0; _key < _len; _key++){
        descriptors[_key] = arguments[_key];
    }
    var result = {
        attrDescriptors: {}
    };
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = descriptors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var descriptor = _step.value;
            if (descriptor.attrTransparencyColor !== void 0) {
                result.attrTransparencyColor = descriptor.attrTransparencyColor;
            }
            if (descriptor.attrDescriptors !== void 0) {
                result.attrDescriptors = _objectSpread({}, result.attrDescriptors, descriptor.attrDescriptors);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return result;
}
var baseTechniqueParamsDescriptor = {
    attrTransparencyColor: "color",
    attrDescriptors: {
        constantHeight: 0 /* FeatureGeometry */ ,
        enabled: 0 /* FeatureGeometry */ ,
        fadeFar: 2 /* TechniqueRendering */ ,
        fadeNear: 2 /* TechniqueRendering */ ,
        transparent: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        side: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        }
    }
};
var pointTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        color: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        size: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        opacity: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        }
    }
});
var squaresTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);
var circlesTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);
var lineMarkerTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        text: 0 /* FeatureGeometry */ ,
        label: 0 /* FeatureGeometry */ ,
        useAbbreviation: 0 /* FeatureGeometry */ ,
        useIsoCode: 0 /* FeatureGeometry */ ,
        poiName: 0 /* FeatureGeometry */ ,
        imageTexture: 0 /* FeatureGeometry */ ,
        iconColor: 2 /* TechniqueRendering */ ,
        iconBrightness: 2 /* TechniqueRendering */ ,
        backgroundColor: 2 /* TechniqueRendering */ ,
        backgroundSize: 2 /* TechniqueRendering */ ,
        backgroundOpacity: 2 /* TechniqueRendering */ ,
        color: 2 /* TechniqueRendering */ ,
        opacity: 2 /* TechniqueRendering */ ,
        size: 2 /* TechniqueRendering */ 
    }
});
var polygonalTechniqueDescriptor = {
    attrDescriptors: {
        polygonOffset: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        polygonOffsetFactor: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        polygonOffsetUnits: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        depthTest: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        transparent: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        opacity: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        color: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        lineColor: 2 /* TechniqueRendering */ ,
        lineFadeFar: 2 /* TechniqueRendering */ ,
        lineFadeNear: 2 /* TechniqueRendering */ 
    }
};
var solidLineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrDescriptors: {
        lineWidth: 2 /* TechniqueRendering */ ,
        secondaryWidth: 2 /* TechniqueRendering */ ,
        secondaryColor: 2 /* TechniqueRendering */ ,
        dashSize: 2 /* TechniqueRendering */ ,
        gapSize: 2 /* TechniqueRendering */ ,
        outlineColor: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        caps: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        drawRangeStart: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        drawRangeEnd: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        dashes: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        dashColor: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        }
    }
});
var lineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        color: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        opacity: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        lineWidth: 0 /* FeatureGeometry */ 
    }
});
var fillTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrDescriptors: {
        wireframe: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        color: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        opacity: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        transparent: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        lineWidth: 2 /* TechniqueRendering */ ,
        map: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        }
    }
});
var standardTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        color: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        vertexColors: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        wireframe: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        roughness: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        metalness: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        alphaTest: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        depthTest: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        transparent: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        opacity: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        emissive: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        emissiveIntensity: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        refractionRatio: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        normalMapType: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        map: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        normalMap: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        displacementMap: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        roughnessMap: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        emissiveMap: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        bumpMap: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        metalnessMap: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        },
        alphaMap: {
            scope: 2 /* TechniqueRendering */ ,
            automatic: true
        }
    }
});
var extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {
    attrDescriptors: {
        height: 0 /* FeatureGeometry */ ,
        floorHeight: 0 /* FeatureGeometry */ ,
        color: 0 /* FeatureGeometry */ ,
        defaultColor: 0 /* FeatureGeometry */ ,
        defaultHeight: 0 /* FeatureGeometry */ ,
        boundaryWalls: 0 /* FeatureGeometry */ ,
        footprint: 0 /* FeatureGeometry */ ,
        maxSlope: 0 /* FeatureGeometry */ ,
        animateExtrusion: 2 /* TechniqueRendering */ ,
        lineWidth: 2 /* TechniqueRendering */ ,
        lineFadeNear: 2 /* TechniqueRendering */ ,
        lineFadeFar: 2 /* TechniqueRendering */ ,
        lineColor: 2 /* TechniqueRendering */ 
    }
});
var textTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        text: 0 /* FeatureGeometry */ ,
        label: 0 /* FeatureGeometry */ ,
        useAbbreviation: 0 /* FeatureGeometry */ ,
        useIsoCode: 0 /* FeatureGeometry */ ,
        backgroundColor: 2 /* TechniqueRendering */ ,
        backgroundSize: 2 /* TechniqueRendering */ ,
        backgroundOpacity: 2 /* TechniqueRendering */ ,
        color: 2 /* TechniqueRendering */ ,
        opacity: 2 /* TechniqueRendering */ ,
        priority: 2 /* TechniqueRendering */ ,
        size: 2 /* TechniqueRendering */ 
    }
});
var shaderTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        params: 2 /* TechniqueRendering */ 
    }
});
var techniqueDescriptors = {
    "extruded-polygon": extrudedPolygonTechniqueDescriptor,
    "line-marker": lineMarkerTechniquePropTypes,
    "labeled-icon": lineMarkerTechniquePropTypes,
    "solid-line": solidLineTechniqueDescriptor,
    "dashed-line": solidLineTechniqueDescriptor,
    terrain: standardTechniqueDescriptor,
    standard: standardTechniqueDescriptor,
    squares: squaresTechniquePropTypes,
    circles: circlesTechniquePropTypes,
    line: lineTechniqueDescriptor,
    segments: lineTechniqueDescriptor,
    fill: fillTechniqueDescriptor,
    text: textTechniqueDescriptor,
    shader: shaderTechniqueDescriptor
};
function getTechniqueDescriptor(technique) {
    if (typeof technique !== "string") {
        technique = technique.name;
    }
    return techniqueDescriptors[technique];
}
function getTechniqueAttributeDescriptor(technique, attrName) {
    var techniqueDescriptor = getTechniqueDescriptor(technique);
    var attrDescriptors = techniqueDescriptor === null || techniqueDescriptor === void 0 ? void 0 : techniqueDescriptor.attrDescriptors;
    var descriptor = attrDescriptors === null || attrDescriptors === void 0 ? void 0 : attrDescriptors[attrName];
    if ((typeof descriptor === "undefined" ? "undefined" : _typeof(descriptor)) === void 0) {
        return void 0;
    } else if (typeof descriptor === "object") {
        return descriptor;
    }
    return {
        scope: descriptor
    };
}
var automaticAttributeCache = /* @__PURE__ */ new Map();
function getTechniqueAutomaticAttrs(technique) {
    var ref;
    if (typeof technique !== "string") {
        technique = technique.name;
    }
    if (automaticAttributeCache.has(technique)) {
        return automaticAttributeCache.get(technique);
    }
    var descriptors = [];
    var attrDescriptors = (ref = getTechniqueDescriptor(technique)) === null || ref === void 0 ? void 0 : ref.attrDescriptors;
    if (attrDescriptors === void 0) {
        return descriptors;
    }
    for(var attrName in attrDescriptors){
        if (!attrDescriptors.hasOwnProperty(attrName)) {
            continue;
        }
        var descr = attrDescriptors[attrName];
        if (descr === void 0 || typeof descr === "number") {
            continue;
        }
        if (descr.automatic === true) {
            descriptors.push(attrName);
        }
    }
    automaticAttributeCache.set(technique, descriptors);
    return descriptors;
}
// src/datasource-protocol/WorkerDecoderProtocol.ts
var RequestController = /*#__PURE__*/ function() {
    function RequestController() {
        var priority = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, abortController = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new AbortController();
        _classCallCheck(this, RequestController);
        this.priority = priority;
        this.abortController = abortController;
    }
    _createClass(RequestController, [
        {
            key: "signal",
            get: function get() {
                return this.abortController.signal;
            }
        },
        {
            key: "abort",
            value: function abort() {
                this.abortController.abort();
            }
        }
    ]);
    return RequestController;
}();
var WorkerDecoderProtocol;
(function(WorkerDecoderProtocol2) {
    var isConfigurationMessage = function isConfigurationMessage(message) {
        return message && typeof message.service === "string" && typeof message.type === "string" && message.type === "configuration" /* Configuration */ ;
    };
    var isDecodeTileRequest = function isDecodeTileRequest(message) {
        return message && typeof message.type === "string" && message.type === "decode-tile-request" /* DecodeTileRequest */ ;
    };
    var isTileInfoRequest = function isTileInfoRequest(message) {
        return message && typeof message.type === "string" && message.type === "tile-info-request" /* TileInfoRequest */ ;
    };
    var DecoderMessageName;
    (function(DecoderMessageName2) {
        DecoderMessageName2["Configuration"] = "configuration";
    })(DecoderMessageName = WorkerDecoderProtocol2.DecoderMessageName || (WorkerDecoderProtocol2.DecoderMessageName = {}));
    WorkerDecoderProtocol2.isConfigurationMessage = isConfigurationMessage;
    var Requests;
    (function(Requests2) {
        Requests2["DecodeTileRequest"] = "decode-tile-request";
        Requests2["TileInfoRequest"] = "tile-info-request";
    })(Requests = WorkerDecoderProtocol2.Requests || (WorkerDecoderProtocol2.Requests = {}));
    WorkerDecoderProtocol2.isDecodeTileRequest = isDecodeTileRequest;
    WorkerDecoderProtocol2.isTileInfoRequest = isTileInfoRequest;
})(WorkerDecoderProtocol || (WorkerDecoderProtocol = {}));
// src/datasource-protocol/WorkerServiceProtocol.ts
var WorkerServiceProtocol;
(function(WorkerServiceProtocol2) {
    var isInitializedMessage = function isInitializedMessage(message) {
        return message && typeof message.service === "string" && typeof message.type === "string" && message.type === "initialized" /* Initialized */ ;
    };
    var isUnknownServiceError = function isUnknownServiceError(error) {
        return error.message.includes("unknown targetServiceType requested: ");
    };
    var isRequestMessage = function isRequestMessage(message) {
        return message && typeof message.service === "string" && typeof message.type === "string" && message.type === "request" /* Request */ ;
    };
    var isResponseMessage = function isResponseMessage(message) {
        return message && typeof message.service === "string" && typeof message.type === "string" && message.type === "response" /* Response */ ;
    };
    WorkerServiceProtocol2.WORKER_SERVICE_MANAGER_SERVICE_ID = "worker-service-manager";
    var ServiceMessageName;
    (function(ServiceMessageName2) {
        ServiceMessageName2["Initialized"] = "initialized";
        ServiceMessageName2["Request"] = "request";
        ServiceMessageName2["Response"] = "response";
    })(ServiceMessageName = WorkerServiceProtocol2.ServiceMessageName || (WorkerServiceProtocol2.ServiceMessageName = {}));
    WorkerServiceProtocol2.isInitializedMessage = isInitializedMessage;
    var Requests;
    (function(Requests2) {
        Requests2["CreateService"] = "create-service";
        Requests2["DestroyService"] = "destroy-service";
    })(Requests = WorkerServiceProtocol2.Requests || (WorkerServiceProtocol2.Requests = {}));
    WorkerServiceProtocol2.isUnknownServiceError = isUnknownServiceError;
    WorkerServiceProtocol2.isRequestMessage = isRequestMessage;
    WorkerServiceProtocol2.isResponseMessage = isResponseMessage;
})(WorkerServiceProtocol || (WorkerServiceProtocol = {}));
// src/datasource-protocol/WorkerTilerProtocol.ts
var WorkerTilerProtocol;
(function(WorkerTilerProtocol2) {
    var isRegisterIndexRequest = function isRegisterIndexRequest(message) {
        return message && typeof message.type === "string" && message.type === "register-index" /* RegisterIndex */ ;
    };
    var isUpdateIndexRequest = function isUpdateIndexRequest(message) {
        return message && typeof message.type === "string" && message.type === "update-index" /* UpdateIndex */ ;
    };
    var isTileRequest = function isTileRequest(message) {
        return message && typeof message.type === "string" && message.type === "tile-request" /* TileRequest */ ;
    };
    var Requests;
    (function(Requests2) {
        Requests2["RegisterIndex"] = "register-index";
        Requests2["UpdateIndex"] = "update-index";
        Requests2["TileRequest"] = "tile-request";
    })(Requests = WorkerTilerProtocol2.Requests || (WorkerTilerProtocol2.Requests = {}));
    WorkerTilerProtocol2.isRegisterIndexRequest = isRegisterIndexRequest;
    WorkerTilerProtocol2.isUpdateIndexRequest = isUpdateIndexRequest;
    WorkerTilerProtocol2.isTileRequest = isTileRequest;
})(WorkerTilerProtocol || (WorkerTilerProtocol = {}));
// src/materials/CirclePointsMaterial.ts
var THREE17 = __toESM(require("three"));
// src/materials/RawShaderMaterial.ts
var THREE16 = __toESM(require("three"));
// src/materials/Utils.ts
var THREE15 = __toESM(require("three"));
var DEFINE_BOOL_TRUE = "";
var DEFINE_BOOL_FALSE = void 0;
function insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {
    var tabChar = addTab === true ? "	" : "";
    var result = shaderContent.replace("#include <".concat(shaderName, ">"), "#include <".concat(shaderName, ">\n").concat(tabChar, "#include <").concat(insertedShaderName, ">"));
    return result;
}
function enforceBlending(material) {
    if (material.transparent) {
        return;
    }
    enableBlending(material);
    material.forcedBlending = true;
}
function enableBlending(material) {
    if (material.transparent === true || material.forcedBlending === true) {
        return;
    }
    material.blending = THREE15.CustomBlending;
    if (material.premultipliedAlpha === true) {
        material.blendSrc = THREE15.OneFactor;
        material.blendDst = THREE15.OneMinusSrcAlphaFactor;
        material.blendSrcAlpha = THREE15.OneFactor;
        material.blendDstAlpha = THREE15.OneMinusSrcAlphaFactor;
    } else {
        material.blendSrc = THREE15.SrcAlphaFactor;
        material.blendDst = THREE15.OneMinusSrcAlphaFactor;
        material.blendSrcAlpha = THREE15.OneFactor;
        material.blendDstAlpha = THREE15.OneMinusSrcAlphaFactor;
    }
}
function disableBlending(material) {
    if (material.transparent === true || material.forcedBlending === true) {
        return;
    }
    material.blending = THREE15.NormalBlending;
}
function setShaderMaterialDefine(material, key, value2) {
    assert(material.defines !== void 0, "Do not use this function in ShaderMaterial derived c-tor.");
    var semanticValue = getShaderMaterialDefine(material, key);
    var needsUpdate = value2 !== semanticValue;
    if (!needsUpdate) {
        return false;
    }
    setShaderDefine(material.defines, key, value2);
    material.needsUpdate = needsUpdate;
    return true;
}
function getShaderMaterialDefine(material, key) {
    var fallbackValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (material.defines === void 0) {
        return fallbackValue;
    }
    return getShaderDefine(material.defines, key);
}
function setShaderDefine(defines, key, value2) {
    var updated = false;
    if (typeof value2 === "number") {
        updated = defines[key] !== value2;
        defines[key] = value2;
    } else if (value2 === true) {
        updated = defines[key] !== DEFINE_BOOL_TRUE;
        defines[key] = DEFINE_BOOL_TRUE;
    } else if (value2 === false && defines[key] !== void 0) {
        delete defines[key];
        updated = true;
    }
    return updated;
}
function getShaderDefine(defines, key) {
    var currentValue = defines[key];
    var semanticValue = currentValue === DEFINE_BOOL_FALSE ? false : currentValue === DEFINE_BOOL_TRUE ? true : currentValue;
    return semanticValue;
}
// src/materials/RawShaderMaterial.ts
var RawShaderMaterial2 = /*#__PURE__*/ function(_RawShaderMaterial) {
    _inherits(RawShaderMaterial2, _RawShaderMaterial);
    var _super = _createSuper(RawShaderMaterial2);
    function RawShaderMaterial2(params) {
        _classCallCheck(this, RawShaderMaterial2);
        var _this;
        var isWebGL2 = (params === null || params === void 0 ? void 0 : params.rendererCapabilities.isWebGL2) === true;
        var shaderParams = params ? _objectSpreadProps(_objectSpread({}, params), {
            glslVersion: isWebGL2 ? THREE16.GLSL3 : THREE16.GLSL1,
            vertexShader: isWebGL2 && params.vertexShader ? convertVertexShaderToWebGL2(params.vertexShader) : params.vertexShader,
            fragmentShader: isWebGL2 && params.fragmentShader ? convertFragmentShaderToWebGL2(params.fragmentShader) : params.fragmentShader
        }) : void 0;
        if (shaderParams) {
            delete shaderParams.rendererCapabilities;
        }
        _this = _super.call(this, shaderParams);
        _this.invalidateFog();
        _this.setOpacity(shaderParams === null || shaderParams === void 0 ? void 0 : shaderParams.opacity);
        return _this;
    }
    _createClass(RawShaderMaterial2, [
        {
            key: "invalidateFog",
            value: function invalidateFog() {
                if (this.defines !== void 0 && this.fog !== getShaderMaterialDefine(this, "USE_FOG")) {
                    setShaderMaterialDefine(this, "USE_FOG", this.fog);
                }
            }
        },
        {
            key: "setOpacity",
            value: function setOpacity(opacity) {
                if (opacity !== void 0) {
                    var ref;
                    this.opacity = opacity;
                    if ((ref = this.uniforms) === null || ref === void 0 ? void 0 : ref.opacity) {
                        this.uniforms.opacity.value = opacity;
                    }
                }
            }
        }
    ]);
    return RawShaderMaterial2;
}(THREE16.RawShaderMaterial);
// src/materials/CirclePointsMaterial.ts
var vertexShader = "\nuniform float size;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec3 position;\n\nvoid main() {\n    vec3 transformed = vec3(position);\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n    gl_PointSize = size;\n}\n";
var fragmentShader = "\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuseColor;\nuniform float opacity;\n\nvoid main() {\n    float alpha = opacity;\n\n    float radius = 0.5;\n    vec2 coords = gl_PointCoord.xy - vec2(0.5);\n    float len = length(coords);\n    float falloff = fwidth(len);\n    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);\n    alpha *= threshold;\n\n    gl_FragColor = vec4(diffuseColor, alpha);\n}";
var _CirclePointsMaterial = /*#__PURE__*/ function(RawShaderMaterial2) {
    _inherits(_CirclePointsMaterial, RawShaderMaterial2);
    var _super = _createSuper(_CirclePointsMaterial);
    function _CirclePointsMaterial(parameters) {
        _classCallCheck(this, _CirclePointsMaterial);
        var _this;
        var defaultColor = new THREE17.Color();
        var defaultOpacity = 1;
        var sizeValue, colorValue, opacityValue;
        var shaderParameters;
        if (parameters) {
            var size = parameters.size, color = parameters.color, opacity = parameters.opacity, shaderParams = _objectWithoutProperties(parameters, [
                "size",
                "color",
                "opacity"
            ]);
            sizeValue = size;
            colorValue = color;
            opacityValue = opacity;
            shaderParams.name = "CirclePointsMaterial";
            shaderParams.vertexShader = vertexShader;
            shaderParams.fragmentShader = fragmentShader;
            shaderParams.uniforms = THREE17.UniformsUtils.merge([
                {
                    size: new THREE17.Uniform(_CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),
                    diffuseColor: new THREE17.Uniform(defaultColor),
                    opacity: new THREE17.Uniform(defaultOpacity)
                },
                THREE17.UniformsLib.fog
            ]);
            shaderParams.depthTest = false;
            shaderParams.extensions = _objectSpreadProps(_objectSpread({}, shaderParams.extensions), {
                derivatives: true
            });
            shaderParameters = shaderParams;
        }
        _this = _super.call(this, shaderParameters);
        enforceBlending(_assertThisInitialized(_this));
        _this.type = "CirclePointsMaterial";
        _this.setOpacity(defaultOpacity);
        if (sizeValue !== void 0) {
            _this.size = sizeValue;
        }
        if (colorValue !== void 0) {
            _this.color = colorValue;
        }
        if (opacityValue !== void 0) {
            _this.setOpacity(opacityValue);
        }
        return _this;
    }
    _createClass(_CirclePointsMaterial, [
        {
            key: "size",
            get: function get() {
                return this.uniforms.size.value;
            },
            set: function set(size) {
                this.uniforms.size.value = size;
            }
        },
        {
            key: "color",
            get: function get() {
                return this.uniforms.diffuseColor.value;
            },
            set: function set(value2) {
                this.uniforms.diffuseColor.value.copy(value2);
            }
        }
    ]);
    return _CirclePointsMaterial;
}(RawShaderMaterial2);
var CirclePointsMaterial = _CirclePointsMaterial;
__publicField(CirclePointsMaterial, "DEFAULT_CIRCLE_SIZE", 1);
// src/materials/CopyMaterial.ts
var THREE18 = __toESM(require("three"));
var CopyShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        opacity: {
            value: 1
        }
    },
    vertexShader: "\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }",
    fragmentShader: "\n    uniform float opacity;\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        gl_FragColor = opacity * texel;\n    }"
};
var CopyMaterial = /*#__PURE__*/ function(_ShaderMaterial) {
    _inherits(CopyMaterial, _ShaderMaterial);
    var _super = _createSuper(CopyMaterial);
    function CopyMaterial(uniforms) {
        _classCallCheck(this, CopyMaterial);
        return _super.call(this, {
            name: "CopyMaterial",
            uniforms: uniforms,
            vertexShader: CopyShader.vertexShader,
            fragmentShader: CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: false,
            blending: THREE18.NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
    return CopyMaterial;
}(THREE18.ShaderMaterial);
// src/materials/DisplacementFeature.ts
function hasDisplacementFeature(material) {
    return "displacementMap" in material;
}
function setDisplacementMapToMaterial(displacementMap, material) {
    if (hasDisplacementFeature(material) && material.displacementMap !== displacementMap) {
        material.displacementMap = displacementMap;
        material.needsUpdate = true;
        if (material.displacementMap !== null) {
            material.displacementMap.needsUpdate = true;
        }
    }
}
// src/materials/EdgeMaterial.ts
var THREE20 = __toESM(require("three"));
// src/materials/MapMeshMaterials.ts
var THREE19 = __toESM(require("three"));
// src/materials/MapMeshMaterialsDefs.ts
var ExtrusionFeatureDefs;
(function(ExtrusionFeatureDefs2) {
    ExtrusionFeatureDefs2.DEFAULT_RATIO_MIN = 0;
    ExtrusionFeatureDefs2.DEFAULT_RATIO_MAX = 1;
    ExtrusionFeatureDefs2.MIN_BUILDING_HEIGHT = 0.1;
})(ExtrusionFeatureDefs || (ExtrusionFeatureDefs = {}));
// src/materials/ShaderChunks/ExtrusionChunks.ts
var MIN_BUILDING_HEIGHT_SQUARED = ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;
var ExtrusionChunks_default = {
    extrusion_pars_vertex: "\n// Add define so we can check for it in the outline effect (see Outline.ts).\n#define HAS_EXTRUSION_PARS_VERTEX\n// Extrusion axis (xyz: vector, w: factor).\nattribute vec4 extrusionAxis;\nuniform float extrusionRatio;\n#ifdef FLAT_SHADED\nvarying vec4 vExtrusionAxis;\n#endif\n#ifdef ZFIGHTING_WORKAROUND\nvarying float vExtrusionRatio;\n#endif\n",
    extrusion_vertex: "\n#define HAS_EXTRUSION_VERTEX\n#ifdef ZFIGHTING_WORKAROUND\n// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.\nconst float MIN_BUILDING_HEIGHT_SQUARED = ".concat(MIN_BUILDING_HEIGHT_SQUARED, ";\nfloat extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);\nvExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;\n#else\nfloat vExtrusionRatio = extrusionRatio;\n#endif\ntransformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);\n#ifdef FLAT_SHADED\nvExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);\n#endif\n"),
    extrusion_normal_fragment_begin: "\n#ifdef FLAT_SHADED\n    // Flattened this divergent path to prevent undefined behaviour in the following derivatives\n    // functions. For more info:\n    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches\n\n    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\n    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\n    vec3 normal = cross( fdx, fdy );\n    if (vExtrusionAxis.w > 0.999999) {\n        normal = vExtrusionAxis.xyz;\n    }\n    normal = normalize(normal);\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n			bitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n		#endif\n	#endif\n#endif\n// non perturbed normal for clearcoat among others\nvec3 geometryNormal = normal;\n",
    extrusion_pars_fragment: "\n#ifdef ZFIGHTING_WORKAROUND\nvarying float vExtrusionRatio;\n#else\nuniform float extrusionRatio;\n#endif\nvarying vec4 vExtrusionAxis;\n",
    extrusion_fragment: "\n#ifndef ZFIGHTING_WORKAROUND\nfloat vExtrusionRatio = extrusionRatio;\n#endif\ngl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );\n"
};
// src/materials/ShaderChunks/FadingChunks.ts
var FadingChunks_default = {
    fading_pars_vertex: "\nvarying float fadingDepth;\n",
    fading_vertex: "\nfadingDepth = -mvPosition.z;\n",
    fading_pars_fragment: "\nvarying float fadingDepth;\nuniform float fadeNear;\nuniform float fadeFar;\n",
    fading_fragment: '\n\n// lerp with "hard" edges\n//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);\n\n// smooth transitions\nfloat fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );\n\ngl_FragColor.a *= 1.0 - fadingFactor;\n\n// debugging color:\n// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);\n'
};
// src/materials/ShaderChunks/ShadowChunks.ts
var simpleLightingShadowChunk = "\n    struct PhysicalMaterial {\n        vec3	diffuseColor;\n        float	specularRoughness;\n        vec3	specularColor;\n    };\n\n    #define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n    void RE_Direct_Physical( const in IncidentLight directLight,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight ) {\n        // directLight.color is the light color * shadow, internally three.js uses a step function, so\n        // this value is either the light color or black. in order to lighten up the shadows, we\n        // take add 50% of the color to grey (to give us either pure white or grey) and multiply this to\n        // the material's diffuse color.\n        #if defined(USE_SHADOWMAP)\n            reflectedLight.directDiffuse = (0.5 * directLight.color +\n                vec3(0.5,0.5,0.5)) * material.diffuseColor;\n        #else\n            reflectedLight.directDiffuse = material.diffuseColor;\n        #endif\n    }\n\n    void RE_IndirectDiffuse_Physical( const in vec3 irradiance,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight ) {\n            // Disable influence of indirect light (it is handled in the RE_Direct_Physical function)\n    }\n\n    void RE_IndirectSpecular_Physical( const in vec3 radiance,\n        const in vec3 irradiance,\n        const in vec3 clearcoatRadiance,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight) {\n            // Disable specular reflection of light.\n    }\n\n    #define RE_Direct               RE_Direct_Physical\n    #define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical\n    #define RE_IndirectSpecular     RE_IndirectSpecular_Physical\n";
// src/materials/MapMeshMaterials.ts
var emptyTexture = new THREE19.Texture();
function cameraToWorldDistance(distance, visibilityRange) {
    return distance * visibilityRange.maximum;
}
function linkMixinWithMaterial(mixin, material) {
    if (material.defines === void 0) {
        material.defines = {};
    }
    mixin.shaderDefines = material.defines;
    if (mixin.shaderUniforms === void 0) {
        mixin.shaderUniforms = {};
    }
}
function linkMixinWithShader(mixin, shader) {
    Object.assign(shader.uniforms, mixin.shaderUniforms);
    mixin.shaderUniforms = shader.uniforms;
}
function hasExtrusionFeature(material) {
    return "extrusionRatio" in material;
}
var DisplacementFeature;
(function(DisplacementFeature3) {
    var isEnabled = function isEnabled(displacementMaterial) {
        return displacementMaterial.displacementMap !== null;
    };
    var updateDisplacementFeature = function updateDisplacementFeature(displacementMaterial) {
        assert(displacementMaterial.shaderDefines !== void 0);
        assert(displacementMaterial.shaderUniforms !== void 0);
        var useDisplacementMap = isEnabled(displacementMaterial);
        var needsUpdate = setShaderDefine(displacementMaterial.shaderDefines, "USE_DISPLACEMENTMAP", useDisplacementMap);
        displacementMaterial.needsUpdate = needsUpdate;
        if (useDisplacementMap) {
            var texture = displacementMaterial.displacementMap;
            texture.needsUpdate = true;
            displacementMaterial.shaderUniforms.displacementMap.value = texture;
        } else if (needsUpdate) {
            displacementMaterial.shaderUniforms.displacementMap.value = emptyTexture;
        }
    };
    var onBeforeCompile = function onBeforeCompile(displacementMaterial, shader) {
        if (!isEnabled(displacementMaterial)) {
            return;
        }
        assert(displacementMaterial.shaderUniforms !== void 0);
        linkMixinWithShader(displacementMaterial, shader);
        shader.vertexShader = shader.vertexShader.replace("#include <skinbase_vertex>", "#include <skinbase_vertex>\n#ifndef USE_ENVMAP\n    vec3 objectNormal = vec3( normal );\n#endif");
        shader.vertexShader = insertShaderInclude(shader.vertexShader, "uv2_pars_vertex", "displacementmap_pars_vertex");
        shader.vertexShader = insertShaderInclude(shader.vertexShader, "skinning_vertex", "displacementmap_vertex", true);
    };
    DisplacementFeature3.isEnabled = isEnabled;
    DisplacementFeature3.updateDisplacementFeature = updateDisplacementFeature;
    DisplacementFeature3.onBeforeCompile = onBeforeCompile;
})(DisplacementFeature || (DisplacementFeature = {}));
var DisplacementFeatureMixin = /*#__PURE__*/ function() {
    function DisplacementFeatureMixin() {
        _classCallCheck(this, DisplacementFeatureMixin);
        __publicField(this, "needsUpdate");
        __publicField(this, "uniformsNeedUpdate");
        __publicField(this, "defines");
        __publicField(this, "shaderDefines");
        __publicField(this, "shaderUniforms");
        __publicField(this, "onBeforeCompile");
        __publicField(this, "m_displacementMap", null);
    }
    _createClass(DisplacementFeatureMixin, [
        {
            key: "displacementMap",
            get: function get() {
                return this.m_displacementMap;
            },
            set: function set(map) {
                this.setDisplacementMap(map);
            }
        },
        {
            key: "getDisplacementMap",
            value: function getDisplacementMap() {
                return this.m_displacementMap;
            }
        },
        {
            key: "setDisplacementMap",
            value: function setDisplacementMap(map) {
                if (map !== this.m_displacementMap) {
                    this.m_displacementMap = map;
                    DisplacementFeature.updateDisplacementFeature(this);
                }
            }
        },
        {
            key: "addDisplacementProperties",
            value: function addDisplacementProperties() {
                var _this = this;
                Object.defineProperty(this, "displacementMap", {
                    get: function() {
                        return _this.getDisplacementMap();
                    },
                    set: function(val) {
                        _this.setDisplacementMap(val);
                    }
                });
            }
        },
        {
            key: "applyDisplacementParameters",
            value: function applyDisplacementParameters(params) {
                var _this = this;
                linkMixinWithMaterial(this, this);
                assert(this.shaderDefines !== void 0);
                assert(this.shaderUniforms !== void 0);
                var uniforms = this.shaderUniforms;
                uniforms.displacementMap = new THREE19.Uniform(emptyTexture);
                uniforms.displacementScale = new THREE19.Uniform(1);
                uniforms.displacementBias = new THREE19.Uniform(0);
                if (params !== void 0) {
                    if (params.displacementMap !== void 0) {
                        this.setDisplacementMap(params.displacementMap);
                    }
                }
                this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, function(shader) {
                    DisplacementFeature.onBeforeCompile(_this, shader);
                });
                this.needsUpdate = DisplacementFeature.isEnabled(this);
            }
        },
        {
            key: "copyDisplacementParameters",
            value: function copyDisplacementParameters(source) {
                this.setDisplacementMap(source.displacementMap);
                return this;
            }
        }
    ]);
    return DisplacementFeatureMixin;
}();
var FadingFeature;
(function(FadingFeature2) {
    var isEnabled = function isEnabled(fadingMaterial) {
        return fadingMaterial.fadeNear !== void 0 && fadingMaterial.fadeFar !== void 0 && fadingMaterial.fadeFar > 0;
    };
    var isDefined = function isDefined(fadingMaterial) {
        return fadingMaterial.fadeNear !== void 0 && fadingMaterial.fadeFar !== void 0;
    };
    var patchGlobalShaderChunks = function patchGlobalShaderChunks() {
        if (THREE19.ShaderChunk.fading_pars_vertex === void 0) {
            Object.assign(THREE19.ShaderChunk, FadingChunks_default);
        }
    };
    var updateFadingFeature = function updateFadingFeature(fadingMaterial) {
        assert(fadingMaterial.shaderDefines !== void 0);
        assert(fadingMaterial.shaderUniforms !== void 0);
        var useFading = isEnabled(fadingMaterial);
        var needsUpdate = setShaderDefine(fadingMaterial.shaderDefines, "FADING_MATERIAL", useFading);
        fadingMaterial.needsUpdate = needsUpdate;
        assert(fadingMaterial.shaderUniforms.fadeNear !== void 0 && fadingMaterial.shaderUniforms.fadeFar !== void 0);
        if (useFading) {
            fadingMaterial.shaderUniforms.fadeNear.value = fadingMaterial.fadeNear;
            fadingMaterial.shaderUniforms.fadeFar.value = fadingMaterial.fadeFar;
            if (needsUpdate) {
                enableBlending(fadingMaterial);
            }
        } else if (needsUpdate) {
            fadingMaterial.shaderUniforms.fadeNear.value = FadingFeature2.DEFAULT_FADE_NEAR;
            fadingMaterial.shaderUniforms.fadeFar.value = FadingFeature2.DEFAULT_FADE_FAR;
            disableBlending(fadingMaterial);
        }
    };
    var onBeforeCompile = function onBeforeCompile(fadingMaterial, shader) {
        if (!isEnabled(fadingMaterial)) {
            return;
        }
        assert(fadingMaterial.shaderUniforms !== void 0);
        linkMixinWithShader(fadingMaterial, shader);
        shader.vertexShader = insertShaderInclude(shader.vertexShader, "fog_pars_vertex", "fading_pars_vertex");
        shader.vertexShader = insertShaderInclude(shader.vertexShader, "fog_vertex", "fading_vertex", true);
        shader.fragmentShader = insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "fading_pars_fragment");
        shader.fragmentShader = insertShaderInclude(shader.fragmentShader, "fog_fragment", "fading_fragment", true);
    };
    var addRenderHelper = function addRenderHelper(object, viewRanges, fadeNear, fadeFar, updateUniforms, additionalCallback) {
        object.onBeforeRender = chainCallbacks(object.onBeforeRender, function(renderer, scene, camera, geometry, material, group) {
            var fadingMaterial = material;
            fadingMaterial.fadeNear = fadeNear === void 0 || fadeNear === FadingFeature2.DEFAULT_FADE_NEAR ? FadingFeature2.DEFAULT_FADE_NEAR : cameraToWorldDistance(fadeNear, viewRanges);
            fadingMaterial.fadeFar = fadeFar === void 0 || fadeFar === FadingFeature2.DEFAULT_FADE_FAR ? FadingFeature2.DEFAULT_FADE_FAR : cameraToWorldDistance(fadeFar, viewRanges);
            if (additionalCallback !== void 0) {
                additionalCallback(renderer, material);
            }
        });
    };
    FadingFeature2.DEFAULT_FADE_NEAR = -1;
    FadingFeature2.DEFAULT_FADE_FAR = -1;
    FadingFeature2.isEnabled = isEnabled;
    FadingFeature2.isDefined = isDefined;
    FadingFeature2.patchGlobalShaderChunks = patchGlobalShaderChunks;
    FadingFeature2.updateFadingFeature = updateFadingFeature;
    FadingFeature2.onBeforeCompile = onBeforeCompile;
    FadingFeature2.addRenderHelper = addRenderHelper;
})(FadingFeature || (FadingFeature = {}));
var FadingFeatureMixin = /*#__PURE__*/ function() {
    function FadingFeatureMixin() {
        _classCallCheck(this, FadingFeatureMixin);
        __publicField(this, "needsUpdate");
        __publicField(this, "uniformsNeedUpdate");
        __publicField(this, "defines");
        __publicField(this, "shaderDefines");
        __publicField(this, "shaderUniforms");
        __publicField(this, "onBeforeCompile");
        __publicField(this, "m_fadeNear", FadingFeature.DEFAULT_FADE_NEAR);
        __publicField(this, "m_fadeFar", FadingFeature.DEFAULT_FADE_FAR);
    }
    _createClass(FadingFeatureMixin, [
        {
            key: "getFadeNear",
            value: function getFadeNear() {
                return this.m_fadeNear;
            }
        },
        {
            key: "setFadeNear",
            value: function setFadeNear(value2) {
                var needsUpdate = value2 !== this.m_fadeNear;
                if (needsUpdate) {
                    this.m_fadeNear = value2;
                    FadingFeature.updateFadingFeature(this);
                }
            }
        },
        {
            key: "getFadeFar",
            value: function getFadeFar() {
                return this.m_fadeFar;
            }
        },
        {
            key: "setFadeFar",
            value: function setFadeFar(value2) {
                var needsUpdate = value2 !== this.m_fadeFar;
                if (needsUpdate) {
                    this.m_fadeFar = value2;
                    FadingFeature.updateFadingFeature(this);
                }
            }
        },
        {
            key: "addFadingProperties",
            value: function addFadingProperties() {
                var _this = this;
                Object.defineProperty(this, "fadeNear", {
                    get: function() {
                        return _this.getFadeNear();
                    },
                    set: function(val) {
                        _this.setFadeNear(val);
                    }
                });
                Object.defineProperty(this, "fadeFar", {
                    get: function() {
                        return _this.getFadeFar();
                    },
                    set: function(val) {
                        _this.setFadeFar(val);
                    }
                });
            }
        },
        {
            key: "applyFadingParameters",
            value: function applyFadingParameters(params) {
                var _this = this;
                linkMixinWithMaterial(this, this);
                assert(this.shaderDefines !== void 0);
                assert(this.shaderUniforms !== void 0);
                this.shaderUniforms.fadeNear = new THREE19.Uniform(FadingFeature.DEFAULT_FADE_NEAR);
                this.shaderUniforms.fadeFar = new THREE19.Uniform(FadingFeature.DEFAULT_FADE_FAR);
                if (params !== void 0) {
                    if (params.fadeNear !== void 0) {
                        this.setFadeNear(params.fadeNear);
                    }
                    if (params.fadeFar !== void 0) {
                        this.setFadeFar(params.fadeFar);
                    }
                }
                this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, function(shader) {
                    FadingFeature.onBeforeCompile(_this, shader);
                });
                this.needsUpdate = FadingFeature.isEnabled(this);
            }
        },
        {
            key: "copyFadingParameters",
            value: function copyFadingParameters(source) {
                this.setFadeNear(source.fadeNear === void 0 ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);
                this.setFadeFar(source.fadeFar === void 0 ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);
                return this;
            }
        }
    ]);
    return FadingFeatureMixin;
}();
var ExtrusionFeature;
(function(ExtrusionFeature4) {
    var isEnabled = function isEnabled(extrusionMaterial) {
        return extrusionMaterial.extrusionRatio !== void 0 && extrusionMaterial.extrusionRatio >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
    };
    var patchGlobalShaderChunks = function patchGlobalShaderChunks() {
        if (THREE19.ShaderChunk.extrusion_pars_vertex === void 0) {
            Object.assign(THREE19.ShaderChunk, ExtrusionChunks_default);
        }
    };
    var updateExtrusionFeature = function updateExtrusionFeature(extrusionMaterial) {
        assert(extrusionMaterial.shaderDefines !== void 0);
        assert(extrusionMaterial.shaderUniforms !== void 0);
        var useExtrusion = isEnabled(extrusionMaterial);
        var needsUpdate = setShaderDefine(extrusionMaterial.shaderDefines, "EXTRUSION_MATERIAL", useExtrusion);
        extrusionMaterial.needsUpdate = needsUpdate;
        if (useExtrusion) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value = extrusionMaterial.extrusionRatio;
        } else if (needsUpdate) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value = ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
        }
    };
    var onBeforeCompile = function onBeforeCompile(extrusionMaterial, shader) {
        if (!isEnabled(extrusionMaterial)) {
            return;
        }
        assert(extrusionMaterial.shaderUniforms !== void 0);
        linkMixinWithShader(extrusionMaterial, shader);
        shader.vertexShader = insertShaderInclude(shader.vertexShader, "common", "extrusion_pars_vertex");
        shader.vertexShader = insertShaderInclude(shader.vertexShader, "begin_vertex", "extrusion_vertex", true);
        shader.fragmentShader = insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "extrusion_pars_fragment");
        shader.fragmentShader = shader.fragmentShader.replace("#include <normal_fragment_begin>", "#include <extrusion_normal_fragment_begin>");
        shader.fragmentShader = insertShaderInclude(shader.fragmentShader, "fog_fragment", "extrusion_fragment", true);
    };
    ExtrusionFeature4.isEnabled = isEnabled;
    ExtrusionFeature4.patchGlobalShaderChunks = patchGlobalShaderChunks;
    ExtrusionFeature4.updateExtrusionFeature = updateExtrusionFeature;
    ExtrusionFeature4.onBeforeCompile = onBeforeCompile;
})(ExtrusionFeature || (ExtrusionFeature = {}));
var ExtrusionFeatureMixin = /*#__PURE__*/ function() {
    function ExtrusionFeatureMixin() {
        _classCallCheck(this, ExtrusionFeatureMixin);
        __publicField(this, "needsUpdate");
        __publicField(this, "uniformsNeedUpdate");
        __publicField(this, "defines");
        __publicField(this, "shaderDefines");
        __publicField(this, "shaderUniforms");
        __publicField(this, "onBeforeCompile");
        __publicField(this, "m_extrusion", ExtrusionFeatureDefs.DEFAULT_RATIO_MAX);
    }
    _createClass(ExtrusionFeatureMixin, [
        {
            key: "getExtrusionRatio",
            value: function getExtrusionRatio() {
                return this.m_extrusion;
            }
        },
        {
            key: "setExtrusionRatio",
            value: function setExtrusionRatio(value2) {
                var needsUpdate = value2 !== this.m_extrusion;
                if (needsUpdate) {
                    this.m_extrusion = value2;
                    ExtrusionFeature.updateExtrusionFeature(this);
                }
            }
        },
        {
            key: "addExtrusionProperties",
            value: function addExtrusionProperties() {
                var _this = this;
                Object.defineProperty(this, "extrusionRatio", {
                    get: function() {
                        return _this.getExtrusionRatio();
                    },
                    set: function(val) {
                        _this.setExtrusionRatio(val);
                    }
                });
            }
        },
        {
            key: "applyExtrusionParameters",
            value: function applyExtrusionParameters(params) {
                var _this = this;
                linkMixinWithMaterial(this, this);
                assert(this.shaderDefines !== void 0);
                assert(this.shaderUniforms !== void 0);
                if (params && params.zFightingWorkaround === true) {
                    this.shaderDefines.ZFIGHTING_WORKAROUND = "";
                }
                this.shaderUniforms.extrusionRatio = new THREE19.Uniform(ExtrusionFeatureDefs.DEFAULT_RATIO_MAX);
                if (params !== void 0) {
                    if (params.extrusionRatio !== void 0) {
                        this.setExtrusionRatio(params.extrusionRatio);
                    }
                }
                this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, function(shader) {
                    ExtrusionFeature.onBeforeCompile(_this, shader);
                });
                this.needsUpdate = ExtrusionFeature.isEnabled(this);
            }
        },
        {
            key: "copyExtrusionParameters",
            value: function copyExtrusionParameters(source) {
                if (source.extrusionRatio !== void 0) {
                    this.setExtrusionRatio(source.extrusionRatio);
                }
                return this;
            }
        }
    ]);
    return ExtrusionFeatureMixin;
}();
var MapMeshBasicMaterial = /*#__PURE__*/ function(_MeshBasicMaterial) {
    _inherits(MapMeshBasicMaterial, _MeshBasicMaterial);
    var _super = _createSuper(MapMeshBasicMaterial);
    function MapMeshBasicMaterial(params) {
        _classCallCheck(this, MapMeshBasicMaterial);
        var _this;
        _this = _super.call(this, params);
        FadingFeature.patchGlobalShaderChunks();
        _this.addFadingProperties();
        _this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        _this.addExtrusionProperties();
        _this.applyExtrusionParameters(_objectSpreadProps(_objectSpread({}, params), {
            zFightingWorkaround: true
        }));
        _this.addDisplacementProperties();
        _this.applyDisplacementParameters(params);
        return _this;
    }
    _createClass(MapMeshBasicMaterial, [
        {
            key: "clone",
            value: function clone() {
                return new MapMeshBasicMaterial().copy(this);
            }
        },
        {
            key: "copy",
            value: function copy(source) {
                _get(_getPrototypeOf(MapMeshBasicMaterial.prototype), "copy", this).call(this, source);
                this.copyFadingParameters(source);
                this.copyExtrusionParameters(source);
                this.copyDisplacementParameters(source);
                return this;
            }
        },
        {
            key: "fadeNear",
            get: function get() {
                return FadingFeature.DEFAULT_FADE_NEAR;
            },
            set: function set(value2) {}
        },
        {
            key: "fadeFar",
            get: function get() {
                return FadingFeature.DEFAULT_FADE_FAR;
            },
            set: function set(value2) {}
        },
        {
            key: "extrusionRatio",
            get: function get() {
                return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
            },
            set: function set(value2) {}
        },
        {
            key: "displacementMap",
            get: function get() {
                return null;
            },
            set: function set(value2) {}
        },
        {
            key: "setDisplacementMap",
            value: function setDisplacementMap(value2) {}
        },
        {
            key: "addFadingProperties",
            value: function addFadingProperties() {}
        },
        {
            key: "applyFadingParameters",
            value: function applyFadingParameters(params) {}
        },
        {
            key: "copyFadingParameters",
            value: function copyFadingParameters(source) {}
        },
        {
            key: "addExtrusionProperties",
            value: function addExtrusionProperties() {}
        },
        {
            key: "applyExtrusionParameters",
            value: function applyExtrusionParameters(params) {}
        },
        {
            key: "copyExtrusionParameters",
            value: function copyExtrusionParameters(source) {}
        },
        {
            key: "addDisplacementProperties",
            value: function addDisplacementProperties() {}
        },
        {
            key: "applyDisplacementParameters",
            value: function applyDisplacementParameters(params) {}
        },
        {
            key: "copyDisplacementParameters",
            value: function copyDisplacementParameters(source) {}
        }
    ]);
    return MapMeshBasicMaterial;
}(THREE19.MeshBasicMaterial);
var MapMeshDepthMaterial = /*#__PURE__*/ function(_MeshDepthMaterial) {
    _inherits(MapMeshDepthMaterial, _MeshDepthMaterial);
    var _super = _createSuper(MapMeshDepthMaterial);
    function MapMeshDepthMaterial(params) {
        _classCallCheck(this, MapMeshDepthMaterial);
        var _this;
        _this = _super.call(this, params);
        ExtrusionFeature.patchGlobalShaderChunks();
        _this.addExtrusionProperties();
        _this.applyExtrusionParameters(_objectSpreadProps(_objectSpread({}, params), {
            zFightingWorkaround: false
        }));
        return _this;
    }
    _createClass(MapMeshDepthMaterial, [
        {
            key: "extrusionRatio",
            get: function get() {
                return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
            },
            set: function set(value2) {}
        },
        {
            key: "addExtrusionProperties",
            value: function addExtrusionProperties() {}
        },
        {
            key: "applyExtrusionParameters",
            value: function applyExtrusionParameters(params) {}
        },
        {
            key: "copyExtrusionParameters",
            value: function copyExtrusionParameters(source) {}
        }
    ]);
    return MapMeshDepthMaterial;
}(THREE19.MeshDepthMaterial);
var MapMeshStandardMaterial = /*#__PURE__*/ function(_MeshStandardMaterial) {
    _inherits(MapMeshStandardMaterial, _MeshStandardMaterial);
    var _super = _createSuper(MapMeshStandardMaterial);
    function MapMeshStandardMaterial(params) {
        _classCallCheck(this, MapMeshStandardMaterial);
        var _this;
        _this = _super.call(this, params);
        __publicField(_assertThisInitialized(_this), "uniformsNeedUpdate");
        FadingFeature.patchGlobalShaderChunks();
        _this.addFadingProperties();
        _this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        _this.addExtrusionProperties();
        _this.applyExtrusionParameters(_objectSpreadProps(_objectSpread({}, params), {
            zFightingWorkaround: true
        }));
        if ((params === null || params === void 0 ? void 0 : params.removeDiffuseLight) === true) {
            _this.onBeforeCompile = chainCallbacks(_this.onBeforeCompile, function(shaderParameters) {
                var shader = shaderParameters;
                shader.fragmentShader = THREE19.ShaderChunk.meshphysical_frag.replace("#include <lights_physical_pars_fragment>", simpleLightingShadowChunk);
            });
        }
        return _this;
    }
    _createClass(MapMeshStandardMaterial, [
        {
            key: "clone",
            value: function clone() {
                return new MapMeshStandardMaterial().copy(this);
            }
        },
        {
            key: "copy",
            value: function copy(source) {
                _get(_getPrototypeOf(MapMeshStandardMaterial.prototype), "copy", this).call(this, source);
                this.copyFadingParameters(source);
                this.copyExtrusionParameters(source);
                return this;
            }
        },
        {
            key: "fadeNear",
            get: function get() {
                return FadingFeature.DEFAULT_FADE_NEAR;
            },
            set: function set(value2) {}
        },
        {
            key: "fadeFar",
            get: function get() {
                return FadingFeature.DEFAULT_FADE_FAR;
            },
            set: function set(value2) {}
        },
        {
            key: "extrusionRatio",
            get: function get() {
                return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
            },
            set: function set(value2) {}
        },
        {
            key: "removeDiffuseLight",
            get: function get() {
                return false;
            },
            set: function set(val) {}
        },
        {
            key: "addFadingProperties",
            value: function addFadingProperties() {}
        },
        {
            key: "applyFadingParameters",
            value: function applyFadingParameters(params) {}
        },
        {
            key: "copyFadingParameters",
            value: function copyFadingParameters(source) {}
        },
        {
            key: "addExtrusionProperties",
            value: function addExtrusionProperties() {}
        },
        {
            key: "applyExtrusionParameters",
            value: function applyExtrusionParameters(params) {}
        },
        {
            key: "copyExtrusionParameters",
            value: function copyExtrusionParameters(source) {}
        }
    ]);
    return MapMeshStandardMaterial;
}(THREE19.MeshStandardMaterial);
applyMixinsWithoutProperties(MapMeshBasicMaterial, [
    FadingFeatureMixin
]);
applyMixinsWithoutProperties(MapMeshStandardMaterial, [
    FadingFeatureMixin
]);
applyMixinsWithoutProperties(MapMeshBasicMaterial, [
    ExtrusionFeatureMixin
]);
applyMixinsWithoutProperties(MapMeshStandardMaterial, [
    ExtrusionFeatureMixin
]);
applyMixinsWithoutProperties(MapMeshDepthMaterial, [
    ExtrusionFeatureMixin
]);
applyMixinsWithoutProperties(MapMeshBasicMaterial, [
    DisplacementFeatureMixin
]);
// src/materials/EdgeMaterial.ts
var vertexSource = "\n#define EDGE_DEPTH_OFFSET 0.0001\n\n#ifdef USE_COLOR\nattribute vec4 color;\n#else\nuniform vec3 color;\n#endif\n\n// SHADER_NAME may be defined by THREE.JS own shaders in which case these attributes & uniforms are\n// already defined\n#ifndef SHADER_NAME\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n#endif\n\nuniform vec3 edgeColor;\nuniform float edgeColorMix;\n\n#ifdef USE_DISPLACEMENTMAP\nattribute vec3 normal;\nattribute vec2 uv;\nuniform sampler2D displacementMap;\n#endif\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_vertex>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\nvoid main() {\n\n    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);\n\n    vec3 transformed = vec3( position );\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_vertex>\n    #endif\n\n    #ifdef USE_DISPLACEMENTMAP\n    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = projectionMatrix * mvPosition;\n    // After projection gl_Position contains clip space coordinates of each vertex\n    // before perspective division (1 / w), thus only vertexes with -w < z < w should\n    // be displayed and offset. We offset only those edges which z coordinate in NDC\n    // space is between: -inf < z < 1\n    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;\n    gl_Position.z -= depthOffset;\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n}";
var fragmentSource = "\nprecision highp float;\nprecision highp int;\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\nvoid main() {\n    float alphaValue = 1.0;\n    gl_FragColor = vec4(vColor, alphaValue);\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}";
var _EdgeMaterial = /*#__PURE__*/ function(RawShaderMaterial2) {
    _inherits(_EdgeMaterial, RawShaderMaterial2);
    var _super = _createSuper(_EdgeMaterial);
    function _EdgeMaterial(params) {
        _classCallCheck(this, _EdgeMaterial);
        var _this;
        var shaderParams;
        if (params) {
            var defines = {};
            var hasExtrusion = params.extrusionRatio !== void 0 && params.extrusionRatio >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN && params.extrusionRatio < ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
            if (params.displacementMap) {
                setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
            }
            if (hasExtrusion) {
                setShaderDefine(defines, "USE_EXTRUSION", true);
            }
            if (params.vertexColors === true) {
                setShaderDefine(defines, "USE_COLOR", true);
            }
            var _displacementMap;
            shaderParams = {
                name: "EdgeMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: {
                    color: new THREE20.Uniform(new THREE20.Color(_EdgeMaterial.DEFAULT_COLOR)),
                    edgeColor: new THREE20.Uniform(new THREE20.Color(_EdgeMaterial.DEFAULT_COLOR)),
                    edgeColorMix: new THREE20.Uniform(_EdgeMaterial.DEFAULT_COLOR_MIX),
                    fadeNear: new THREE20.Uniform(FadingFeature.DEFAULT_FADE_NEAR),
                    fadeFar: new THREE20.Uniform(FadingFeature.DEFAULT_FADE_FAR),
                    extrusionRatio: new THREE20.Uniform(ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),
                    displacementMap: new THREE20.Uniform((_displacementMap = params.displacementMap) !== null && _displacementMap !== void 0 ? _displacementMap : new THREE20.Texture())
                },
                depthWrite: false,
                defines: defines,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        _this = _super.call(this, shaderParams);
        enforceBlending(_assertThisInitialized(_this));
        FadingFeature.patchGlobalShaderChunks();
        ExtrusionFeature.patchGlobalShaderChunks();
        if (params !== void 0) {
            if (params.color !== void 0) {
                _this.color.set(params.color);
            }
            if (params.colorMix !== void 0) {
                _this.colorMix = params.colorMix;
            }
            if (params.fadeNear !== void 0) {
                _this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== void 0) {
                _this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== void 0) {
                _this.displacementMap = params.displacementMap;
            }
            if (params.extrusionRatio !== void 0) {
                _this.extrusionRatio = params.extrusionRatio;
            }
        }
        return _this;
    }
    _createClass(_EdgeMaterial, [
        {
            key: "objectColor",
            get: function get() {
                return this.uniforms.color.value;
            },
            set: function set(value2) {
                this.uniforms.color.value.copy(value2);
            }
        },
        {
            key: "color",
            get: function get() {
                return this.uniforms.edgeColor.value;
            },
            set: function set(value2) {
                this.uniforms.edgeColor.value.copy(value2);
            }
        },
        {
            key: "lineWidth",
            get: function get() {
                return this.linewidth;
            },
            set: function set(value2) {
                this.linewidth = value2;
                if (this.linewidth <= 0) {
                    this.visible = false;
                } else {
                    this.visible = true;
                }
            }
        },
        {
            key: "colorMix",
            get: function get() {
                return this.uniforms.edgeColorMix.value;
            },
            set: function set(value2) {
                if (this.uniforms.edgeColorMix.value === value2) {
                    return;
                }
                this.uniforms.edgeColorMix.value = value2;
            }
        },
        {
            key: "fadeNear",
            get: function get() {
                return this.uniforms.fadeNear.value;
            },
            set: function set(value2) {
                this.uniforms.fadeNear.value = value2;
            }
        },
        {
            key: "fadeFar",
            get: function get() {
                return this.uniforms.fadeFar.value;
            },
            set: function set(value2) {
                if (this.uniforms.fadeFar.value === value2) {
                    return;
                }
                this.uniforms.fadeFar.value = value2;
                setShaderMaterialDefine(this, "USE_FADING", value2 > 0);
            }
        },
        {
            key: "extrusionRatio",
            get: function get() {
                return this.uniforms.extrusionRatio.value;
            },
            set: function set(value2) {
                if (this.uniforms.extrusionRatio.value === value2) {
                    return;
                }
                this.uniforms.extrusionRatio.value = value2;
                var useExtrusion = value2 >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
                setShaderMaterialDefine(this, "USE_EXTRUSION", useExtrusion);
            }
        },
        {
            key: "displacementMap",
            get: function get() {
                return this.uniforms.displacementMap.value;
            },
            set: function set(map) {
                if (this.uniforms.displacementMap.value === map) {
                    return;
                }
                this.uniforms.displacementMap.value = map;
                var useDisplacementMap = map !== null;
                if (useDisplacementMap) {
                    this.uniforms.displacementMap.value.needsUpdate = true;
                }
                setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
            }
        }
    ]);
    return _EdgeMaterial;
}(RawShaderMaterial2);
var EdgeMaterial = _EdgeMaterial;
__publicField(EdgeMaterial, "DEFAULT_COLOR", 0);
__publicField(EdgeMaterial, "DEFAULT_COLOR_MIX", 0);
// src/materials/GroundAtmosphereMaterial.ts
var THREE21 = __toESM(require("three"));
// src/materials/ShaderChunks/AtmosphereChunks.ts
var AtmosphereChunks_default = {
    atmosphere_vertex_utils: "\n\n    const float RayleighScaleDepth = 0.25;\n\n    struct AtmosphereColor\n    {\n        vec3 mie;\n        vec3 rayleigh;\n    };\n\n    float scale(float cosAngle)\n    {\n        float x = 1.0 - cosAngle;\n        return RayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n    }\n\n    float getNearSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {\n        // Solve simple square equation for the x0 (first point of intersection).\n#if defined(IMPROVE_INTERSECT_PRECISION)\n        // To improve precision instead of simple projection: b = 2.0 * dot(vPos, v3Ray),\n        // we change the equation that gives better results especially around the poles.\n        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);\n#else\n        float fB = 2.0 * dot(v3Pos, v3Ray);\n#endif\n        float fC = fCameraHeight2 - fOuterRadius2;\n        // det = b^2 - 4*a*c, where a = 1\n        float fDet = max(0.0, fB * fB - 4.0 * fC);\n        // Intersection points distances are defined as follows:\n        // x0 = (-b - sqrt(det)) / 2*a ^ x1 = (-b + sqrt(det)) / 2*a\n        // we search for x0:\n        return 0.5 * (-fB - sqrt(fDet));\n    }\n\n    float getFarSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {\n        // Solve simple square equation for the x1 (second point of intersection).\n#if defined(IMPROVE_INTERSECT_PRECISION)\n        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);\n#else\n        float fB = 2.0 * dot(v3Pos, v3Ray);\n#endif\n        float fC = fCameraHeight2 - fOuterRadius2;\n        // det = b^2 - 4*a*c, where a = 1\n        float fDet = max(0.0, fB * fB - 4.0 * fC);\n        // Compute second intersection distance:\n        // x1 = (-b + sqrt(det)) / 2*a\n        return 0.5 * (-fB + sqrt(fDet));\n    }\n    ",
    atmosphere_fragment_utils: "\n\n    // Branch free RGB to HSV conversion.\n    // Based on article:\n    // http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\n    // and optimized OpenGL SL algorithm\n    // http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec3 rgb2Hsv(vec3 c)\n    {\n        const vec4 RGB_HSV_CONV = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        // Ternary operator may be used explicitly if compiler can use fast conditional move.\n        // vec4 p = c.g < c.b ? vec4(c.bg, RGB_HSV_CONV.wz) : vec4(c.gb, RGB_HSV_CONV.xy);\n        vec4 p = mix(vec4(c.bg, RGB_HSV_CONV.wz), vec4(c.gb, RGB_HSV_CONV.xy), step(c.b, c.g));\n        // vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    }\n\n    // Branch free HSV to RGB conversion\n    vec3 hsv2Rgb(vec3 c)\n    {\n        const vec4 HSV_RGB_CONV = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + HSV_RGB_CONV.xyz) * 6.0 - HSV_RGB_CONV.www);\n        return c.z * mix(HSV_RGB_CONV.xxx, clamp(p - HSV_RGB_CONV.xxx, 0.0, 1.0), c.y);\n    }\n\n    vec3 correctExposure(vec3 rgb, float exposure)\n    {\n        const vec3 fullColor = vec3(1.0);\n        return fullColor - exp(-exposure * rgb);\n    }\n\n    vec3 correctColor(vec3 rgb, vec3 hsvShift)\n    {\n        const float e = 0.0000001;\n        // Convert rgb color to hsv\n        vec3 hsv = rgb2Hsv(rgb);\n        // Shift hue value with angle wrapping\n        hsv.x = mod(hsv.x + hsvShift.x, 1.0);\n        // Shift and clamp saturation\n        hsv.y = clamp(hsv.y + hsvShift.y, 0.0, 1.0);\n        // Change value if it is significant (greater then epsilon)\n        hsv.z = hsv.z > e ? clamp(hsv.z + hsvShift.z, 0.0, 1.0) : 0.0;\n        // Convert shifted hsv back to rgb\n        return hsv2Rgb(hsv);\n    }\n    "
};
// src/materials/GroundAtmosphereMaterial.ts
var EQUATORIAL_RADIUS = 6378137;
var GroundAtmosphereShader = {
    uniforms: {
        u_eyePositionWorld: new THREE21.Uniform(new THREE21.Vector3()),
        u_lightDirectionWorld: new THREE21.Uniform(new THREE21.Vector3(0, 1, 0)),
        u_modelViewProjection: new THREE21.Uniform(new THREE21.Matrix4()),
        u_atmosphereEnv: new THREE21.Uniform(new THREE21.Vector3(EQUATORIAL_RADIUS * 1.001, EQUATORIAL_RADIUS * 1.025, 0)),
        u_hsvCorrection: new THREE21.Uniform(new THREE21.Vector3(0, 0, 0)),
        topColor: new THREE21.Uniform(new THREE21.Color(30719)),
        bottomColor: new THREE21.Uniform(new THREE21.Color(16777215)),
        offset: new THREE21.Uniform(33),
        exponent: new THREE21.Uniform(0.6),
        fogColor: new THREE21.Uniform(new THREE21.Color(30719)),
        fogNear: new THREE21.Uniform(new THREE21.Color(30719)),
        fogFar: new THREE21.Uniform(new THREE21.Color(16777215))
    },
    vertexShader: "\n\n    #define IMPROVE_INTERSECT_PRECISION 1\n    #define IMPROVE_DOT_PRECISION 1\n\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n\n    // Base mandatory uniforms\n    uniform mat4 u_modelViewProjection;\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_hsvCorrection;\n\n    const float Pi = 3.141592653589793;\n    const float Kr = 0.0025;\n    const float Km = 0.0015;\n    const float Kr4PI = Kr * 4.0 * Pi;\n    const float Km4PI = Km * 4.0 * Pi;\n    const float ESun = 25.0; // should be 15.0\n    const float KmESun = Km * ESun;\n    const float KrESun = Kr * ESun;\n    const vec3 InvWavelength = vec3(\n        1.0 / pow(0.650, 4.0), // Red\n        1.0 / pow(0.570, 4.0), // Green\n        1.0 / pow(0.475, 4.0)); // Blue\n\n    const int nSamples = 2;\n    const float fSamples = 2.0;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n    varying vec3 v_vertToOrigin;\n\n    ".concat(AtmosphereChunks_default.atmosphere_vertex_utils, "\n\n    //\n    // Computes rayleight and mia atmosphere factors for ground.\n    //\n    // Code based on GPU Gems article.\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    //\n    // Further modifications by HERE.\n    //\n    AtmosphereColor computeGroundAtmosphere(vec3 v3Pos, vec3 vLightDir)\n    {\n        // Retrieve environment variables\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        // All that may be moved to const or define(s) at further optimizations:\n        float fScale = 1.0 / (fOuterRadius - fInnerRadius);\n        float fScaleOverScaleDepth = fScale / RayleighScaleDepth;\n        float fCameraHeight2 = fCameraHeight * fCameraHeight;\n        float fOuterRadius2 = fOuterRadius * fOuterRadius;\n\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = v3Pos - u_eyePositionWorld;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n#if !defined(IMPROVE_DOT_PRECISION)\n        vec3 v3Dir = normalize(v3Pos);\n#endif\n\n#ifdef CAMERA_IN_SPACE\n\n        // Calculate first point of camera ray and sphere intersection.\n        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);\n        // Make far relative to first atmosphere intersection, setting it to\n        // the length of ray passed through atmosphere\n        fFar -= fNear;\n\n        // Compute the ray's starting position within the atmosphere, then\n        // calculate its scattering offset\n        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;\n        float fDepth = exp((fInnerRadius - fOuterRadius) / RayleighScaleDepth);\n\n#else // CAMERA_IN_ATMOSPHERE\n\n        // The ray starts already in atmosphere\n        vec3 v3Start = u_eyePositionWorld;\n        // Virtually fNear is just at eye position, so ray passing through atmosphere does not shorten\n        // fFar -= 0.0;\n        float fDepth = exp((fInnerRadius - fCameraHeight) / RayleighScaleDepth);\n#endif\n\n#if defined(IMPROVE_DOT_PRECISION)\n        float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\n#else\n        float fCameraAngle = dot(-v3Ray, v3Dir);\n#endif\n        float fCameraScale = scale(fCameraAngle);\n\n#ifdef DYNAMIC_LIGHT\n        // When we want the atmosphere to be uniform over the globe so it is set to 1.0.\n        #if defined(IMPROVE_DOT_PRECISION)\n            // The light angle for given light source may be calculated as:\n            // angle = dot(vLightDir, v3Dir) / length(v3Dir);\n            // where v3Dir holds normalized vertex position, but for precision issues we v3Pos (un-normalized)\n            float fLightAngle = dot(vLightDir, v3Pos) / length(v3Pos);\n        #else\n            float fLightAngle = dot(vLightDir, v3Dir);\n        #endif\n#else\n        float fLightAngle = 1.0;\n#endif\n        float fLightScale = scale(fLightAngle);\n\n        float fCameraOffset = fDepth * fCameraScale;\n        float fTemp = (fLightScale + fCameraScale);\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3BaseColor = vec3(0.0);\n        vec3 v3Attenuate = vec3(0.0);\n        for(int i = 0; i < nSamples; i++)\n        {\n            float fHeight = length(v3SamplePoint);\n            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n            float fScatter = fDepth * fTemp - fCameraOffset;\n            // Compute color factors\n            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n            v3BaseColor += v3Attenuate * (fDepth * fScaledLength);\n            // Move to the next point\n            v3SamplePoint += v3SampleRay;\n        }\n\n        AtmosphereColor color;\n        color.mie = v3BaseColor * (InvWavelength * KrESun + KmESun);\n        // Calculate the attenuation factor for the ground\n        color.rayleigh = v3Attenuate;\n\n        return color;\n    }\n\n    void main(void)\n    {\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        AtmosphereColor atmColor = computeGroundAtmosphere(position.xyz, vLightDir);\n        v_mieColor = atmColor.mie;\n        v_rayleighColor = atmColor.rayleigh;\n        v_vertToCamera = u_eyePositionWorld - position.xyz;\n        v_vertToOrigin = normalize(position.xyz);\n\n        gl_Position = u_modelViewProjection * position;\n    }\n    "),
    fragmentShader: "\n\n    // Exposure correction gives more subtle gradients on the ground.\n    #define CORRECT_EXPOSURE 1\n    #define FADE_DEPTH 1\n    #define NIGHT_LOCAL 1\n\n    precision highp float;\n    precision highp int;\n\n    #ifdef CORRECT_COLOR\n    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness\n    #endif\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    const float g = -0.95;\n    const float g2 = g * g;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n    varying vec3 v_vertToOrigin;\n\n    ".concat(AtmosphereChunks_default.atmosphere_fragment_utils, "\n\n    void main(void)\n    {\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        // GPU gems mix of ground solution, with custom alpha settings\n        vec3 cRgb = v_mieColor + 0.25 * v_rayleighColor;\n\n        // Not needed for HDR frame buffer\n    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)\n        // Interesting results with exposure factor: 2.0, 3.5, 4.0\n        cRgb = correctExposure(cRgb, 3.0);\n    #endif\n\n    #ifdef CORRECT_COLOR\n        cRgb = correctColor(cRgb, u_hsvCorrection);\n    #endif\n\n        // Base atmosphere opacity\n        float fAtmosphereAlpha = 1.0;\n\n        // Factor based on the distance of camera atmosphere and ground, results are:\n        // 0.0 = camera on the ground surface,\n        // 1.0 = at the outer edge of the atmosphere.\n        float fDepthFactor = clamp((fCameraHeight - fInnerRadius) /\n            (fOuterRadius - fInnerRadius), 0.0, 1.0);\n    #ifdef FADE_DEPTH\n        // Fade alpha based on the distance of camera between atmosphere layers\n        #ifdef FADE_DEPTH_LINEAR\n            fAtmosphereAlpha *= fDepthFactor;\n        #else\n            fAtmosphereAlpha *= pow(fDepthFactor, 1.5);\n        #endif\n    #endif\n\n#if defined(FADE_NIGHT) || defined(DARKEN_NIGHT)\n    #ifdef DYNAMIC_LIGHT\n        // Adjust factor based on time of day, results are:\n        // 0.0 = night,\n        // 1.0 = day.\n        #ifdef NIGHT_GLOBAL\n            // Global night fade based on camera and light orientation\n            float fNightFactor = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);\n            fNightFactor = pow(fNightFactor, 0.5);\n        #else // NIGHT_LOCAL\n            float fNightFactor =\n                clamp(dot(v_vertToOrigin, vLightDir) / length(v_vertToOrigin), 0.0, 1.0);\n            fNightFactor = pow(fNightFactor, 0.8);\n        #endif\n    #else\n        float fNightFactor = 1.0;\n    #endif\n#endif\n\n    #ifdef FADE_NIGHT\n        // Adjust alpha for night side of the globe\n        fAtmosphereAlpha *= fNightFactor;\n    #endif\n\n    #ifdef DARKEN_NIGHT\n        // Change the brightness depending on night / day side.\n        // NOTE: Darkening should be rather applied in HSV space, without loss on saturation,\n        // but it is much more GPU consuming.\n        const float minBrightness = 0.5;\n        float fDarkenFactor = clamp(fNightFactor, minBrightness, 1.0);\n        cRgb *= fDarkenFactor;\n    #endif\n\n    #ifdef EXPOSURE_DEPTH\n        // Control exposure depending from ground distance\n        float exposureBoost = 3.0 - fDepthFactor;\n        cRgb = correctExposure(cRgb, exposureBoost);\n    #endif\n\n        // Experimental fading out of focus point - similar to fresnel effect in top view.\n        // This fade is handy to better expose cartographic/map features in screen center.\n        float fFocusFactor = 1.0 - clamp(dot(normalize(v_vertToCamera), v_vertToOrigin), 0.0, 1.0) + 0.1;\n        fFocusFactor = pow(fFocusFactor, 2.5);\n        fAtmosphereAlpha *= fFocusFactor;\n\n        // Integrate all features\n        gl_FragColor = vec4(cRgb, fAtmosphereAlpha);\n    }\n    ")
};
var GroundAtmosphereMaterial = /*#__PURE__*/ function(RawShaderMaterial2) {
    _inherits(GroundAtmosphereMaterial, RawShaderMaterial2);
    var _super = _createSuper(GroundAtmosphereMaterial);
    function GroundAtmosphereMaterial(params) {
        _classCallCheck(this, GroundAtmosphereMaterial);
        var shaderParams;
        if (params) {
            var defines = {};
            defines.CAMERA_IN_SPACE = "";
            shaderParams = {
                name: "GroundAtmosphereMaterial",
                vertexShader: GroundAtmosphereShader.vertexShader,
                fragmentShader: GroundAtmosphereShader.fragmentShader,
                uniforms: GroundAtmosphereShader.uniforms,
                transparent: true,
                depthTest: false,
                depthWrite: false,
                side: THREE21.FrontSide,
                blending: THREE21.NormalBlending,
                fog: false,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        return _super.call(this, shaderParams);
    }
    _createClass(GroundAtmosphereMaterial, [
        {
            key: "setDynamicLighting",
            value: function setDynamicLighting(enableLighting) {
                setShaderMaterialDefine(this, "DYNAMIC_LIGHT", enableLighting);
            }
        },
        {
            key: "outerRadius",
            get: function get() {
                return this.uniforms.u_atmosphereEnv.value.y;
            },
            set: function set(radius) {
                this.uniforms.u_atmosphereEnv.value.y = radius;
            }
        },
        {
            key: "innerRadius",
            get: function get() {
                return this.uniforms.u_atmosphereEnv.value.x;
            },
            set: function set(radius) {
                this.uniforms.u_atmosphereEnv.value.x = radius;
            }
        },
        {
            key: "updateUniforms",
            value: function updateUniforms(shaderMaterial, object, camera, lightDirection) {
                var cameraInfo = this.getCameraInfo(object, camera);
                if (shaderMaterial !== void 0 && shaderMaterial.isMaterial) {
                    if (shaderMaterial.uniforms && shaderMaterial.uniforms.u_atmosphereEnv && shaderMaterial.uniforms.u_hsvCorrection && shaderMaterial.uniforms.u_eyePositionWorld && shaderMaterial.uniforms.u_modelViewProjection && shaderMaterial.uniforms.u_lightDirectionWorld) {
                        var eyePos = cameraInfo.eyePos;
                        var mvp = cameraInfo.modelViewProjection;
                        var cameraHeight = cameraInfo.eyeHeight;
                        shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);
                        shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);
                        shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;
                        shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();
                        var cameraInSpace = cameraHeight > this.outerRadius;
                        var needsUpdate0 = setShaderDefine(shaderMaterial.defines, "CAMERA_IN_SPACE", cameraInSpace);
                        var needsUpdate1 = setShaderDefine(shaderMaterial.defines, "CAMERA_IN_ATMOSPHERE", !cameraInSpace);
                        shaderMaterial.needsUpdate = shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;
                    } else {
                        throw Error("Atmosphere material has missing uniforms");
                    }
                } else {
                    throw Error("Wrong object used, only Material objects are supported");
                }
            }
        },
        {
            key: "getCameraInfo",
            value: function getCameraInfo(object, camera) {
                var reverse = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (reverse) {
                    var modelMatrix = new THREE21.Matrix4().identity();
                    var viewMatrix = new THREE21.Matrix4().copy(object.matrixWorld).invert().transpose();
                    var projectionMatrix = camera.projectionMatrix;
                    var mvpMatrix = new THREE21.Matrix4();
                    mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
                    mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
                    var eyePos = new THREE21.Vector3();
                    object.getWorldPosition(eyePos);
                    var objectPos = new THREE21.Vector3();
                    camera.getWorldPosition(objectPos);
                    var eyeHeight = objectPos.distanceTo(eyePos);
                    return {
                        modelViewProjection: mvpMatrix,
                        eyePos: eyePos,
                        eyeHeight: eyeHeight
                    };
                } else {
                    var modelMatrix1 = object.matrixWorld;
                    var viewMatrix1 = camera.matrixWorldInverse;
                    var projectionMatrix1 = camera.projectionMatrix;
                    var mvpMatrix1 = new THREE21.Matrix4();
                    mvpMatrix1.multiplyMatrices(viewMatrix1, modelMatrix1);
                    mvpMatrix1.multiplyMatrices(projectionMatrix1, mvpMatrix1);
                    var eyePos1 = new THREE21.Vector3();
                    camera.getWorldPosition(eyePos1);
                    var objectPos1 = new THREE21.Vector3();
                    object.getWorldPosition(objectPos1);
                    var eyeHeight1 = objectPos1.distanceTo(eyePos1);
                    eyePos1.sub(objectPos1);
                    return {
                        modelViewProjection: mvpMatrix1,
                        eyePos: eyePos1,
                        eyeHeight: eyeHeight1
                    };
                }
            }
        }
    ]);
    return GroundAtmosphereMaterial;
}(RawShaderMaterial2);
// src/materials/HighPrecisionLineMaterial.ts
var THREE22 = __toESM(require("three"));
// src/materials/ShaderChunks/LinesChunks.ts
var LinesChunks_default = {
    extrude_line_vert_func: "\nvec3 extrudeLine(\n        in vec3 vertexPosition,\n        in float linePosition,\n        in float extrusionWidth,\n        in vec4 bitangent,\n        in vec3 tangent,\n        in float tanHalfAngle,\n        inout vec2 uv\n    ) {\n    vec3 result = vertexPosition;\n    // Retrieve the angle between this segment and the previous one (stored in the bitangent w\n    // component).\n    float angle = bitangent.w;\n    // Extrude according to the angle between segments to properly render narrow joints...\n    if (angle != 0.0) {\n        result += uv.y * extrusionWidth * bitangent.xyz / cos(angle / 2.0);\n        uv.x = linePosition + uv.x * extrusionWidth * uv.y * tanHalfAngle;\n    }\n    // ... or extrude in a simple manner for segments that keep the same direction.\n    else {\n        result += uv.y * extrusionWidth * bitangent.xyz + uv.x * extrusionWidth * tangent;\n        uv.x = linePosition + uv.x * extrusionWidth;\n    }\n    uv.y *= extrusionWidth;\n    return result;\n}\n",
    round_edges_and_add_caps: "\n#define CAPS_NONE ".concat(0 /* CAPS_NONE */ , "\n#define CAPS_SQUARE ", 1 /* CAPS_SQUARE */ , "\n#define CAPS_ROUND ", 2 /* CAPS_ROUND */ , "\n#define CAPS_TRIANGLE_IN ", 3 /* CAPS_TRIANGLE_IN */ , "\n#define CAPS_TRIANGLE_OUT ", 4 /* CAPS_TRIANGLE_OUT */ , "\n\nfloat roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {\n    // Compute the line's width to length ratio.\n    float widthRatio = range.y / range.x;\n\n    // Compute the inner segment distance (same for all cap mode).\n    float dist = abs(coords.y);\n    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);\n    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);\n    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));\n    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));\n\n    #if CAPS_MODE != CAPS_ROUND\n    // Compute the caps mask.\n    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);\n    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);\n    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);\n    float capMask = capRangeMask * max(beginCapMask, endCapMask);\n\n    // Compute the outer segment distance (specific for each cap mode).\n    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;\n    #if CAPS_MODE == CAPS_NONE\n    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);\n    #elif CAPS_MODE == CAPS_SQUARE\n    dist = mix(dist, max(abs(coords.y), capDist), capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_OUT\n    dist = mix(dist, abs(coords.y) + capDist, capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_IN\n    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);\n    #endif\n    #endif // CAPS_MODE != CAPS_ROUND\n\n    return dist;\n}\n"),
    tile_clip_func: "\nvoid tileClip(vec2 tilePos, vec2 tileSize) {\n    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))\n        discard;\n    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))\n        discard;\n}\n",
    high_precision_vert_func: "\nvec3 subtractDblEyePos( const in vec3 pos ) {\n    vec3 t1 = positionLow - u_eyepos_lowpart;\n    vec3 e = t1 - positionLow;\n    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;\n    vec3 high_delta = t1 + t2;\n    vec3 low_delta = t2 - (high_delta - t1);\n    return (high_delta + low_delta);\n}\n"
};
// src/materials/HighPrecisionLineMaterial.ts
var vertexSource2 = "\n#ifdef USE_COLOR\nattribute vec4 color;\nvarying vec3 vColor;\n#endif\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 position;        // high part\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n}";
var fragmentSource2 = "\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuseColor;\nuniform float opacity;\n\n#ifdef USE_COLOR\nvarying vec3 color;\n#endif\n\nvoid main() {\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( diffuseColor * vColor, opacity );\n    #else\n    gl_FragColor = vec4( diffuseColor, opacity );\n    #endif\n}";
var _HighPrecisionLineMaterial = /*#__PURE__*/ function(RawShaderMaterial2) {
    _inherits(_HighPrecisionLineMaterial, RawShaderMaterial2);
    var _super = _createSuper(_HighPrecisionLineMaterial);
    function _HighPrecisionLineMaterial(params) {
        _classCallCheck(this, _HighPrecisionLineMaterial);
        var _this;
        Object.assign(THREE22.ShaderChunk, LinesChunks_default);
        var shaderParams = params ? {
            name: "HighPrecisionLineMaterial",
            vertexShader: vertexSource2,
            fragmentShader: fragmentSource2,
            uniforms: {
                diffuseColor: new THREE22.Uniform(new THREE22.Color(_HighPrecisionLineMaterial.DEFAULT_COLOR)),
                opacity: new THREE22.Uniform(_HighPrecisionLineMaterial.DEFAULT_OPACITY),
                u_mvp: new THREE22.Uniform(new THREE22.Matrix4()),
                u_eyepos: new THREE22.Uniform(new THREE22.Vector3()),
                u_eyepos_lowpart: new THREE22.Uniform(new THREE22.Vector3())
            },
            rendererCapabilities: params.rendererCapabilities
        } : void 0;
        Object.assign(shaderParams, params);
        _this = _super.call(this, shaderParams);
        __publicField(_assertThisInitialized(_this), "isHighPrecisionLineMaterial");
        _this.type = "HighPrecisionLineMaterial";
        _this.isHighPrecisionLineMaterial = true;
        if (params) {
            if (params.color !== void 0) {
                _this.color.set(params.color);
            }
            if (params.opacity !== void 0) {
                _this.opacity = params.opacity;
            }
        }
        _this.updateTransparencyFeature();
        return _this;
    }
    _createClass(_HighPrecisionLineMaterial, [
        {
            key: "color",
            get: function get() {
                return this.uniforms.diffuseColor.value;
            },
            set: function set(value2) {
                this.uniforms.diffuseColor.value.copy(value2);
            }
        },
        {
            key: "updateTransparencyFeature",
            value: function updateTransparencyFeature() {
                this.transparent = this.opacity < 1 ? true : false;
            }
        }
    ]);
    return _HighPrecisionLineMaterial;
}(RawShaderMaterial2);
var HighPrecisionLineMaterial = _HighPrecisionLineMaterial;
__publicField(HighPrecisionLineMaterial, "DEFAULT_COLOR", 80);
__publicField(HighPrecisionLineMaterial, "DEFAULT_OPACITY", 1);
function isHighPrecisionLineMaterial(material) {
    return material !== void 0 && material.isHighPrecisionLineMaterial === true;
}
// src/materials/HighPrecisionPointMaterial.ts
var THREE23 = __toESM(require("three"));
var vertexSource3 = "\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\nuniform float size;\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n\n    // ignore sizeAttenuation for now!\n    gl_PointSize = size;\n}";
var _HighPrecisionPointMaterial = /*#__PURE__*/ function(_PointsMaterial) {
    _inherits(_HighPrecisionPointMaterial, _PointsMaterial);
    var _super = _createSuper(_HighPrecisionPointMaterial);
    function _HighPrecisionPointMaterial(params) {
        _classCallCheck(this, _HighPrecisionPointMaterial);
        var _this;
        Object.assign(THREE23.ShaderChunk, LinesChunks_default);
        var shaderParams = params;
        _this = _super.call(this, shaderParams);
        __publicField(_assertThisInitialized(_this), "isHighPrecisionPointMaterial");
        __publicField(_assertThisInitialized(_this), "uniforms");
        __publicField(_assertThisInitialized(_this), "vertexShader");
        __publicField(_assertThisInitialized(_this), "fragmentShader");
        _this.type = "HighPrecisionPointMaterial";
        _this.vertexShader = vertexSource3;
        _this.fragmentShader = THREE23.ShaderChunk.points_frag;
        _this.fog = false;
        _this.uniforms = {
            diffuseColor: new THREE23.Uniform(new THREE23.Color(_HighPrecisionPointMaterial.DEFAULT_COLOR)),
            opacity: new THREE23.Uniform(_HighPrecisionPointMaterial.DEFAULT_OPACITY),
            size: new THREE23.Uniform(_HighPrecisionPointMaterial.DEFAULT_SIZE),
            scale: new THREE23.Uniform(_HighPrecisionPointMaterial.DEFAULT_SCALE),
            map: new THREE23.Uniform(new THREE23.Texture()),
            uvTransform: new THREE23.Uniform(new THREE23.Matrix3()),
            u_mvp: new THREE23.Uniform(new THREE23.Matrix4()),
            u_eyepos: new THREE23.Uniform(new THREE23.Vector3()),
            u_eyepos_lowpart: new THREE23.Uniform(new THREE23.Vector3())
        };
        _this.isHighPrecisionPointMaterial = true;
        if (params !== void 0) {
            if (params.color !== void 0) {
                _this.color.set(params.color);
            }
            if (params.opacity !== void 0) {
                _this.opacity = params.opacity;
            }
            if (params.size !== void 0) {
                _this.size = params.size;
            }
            if (params.scale !== void 0) {
                _this.scale = params.scale;
            }
            if (params.uvTransform !== void 0) {
                _this.uvTransform = params.uvTransform;
            }
            if (params.map !== void 0) {
                _this.map = params.map;
            }
        }
        return _this;
    }
    _createClass(_HighPrecisionPointMaterial, [
        {
            key: "scale",
            get: function get() {
                return this.uniforms.scale.value;
            },
            set: function set(value2) {
                this.uniforms.scale.value = value2;
            }
        },
        {
            key: "uvTransform",
            get: function get() {
                return this.uniforms.uvTransform.value;
            },
            set: function set(value2) {
                this.uniforms.uvTransform.value = value2;
            }
        }
    ]);
    return _HighPrecisionPointMaterial;
}(THREE23.PointsMaterial);
var HighPrecisionPointMaterial = _HighPrecisionPointMaterial;
__publicField(HighPrecisionPointMaterial, "DEFAULT_COLOR", 80);
__publicField(HighPrecisionPointMaterial, "DEFAULT_OPACITY", 1);
__publicField(HighPrecisionPointMaterial, "DEFAULT_SIZE", 1);
__publicField(HighPrecisionPointMaterial, "DEFAULT_SCALE", 1);
function isHighPrecisionPointMaterial(material) {
    return material !== void 0 && material.isHighPrecisionPointMaterial === true;
}
// src/materials/IconMaterial.ts
var THREE24 = __toESM(require("three"));
var vertexSource4 = "\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n}";
var fragmentSource3 = "\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n\n    vec4 color = texture2D(map, vUv.xy);\n    color *= vColor;\n    if (color.a < 0.05) {\n        discard;\n    }\n    gl_FragColor = color;\n}";
var IconMaterial = /*#__PURE__*/ function(RawShaderMaterial2) {
    _inherits(IconMaterial, RawShaderMaterial2);
    var _super = _createSuper(IconMaterial);
    function IconMaterial(params) {
        _classCallCheck(this, IconMaterial);
        var shaderParams = params ? {
            name: "IconMaterial",
            vertexShader: vertexSource4,
            fragmentShader: fragmentSource3,
            uniforms: {
                map: new THREE24.Uniform(params.map)
            },
            depthTest: false,
            depthWrite: false,
            transparent: true,
            vertexColors: true,
            premultipliedAlpha: true,
            rendererCapabilities: params.rendererCapabilities
        } : void 0;
        return _super.call(this, shaderParams);
    }
    _createClass(IconMaterial, [
        {
            key: "map",
            get: function get() {
                return this.uniforms.map.value;
            }
        }
    ]);
    return IconMaterial;
}(RawShaderMaterial2);
// src/materials/LuminosityHighPassShader.ts
var THREE25 = __toESM(require("three"));
var LuminosityHighPassShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        luminosityThreshold: {
            value: 1
        },
        smoothWidth: {
            value: 1
        },
        defaultColor: {
            value: new THREE25.Color(0)
        },
        defaultOpacity: {
            value: 0
        }
    },
    vertexShader: "\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }",
    fragmentShader: "\n    uniform sampler2D tDiffuse;\n    uniform vec3 defaultColor;\n    uniform float defaultOpacity;\n    uniform float luminosityThreshold;\n    uniform float smoothWidth;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        vec3 luma = vec3( 0.299, 0.587, 0.114 );\n        float v = dot( texel.xyz, luma );\n        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n        gl_FragColor = mix( outputColor, texel, alpha );\n    }"
};
// src/materials/MSAAMaterial.ts
var THREE26 = __toESM(require("three"));
var MSAAMaterial = /*#__PURE__*/ function(_ShaderMaterial) {
    _inherits(MSAAMaterial, _ShaderMaterial);
    var _super = _createSuper(MSAAMaterial);
    function MSAAMaterial(uniforms) {
        _classCallCheck(this, MSAAMaterial);
        return _super.call(this, {
            uniforms: uniforms,
            vertexShader: CopyShader.vertexShader,
            fragmentShader: CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: true,
            blending: THREE26.AdditiveBlending,
            depthTest: false,
            depthWrite: false
        });
    }
    return MSAAMaterial;
}(THREE26.ShaderMaterial);
// src/materials/SepiaShader.ts
var SepiaShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        amount: {
            value: 1
        }
    },
    vertexShader: "\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",
    fragmentShader: "\n        uniform float amount;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 color = texture2D( tDiffuse, vUv );\n            vec3 c = color.rgb;\n            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n        }"
};
// src/materials/SkyAtmosphereMaterial.ts
var THREE27 = __toESM(require("three"));
var EQUATORIAL_RADIUS2 = 6378137;
var SkyAtmosphereShader = {
    uniforms: {
        u_eyePositionWorld: new THREE27.Uniform(new THREE27.Vector3()),
        u_lightDirectionWorld: new THREE27.Uniform(new THREE27.Vector3(0, 1, 0)),
        u_modelViewProjection: new THREE27.Uniform(new THREE27.Matrix4()),
        u_atmosphereEnv: new THREE27.Uniform(new THREE27.Vector3(EQUATORIAL_RADIUS2, EQUATORIAL_RADIUS2 * 1.025, 0)),
        u_hsvCorrection: new THREE27.Uniform(new THREE27.Vector3(0, 0, 0)),
        topColor: new THREE27.Uniform(new THREE27.Color(30719)),
        bottomColor: new THREE27.Uniform(new THREE27.Color(16777215)),
        offset: new THREE27.Uniform(33),
        exponent: new THREE27.Uniform(0.6),
        fogColor: new THREE27.Uniform(new THREE27.Color(30719)),
        fogNear: new THREE27.Uniform(new THREE27.Color(30719)),
        fogFar: new THREE27.Uniform(new THREE27.Color(16777215))
    },
    vertexShader: "\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n\n    uniform mat4 u_modelViewProjection;\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_hsvCorrection;\n\n    const float Pi = 3.141592653589793;\n    const float Kr = 0.0025;\n    const float Kr4PI = Kr * 4.0 * Pi;\n    const float Km = 0.0015;\n    const float Km4PI = Km * 4.0 * Pi;\n    const float ESun = 15.0; // should be 15.0\n    const float KmESun = Km * ESun;\n    const float KrESun = Kr * ESun;\n    const vec3 InvWavelength = vec3(\n        5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\n        9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\n        19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\n\n    const int nSamples = 2;\n    const float fSamples = 2.0;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n\n    ".concat(AtmosphereChunks_default.atmosphere_vertex_utils, "\n\n    //\n    // Computes rayleight and mia atmosphere factors for sky.\n    //\n    // Code based on GPU Gems article.\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    //\n    // Further modifications by HERE\n    //\n    AtmosphereColor computeSkyAtmosphere(vec3 v3Pos, vec3 vLightDir)\n    {\n        // Unpack attributes\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        // All that may be const or define(s) at further optimization:\n        float fScale = 1.0 / (fOuterRadius - fInnerRadius);\n        float fScaleOverScaleDepth = (fScale / RayleighScaleDepth);\n        float fCameraHeight2 = fCameraHeight * fCameraHeight;\n        float fOuterRadius2 = fOuterRadius * fOuterRadius;\n\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = v3Pos - u_eyePositionWorld;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n    #ifdef CAMERA_IN_SPACE\n\n        // Calculate the closest intersection of the ray with the outer\n        // atmosphere, this is the first point of the ray passing through the atmosphere dome.\n        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);\n        // Make far relative to first atmosphere intersection\n        fFar -= fNear;\n\n        // Compute the ray's starting position within the atmosphere, then\n        // calculate its scattering offset\n        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;\n\n        float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n        float fStartDepth = exp(-1.0 / RayleighScaleDepth );\n        float fStartOffset = fStartDepth * scale(fStartAngle);\n\n    #else // CAMERA_IN_ATMOSPHERE\n\n        // The ray starts already in atmosphere\n        vec3 v3Start = u_eyePositionWorld;\n        float height = length(v3Start);\n        float depth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n        float fStartAngle = dot(v3Ray, v3Start) / height;\n        float fStartOffset = depth * scale(fStartAngle);\n\n    #endif\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3BaseColor = vec3(0.0);\n        vec3 v3Attenuate = vec3(0.0);\n        for(int i=0; i < nSamples; i++)\n        {\n            float height = length(v3SamplePoint);\n            float depth = exp(fScaleOverScaleDepth * (fInnerRadius - height));\n            float fLightAngle = dot(vLightDir, v3SamplePoint) / height;\n            float fCameraAngle = dot(v3Ray, v3SamplePoint) / height;\n            float fScatter = (fStartOffset + depth * (scale(fLightAngle) - scale(fCameraAngle)));\n            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n            v3BaseColor += v3Attenuate * (depth * fScaledLength);\n            v3SamplePoint += v3SampleRay;\n        }\n\n        // Scale the Mie and Rayleigh colors and set up output of the function\n        AtmosphereColor color;\n        color.mie = v3BaseColor * KmESun;\n        color.rayleigh = v3BaseColor * (InvWavelength * KrESun);\n        return color;\n    }\n\n    void main(void)\n    {\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        AtmosphereColor atmColor = computeSkyAtmosphere(position.xyz, vLightDir);\n        v_mieColor = atmColor.mie;\n        v_rayleighColor = atmColor.rayleigh;\n        v_vertToCamera = u_eyePositionWorld - position.xyz;\n\n        gl_Position = u_modelViewProjection * position;\n    }\n    "),
    fragmentShader: "\n    // Because of harsh light distribution the exposure correction is always enabled for the sky.\n    #define CORRECT_EXPOSURE 1\n\n    precision highp float;\n    precision highp int;\n\n    #ifdef CORRECT_COLOR\n    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness\n    #endif\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    const float g = -0.95;\n    const float g2 = g * g;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n\n    ".concat(AtmosphereChunks_default.atmosphere_fragment_utils, "\n\n    void main(void)\n    {\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n            // Alter alpha based on time of day (0.0 = night , 1.0 = day)\n            float fNightAlpha = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n            float fNightAlpha = 1.0;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        // NOTE:\n        // For better precision normalization may be added on fragment (for mobile devices)\n        // while in vertex shader may be left un-normalized\n        // dot(vLightDir, normalize(v_vertToCamera)) / length(v_vertToCamera);\n        float fCosAngle = dot(vLightDir, v_vertToCamera) / length(v_vertToCamera);\n        float fRayleighPhase = 0.75 * (1.0 + fCosAngle * fCosAngle);\n        float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCosAngle * fCosAngle) / pow(1.0 + g2 - 2.0 * g * fCosAngle, 1.5);\n\n        vec3 cRgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n\n        // Sky produces very harsh lighting effect so exposure correction is always enabled.\n    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)\n        // Exposure factor may be exposed to uniform variable.\n        cRgb = correctExposure(cRgb, 2.0);\n    #endif\n\n    #ifdef CORRECT_COLOR\n        cRgb = correctColor(cRgb, u_hsvCorrection);\n    #endif\n\n        // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)\n        float fAtmosphereAlpha = clamp((fOuterRadius - fCameraHeight) /\n            (fOuterRadius - fInnerRadius), 0.0, 1.0);\n        fAtmosphereAlpha *= pow(fNightAlpha, 0.5);\n\n        gl_FragColor = vec4(cRgb, mix(cRgb.b, 1.0, fAtmosphereAlpha));\n    }\n    ")
};
var SkyAtmosphereMaterial = /*#__PURE__*/ function(RawShaderMaterial2) {
    _inherits(SkyAtmosphereMaterial, RawShaderMaterial2);
    var _super = _createSuper(SkyAtmosphereMaterial);
    function SkyAtmosphereMaterial(params) {
        _classCallCheck(this, SkyAtmosphereMaterial);
        var shaderParams;
        if (params) {
            var defines = {};
            defines.CAMERA_IN_SPACE = "";
            shaderParams = {
                name: "SkyAtmosphereMaterial",
                vertexShader: SkyAtmosphereShader.vertexShader,
                fragmentShader: SkyAtmosphereShader.fragmentShader,
                uniforms: SkyAtmosphereShader.uniforms,
                transparent: true,
                depthTest: true,
                depthWrite: false,
                side: THREE27.BackSide,
                blending: THREE27.NormalBlending,
                fog: false,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        return _super.call(this, shaderParams);
    }
    _createClass(SkyAtmosphereMaterial, [
        {
            key: "setDynamicLighting",
            value: function setDynamicLighting(enableLighting) {
                setShaderMaterialDefine(this, "DYNAMIC_LIGHT", enableLighting);
            }
        },
        {
            key: "outerRadius",
            get: function get() {
                return this.uniforms.u_atmosphereEnv.value.y;
            },
            set: function set(radius) {
                this.uniforms.u_atmosphereEnv.value.y = radius;
            }
        },
        {
            key: "innerRadius",
            get: function get() {
                return this.uniforms.u_atmosphereEnv.value.x;
            },
            set: function set(radius) {
                this.uniforms.u_atmosphereEnv.value.x = radius;
            }
        },
        {
            key: "updateUniforms",
            value: function updateUniforms(shaderMaterial, object, camera, lightDirection) {
                var cameraInfo = this.getCameraInfo(object, camera);
                if (shaderMaterial !== void 0 && shaderMaterial.isMaterial) {
                    if (shaderMaterial.uniforms && shaderMaterial.uniforms.u_atmosphereEnv && shaderMaterial.uniforms.u_hsvCorrection && shaderMaterial.uniforms.u_eyePositionWorld && shaderMaterial.uniforms.u_modelViewProjection && shaderMaterial.uniforms.u_lightDirectionWorld) {
                        var eyePos = cameraInfo.eyePos;
                        var mvp = cameraInfo.modelViewProjection;
                        var cameraHeight = cameraInfo.eyeHeight;
                        shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);
                        shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);
                        shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;
                        shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();
                        var cameraInSpace = cameraHeight > this.outerRadius;
                        var needsUpdate0 = setShaderDefine(shaderMaterial.defines, "CAMERA_IN_SPACE", cameraInSpace);
                        var needsUpdate1 = setShaderDefine(shaderMaterial.defines, "CAMERA_IN_ATMOSPHERE", !cameraInSpace);
                        shaderMaterial.needsUpdate = shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;
                    } else {
                        throw Error("Atmosphere material has missing uniforms");
                    }
                } else {
                    throw Error("Wrong object used, only Material objects are supported");
                }
            }
        },
        {
            key: "getCameraInfo",
            value: function getCameraInfo(object, camera) {
                var reverse = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (reverse) {
                    var modelMatrix = new THREE27.Matrix4().identity();
                    var viewMatrix = new THREE27.Matrix4().copy(object.matrixWorld).invert().transpose();
                    var projectionMatrix = camera.projectionMatrix;
                    var mvpMatrix = new THREE27.Matrix4();
                    mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
                    mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
                    var eyePos = new THREE27.Vector3();
                    object.getWorldPosition(eyePos);
                    var objectPos = new THREE27.Vector3();
                    camera.getWorldPosition(objectPos);
                    var eyeHeight = objectPos.distanceTo(eyePos);
                    return {
                        modelViewProjection: mvpMatrix,
                        eyePos: eyePos,
                        eyeHeight: eyeHeight
                    };
                } else {
                    var modelMatrix1 = object.matrixWorld;
                    var viewMatrix1 = camera.matrixWorldInverse;
                    var projectionMatrix1 = camera.projectionMatrix;
                    var mvpMatrix1 = new THREE27.Matrix4();
                    mvpMatrix1.multiplyMatrices(viewMatrix1, modelMatrix1);
                    mvpMatrix1.multiplyMatrices(projectionMatrix1, mvpMatrix1);
                    var eyePos1 = new THREE27.Vector3();
                    camera.getWorldPosition(eyePos1);
                    var objectPos1 = new THREE27.Vector3();
                    object.getWorldPosition(objectPos1);
                    var eyeHeight1 = objectPos1.distanceTo(eyePos1);
                    eyePos1.sub(objectPos1);
                    return {
                        modelViewProjection: mvpMatrix1,
                        eyePos: eyePos1,
                        eyeHeight: eyeHeight1
                    };
                }
            }
        }
    ]);
    return SkyAtmosphereMaterial;
}(RawShaderMaterial2);
// src/materials/SolidLineMaterial.ts
var THREE28 = __toESM(require("three"));
var LineCapsDefinesMapping = {
    None: 0 /* CAPS_NONE */ ,
    Square: 1 /* CAPS_SQUARE */ ,
    Round: 2 /* CAPS_ROUND */ ,
    TriangleIn: 3 /* CAPS_TRIANGLE_IN */ ,
    TriangleOut: 4 /* CAPS_TRIANGLE_OUT */ 
};
var DefinesLineCapsMapping = Object.keys(LineCapsDefinesMapping).reduce(function(r, lineCapsName) {
    var defineKey = lineCapsName;
    var defineValue = LineCapsDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
var LineDashesDefinesMapping = {
    Square: 0 /* DASHES_SQUARE */ ,
    Round: 1 /* DASHES_ROUND */ ,
    Diamond: 2 /* DASHES_DIAMOND */ 
};
var DefinesLineDashesMapping = Object.keys(LineDashesDefinesMapping).reduce(function(r, lineDashesName) {
    var defineKey = lineDashesName;
    var defineValue = LineDashesDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
var tmpColor2 = new THREE28.Color();
var vertexSource5 = "\n#define SEGMENT_OFFSET 0.1\n\nattribute vec3 extrusionCoord;\nattribute vec3 position;\nattribute vec4 biTangent;\nattribute vec3 tangent;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float extrusionWidth;\nuniform float outlineWidth;\nuniform float offset;\nuniform vec2 drawRange;\n\n#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\n#endif\n\n#ifdef USE_TILE_CLIP\nvarying vec3 vPosition;\n#endif\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nattribute vec3 color;\nvarying vec3 vColor;\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\n#include <fog_pars_vertex>\n\n#include <extrude_line_vert_func>\n\nvoid main() {\n    // Calculate the segment.\n    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;\n    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;\n\n    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.\n    float linePos = mix(segment.x, segment.y, segmentPos);\n    vec2 extrusionDir = sign(extrusionCoord.xy);\n    // Precompute to avoid computing multiple times\n    float tanHalfAngle = tan(biTangent.w / 2.0);\n    float extrusionFactor = extrusionDir.y * tanHalfAngle;\n\n    // Calculate the extruded vertex position (and scale the extrusion direction).\n    vec3 pos = extrudeLine(\n        position, linePos, extrusionWidth + outlineWidth, biTangent, tangent, tanHalfAngle,\n        extrusionDir);\n\n    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).\n    vRange = vec3(extrusionCoord.z, extrusionWidth, extrusionFactor);\n    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);\n\n    // Adjust the segment to fit the drawRange.\n    float capDist = (extrusionWidth + outlineWidth) / extrusionCoord.z;\n    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {\n        vCoords.zw += 1.0;\n    }\n    if (vCoords.z < drawRange.x) {\n        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);\n    }\n    if (vCoords.w > drawRange.y) {\n        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);\n    }\n\n    // Transform position.\n    #ifdef USE_DISPLACEMENTMAP\n    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    // Shift the line based on the offset, where the bitangent is the cross product of the average\n    // of the two direction vectors (the previous and next segment directions) and the normal of\n    // the line (facing into the sky). The w component is the angle between the two segments.\n    // Note, we need to take the angle into consideration, so we use trigonometry to calculate how\n    // much we need to extend the offset. Note, orthough this looks complicated we are doing this\n    // in the vertex shader, so it should not cause a performance issue.\n    pos += biTangent.xyz * offset * sqrt(1.0 + pow(abs(tanHalfAngle), 2.0));\n\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Pass extruded position to fragment shader.\n    #ifdef USE_TILE_CLIP\n    vPosition = pos;\n    #endif\n\n    #ifdef USE_COLOR\n    // Pass vertex color to fragment shader.\n    vColor = color;\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n\n    #include <fog_vertex>\n}";
var fragmentSource4 = "\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuseColor;\nuniform vec3 outlineColor;\nuniform float opacity;\nuniform float extrusionWidth;\nuniform float outlineWidth;\nuniform vec2 tileSize;\nuniform vec2 drawRange;\n\n#ifdef USE_DASHED_LINE\nuniform float dashSize;\nuniform float gapSize;\nuniform vec3 dashColor;\n\n#define DASHES_SQUARE ".concat(0 /* DASHES_SQUARE */ , "\n#define DASHES_ROUND ", 1 /* DASHES_ROUND */ , "\n#define DASHES_DIAMOND ", 2 /* DASHES_DIAMOND */ , "\n#endif\n\n#ifdef USE_TILE_CLIP\nvarying vec3 vPosition;\n#endif\n\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\n#include <round_edges_and_add_caps>\n#include <tile_clip_func>\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\n#include <fog_pars_fragment>\n\nvoid main() {\n    float alpha = opacity;\n    vec3 outputDiffuse = diffuseColor;\n\n    #ifdef USE_TILE_CLIP\n    tileClip(vPosition.xy, tileSize);\n    #endif\n\n    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).\n    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);\n    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).\n    float distToEdge = distToCenter - (extrusionWidth + outlineWidth) / extrusionWidth;\n\n    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope\n    // of distToChange increases (i.e. the line is further away).\n    float width = fwidth(distToEdge);\n\n    float s = opacity < 0.98\n        ? clamp((distToEdge + width) / (2.0 * width), 0.0, 1.0) // prefer a boxstep\n        : smoothstep(-width, width, distToEdge);\n\n    if (opacity < 0.98 && 1.0 - s < opacity) {\n        // drop the fragment when the line is using opacity.\n        discard;\n    }\n\n    alpha *= 1.0 - s;\n\n    #ifdef USE_DASHED_LINE\n    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).\n    float d = dashSize / vRange.x;\n    float g = gapSize / vRange.x;\n    float distToDashOrigin = mod(vCoords.x, d + g) / d;\n\n    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the\n    // dashBlendFactor similarly on how we did it for the line opacity.\n    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);\n    #if DASHES_MODE == DASHES_ROUND\n    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));\n    #elif DASHES_MODE == DASHES_DIAMOND\n    distToDashEdge -= distToCenter * 0.5;\n    #endif\n    float dashWidth = fwidth(distToDashEdge);\n    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);\n\n    #ifdef USE_DASH_COLOR\n    outputDiffuse = mix(diffuseColor, dashColor, dashBlendFactor);\n    #endif\n    #endif\n\n    #ifdef USE_OUTLINE\n    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and\n    // compute the outlineBlendFactor (used to mix line and outline colors).\n    float distToOutline = distToCenter - 1.0;\n    float outlineWidth = fwidth(distToOutline);\n    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);\n\n    // Mix the colors using the different computed factors.\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);\n    outputDiffuse = mix(\n      mix(\n        mix(outlineColor, diffuseColor, colorBlendFactor),\n        outputDiffuse,\n        dashBlendFactor\n      ),\n      outlineColor,\n      outlineBlendFactor\n    );\n    #else\n    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);\n    #endif\n    #endif\n\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    // Multiply the alpha by the dashBlendFactor.\n    #if defined(USE_OUTLINE)\n    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);\n    #else\n    alpha *= 1.0 - dashBlendFactor;\n    #endif\n    #endif\n\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( outputDiffuse * vColor, alpha );\n    #else\n    gl_FragColor = vec4( outputDiffuse, alpha );\n    #endif\n\n    #include <fog_fragment>\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n\n\n}");
var _SolidLineMaterial = /*#__PURE__*/ function(RawShaderMaterial2) {
    _inherits(_SolidLineMaterial, RawShaderMaterial2);
    var _super = _createSuper(_SolidLineMaterial);
    function _SolidLineMaterial(params) {
        _classCallCheck(this, _SolidLineMaterial);
        var _this;
        Object.assign(THREE28.ShaderChunk, LinesChunks_default);
        FadingFeature.patchGlobalShaderChunks();
        var defines = {
            CAPS_MODE: 2 /* CAPS_ROUND */ ,
            DASHES_MODE: 0 /* DASHES_SQUARE */ 
        };
        var fogParam = true;
        var opacityParam = 1;
        var displacementMap;
        var shaderParams;
        if (params) {
            fogParam = params.fog === true;
            if (fogParam) {
                setShaderDefine(defines, "USE_FOG", true);
            }
            opacityParam = params.opacity !== void 0 ? params.opacity : opacityParam;
            displacementMap = params.displacementMap;
            if (displacementMap !== void 0) {
                setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
            }
            var hasOutline = params.outlineWidth !== void 0 && params.outlineWidth > 0;
            if (hasOutline) {
                setShaderDefine(defines, "USE_OUTLINE", true);
            }
            shaderParams = {
                name: "SolidLineMaterial",
                vertexShader: vertexSource5,
                fragmentShader: fragmentSource4,
                uniforms: THREE28.UniformsUtils.merge([
                    {
                        diffuseColor: new THREE28.Uniform(new THREE28.Color(_SolidLineMaterial.DEFAULT_COLOR)),
                        dashColor: new THREE28.Uniform(new THREE28.Color(_SolidLineMaterial.DEFAULT_COLOR)),
                        outlineColor: new THREE28.Uniform(new THREE28.Color(_SolidLineMaterial.DEFAULT_COLOR)),
                        extrusionWidth: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_WIDTH),
                        outlineWidth: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),
                        offset: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_OFFSET),
                        opacity: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_OPACITY),
                        tileSize: new THREE28.Uniform(new THREE28.Vector2()),
                        fadeNear: new THREE28.Uniform(FadingFeature.DEFAULT_FADE_NEAR),
                        fadeFar: new THREE28.Uniform(FadingFeature.DEFAULT_FADE_FAR),
                        displacementMap: new THREE28.Uniform(displacementMap !== void 0 ? displacementMap : new THREE28.Texture()),
                        drawRange: new THREE28.Uniform(new THREE28.Vector2(_SolidLineMaterial.DEFAULT_DRAW_RANGE_START, _SolidLineMaterial.DEFAULT_DRAW_RANGE_END)),
                        dashSize: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_DASH_SIZE),
                        gapSize: new THREE28.Uniform(_SolidLineMaterial.DEFAULT_GAP_SIZE)
                    },
                    THREE28.UniformsLib.fog
                ]),
                defines: defines,
                opacity: opacityParam,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        _this = _super.call(this, shaderParams);
        _this.fog = fogParam;
        _this.setOpacity(opacityParam);
        _this.stencilFunc = THREE28.NotEqualStencilFunc;
        _this.stencilZPass = THREE28.ReplaceStencilOp;
        _this.stencilRef = 1;
        _this.stencilWrite = false;
        enforceBlending(_assertThisInitialized(_this));
        _this.extensions.derivatives = true;
        if (params) {
            if (params.color !== void 0) {
                tmpColor2.set(params.color);
                _this.color = tmpColor2;
            }
            if (params.outlineColor !== void 0) {
                tmpColor2.set(params.outlineColor);
                _this.outlineColor = tmpColor2;
            }
            if (params.lineWidth !== void 0) {
                _this.lineWidth = params.lineWidth;
            }
            if (params.outlineWidth !== void 0) {
                _this.outlineWidth = params.outlineWidth;
            }
            if (params.opacity !== void 0) {
                _this.setOpacity(params.opacity);
            }
            if (params.depthTest !== void 0) {
                _this.depthTest = params.depthTest;
            }
            if (params.depthWrite !== void 0) {
                _this.depthWrite = params.depthWrite;
            }
            if (params.fadeNear !== void 0) {
                _this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== void 0) {
                _this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== void 0) {
                _this.displacementMap = params.displacementMap;
            }
            if (params.caps !== void 0) {
                _this.caps = params.caps;
            }
            if (params.drawRangeStart !== void 0) {
                _this.drawRangeStart = params.drawRangeStart;
            }
            if (params.drawRangeEnd !== void 0) {
                _this.drawRangeEnd = params.drawRangeEnd;
            }
            if (params.dashes !== void 0) {
                _this.dashes = params.dashes;
            }
            if (params.dashColor !== void 0) {
                tmpColor2.set(params.dashColor);
                _this.dashColor = tmpColor2;
            }
            if (params.dashSize !== void 0) {
                _this.dashSize = params.dashSize;
            }
            if (params.gapSize !== void 0) {
                _this.gapSize = params.gapSize;
            }
            if (params.fog !== void 0) {
                _this.fog = params.fog;
                _this.invalidateFog();
            }
            var _offset;
            _this.offset = (_offset = params.offset) !== null && _offset !== void 0 ? _offset : 0;
        }
        return _this;
    }
    _createClass(_SolidLineMaterial, [
        {
            key: "offset",
            get: function get() {
                return this.uniforms.offset.value;
            },
            set: function set(offset) {
                this.uniforms.offset.value = offset;
            }
        },
        {
            key: "outline",
            get: function get() {
                return getShaderMaterialDefine(this, "USE_OUTLINE") === true;
            },
            set: function set(enable) {
                setShaderMaterialDefine(this, "USE_OUTLINE", enable);
            }
        },
        {
            key: "setOpacity",
            value: function setOpacity(opacity) {
                _get(_getPrototypeOf(_SolidLineMaterial.prototype), "setOpacity", this).call(this, opacity);
                if (opacity !== void 0) {
                    this.stencilWrite = opacity < 0.98;
                }
            }
        },
        {
            key: "color",
            get: function get() {
                return this.uniforms.diffuseColor.value;
            },
            set: function set(value2) {
                this.uniforms.diffuseColor.value.copy(value2);
            }
        },
        {
            key: "outlineColor",
            get: function get() {
                return this.uniforms.outlineColor.value;
            },
            set: function set(value2) {
                this.uniforms.outlineColor.value.copy(value2);
            }
        },
        {
            key: "dashColor",
            get: function get() {
                return this.uniforms.dashColor.value;
            },
            set: function set(value2) {
                this.uniforms.dashColor.value.copy(value2);
                setShaderMaterialDefine(this, "USE_DASH_COLOR", true);
            }
        },
        {
            key: "lineWidth",
            get: function get() {
                return this.uniforms.extrusionWidth.value * 2;
            },
            set: function set(value2) {
                this.uniforms.extrusionWidth.value = value2 / 2;
            }
        },
        {
            key: "outlineWidth",
            get: function get() {
                return this.uniforms.outlineWidth.value;
            },
            set: function set(value2) {
                this.uniforms.outlineWidth.value = value2;
                this.outline = value2 > 0;
            }
        },
        {
            key: "dashSize",
            get: function get() {
                return this.uniforms.dashSize.value;
            },
            set: function set(value2) {
                this.uniforms.dashSize.value = value2;
            }
        },
        {
            key: "gapSize",
            get: function get() {
                return this.uniforms.gapSize.value;
            },
            set: function set(value2) {
                var ref, ref1;
                this.uniforms.gapSize.value = value2;
                setShaderMaterialDefine(this, "USE_DASHED_LINE", value2 > 0);
                if (((ref = this.uniforms) === null || ref === void 0 ? void 0 : (ref1 = ref.gapSize) === null || ref1 === void 0 ? void 0 : ref1.value) === 0) {
                    this.stencilWrite = this.opacity < 0.98;
                }
            }
        },
        {
            key: "caps",
            get: function get() {
                var result = "Round";
                var capsMode = getShaderMaterialDefine(this, "CAPS_MODE");
                if (typeof capsMode === "number" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {
                    result = DefinesLineCapsMapping[capsMode];
                }
                return result;
            },
            set: function set(value2) {
                if (LineCapsDefinesMapping.hasOwnProperty(value2)) {
                    setShaderMaterialDefine(this, "CAPS_MODE", LineCapsDefinesMapping[value2]);
                }
            }
        },
        {
            key: "dashes",
            get: function get() {
                var result = "Square";
                var dashesMode = getShaderMaterialDefine(this, "DASHES_MODE");
                if (typeof dashesMode === "number" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {
                    result = DefinesLineDashesMapping[dashesMode];
                }
                return result;
            },
            set: function set(value2) {
                if (LineDashesDefinesMapping.hasOwnProperty(value2)) {
                    setShaderMaterialDefine(this, "DASHES_MODE", LineDashesDefinesMapping[value2]);
                }
            }
        },
        {
            key: "fadeNear",
            get: function get() {
                return this.uniforms.fadeNear.value;
            },
            set: function set(value2) {
                this.uniforms.fadeNear.value = value2;
            }
        },
        {
            key: "fadeFar",
            get: function get() {
                return this.uniforms.fadeFar.value;
            },
            set: function set(value2) {
                this.uniforms.fadeFar.value = value2;
                setShaderMaterialDefine(this, "USE_FADING", value2 > 0);
            }
        },
        {
            key: "displacementMap",
            get: function get() {
                return this.uniforms.displacementMap.value;
            },
            set: function set(map) {
                if (this.uniforms.displacementMap.value === map) {
                    return;
                }
                this.uniforms.displacementMap.value = map;
                var useDisplacementMap = map !== null;
                if (useDisplacementMap) {
                    this.uniforms.displacementMap.value.needsUpdate = true;
                }
                setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
            }
        },
        {
            key: "drawRangeStart",
            get: function get() {
                return this.uniforms.drawRange.value.x;
            },
            set: function set(value2) {
                this.uniforms.drawRange.value.x = value2;
            }
        },
        {
            key: "drawRangeEnd",
            get: function get() {
                return this.uniforms.drawRange.value.y;
            },
            set: function set(value2) {
                this.uniforms.drawRange.value.y = value2;
            }
        },
        {
            key: "clipTileSize",
            get: function get() {
                return this.uniforms.tileSize.value;
            },
            set: function set(tileSize) {
                this.uniforms.tileSize.value.copy(tileSize);
                var useTileClip = tileSize.x > 0 && tileSize.y > 0;
                setShaderMaterialDefine(this, "USE_TILE_CLIP", useTileClip);
            }
        },
        {
            key: "copy",
            value: function copy(other) {
                _get(_getPrototypeOf(_SolidLineMaterial.prototype), "copy", this).call(this, other);
                this.invalidateFog();
                this.setOpacity(other.opacity);
                return this;
            }
        }
    ]);
    return _SolidLineMaterial;
}(RawShaderMaterial2);
var SolidLineMaterial = _SolidLineMaterial;
__publicField(SolidLineMaterial, "DEFAULT_COLOR", 16711680);
__publicField(SolidLineMaterial, "DEFAULT_WIDTH", 1);
__publicField(SolidLineMaterial, "DEFAULT_OUTLINE_WIDTH", 0);
__publicField(SolidLineMaterial, "DEFAULT_OPACITY", 1);
__publicField(SolidLineMaterial, "DEFAULT_DRAW_RANGE_START", 0);
__publicField(SolidLineMaterial, "DEFAULT_DRAW_RANGE_END", 1);
__publicField(SolidLineMaterial, "DEFAULT_DASH_SIZE", 1);
__publicField(SolidLineMaterial, "DEFAULT_GAP_SIZE", 1);
__publicField(SolidLineMaterial, "DEFAULT_OFFSET", 0);
// src/materials/VignetteShader.ts
var VignetteShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        offset: {
            value: 1
        },
        darkness: {
            value: 1
        }
    },
    vertexShader: "\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",
    fragmentShader: "\n        uniform float offset;\n        uniform float darkness;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 texel = texture2D( tDiffuse, vUv );\n            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n        }"
};
// src/mapview/AnimatedExtrusionHandler.ts
var AnimatedExtrusionState = /* @__PURE__ */ function(AnimatedExtrusionState2) {
    AnimatedExtrusionState2[AnimatedExtrusionState2["None"] = 0] = "None";
    AnimatedExtrusionState2[AnimatedExtrusionState2["Started"] = 1] = "Started";
    AnimatedExtrusionState2[AnimatedExtrusionState2["Finished"] = 2] = "Finished";
    return AnimatedExtrusionState2;
}(AnimatedExtrusionState || {});
var DEFAULT_EXTRUSION_DURATION = 750;
var DEFAULT_MIN_ZOOM_LEVEL = 1;
var AnimatedExtrusionHandler = /*#__PURE__*/ function() {
    function AnimatedExtrusionHandler(m_mapView) {
        _classCallCheck(this, AnimatedExtrusionHandler);
        this.m_mapView = m_mapView;
        __publicField(this, "enabled", true);
        __publicField(this, "duration", DEFAULT_EXTRUSION_DURATION);
        __publicField(this, "m_minZoomLevel", DEFAULT_MIN_ZOOM_LEVEL);
        __publicField(this, "m_forceEnabled", false);
        __publicField(this, "m_dataSourceMap", /* @__PURE__ */ new Map());
        __publicField(this, "m_state", 0 /* None */ );
        __publicField(this, "m_startTime", -1);
    }
    _createClass(AnimatedExtrusionHandler, [
        {
            key: "forceEnabled",
            get: function get() {
                return this.m_forceEnabled;
            },
            set: function set(force) {
                this.m_forceEnabled = force;
                this.duration = DEFAULT_EXTRUSION_DURATION;
            }
        },
        {
            key: "minZoomLevel",
            get: function get() {
                return this.m_minZoomLevel;
            }
        },
        {
            key: "setAnimationProperties",
            value: function setAnimationProperties(technique, env) {
                if (!isExtrudedPolygonTechnique(technique)) {
                    return false;
                }
                if (technique.hasOwnProperty("minZoomLevel")) {
                    this.m_minZoomLevel = technique.minZoomLevel;
                }
                if (this.forceEnabled) {
                    return this.enabled;
                }
                if (technique.animateExtrusionDuration !== void 0) {
                    this.duration = technique.animateExtrusionDuration;
                }
                var animateExtrusionValue = getPropertyValue(technique.animateExtrusion, env);
                if (animateExtrusionValue === null) {
                    return this.enabled;
                }
                return typeof animateExtrusionValue === "boolean" ? animateExtrusionValue : typeof animateExtrusionValue === "number" ? animateExtrusionValue !== 0 : false;
            }
        },
        {
            key: "update",
            value: function update(zoomLevel) {
                var extrusionVisible = this.m_dataSourceMap.size > 0 && zoomLevel >= this.m_minZoomLevel;
                if (this.m_state === 0 /* None */  && extrusionVisible) {
                    this.m_state = 1 /* Started */ ;
                } else if (this.m_state !== 0 /* None */  && !extrusionVisible) {
                    this.resetAnimation(true);
                }
                this.animateExtrusion();
            }
        },
        {
            key: "add",
            value: function add(tile, materials) {
                tile.addDisposeCallback(this.removeTile.bind(this));
                var animated = false;
                if (this.m_state !== 0 /* None */ ) {
                    animated = this.skipAnimation(tile);
                    if (animated) {
                        this.setTileExtrusionRatio(materials, 1);
                    } else if (this.m_state === 2 /* Finished */ ) {
                        this.resetAnimation(false);
                    }
                }
                this.getOrCreateTileMap(tile.dataSource).set(tile.tileKey.mortonCode(), {
                    materials: materials,
                    animated: animated
                });
            }
        },
        {
            key: "isAnimating",
            get: function get() {
                return this.m_state !== 2 /* Finished */  && this.m_state !== 0 /* None */ ;
            }
        },
        {
            key: "getTileMap",
            value: function getTileMap(dataSource) {
                var create = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                return this.m_dataSourceMap.get(dataSource);
            }
        },
        {
            key: "getOrCreateTileMap",
            value: function getOrCreateTileMap(dataSource) {
                var tileMap = this.m_dataSourceMap.get(dataSource);
                if (!tileMap) {
                    tileMap = /* @__PURE__ */ new Map();
                    this.m_dataSourceMap.set(dataSource, tileMap);
                }
                return tileMap;
            }
        },
        {
            key: "skipAnimation",
            value: function skipAnimation(tile) {
                return this.wasAnyAncestorAnimated(tile) || this.wasAnyDescendantAnimated(tile);
            }
        },
        {
            key: "wasAnyAncestorAnimated",
            value: function wasAnyAncestorAnimated(tile) {
                var minLevel = tile.dataSource.getDataZoomLevel(this.m_minZoomLevel);
                var distanceToMinLevel = Math.max(0, tile.tileKey.level - minLevel);
                var levelsUp = Math.min(distanceToMinLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceUp);
                var tileMap = this.getTileMap(tile.dataSource);
                if (!tileMap) {
                    return false;
                }
                var lastTileKey = tile.tileKey;
                for(var deltaUp = 1; deltaUp <= levelsUp; ++deltaUp){
                    var ref;
                    lastTileKey = lastTileKey.parent();
                    var ref1;
                    if ((ref1 = (ref = tileMap.get(lastTileKey.mortonCode())) === null || ref === void 0 ? void 0 : ref.animated) !== null && ref1 !== void 0 ? ref1 : false) {
                        return true;
                    }
                }
                return false;
            }
        },
        {
            key: "wasAnyDescendantAnimated",
            value: function wasAnyDescendantAnimated(tile) {
                var distanceToMaxLevel = tile.dataSource.maxDataLevel - tile.tileKey.level;
                var levelsDown = Math.min(distanceToMaxLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceDown);
                var tileMap = this.getTileMap(tile.dataSource);
                if (!tileMap) {
                    return false;
                }
                var tilingScheme = tile.dataSource.getTilingScheme();
                var nextTileKeys = [
                    tile.tileKey
                ];
                var childTileKeys = [];
                for(var deltaDown = 1; deltaDown <= levelsDown; ++deltaDown){
                    childTileKeys.length = 0;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = nextTileKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var tileKey = _step.value;
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = tilingScheme.getSubTileKeys(tileKey)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var childTileKey = _step1.value;
                                    var ref;
                                    var ref1;
                                    if ((ref1 = (ref = tileMap.get(childTileKey.mortonCode())) === null || ref === void 0 ? void 0 : ref.animated) !== null && ref1 !== void 0 ? ref1 : false) {
                                        return true;
                                    }
                                    childTileKeys.push(childTileKey);
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    ;
                    var ref2;
                    ref2 = [
                        childTileKeys,
                        nextTileKeys
                    ], nextTileKeys = ref2[0], childTileKeys = ref2[1], ref2;
                }
                return false;
            }
        },
        {
            key: "removeTile",
            value: function removeTile(tile) {
                var tileMap = this.getTileMap(tile.dataSource);
                if (!tileMap) {
                    return;
                }
                tileMap.delete(tile.tileKey.mortonCode());
                if (tileMap.size === 0) {
                    this.m_dataSourceMap.delete(tile.dataSource);
                }
            }
        },
        {
            key: "animateExtrusion",
            value: function animateExtrusion() {
                if (this.m_state !== 1 /* Started */ ) {
                    return;
                }
                var currentTime = Date.now();
                if (this.m_startTime < 0) {
                    this.m_startTime = currentTime;
                }
                var duration = this.duration;
                var timeProgress = Math.min(currentTime - this.m_startTime, duration);
                var extrusionRatio = MathUtils.easeInOutCubic(ExtrusionFeatureDefs.DEFAULT_RATIO_MIN, ExtrusionFeatureDefs.DEFAULT_RATIO_MAX, timeProgress / duration);
                this.setExtrusionRatio(extrusionRatio);
                if (timeProgress >= duration) {
                    this.m_state = 2 /* Finished */ ;
                }
                this.m_mapView.update();
            }
        },
        {
            key: "resetAnimation",
            value: function resetAnimation(resetTiles) {
                this.m_state = 0 /* None */ ;
                this.m_startTime = -1;
                if (resetTiles) {
                    this.m_dataSourceMap.forEach(function(tileMap) {
                        tileMap.forEach(function(state) {
                            state.animated = false;
                        });
                    });
                }
            }
        },
        {
            key: "setExtrusionRatio",
            value: function setExtrusionRatio(value2) {
                var _this = this;
                this.m_dataSourceMap.forEach(function(tileMap) {
                    tileMap.forEach(function(state) {
                        if (!state.animated) {
                            _this.setTileExtrusionRatio(state.materials, value2);
                            if (value2 >= 1) {
                                state.animated = true;
                            }
                        }
                    });
                });
            }
        },
        {
            key: "setTileExtrusionRatio",
            value: function setTileExtrusionRatio(materials, value2) {
                materials.forEach(function(material) {
                    material.extrusionRatio = value2;
                });
            }
        }
    ]);
    return AnimatedExtrusionHandler;
}();
// src/mapview/ITileLoader.ts
var TileLoaderState = /* @__PURE__ */ function(TileLoaderState2) {
    TileLoaderState2[TileLoaderState2["Initialized"] = 0] = "Initialized";
    TileLoaderState2[TileLoaderState2["Loading"] = 1] = "Loading";
    TileLoaderState2[TileLoaderState2["Loaded"] = 2] = "Loaded";
    TileLoaderState2[TileLoaderState2["Decoding"] = 3] = "Decoding";
    TileLoaderState2[TileLoaderState2["Ready"] = 4] = "Ready";
    TileLoaderState2[TileLoaderState2["Canceled"] = 5] = "Canceled";
    TileLoaderState2[TileLoaderState2["Failed"] = 6] = "Failed";
    return TileLoaderState2;
}(TileLoaderState || {});
// src/mapview/BaseTileLoader.ts
var logger2 = LoggerManager.instance.create("BaseTileLoader");
var BaseTileLoader = /*#__PURE__*/ function() {
    function BaseTileLoader(dataSource, tileKey) {
        _classCallCheck(this, BaseTileLoader);
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        __publicField(this, "state", 0 /* Initialized */ );
        __publicField(this, "error");
        __publicField(this, "m_priority", 0);
        __publicField(this, "loadAbortController", new AbortController());
        __publicField(this, "donePromise");
        __publicField(this, "resolveDonePromise");
        __publicField(this, "rejectedDonePromise");
    }
    _createClass(BaseTileLoader, [
        {
            key: "priority",
            get: function get() {
                return this.m_priority;
            },
            set: function set(value2) {
                this.m_priority = value2;
            }
        },
        {
            key: "loadAndDecode",
            value: function loadAndDecode() {
                switch(this.state){
                    case 1 /* Loading */ :
                    case 2 /* Loaded */ :
                    case 3 /* Decoding */ :
                        return this.donePromise;
                    case 4 /* Ready */ :
                    case 6 /* Failed */ :
                    case 0 /* Initialized */ :
                    case 5 /* Canceled */ :
                        this.load();
                        return this.donePromise;
                }
            }
        },
        {
            key: "waitSettled",
            value: function waitSettled() {
                if (!this.donePromise) {
                    return Promise.resolve(this.state);
                }
                return this.donePromise;
            }
        },
        {
            key: "cancel",
            value: function cancel() {
                if (this.state === 1 /* Loading */ ) {
                    this.loadAbortController.abort();
                    this.loadAbortController = new AbortController();
                }
                this.cancelImpl();
                this.onDone(5 /* Canceled */ );
            }
        },
        {
            key: "isFinished",
            get: function get() {
                return this.state === 4 /* Ready */  || this.state === 5 /* Canceled */  || this.state === 6 /* Failed */ ;
            }
        },
        {
            key: "cancelImpl",
            value: function cancelImpl() {}
        },
        {
            key: "load",
            value: function load() {
                var _this = this;
                this.loadImpl(this.loadAbortController.signal, this.onDone.bind(this), this.onError.bind(this));
                if (this.donePromise === void 0) {
                    this.donePromise = new Promise(function(resolve, reject) {
                        _this.resolveDonePromise = resolve;
                        _this.rejectedDonePromise = reject;
                    });
                }
                this.state = 1 /* Loading */ ;
            }
        },
        {
            key: "onDone",
            value: function onDone(doneState) {
                if (this.resolveDonePromise && doneState === 4 /* Ready */ ) {
                    this.resolveDonePromise(doneState);
                } else if (this.rejectedDonePromise) {
                    this.rejectedDonePromise(doneState);
                }
                this.resolveDonePromise = void 0;
                this.rejectedDonePromise = void 0;
                this.donePromise = void 0;
                this.state = doneState;
            }
        },
        {
            key: "onError",
            value: function onError(error) {
                if (this.state === 5 /* Canceled */ ) {
                    return;
                }
                var dataSource = this.dataSource;
                logger2.error("[".concat(dataSource.name, "]: failed to load tile ").concat(this.tileKey.mortonCode()), error);
                this.error = error;
                this.onDone(6 /* Failed */ );
            }
        }
    ]);
    return BaseTileLoader;
}();
// src/mapview/PlaneViewBounds.ts
var import_three14 = require("three");
// src/mapview/Utils.ts
var THREE97 = __toESM(require("three"));
// src/mapview/CameraUtils.ts
var THREE30 = __toESM(require("three"));
// src/mapview/FovCalculation.ts
var THREE29 = __toESM(require("three"));
var DEFAULT_FOV_CALCULATION = {
    type: "dynamic",
    fov: 40
};
var MIN_FOV_DEG = 10;
var MAX_FOV_DEG = 140;
var MIN_FOV_RAD = THREE29.MathUtils.degToRad(MIN_FOV_DEG);
var MAX_FOV_RAD = THREE29.MathUtils.degToRad(MAX_FOV_DEG);
// src/mapview/CameraUtils.ts
function isCenteredProjection(principalPoint) {
    return principalPoint.x === 0 && principalPoint.y === 0;
}
function computePosSideFov(focalLength, ppOffset, viewportSide) {
    assert(focalLength > 0, "Focal length must be larger than 0");
    return Math.atan((1 - ppOffset) * viewportSide * 0.5 / focalLength);
}
function computeFov(focalLength, ppOffset, viewportSide) {
    assert(focalLength > 0, "Focal length must be larger than 0");
    return ppOffset === 0 ? 2 * Math.atan(0.5 * viewportSide / focalLength) : computePosSideFov(focalLength, ppOffset, viewportSide) + computePosSideFov(focalLength, -ppOffset, viewportSide);
}
function getFovs(camera) {
    return camera.userData.fovs;
}
function setCameraParams(camera, ppalPoint, focalLength, viewportHeight, verticalFov) {
    var viewportWidth = viewportHeight * camera.aspect;
    var hFov = computeFov(focalLength, ppalPoint.x, viewportWidth);
    if (hFov < MIN_FOV_RAD || hFov > MAX_FOV_RAD) {
        hFov = THREE30.MathUtils.clamp(hFov, MIN_FOV_RAD, MAX_FOV_RAD);
        var focalLength2 = computeFocalLengthFromFov(hFov, viewportWidth, ppalPoint.x);
        verticalFov = computeFov(focalLength2, ppalPoint.y, viewportHeight);
    }
    camera.fov = THREE30.MathUtils.radToDeg(verticalFov);
    if (isCenteredProjection(ppalPoint)) {
        delete camera.userData.fovs;
    } else {
        var width = viewportHeight * camera.aspect;
        camera.userData.fovs = {
            top: computePosSideFov(focalLength, ppalPoint.y, viewportHeight),
            right: computePosSideFov(focalLength, ppalPoint.x, width),
            horizontal: hFov
        };
    }
    camera.userData.focalLength = focalLength;
}
function computeFocalLengthFromFov(fov, viewportSide, ppOffset) {
    var halfSide = viewportSide / 2;
    var ppCentered = ppOffset === 0;
    if (ppCentered) {
        return halfSide / Math.tan(fov / 2);
    }
    var eps = 1e-6;
    var ppOffsetSq = Math.pow(ppOffset, 2);
    if (Math.abs(fov - Math.PI / 2) < eps) {
        return halfSide * Math.sqrt(1 - ppOffsetSq);
    }
    var tanFov = Math.tan(fov);
    var sign = Math.sign(tanFov);
    var sqrt = Math.sqrt(1 + Math.pow(tanFov, 2) * (1 - ppOffsetSq));
    var f = halfSide * (1 + sign * sqrt) / tanFov;
    assert(f >= 0, "Focal length must be larger than 0");
    return f;
}
var CameraUtils;
(function(CameraUtils2) {
    var getFocalLength = function getFocalLength(camera) {
        var ref;
        return (ref = camera.userData) === null || ref === void 0 ? void 0 : ref.focalLength;
    };
    var setFocalLength = function setFocalLength(camera, focalLength, viewportHeight) {
        var ppalPoint = getPrincipalPoint(camera);
        var vFov = computeFov(focalLength, ppalPoint.y, viewportHeight);
        if (vFov < MIN_FOV_RAD || vFov > MAX_FOV_RAD) {
            setVerticalFov(camera, vFov, viewportHeight);
        } else {
            setCameraParams(camera, ppalPoint, focalLength, viewportHeight, vFov);
        }
        return getFocalLength(camera);
    };
    var getVerticalFov = function getVerticalFov(camera) {
        return THREE30.MathUtils.degToRad(camera.fov);
    };
    var setVerticalFov = function setVerticalFov(camera, verticalFov, viewportHeight) {
        verticalFov = THREE30.MathUtils.clamp(verticalFov, MIN_FOV_RAD, MAX_FOV_RAD);
        var ppalPoint = getPrincipalPoint(camera);
        var focalLength = computeFocalLengthFromFov(verticalFov, viewportHeight, ppalPoint.y);
        setCameraParams(camera, ppalPoint, focalLength, viewportHeight, verticalFov);
        return getVerticalFov(camera);
    };
    var convertWorldToScreenSize = function convertWorldToScreenSize(focalLength, distance, worldSize) {
        return focalLength * worldSize / distance;
    };
    var convertScreenToWorldSize = function convertScreenToWorldSize(focalLength, distance, screenSize) {
        return distance * screenSize / focalLength;
    };
    var getPrincipalPoint = function getPrincipalPoint(camera) {
        var result = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new THREE30.Vector2();
        result.x = -camera.projectionMatrix.elements[8];
        result.y = -camera.projectionMatrix.elements[9];
        return result;
    };
    var setPrincipalPoint = function setPrincipalPoint(camera, ndcCoords) {
        var height = 1;
        var width = camera.aspect;
        var maxNdcCoord = 1 - 1e-6;
        camera.setViewOffset(width, height, -THREE30.MathUtils.clamp(ndcCoords.x, -maxNdcCoord, maxNdcCoord) * width / 2, THREE30.MathUtils.clamp(ndcCoords.y, -maxNdcCoord, maxNdcCoord) * height / 2, width, height);
    };
    var getHorizontalFov = function getHorizontalFov(camera) {
        var ref;
        var ref1;
        return (ref1 = (ref = getFovs(camera)) === null || ref === void 0 ? void 0 : ref.horizontal) !== null && ref1 !== void 0 ? ref1 : 2 * Math.atan(Math.tan(THREE30.MathUtils.degToRad(camera.fov) / 2) * camera.aspect);
    };
    var getTopFov = function getTopFov(camera) {
        var ref;
        var ref1;
        return (ref1 = (ref = getFovs(camera)) === null || ref === void 0 ? void 0 : ref.top) !== null && ref1 !== void 0 ? ref1 : THREE30.MathUtils.degToRad(camera.fov / 2);
    };
    var getBottomFov = function getBottomFov(camera) {
        return THREE30.MathUtils.degToRad(camera.fov) - getTopFov(camera);
    };
    var getRightFov = function getRightFov(camera) {
        var ref;
        var ref1;
        return (ref1 = (ref = getFovs(camera)) === null || ref === void 0 ? void 0 : ref.right) !== null && ref1 !== void 0 ? ref1 : getHorizontalFov(camera) / 2;
    };
    var getLeftFov = function getLeftFov(camera) {
        var ref;
        return ((ref = getFovs(camera)) === null || ref === void 0 ? void 0 : ref.right) !== void 0 ? getHorizontalFov(camera) - getRightFov(camera) : getHorizontalFov(camera) / 2;
    };
    CameraUtils2.getFocalLength = getFocalLength;
    CameraUtils2.setFocalLength = setFocalLength;
    CameraUtils2.getVerticalFov = getVerticalFov;
    CameraUtils2.setVerticalFov = setVerticalFov;
    CameraUtils2.convertWorldToScreenSize = convertWorldToScreenSize;
    CameraUtils2.convertScreenToWorldSize = convertScreenToWorldSize;
    CameraUtils2.getPrincipalPoint = getPrincipalPoint;
    CameraUtils2.setPrincipalPoint = setPrincipalPoint;
    CameraUtils2.getHorizontalFov = getHorizontalFov;
    CameraUtils2.getTopFov = getTopFov;
    CameraUtils2.getBottomFov = getBottomFov;
    CameraUtils2.getRightFov = getRightFov;
    CameraUtils2.getLeftFov = getLeftFov;
})(CameraUtils || (CameraUtils = {}));
// src/mapview/geometry/Object3DUtils.ts
var THREE96 = __toESM(require("three"));
// src/mapview/Tile.ts
var THREE95 = __toESM(require("three"));
// src/mapview/geometry/LodMesh.ts
var THREE31 = __toESM(require("three"));
var LodMesh = /*#__PURE__*/ function(_Mesh) {
    _inherits(LodMesh, _Mesh);
    var _super = _createSuper(LodMesh);
    function LodMesh(geometries, material) {
        _classCallCheck(this, LodMesh);
        var _this;
        _this = _super.call(this, void 0, material);
        __publicField(_assertThisInitialized(_this), "m_geometries");
        _this.geometries = geometries;
        return _this;
    }
    _createClass(LodMesh, [
        {
            key: "geometries",
            get: function get() {
                return this.m_geometries;
            },
            set: function set(geometries) {
                if (this.m_geometries !== geometries) {
                    this.disposeGeometries();
                }
                this.m_geometries = geometries;
                if (this.geometries && this.m_geometries.length > 0) {
                    this.geometry = this.m_geometries[0];
                }
            }
        },
        {
            key: "setLevelOfDetail",
            value: function setLevelOfDetail(level) {
                if (!this.m_geometries || this.m_geometries.length === 0) {
                    return;
                }
                level = THREE31.MathUtils.clamp(level, 0, this.m_geometries.length - 1);
                this.geometry = this.m_geometries[level];
            }
        },
        {
            key: "disposeGeometries",
            value: function disposeGeometries() {
                if (this.m_geometries) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = this.m_geometries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var geometry = _step.value;
                            geometry.dispose();
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                this.geometry.dispose();
            }
        }
    ]);
    return LodMesh;
}(THREE31.Mesh);
// src/mapview/MapView.ts
var THREE91 = __toESM(require("three"));
// src/map-controls/MapControls.ts
var THREE32 = __toESM(require("three"));
// src/map-controls/Utils.ts
var import_three4 = require("three");
// src/map-controls/MapControls.ts
var DEFAULT_MAX_TILT_ANGLE = THREE32.MathUtils.degToRad(89);
// src/map-controls/MapAnimations.ts
var THREE33 = __toESM(require("three"));
var TWEEN = __toESM(require("@tweenjs/tween.js"));
// src/map-controls/CameraKeyTrackAnimation.ts
var THREE34 = __toESM(require("three"));
var logger3 = LoggerManager.instance.create("CameraKeyTrackAnimation");
var MIN_DISTANCE = 0;
var ControlPoint = function ControlPoint(options) {
    _classCallCheck(this, ControlPoint);
    __publicField(this, "timestamp", 0);
    __publicField(this, "target");
    __publicField(this, "name");
    __publicField(this, "tilt");
    __publicField(this, "heading");
    __publicField(this, "distance");
    this.timestamp = options.timestamp;
    this.target = options.target ? GeoCoordinates.fromObject(options.target) : new GeoCoordinates(0, 0);
    var _tilt;
    this.tilt = (_tilt = options.tilt) !== null && _tilt !== void 0 ? _tilt : 0;
    var _heading;
    this.heading = (_heading = options.heading) !== null && _heading !== void 0 ? _heading : 0;
    var _distance;
    this.distance = (_distance = options.distance) !== null && _distance !== void 0 ? _distance : MIN_DISTANCE;
    var _name;
    this.name = (_name = options.name) !== null && _name !== void 0 ? _name : Date.now().toString();
};
var AnimationDummy = /*#__PURE__*/ function(_Object3D) {
    _inherits(AnimationDummy, _Object3D);
    var _super = _createSuper(AnimationDummy);
    function AnimationDummy(name2) {
        _classCallCheck(this, AnimationDummy);
        var _this;
        _this = _super.call(this);
        __publicField(_assertThisInitialized(_this), "distance", 0);
        _this.name = name2;
        return _this;
    }
    return AnimationDummy;
}(THREE34.Object3D);
var CameraKeyTrackAnimation = /*#__PURE__*/ function() {
    function CameraKeyTrackAnimation(m_mapView, m_options) {
        var _this = this;
        _classCallCheck(this, CameraKeyTrackAnimation);
        this.m_mapView = m_mapView;
        this.m_options = m_options;
        __publicField(this, "m_animationClip");
        __publicField(this, "m_animationMixer");
        __publicField(this, "m_animationAction");
        __publicField(this, "m_dummy", new AnimationDummy("dummy"));
        __publicField(this, "m_azimuthAxis", new THREE34.Vector3(0, 0, 1));
        __publicField(this, "m_altitudeAxis", new THREE34.Vector3(1, 0, 0));
        __publicField(this, "m_running", false);
        __publicField(this, "m_onFinished");
        __publicField(this, "m_name");
        __publicField(this, "m_lastFrameTime", 0);
        __publicField(this, "m_animateCb");
        var interpolation = this.m_options.interpolation !== void 0 ? this.m_options.interpolation : THREE34.InterpolateSmooth;
        var _loop;
        this.m_options.loop = (_loop = this.m_options.loop) !== null && _loop !== void 0 ? _loop : THREE34.LoopOnce;
        var _repetitions;
        this.m_options.repetitions = (_repetitions = this.m_options.repetitions) !== null && _repetitions !== void 0 ? _repetitions : 1;
        var _rotateOnlyClockwise;
        this.m_options.rotateOnlyClockwise = (_rotateOnlyClockwise = this.m_options.rotateOnlyClockwise) !== null && _rotateOnlyClockwise !== void 0 ? _rotateOnlyClockwise : true;
        var _name;
        this.m_name = ((_name = this.m_options.name) !== null && _name !== void 0 ? _name : "CameraKeyTrackAnimation") + Date.now();
        var timestamps = this.m_options.controlPoints.map(function(point) {
            return point.timestamp;
        });
        var posValues = [];
        var rotValues = [];
        this.m_options.controlPoints.map(function(point) {
            var worldPos = _this.m_mapView.projection.projectPoint(point.target);
            posValues.push(worldPos.x);
            posValues.push(worldPos.y);
            posValues.push(worldPos.z);
            var rot = new THREE34.Quaternion();
            rot.setFromAxisAngle(_this.m_azimuthAxis, THREE34.MathUtils.degToRad(point.heading));
            rot.multiply(new THREE34.Quaternion().setFromAxisAngle(_this.m_altitudeAxis, THREE34.MathUtils.degToRad(point.tilt)));
            rotValues.push(rot.x);
            rotValues.push(rot.y);
            rotValues.push(rot.z);
            rotValues.push(rot.w);
        });
        var lookAtTrack = new THREE34.VectorKeyframeTrack(".position", timestamps, posValues, interpolation);
        var rotationTrack = new THREE34.QuaternionKeyframeTrack(".quaternion", timestamps, rotValues, interpolation);
        var distanceTrack = new THREE34.NumberKeyframeTrack(".distance", timestamps, this.m_options.controlPoints.map(function(point) {
            return point.distance;
        }), interpolation);
        this.m_animationClip = new THREE34.AnimationClip("cameraflyoveranimation", -1, [
            lookAtTrack,
            rotationTrack,
            distanceTrack
        ]);
        if (!this.m_animationClip.validate()) {
            logger3.error("Review the entered controlpoints for: ", this.m_name, ", The Animation was provided with invalid track data");
        }
        this.m_animationClip.resetDuration();
        this.m_animationClip.trim();
        this.m_animationMixer = new THREE34.AnimationMixer(this.m_dummy);
        this.m_animationAction = this.m_animationMixer.clipAction(this.m_animationClip);
        this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
        this.m_animationAction.clampWhenFinished = true;
        this.m_animateCb = this.animate.bind(this);
        this.m_animationMixer.addEventListener("finished", this.stop.bind(this));
    }
    _createClass(CameraKeyTrackAnimation, [
        {
            key: "loop",
            set: function set(value2) {
                this.m_options.loop = value2;
                this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
            }
        },
        {
            key: "repetitions",
            set: function set(value2) {
                this.m_options.repetitions = value2;
                this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
            }
        },
        {
            key: "rotateOnlyClockwise",
            set: function set(value2) {
                this.m_options.rotateOnlyClockwise = value2;
            }
        },
        {
            key: "start",
            value: function start(time, onFinished) {
                if (this.m_running) {
                    this.stop();
                }
                this.m_onFinished = onFinished;
                this.m_animationAction.reset().play();
                this.m_lastFrameTime = Date.now();
                this.m_mapView.addEventListener("render" /* Render */ , this.m_animateCb);
                this.m_mapView.beginAnimation();
                this.m_running = true;
            }
        },
        {
            key: "stop",
            value: function stop() {
                this.m_mapView.removeEventListener("render" /* Render */ , this.m_animateCb);
                this.m_mapView.endAnimation();
                if (this.m_onFinished !== void 0) {
                    window.setTimeout(this.m_onFinished, 0);
                }
                this.m_running = false;
            }
        },
        {
            key: "isRunning",
            value: function isRunning() {
                return this.m_running;
            }
        },
        {
            key: "updateCameraFromDummy",
            value: function updateCameraFromDummy() {
                var tilt = THREE34.MathUtils.radToDeg(this.m_azimuthAxis.clone().applyQuaternion(this.m_dummy.quaternion).angleTo(this.m_azimuthAxis));
                tilt = THREE34.MathUtils.clamp(tilt, 0, MapViewUtils.MAX_TILT_DEG);
                var vec0 = this.m_altitudeAxis.clone().applyQuaternion(this.m_dummy.quaternion);
                var angle = vec0.angleTo(this.m_altitudeAxis);
                if (this.m_options.rotateOnlyClockwise) {
                    var direction = this.m_azimuthAxis.dot(vec0.normalize().cross(this.m_altitudeAxis));
                    if (direction >= 0) {
                        angle = 2 * Math.PI - angle;
                    }
                }
                var heading = THREE34.MathUtils.radToDeg(angle);
                var target = this.m_mapView.projection.unprojectPoint(this.m_dummy.position);
                var distance = Math.max(MIN_DISTANCE, this.m_dummy.distance);
                if (isNaN(tilt) || isNaN(heading) || isNaN(distance) || !target.isValid()) {
                    logger3.error("Cannot update due to invalid data", tilt, heading, distance, target);
                }
                this.m_mapView.lookAt({
                    target: target,
                    distance: distance,
                    tilt: tilt,
                    heading: heading
                });
            }
        },
        {
            key: "animate",
            value: function animate(event) {
                var deltaTime = (Date.now() - this.m_lastFrameTime) / 1e3;
                this.m_animationMixer.update(deltaTime);
                this.m_lastFrameTime = Date.now();
                this.updateCameraFromDummy();
            }
        }
    ]);
    return CameraKeyTrackAnimation;
}();
// src/map-controls/CameraAnimationBuilder.ts
var THREE35 = __toESM(require("three"));
var CameraAnimationBuilder = /*#__PURE__*/ function() {
    function CameraAnimationBuilder() {
        _classCallCheck(this, CameraAnimationBuilder);
    }
    _createClass(CameraAnimationBuilder, null, [
        {
            key: "getLookAtFromView",
            value: function getLookAtFromView(mapView) {
                return {
                    target: mapView.target,
                    heading: mapView.heading,
                    tilt: mapView.tilt,
                    distance: mapView.targetDistance
                };
            }
        },
        {
            key: "appendControlPoint",
            value: function appendControlPoint(options, point, appendTime) {
                appendTime = appendTime !== null && appendTime !== void 0 ? appendTime : 10;
                if (options.controlPoints.length > 0 && (point.timestamp === void 0 || point.timestamp <= options.controlPoints[options.controlPoints.length - 1].timestamp)) {
                    point.timestamp = options.controlPoints[options.controlPoints.length - 1].timestamp + appendTime;
                }
                options.controlPoints.push(point);
            }
        },
        {
            key: "prependControlPoint",
            value: function prependControlPoint(options, point, prependTime) {
                prependTime = prependTime !== void 0 ? prependTime : 10;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = options.controlPoints[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var controlPoint = _step.value;
                        controlPoint.timestamp += prependTime;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                point.timestamp = 0;
                options.controlPoints.unshift(point);
            }
        },
        {
            key: "createBowFlyToOptions",
            value: function createBowFlyToOptions(mapView, startControlPoint, targetControlPoint, altitude) {
                var duration = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 10;
                var controlPoints = [
                    startControlPoint
                ];
                var startWorldTarget = new THREE35.Vector3();
                mapView.projection.projectPoint(startControlPoint.target, startWorldTarget);
                var maxAltitude = altitude !== null && altitude !== void 0 ? altitude : 2 * startWorldTarget.distanceTo(mapView.projection.projectPoint(targetControlPoint.target));
                maxAltitude = Math.max(startControlPoint.distance + targetControlPoint.distance, maxAltitude);
                var midCoord0 = GeoCoordinates.lerp(startControlPoint.target, targetControlPoint.target, 0.25);
                var midPoint0 = new ControlPoint({
                    target: midCoord0,
                    distance: maxAltitude,
                    timestamp: duration / 3,
                    tilt: MathUtils6.interpolateAnglesDeg(startControlPoint.tilt, targetControlPoint.tilt, 0.25),
                    heading: MathUtils6.interpolateAnglesDeg(startControlPoint.heading, targetControlPoint.heading, 0.25)
                });
                controlPoints.push(midPoint0);
                var midCoord1 = GeoCoordinates.lerp(startControlPoint.target, targetControlPoint.target, 0.75);
                var midPoint1 = new ControlPoint({
                    target: midCoord1,
                    distance: maxAltitude,
                    timestamp: duration / 3 * 2,
                    tilt: MathUtils6.interpolateAnglesDeg(startControlPoint.tilt, targetControlPoint.tilt, 0.75),
                    heading: MathUtils6.interpolateAnglesDeg(startControlPoint.heading, targetControlPoint.heading, 0.75)
                });
                controlPoints.push(midPoint1);
                targetControlPoint.timestamp = duration;
                controlPoints.push(targetControlPoint);
                return {
                    controlPoints: controlPoints
                };
            }
        },
        {
            key: "createOrbitOptions",
            value: function createOrbitOptions(startControlPoint) {
                var duration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
                var amountOfKeys = 4;
                var controlPoints = [
                    startControlPoint
                ];
                var steps = amountOfKeys - 1;
                var headingStep = 360 / steps;
                var timeStep = duration / steps;
                for(var n = 1; n < amountOfKeys; n++){
                    var prev = controlPoints[n - 1];
                    controlPoints.push(_objectSpreadProps(_objectSpread({}, prev), {
                        heading: prev.heading - headingStep,
                        timestamp: prev.timestamp + timeStep
                    }));
                }
                return {
                    controlPoints: controlPoints
                };
            }
        }
    ]);
    return CameraAnimationBuilder;
}();
// src/ecs/Utils.js
function queryKey(Components) {
    var ids = [];
    for(var n = 0; n < Components.length; n++){
        var T = Components[n];
        if (!componentRegistered(T)) {
            throw new Error("Tried to create a query with an unregistered component");
        }
        if (typeof T === "object") {
            var operator = T.operator === "not" ? "!" : T.operator;
            ids.push(operator + T.Component._typeId);
        } else {
            ids.push(T._typeId);
        }
    }
    return ids.sort().join("-");
}
var hasWindow = typeof window !== "undefined";
var now = hasWindow && typeof window.performance !== "undefined" ? performance.now.bind(performance) : Date.now.bind(Date);
function componentRegistered(T) {
    return typeof T === "object" && T.Component._typeId !== void 0 || T.isComponent && T._typeId !== void 0;
}
// src/ecs/EventDispatcher.js
var EventDispatcher2 = /*#__PURE__*/ function() {
    function EventDispatcher2() {
        _classCallCheck(this, EventDispatcher2);
        this._listeners = {};
        this.stats = {
            fired: 0,
            handled: 0
        };
    }
    _createClass(EventDispatcher2, [
        {
            key: "addEventListener",
            value: function addEventListener(eventName, listener) {
                var listeners = this._listeners;
                if (listeners[eventName] === void 0) {
                    listeners[eventName] = [];
                }
                if (listeners[eventName].indexOf(listener) === -1) {
                    listeners[eventName].push(listener);
                }
            }
        },
        {
            key: "hasEventListener",
            value: function hasEventListener(eventName, listener) {
                return this._listeners[eventName] !== void 0 && this._listeners[eventName].indexOf(listener) !== -1;
            }
        },
        {
            key: "removeEventListener",
            value: function removeEventListener(eventName, listener) {
                var listenerArray = this._listeners[eventName];
                if (listenerArray !== void 0) {
                    var index = listenerArray.indexOf(listener);
                    if (index !== -1) {
                        listenerArray.splice(index, 1);
                    }
                }
            }
        },
        {
            key: "dispatchEvent",
            value: function dispatchEvent(eventName, entity, component) {
                this.stats.fired++;
                var listenerArray = this._listeners[eventName];
                if (listenerArray !== void 0) {
                    var array = listenerArray.slice(0);
                    for(var i = 0; i < array.length; i++){
                        array[i].call(this, entity, component);
                    }
                }
            }
        },
        {
            key: "resetCounters",
            value: function resetCounters() {
                this.stats.fired = this.stats.handled = 0;
            }
        }
    ]);
    return EventDispatcher2;
}();
// src/ecs/Query.js
var Query = /*#__PURE__*/ function() {
    function Query(Components, manager) {
        var _this = this;
        _classCallCheck(this, Query);
        this.Components = [];
        this.NotComponents = [];
        Components.forEach(function(component) {
            if (typeof component === "object") {
                _this.NotComponents.push(component.Component);
            } else {
                _this.Components.push(component);
            }
        });
        if (this.Components.length === 0) {
            throw new Error("Can't create a query without components");
        }
        this.entities = [];
        this.eventDispatcher = new EventDispatcher2();
        this.reactive = false;
        this.key = queryKey(Components);
        for(var i = 0; i < manager._entities.length; i++){
            var entity = manager._entities[i];
            if (this.match(entity)) {
                entity.queries.push(this);
                this.entities.push(entity);
            }
        }
    }
    _createClass(Query, [
        {
            key: "addEntity",
            value: function addEntity(entity) {
                entity.queries.push(this);
                this.entities.push(entity);
                this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_ADDED, entity);
            }
        },
        {
            key: "removeEntity",
            value: function removeEntity(entity) {
                var index = this.entities.indexOf(entity);
                if (~index) {
                    this.entities.splice(index, 1);
                    index = entity.queries.indexOf(this);
                    entity.queries.splice(index, 1);
                    this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_REMOVED, entity);
                }
            }
        },
        {
            key: "match",
            value: function match(entity) {
                return entity.hasAllComponents(this.Components) && !entity.hasAnyComponents(this.NotComponents);
            }
        },
        {
            key: "toJSON",
            value: function toJSON() {
                return {
                    key: this.key,
                    reactive: this.reactive,
                    components: {
                        included: this.Components.map(function(C) {
                            return C.name;
                        }),
                        not: this.NotComponents.map(function(C) {
                            return C.name;
                        })
                    },
                    numEntities: this.entities.length
                };
            }
        },
        {
            key: "stats",
            value: function stats() {
                return {
                    numComponents: this.Components.length,
                    numEntities: this.entities.length
                };
            }
        }
    ]);
    return Query;
}();
Query.prototype.ENTITY_ADDED = "Query#ENTITY_ADDED";
Query.prototype.ENTITY_REMOVED = "Query#ENTITY_REMOVED";
Query.prototype.COMPONENT_CHANGED = "Query#COMPONENT_CHANGED";
// src/ecs/Component.js
var Component = /*#__PURE__*/ function() {
    function Component(props) {
        _classCallCheck(this, Component);
        if (props !== false) {
            var schema = this.constructor.schema;
            for(var key in schema){
                if (props && props.hasOwnProperty(key)) {
                    this[key] = props[key];
                } else {
                    var schemaProp = schema[key];
                    if (schemaProp.hasOwnProperty("default")) {
                        this[key] = schemaProp.type.clone(schemaProp.default);
                    } else {
                        var type = schemaProp.type;
                        this[key] = type.clone(type.default);
                    }
                }
            }
            if (process.env.NODE_ENV !== "production" && props !== void 0) {
                this.checkUndefinedAttributes(props);
            }
        }
        this._pool = null;
    }
    _createClass(Component, [
        {
            key: "copy",
            value: function copy(source) {
                var schema = this.constructor.schema;
                for(var key in schema){
                    var prop = schema[key];
                    if (source.hasOwnProperty(key)) {
                        this[key] = prop.type.copy(source[key], this[key]);
                    }
                }
                if (process.env.NODE_ENV !== "production") {
                    this.checkUndefinedAttributes(source);
                }
                return this;
            }
        },
        {
            key: "clone",
            value: function clone() {
                return new this.constructor().copy(this);
            }
        },
        {
            key: "reset",
            value: function reset() {
                var schema = this.constructor.schema;
                for(var key in schema){
                    var schemaProp = schema[key];
                    if (schemaProp.hasOwnProperty("default")) {
                        this[key] = schemaProp.type.copy(schemaProp.default, this[key]);
                    } else {
                        var type = schemaProp.type;
                        this[key] = type.copy(type.default, this[key]);
                    }
                }
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                if (this._pool) {
                    this._pool.release(this);
                }
            }
        },
        {
            key: "getName",
            value: function getName() {
                return this.constructor.getName();
            }
        },
        {
            key: "checkUndefinedAttributes",
            value: function checkUndefinedAttributes(src) {
                var _this = this;
                var schema = this.constructor.schema;
                Object.keys(src).forEach(function(srcKey) {
                    if (!schema.hasOwnProperty(srcKey)) {
                        console.warn("Trying to set attribute '".concat(srcKey, "' not defined in the '").concat(_this.constructor.name, "' schema. Please fix the schema, the attribute value won't be set"));
                    }
                });
            }
        }
    ]);
    return Component;
}();
Component.schema = {};
Component.isComponent = true;
Component.getName = function() {
    return this.displayName || this.name;
};
// src/ecs/SystemStateComponent.js
var SystemStateComponent = /*#__PURE__*/ function(Component) {
    _inherits(SystemStateComponent, Component);
    var _super = _createSuper(SystemStateComponent);
    function SystemStateComponent() {
        _classCallCheck(this, SystemStateComponent);
        return _super.apply(this, arguments);
    }
    return SystemStateComponent;
}(Component);
SystemStateComponent.isSystemStateComponent = true;
// src/ecs/System.js
var System = /*#__PURE__*/ function() {
    function System(world, attributes) {
        var _this = this;
        _classCallCheck(this, System);
        this.world = world;
        this.enabled = true;
        this._queries = {};
        this.queries = {};
        this.priority = 0;
        this.executeTime = 0;
        if (attributes && attributes.priority) {
            this.priority = attributes.priority;
        }
        this._mandatoryQueries = [];
        this.initialized = true;
        if (this.constructor.queries) {
            var _this1 = this, _loop = function(queryName) {
                var queryConfig = _this1.constructor.queries[queryName];
                var Components = queryConfig.components;
                if (!Components || Components.length === 0) {
                    throw new Error("'components' attribute can't be empty in a query");
                }
                var unregisteredComponents = Components.filter(function(Component2) {
                    return !componentRegistered(Component2);
                });
                if (unregisteredComponents.length > 0) {
                    throw new Error("Tried to create a query '".concat(_this1.constructor.name, ".").concat(queryName, "' with unregistered components: [").concat(unregisteredComponents.map(function(c) {
                        return c.getName();
                    }).join(", "), "]"));
                }
                var query = _this1.world.entityManager.queryComponents(Components);
                _this1._queries[queryName] = query;
                if (queryConfig.mandatory === true) {
                    _this1._mandatoryQueries.push(query);
                }
                _this1.queries[queryName] = {
                    results: query.entities
                };
                var validEvents = [
                    "added",
                    "removed",
                    "changed"
                ];
                var eventMapping = {
                    added: Query.prototype.ENTITY_ADDED,
                    removed: Query.prototype.ENTITY_REMOVED,
                    changed: Query.prototype.COMPONENT_CHANGED
                };
                if (queryConfig.listen) {
                    validEvents.forEach(function(eventName) {
                        if (!_this.execute) {
                            console.warn("System '".concat(_this.getName(), "' has defined listen events (").concat(validEvents.join(", "), ") for query '").concat(queryName, "' but it does not implement the 'execute' method."));
                        }
                        if (queryConfig.listen[eventName]) {
                            var event = queryConfig.listen[eventName];
                            if (eventName === "changed") {
                                query.reactive = true;
                                if (event === true) {
                                    var eventList = _this.queries[queryName][eventName] = [];
                                    query.eventDispatcher.addEventListener(Query.prototype.COMPONENT_CHANGED, function(entity) {
                                        if (eventList.indexOf(entity) === -1) {
                                            eventList.push(entity);
                                        }
                                    });
                                } else if (Array.isArray(event)) {
                                    var eventList1 = _this.queries[queryName][eventName] = [];
                                    query.eventDispatcher.addEventListener(Query.prototype.COMPONENT_CHANGED, function(entity, changedComponent) {
                                        if (event.indexOf(changedComponent.constructor) !== -1 && eventList1.indexOf(entity) === -1) {
                                            eventList1.push(entity);
                                        }
                                    });
                                } else {}
                            } else {
                                var eventList2 = _this.queries[queryName][eventName] = [];
                                query.eventDispatcher.addEventListener(eventMapping[eventName], function(entity) {
                                    if (eventList2.indexOf(entity) === -1) eventList2.push(entity);
                                });
                            }
                        }
                    });
                }
            };
            for(var queryName in this.constructor.queries)_loop(queryName);
        }
    }
    _createClass(System, [
        {
            key: "canExecute",
            value: function canExecute() {
                if (this._mandatoryQueries.length === 0) return true;
                for(var i = 0; i < this._mandatoryQueries.length; i++){
                    var query = this._mandatoryQueries[i];
                    if (query.entities.length === 0) {
                        return false;
                    }
                }
                return true;
            }
        },
        {
            key: "getName",
            value: function getName() {
                return this.constructor.getName();
            }
        },
        {
            key: "stop",
            value: function stop() {
                this.executeTime = 0;
                this.enabled = false;
            }
        },
        {
            key: "play",
            value: function play() {
                this.enabled = true;
            }
        },
        {
            key: "clearEvents",
            value: function clearEvents() {
                for(var queryName in this.queries){
                    var query = this.queries[queryName];
                    if (query.added) {
                        query.added.length = 0;
                    }
                    if (query.removed) {
                        query.removed.length = 0;
                    }
                    if (query.changed) {
                        if (Array.isArray(query.changed)) {
                            query.changed.length = 0;
                        } else {
                            for(var name2 in query.changed){
                                query.changed[name2].length = 0;
                            }
                        }
                    }
                }
            }
        },
        {
            key: "toJSON",
            value: function toJSON() {
                var json = {
                    name: this.getName(),
                    enabled: this.enabled,
                    executeTime: this.executeTime,
                    priority: this.priority,
                    queries: {}
                };
                if (this.constructor.queries) {
                    var _this = this, _loop = function(queryName) {
                        var query = _this.queries[queryName];
                        var queryDefinition = queries[queryName];
                        var jsonQuery = json.queries[queryName] = {
                            key: _this._queries[queryName].key
                        };
                        jsonQuery.mandatory = queryDefinition.mandatory === true;
                        jsonQuery.reactive = queryDefinition.listen && (queryDefinition.listen.added === true || queryDefinition.listen.removed === true || queryDefinition.listen.changed === true || Array.isArray(queryDefinition.listen.changed));
                        if (jsonQuery.reactive) {
                            jsonQuery.listen = {};
                            var methods = [
                                "added",
                                "removed",
                                "changed"
                            ];
                            methods.forEach(function(method) {
                                if (query[method]) {
                                    jsonQuery.listen[method] = {
                                        entities: query[method].length
                                    };
                                }
                            });
                        }
                    };
                    var queries = this.constructor.queries;
                    for(var queryName in queries)_loop(queryName);
                }
                return json;
            }
        }
    ]);
    return System;
}();
System.isSystem = true;
System.getName = function() {
    return this.displayName || this.name;
};
// src/ecs/TagComponent.js
var TagComponent = /*#__PURE__*/ function(Component) {
    _inherits(TagComponent, Component);
    var _super = _createSuper(TagComponent);
    function TagComponent() {
        _classCallCheck(this, TagComponent);
        return _super.call(this, false);
    }
    return TagComponent;
}(Component);
TagComponent.isTagComponent = true;
// src/ecs/Types.js
var copyValue = function(src) {
    return src;
};
var cloneValue = function(src) {
    return src;
};
var copyArray = function(src, dest) {
    if (!src) {
        return src;
    }
    if (!dest) {
        return src.slice();
    }
    dest.length = 0;
    for(var i = 0; i < src.length; i++){
        dest.push(src[i]);
    }
    return dest;
};
var cloneArray = function(src) {
    return src && src.slice();
};
var copyJSON = function(src) {
    return JSON.parse(JSON.stringify(src));
};
var cloneJSON = function(src) {
    return JSON.parse(JSON.stringify(src));
};
function createType(typeDefinition) {
    var mandatoryProperties = [
        "name",
        "default",
        "copy",
        "clone"
    ];
    var undefinedProperties = mandatoryProperties.filter(function(p) {
        return !typeDefinition.hasOwnProperty(p);
    });
    if (undefinedProperties.length > 0) {
        throw new Error("createType expects a type definition with the following properties: ".concat(undefinedProperties.join(", ")));
    }
    typeDefinition.isType = true;
    return typeDefinition;
}
var Types = {
    Number: createType({
        name: "Number",
        default: 0,
        copy: copyValue,
        clone: cloneValue
    }),
    Boolean: createType({
        name: "Boolean",
        default: false,
        copy: copyValue,
        clone: cloneValue
    }),
    String: createType({
        name: "String",
        default: "",
        copy: copyValue,
        clone: cloneValue
    }),
    Array: createType({
        name: "Array",
        default: [],
        copy: copyArray,
        clone: cloneArray
    }),
    Ref: createType({
        name: "Ref",
        default: void 0,
        copy: copyValue,
        clone: cloneValue
    }),
    JSON: createType({
        name: "JSON",
        default: null,
        copy: copyJSON,
        clone: cloneJSON
    })
};
// src/ecs/RemoteDevTools/utils.js
function generateId(length) {
    var result = "";
    var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    var charactersLength = characters.length;
    for(var i = 0; i < length; i++){
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
function injectScript(src, onLoad) {
    var script2 = document.createElement("script");
    script2.src = src;
    script2.onload = onLoad;
    (document.head || document.documentElement).appendChild(script2);
}
// src/ecs/RemoteDevTools/index.js
var import_react_native = require("react-native");
function hookConsoleAndErrors(connection2) {
    if (import_react_native.Platform.OS !== "web") return;
    var wrapFunctions = [
        "error",
        "warning",
        "log"
    ];
    wrapFunctions.forEach(function(key) {
        if (typeof console[key] === "function") {
            var fn = console[key].bind(console);
            console[key] = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                connection2.send({
                    method: "console",
                    type: key,
                    args: JSON.stringify(args)
                });
                return fn.apply(null, args);
            };
        }
    });
    window.addEventListener("error", function(error) {
        connection2.send({
            method: "error",
            error: JSON.stringify({
                message: error.error.message,
                stack: error.error.stack
            })
        });
    });
}
function includeRemoteIdHTML(remoteId2) {
    if (import_react_native.Platform.OS !== "web") return;
    var infoDiv2 = document.createElement("div");
    infoDiv2.style.cssText = "\n    align-items: center;\n    background-color: #333;\n    color: #aaa;\n    display:flex;\n    font-family: Arial;\n    font-size: 1.1em;\n    height: 40px;\n    justify-content: center;\n    left: 0;\n    opacity: 0.9;\n    position: absolute;\n    right: 0;\n    text-align: center;\n    top: 0;\n  ";
    infoDiv2.innerHTML = 'Open ECSY devtools to connect to this page using the code:&nbsp;<b style="color: #fff">'.concat(remoteId2, '</b>&nbsp;<button onClick="generateNewCode()">Generate new code</button>');
    document.body.appendChild(infoDiv2);
    return infoDiv2;
}
function enableRemoteDevtools(remoteId) {
    if (import_react_native.Platform.OS !== "web") return;
    if (!hasWindow) {
        console.warn("Remote devtools not available outside the browser");
        return;
    }
    window.generateNewCode = function() {
        window.localStorage.clear();
        remoteId = generateId(6);
        window.localStorage.setItem("ecsyRemoteId", remoteId);
        window.location.reload(false);
    };
    remoteId = remoteId || window.localStorage.getItem("ecsyRemoteId");
    if (!remoteId) {
        remoteId = generateId(6);
        window.localStorage.setItem("ecsyRemoteId", remoteId);
    }
    var infoDiv = includeRemoteIdHTML(remoteId);
    window.__ECSY_REMOTE_DEVTOOLS_INJECTED = true;
    window.__ECSY_REMOTE_DEVTOOLS = {};
    var Version = "";
    var worldsBeforeLoading = [];
    var onWorldCreated = function(e) {
        var world = e.detail.world;
        Version = e.detail.version;
        worldsBeforeLoading.push(world);
    };
    window.addEventListener("ecsy-world-created", onWorldCreated);
    var onLoaded = function() {
        var peer = new Peer(remoteId, {
            host: "peerjs.ecsy.io",
            secure: true,
            port: 443,
            config: {
                iceServers: [
                    {
                        url: "stun:stun.l.google.com:19302"
                    },
                    {
                        url: "stun:stun1.l.google.com:19302"
                    },
                    {
                        url: "stun:stun2.l.google.com:19302"
                    },
                    {
                        url: "stun:stun3.l.google.com:19302"
                    },
                    {
                        url: "stun:stun4.l.google.com:19302"
                    }
                ]
            },
            debug: 3
        });
        peer.on("open", function() {
            peer.on("connection", function(connection) {
                window.__ECSY_REMOTE_DEVTOOLS.connection = connection;
                connection.on("open", function() {
                    infoDiv.innerHTML = "Connected";
                    connection.on("data", function(data) {
                        if (data.type === "init") {
                            var script = document.createElement("script");
                            script.setAttribute("type", "text/javascript");
                            script.onload = function() {
                                script.parentNode.removeChild(script);
                                window.removeEventListener("ecsy-world-created", onWorldCreated);
                                worldsBeforeLoading.forEach(function(world) {
                                    var event = new CustomEvent("ecsy-world-created", {
                                        detail: {
                                            world: world,
                                            version: Version
                                        }
                                    });
                                    window.dispatchEvent(event);
                                });
                            };
                            script.innerHTML = data.script;
                            (document.head || document.documentElement).appendChild(script);
                            script.onload();
                            hookConsoleAndErrors(connection);
                        } else if (data.type === "executeScript") {
                            var value = eval(data.script);
                            if (data.returnEval) {
                                connection.send({
                                    method: "evalReturn",
                                    value: value
                                });
                            }
                        }
                    });
                });
            });
        });
    };
    injectScript("https://cdn.jsdelivr.net/npm/peerjs@0.3.20/dist/peer.min.js", onLoaded);
}
if (hasWindow && import_react_native.Platform.OS == "web") {
    var urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("enable-remote-devtools")) {
        enableRemoteDevtools();
    }
}
// src/Rotating.ts
var Rotating = /*#__PURE__*/ function(Component) {
    _inherits(Rotating, Component);
    var _super = _createSuper(Rotating);
    function Rotating() {
        _classCallCheck(this, Rotating);
        var _this;
        _this = _super.call.apply(_super, [
            this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assertThisInitialized(_this), "speed", 1);
        return _this;
    }
    return Rotating;
}(Component);
Rotating.schema = {
    speed: {
        default: 1,
        type: Types.Number
    }
};
// src/mapview/DataSource.ts
var THREE36 = __toESM(require("three"));
var logger4 = LoggerManager.instance.create("DataSource");
var _DataSource = /*#__PURE__*/ function(_EventDispatcher) {
    _inherits(_DataSource, _EventDispatcher);
    var _super = _createSuper(_DataSource);
    function _DataSource() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, _DataSource);
        var _this;
        _this = _super.call(this);
        __publicField(_assertThisInitialized(_this), "UPDATE_EVENT", {
            type: "update"
        });
        __publicField(_assertThisInitialized(_this), "enabled", true);
        __publicField(_assertThisInitialized(_this), "cacheable", false);
        __publicField(_assertThisInitialized(_this), "useGeometryLoader", false);
        __publicField(_assertThisInitialized(_this), "name");
        __publicField(_assertThisInitialized(_this), "addGroundPlane", false);
        __publicField(_assertThisInitialized(_this), "minDataLevel", 1);
        __publicField(_assertThisInitialized(_this), "maxDataLevel", 20);
        __publicField(_assertThisInitialized(_this), "minDisplayLevel", 1);
        __publicField(_assertThisInitialized(_this), "maxDisplayLevel", 20);
        __publicField(_assertThisInitialized(_this), "allowOverlappingTiles", true);
        __publicField(_assertThisInitialized(_this), "enablePicking", true);
        __publicField(_assertThisInitialized(_this), "dataSourceOrder", 0);
        __publicField(_assertThisInitialized(_this), "exprPool", new ExprPool());
        __publicField(_assertThisInitialized(_this), "m_mapView");
        __publicField(_assertThisInitialized(_this), "m_styleSetName");
        __publicField(_assertThisInitialized(_this), "m_maxGeometryHeight", 0);
        __publicField(_assertThisInitialized(_this), "m_minGeometryHeight", 0);
        __publicField(_assertThisInitialized(_this), "m_storageLevelOffset", 0);
        __publicField(_assertThisInitialized(_this), "m_featureStateMap", /* @__PURE__ */ new Map());
        __publicField(_assertThisInitialized(_this), "languages");
        var name2 = options.name;
        var styleSetName = options.styleSetName, languages = options.languages, minZoomLevel = options.minZoomLevel, maxZoomLevel = options.maxZoomLevel, minDataLevel = options.minDataLevel, maxDataLevel = options.maxDataLevel, minDisplayLevel = options.minDisplayLevel, maxDisplayLevel = options.maxDisplayLevel, storageLevelOffset = options.storageLevelOffset, allowOverlappingTiles = options.allowOverlappingTiles, enablePicking = options.enablePicking, minGeometryHeight = options.minGeometryHeight, maxGeometryHeight = options.maxGeometryHeight, dataSourceOrder = options.dataSourceOrder;
        if (name2 === void 0 || name2.length === 0) {
            name2 = "anonymous-datasource#".concat(++_DataSource.uniqueNameCounter);
        }
        _this.name = name2;
        _this.styleSetName = styleSetName;
        if (languages !== void 0) {
            _this.languages = languages;
        }
        if (minDataLevel !== void 0) {
            _this.minDataLevel = minDataLevel;
        }
        if (maxDataLevel !== void 0) {
            _this.maxDataLevel = maxDataLevel;
        }
        if (minZoomLevel !== void 0) {
            _this.minZoomLevel = minZoomLevel;
        }
        if (maxZoomLevel !== void 0) {
            _this.maxZoomLevel = maxZoomLevel;
        }
        if (minDisplayLevel !== void 0) {
            _this.minDisplayLevel = minDisplayLevel;
        }
        if (maxDisplayLevel !== void 0) {
            _this.maxDisplayLevel = maxDisplayLevel;
        }
        if (storageLevelOffset !== void 0) {
            _this.m_storageLevelOffset = storageLevelOffset;
        }
        if (allowOverlappingTiles !== void 0) {
            _this.allowOverlappingTiles = allowOverlappingTiles;
        }
        if (enablePicking !== void 0) {
            _this.enablePicking = enablePicking;
        }
        if (minGeometryHeight !== void 0) {
            _this.minGeometryHeight = minGeometryHeight;
        }
        if (maxGeometryHeight !== void 0) {
            _this.maxGeometryHeight = maxGeometryHeight;
        }
        if (dataSourceOrder) {
            _this.dataSourceOrder = dataSourceOrder;
        }
        return _this;
    }
    _createClass(_DataSource, [
        {
            key: "getFeatureState",
            value: function getFeatureState(featureId) {
                return this.m_featureStateMap.get(featureId);
            }
        },
        {
            key: "clearFeatureState",
            value: function clearFeatureState() {
                this.m_featureStateMap.clear();
            }
        },
        {
            key: "setFeatureState",
            value: function setFeatureState(featureId, state) {
                this.m_featureStateMap.set(featureId, state);
            }
        },
        {
            key: "removeFeatureState",
            value: function removeFeatureState(featureId) {
                this.m_featureStateMap.delete(featureId);
            }
        },
        {
            key: "styleSetName",
            get: function get() {
                return this.m_styleSetName;
            },
            set: function set(styleSetName) {
                if (styleSetName !== this.m_styleSetName) {
                    this.m_styleSetName = styleSetName;
                    this.clearCache();
                    this.requestUpdate();
                }
            }
        },
        {
            key: "dispose",
            value: function dispose() {}
        },
        {
            key: "clearCache",
            value: function clearCache() {}
        },
        {
            key: "isFullyCovering",
            value: function isFullyCovering() {
                return this.addGroundPlane;
            }
        },
        {
            key: "ready",
            value: function ready() {
                return true;
            }
        },
        {
            key: "mapView",
            get: function get() {
                if (this.m_mapView === void 0) {
                    throw new Error("This DataSource was not added to MapView");
                }
                return this.m_mapView;
            }
        },
        {
            key: "projection",
            get: function get() {
                return this.mapView.projection;
            }
        },
        {
            key: "connect",
            value: function connect() {
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "attach",
            value: function attach(mapView) {
                this.m_mapView = mapView;
            }
        },
        {
            key: "detach",
            value: function detach(mapView) {
                assert(this.m_mapView === mapView);
                this.m_mapView = void 0;
            }
        },
        {
            key: "isDetached",
            value: function isDetached() {
                return this.m_mapView === void 0;
            }
        },
        {
            key: "setTheme",
            value: function setTheme(theme, languages) {
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "setLanguages",
            value: function setLanguages(languages) {
                this.languages = languages;
            }
        },
        {
            key: "setPoliticalView",
            value: function setPoliticalView(pov) {}
        },
        {
            key: "updateTile",
            value: function updateTile(tile) {}
        },
        {
            key: "shouldPreloadTiles",
            value: function shouldPreloadTiles() {
                return false;
            }
        },
        {
            key: "minZoomLevel",
            get: function get() {
                logger4.warn("DataSource.minZoomLevel is deprecated. Use minDataLevel and maxDataLevel instead.");
                return this.minDataLevel;
            },
            set: function set(level) {
                logger4.warn("DataSource.minZoomLevel is deprecated. Use minDataLevel and minDisplayLevel instead.");
                this.minDataLevel = level;
            }
        },
        {
            key: "maxZoomLevel",
            get: function get() {
                logger4.warn("DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.");
                return this.maxDataLevel;
            },
            set: function set(level) {
                logger4.warn("DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.");
                this.maxDataLevel = level;
            }
        },
        {
            key: "maxGeometryHeight",
            get: function get() {
                return this.m_maxGeometryHeight;
            },
            set: function set(value2) {
                this.m_maxGeometryHeight = value2;
            }
        },
        {
            key: "minGeometryHeight",
            get: function get() {
                return this.m_minGeometryHeight;
            },
            set: function set(value2) {
                this.m_minGeometryHeight = value2;
            }
        },
        {
            key: "storageLevelOffset",
            get: function get() {
                return this.m_storageLevelOffset;
            },
            set: function set(levelOffset) {
                this.m_storageLevelOffset = levelOffset;
            }
        },
        {
            key: "setEnableElevationOverlay",
            value: function setEnableElevationOverlay(enable) {}
        },
        {
            key: "getDataZoomLevel",
            value: function getDataZoomLevel(zoomLevel) {
                return THREE36.MathUtils.clamp(zoomLevel + this.m_storageLevelOffset, this.minDataLevel, this.maxDataLevel);
            }
        },
        {
            key: "isVisible",
            value: function isVisible(zoomLevel) {
                return zoomLevel >= this.minDisplayLevel && zoomLevel <= this.maxDisplayLevel;
            }
        },
        {
            key: "canGetTile",
            value: function canGetTile(zoomLevel, tileKey) {
                return tileKey.level <= zoomLevel;
            }
        },
        {
            key: "shouldSubdivide",
            value: function shouldSubdivide(zoomLevel, tileKey) {
                return tileKey.level <= zoomLevel;
            }
        },
        {
            key: "shouldRenderText",
            value: function shouldRenderText(zoomLevel, tileKey) {
                return true;
            }
        },
        {
            key: "requestUpdate",
            value: function requestUpdate() {
                this.dispatchEvent(this.UPDATE_EVENT);
            }
        }
    ]);
    return _DataSource;
}(THREE36.EventDispatcher);
var DataSource = _DataSource;
__publicField(DataSource, "uniqueNameCounter", 0);
// src/mapview/geometry/AddGroundPlane.ts
var THREE46 = __toESM(require("three"));
// src/geometry/ClipLineString.ts
var import_three5 = require("three");
var ClipEdge = /*#__PURE__*/ function() {
    function ClipEdge(x1, y1, x2, y2, isInside) {
        _classCallCheck(this, ClipEdge);
        this.isInside = isInside;
        __publicField(this, "p0");
        __publicField(this, "p1");
        this.p0 = new import_three5.Vector2(x1, y1);
        this.p1 = new import_three5.Vector2(x2, y2);
    }
    _createClass(ClipEdge, [
        {
            key: "inside",
            value: function inside(point) {
                return this.isInside(point);
            }
        },
        {
            key: "computeIntersection",
            value: function computeIntersection(a, b) {
                var result = new import_three5.Vector2();
                Math2D.intersectLines(a.x, a.y, b.x, b.y, this.p0.x, this.p0.y, this.p1.x, this.p1.y, result);
                return result;
            }
        },
        {
            key: "clipLine",
            value: function clipLine(lineString) {
                var inputList = lineString;
                var result = [];
                lineString = [];
                result.push(lineString);
                var pushPoint = function(point) {
                    if (lineString.length === 0 || !lineString[lineString.length - 1].equals(point)) {
                        lineString.push(point);
                    }
                };
                for(var i = 0; i < inputList.length; ++i){
                    var currentPoint = inputList[i];
                    var prevPoint = i > 0 ? inputList[i - 1] : void 0;
                    if (this.inside(currentPoint)) {
                        if (prevPoint !== void 0 && !this.inside(prevPoint)) {
                            if (lineString.length > 0) {
                                lineString = [];
                                result.push(lineString);
                            }
                            pushPoint(this.computeIntersection(prevPoint, currentPoint));
                        }
                        pushPoint(currentPoint);
                    } else if (prevPoint !== void 0 && this.inside(prevPoint)) {
                        pushPoint(this.computeIntersection(prevPoint, currentPoint));
                    }
                }
                if (result[result.length - 1].length === 0) {
                    result.length = result.length - 1;
                }
                return result;
            }
        },
        {
            key: "clipLines",
            value: function clipLines(lineStrings) {
                var _this = this;
                var reuslt = [];
                lineStrings.forEach(function(lineString) {
                    _this.clipLine(lineString).forEach(function(clippedLine) {
                        reuslt.push(clippedLine);
                    });
                });
                return reuslt;
            }
        }
    ]);
    return ClipEdge;
}();
var ec = EarthConstants.EQUATORIAL_CIRCUMFERENCE;
var border = 0;
var WRAP_MIDDLE_CLIP_EDGES = [
    new ClipEdge(0 - border, ec, 0 - border, 0, function(p) {
        return p.x > 0 - border;
    }),
    new ClipEdge(ec + border, 0, ec + border, ec, function(p) {
        return p.x < ec + border;
    })
];
var WRAP_LEFT_CLIP_EDGES = [
    new ClipEdge(-ec - border, ec, -ec - border, 0, function(p) {
        return p.x > -ec - border;
    }),
    new ClipEdge(0 + border, 0, 0 + border, ec, function(p) {
        return p.x < 0 + border;
    })
];
var WRAP_RIGHT_CLIP_EDGES = [
    new ClipEdge(ec - border, ec, ec - border, 0, function(p) {
        return p.x > ec - border;
    }),
    new ClipEdge(ec * 2 + border, 0, ec * 2 + border, ec, function(p) {
        return p.x < ec * 2 + border;
    })
];
// src/geometry/ClipPolygon.ts
var import_three6 = require("three");
var ClippingEdge = /*#__PURE__*/ function() {
    function ClippingEdge() {
        _classCallCheck(this, ClippingEdge);
    }
    _createClass(ClippingEdge, [
        {
            key: "clipPolygon",
            value: function clipPolygon(polygon, extent) {
                var inputList = polygon;
                polygon = [];
                var pushPoint = function(point) {
                    var lastAddedPoint = polygon[polygon.length - 1];
                    if (!(lastAddedPoint === null || lastAddedPoint === void 0 ? void 0 : lastAddedPoint.equals(point)) || point.isClipped === true && !(lastAddedPoint === null || lastAddedPoint === void 0 ? void 0 : lastAddedPoint.isClipped) || !point.isClipped && (lastAddedPoint === null || lastAddedPoint === void 0 ? void 0 : lastAddedPoint.isClipped) === true) {
                        polygon.push(point);
                    }
                };
                for(var i = 0; i < inputList.length; ++i){
                    var currentPoint = inputList[i];
                    var prevPoint = inputList[(i + inputList.length - 1) % inputList.length];
                    if (this.inside(currentPoint, extent)) {
                        if (!this.inside(prevPoint, extent)) {
                            var p = this.computeIntersection(prevPoint, currentPoint, extent);
                            p.isClipped = true;
                            pushPoint(p);
                        }
                        pushPoint(currentPoint);
                    } else if (this.inside(prevPoint, extent)) {
                        var p1 = this.computeIntersection(prevPoint, currentPoint, extent);
                        p1.isClipped = true;
                        pushPoint(p1);
                    }
                }
                return polygon;
            }
        }
    ]);
    return ClippingEdge;
}();
var TopClippingEdge = /*#__PURE__*/ function(ClippingEdge) {
    _inherits(TopClippingEdge, ClippingEdge);
    var _super = _createSuper(TopClippingEdge);
    function TopClippingEdge() {
        _classCallCheck(this, TopClippingEdge);
        return _super.apply(this, arguments);
    }
    _createClass(TopClippingEdge, [
        {
            key: "inside",
            value: function inside(point) {
                return point.y >= 0;
            }
        },
        {
            key: "computeIntersection",
            value: function computeIntersection(a, b) {
                var x1 = a.x, y1 = a.y;
                var x2 = b.x, y2 = b.y;
                var v = new import_three6.Vector2((x1 * y2 - y1 * x2) / -(y1 - y2), 0).round();
                return v;
            }
        }
    ]);
    return TopClippingEdge;
}(ClippingEdge);
var RightClippingEdge = /*#__PURE__*/ function(ClippingEdge) {
    _inherits(RightClippingEdge, ClippingEdge);
    var _super = _createSuper(RightClippingEdge);
    function RightClippingEdge() {
        _classCallCheck(this, RightClippingEdge);
        return _super.apply(this, arguments);
    }
    _createClass(RightClippingEdge, [
        {
            key: "inside",
            value: function inside(point, extent) {
                return point.x <= extent;
            }
        },
        {
            key: "computeIntersection",
            value: function computeIntersection(a, b, extent) {
                var x1 = a.x, y1 = a.y;
                var x2 = b.x, y2 = b.y;
                var v = new import_three6.Vector2(extent, (x1 * y2 - y1 * x2 - (y1 - y2) * -extent) / (x1 - x2)).round();
                return v;
            }
        }
    ]);
    return RightClippingEdge;
}(ClippingEdge);
var BottomClipEdge = /*#__PURE__*/ function(ClippingEdge) {
    _inherits(BottomClipEdge, ClippingEdge);
    var _super = _createSuper(BottomClipEdge);
    function BottomClipEdge() {
        _classCallCheck(this, BottomClipEdge);
        return _super.apply(this, arguments);
    }
    _createClass(BottomClipEdge, [
        {
            key: "inside",
            value: function inside(point, extent) {
                return point.y <= extent;
            }
        },
        {
            key: "computeIntersection",
            value: function computeIntersection(a, b, extent) {
                var x1 = a.x, y1 = a.y;
                var x2 = b.x, y2 = b.y;
                var v = new import_three6.Vector2((x1 * y2 - y1 * x2 - (x1 - x2) * extent) / -(y1 - y2), extent).round();
                return v;
            }
        }
    ]);
    return BottomClipEdge;
}(ClippingEdge);
var LeftClippingEdge = /*#__PURE__*/ function(ClippingEdge) {
    _inherits(LeftClippingEdge, ClippingEdge);
    var _super = _createSuper(LeftClippingEdge);
    function LeftClippingEdge() {
        _classCallCheck(this, LeftClippingEdge);
        return _super.apply(this, arguments);
    }
    _createClass(LeftClippingEdge, [
        {
            key: "inside",
            value: function inside(point) {
                return point.x >= 0;
            }
        },
        {
            key: "computeIntersection",
            value: function computeIntersection(a, b) {
                var x1 = a.x, y1 = a.y;
                var x2 = b.x, y2 = b.y;
                var v = new import_three6.Vector2(0, (x1 * y2 - y1 * x2) / (x1 - x2)).round();
                return v;
            }
        }
    ]);
    return LeftClippingEdge;
}(ClippingEdge);
var clipEdges = [
    new TopClippingEdge(),
    new RightClippingEdge(),
    new BottomClipEdge(),
    new LeftClippingEdge()
];
// src/geometry/EdgeLengthGeometrySubdivisionModifier.ts
var import_three8 = require("three");
// src/geometry/SubdivisionModifier.ts
var import_three7 = require("three");
var tmpVectorA = new import_three7.Vector3();
var tmpVectorB = new import_three7.Vector3();
var tmpVectorC = new import_three7.Vector3();
var SubdivisionModifier = /*#__PURE__*/ function() {
    function SubdivisionModifier() {
        _classCallCheck(this, SubdivisionModifier);
    }
    _createClass(SubdivisionModifier, [
        {
            key: "modify",
            value: function modify(geometry) {
                var middleVertex = function middleVertex(i, j) {
                    var _position;
                    var key = "".concat(Math.min(i, j), "_").concat(Math.max(i, j));
                    var h = cache6.get(key);
                    if (h !== void 0) {
                        return h;
                    }
                    tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);
                    tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);
                    tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
                    var index = position.length / 3;
                    (_position = position).push.apply(_position, _toConsumableArray(tmpVectorC.toArray()));
                    cache6.set(key, index);
                    if (uv !== void 0) {
                        tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);
                        tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);
                        tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
                        uv.push(tmpVectorC.x, tmpVectorC.y);
                    }
                    if (edge !== void 0) {
                        if (edge[i] === j) {
                            edge.push(j);
                            edge[i] = index;
                        } else if (edge[j] === i) {
                            edge.push(i);
                            edge[j] = index;
                        } else {
                            edge.push(-1);
                        }
                    }
                    if (wall !== void 0) {
                        if (wall[i] === j) {
                            wall.push(j);
                            wall[i] = index;
                        } else if (wall[j] === i) {
                            wall.push(i);
                            wall[j] = index;
                        } else {
                            wall.push(-1);
                        }
                    }
                    return index;
                };
                var positionAttr = geometry.getAttribute("position");
                var position = Array.from(positionAttr.array);
                var uvAttr = geometry.getAttribute("uv");
                var uv = uvAttr !== void 0 ? Array.from(uvAttr.array) : void 0;
                var edgeAttr = geometry.getAttribute("edge");
                var edge = edgeAttr !== void 0 ? Array.from(edgeAttr.array) : void 0;
                var wallAttr = geometry.getAttribute("wall");
                var wall = wallAttr !== void 0 ? Array.from(wallAttr.array) : void 0;
                var indexAttr = geometry.getIndex();
                var indices = Array.from(indexAttr.array);
                var cache6 = /* @__PURE__ */ new Map();
                var newIndices = [];
                while(indices.length >= 3){
                    var v0 = indices.shift();
                    var v1 = indices.shift();
                    var v2 = indices.shift();
                    tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);
                    tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);
                    tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);
                    var edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);
                    switch(edgeToSplit){
                        case 0:
                            {
                                var v3 = middleVertex(v0, v1);
                                indices.push(v0, v3, v2, v3, v1, v2);
                                break;
                            }
                        case 1:
                            {
                                var v31 = middleVertex(v1, v2);
                                indices.push(v0, v1, v31, v0, v31, v2);
                                break;
                            }
                        case 2:
                            {
                                var v32 = middleVertex(v2, v0);
                                indices.push(v0, v1, v32, v32, v1, v2);
                                break;
                            }
                        case void 0:
                            {
                                newIndices.push(v0, v1, v2);
                                break;
                            }
                        default:
                            throw new Error("failed to subdivide the given geometry");
                    }
                }
                positionAttr.array = _instanceof(positionAttr.array, Float32Array) ? new Float32Array(position) : new Float64Array(position);
                positionAttr.count = position.length / positionAttr.itemSize;
                positionAttr.needsUpdate = true;
                geometry.setIndex(newIndices);
                if (uv !== void 0) {
                    uvAttr.array = new Float32Array(uv);
                    uvAttr.count = uv.length / uvAttr.itemSize;
                    uvAttr.needsUpdate = true;
                }
                if (edge !== void 0) {
                    edgeAttr.array = new Float32Array(edge);
                    edgeAttr.count = edge.length / edgeAttr.itemSize;
                    edgeAttr.needsUpdate = true;
                }
                return geometry;
            }
        }
    ]);
    return SubdivisionModifier;
}();
// src/geometry/EdgeLengthGeometrySubdivisionModifier.ts
var VERTEX_POSITION_CACHE = [
    new import_three8.Vector3(),
    new import_three8.Vector3()
];
var EdgeLengthGeometrySubdivisionModifier = /*#__PURE__*/ function(SubdivisionModifier) {
    _inherits(EdgeLengthGeometrySubdivisionModifier, SubdivisionModifier);
    var _super = _createSuper(EdgeLengthGeometrySubdivisionModifier);
    function EdgeLengthGeometrySubdivisionModifier(subdivision, geoBox) {
        var subdivisionMode = arguments.length > 2 && arguments[2] !== void 0 /* All */  ? arguments[2] : 0, projection = arguments.length > 3 ? arguments[3] : void 0;
        _classCallCheck(this, EdgeLengthGeometrySubdivisionModifier);
        var _this;
        _this = _super.call(this);
        _this.subdivision = subdivision;
        _this.geoBox = geoBox;
        _this.subdivisionMode = subdivisionMode;
        _this.projection = projection;
        __publicField(_assertThisInitialized(_this), "m_projectedBox");
        __publicField(_assertThisInitialized(_this), "m_maxLength");
        __publicField(_assertThisInitialized(_this), "m_maxLengthX");
        __publicField(_assertThisInitialized(_this), "m_maxLengthY");
        assert(projection.type === 0 /* Planar */ , "EdgeLengthGeometrySubdivisionModifier only supports planar projections");
        var northEast = projection.projectPoint(geoBox.northEast, VERTEX_POSITION_CACHE[0]);
        var southWest = projection.projectPoint(geoBox.southWest, VERTEX_POSITION_CACHE[1]);
        _this.m_projectedBox = {
            min: {
                x: Math.min(northEast.x, southWest.x),
                y: Math.min(northEast.y, southWest.y),
                z: Math.min(northEast.z, southWest.z)
            },
            max: {
                x: Math.max(northEast.x, southWest.x),
                y: Math.max(northEast.y, southWest.y),
                z: Math.max(northEast.z, southWest.z)
            }
        };
        _this.m_maxLengthX = (_this.m_projectedBox.max.x - _this.m_projectedBox.min.x) / subdivision;
        _this.m_maxLengthY = (_this.m_projectedBox.max.y - _this.m_projectedBox.min.y) / subdivision;
        if (_this.subdivisionMode === 0 /* All */ ) {
            _this.m_maxLengthX *= 1.1;
            _this.m_maxLengthY *= 1.1;
        }
        _this.m_maxLength = Math.sqrt(_this.m_maxLengthX * _this.m_maxLengthX + _this.m_maxLengthY * _this.m_maxLengthY);
        return _this;
    }
    _createClass(EdgeLengthGeometrySubdivisionModifier, [
        {
            key: "maxLength",
            get: function get() {
                return this.m_maxLength;
            }
        },
        {
            key: "maxLengthX",
            get: function get() {
                return this.m_maxLengthX;
            }
        },
        {
            key: "maxLengthY",
            get: function get() {
                return this.m_maxLengthY;
            }
        },
        {
            key: "shouldSplitTriangle",
            value: function shouldSplitTriangle(a, b, c) {
                var shouldSplitAB = this.shouldSplitEdge(a, b);
                var shouldSplitBC = this.shouldSplitEdge(b, c);
                var shouldSplitCA = this.shouldSplitEdge(c, a);
                var shouldSplit = shouldSplitAB || shouldSplitBC || shouldSplitCA;
                if (!shouldSplit) {
                    return;
                }
                var ab = a.distanceTo(b);
                var bc = b.distanceTo(c);
                var ca = c.distanceTo(a);
                var maxDistance = Math.max(shouldSplitAB ? ab : 0, shouldSplitBC ? bc : 0, shouldSplitCA ? ca : 0);
                if (ab === maxDistance) {
                    return 0;
                } else if (bc === maxDistance) {
                    return 1;
                } else if (ca === maxDistance) {
                    return 2;
                }
                throw new Error("Could not split triangle.");
            }
        },
        {
            key: "shouldSplitEdge",
            value: function shouldSplitEdge(a, b) {
                switch(this.subdivisionMode){
                    case 0 /* All */ :
                        return a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX || a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY || a.distanceTo(b) > this.m_maxLength;
                    case 1 /* NoDiagonals */ :
                        return a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX || a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY;
                }
            }
        }
    ]);
    return EdgeLengthGeometrySubdivisionModifier;
}(SubdivisionModifier);
// src/geometry/SphericalGeometrySubdivisionModifier.ts
var import_three9 = require("three");
var VERTEX_POSITION_CACHE2 = [
    new import_three9.Vector3(),
    new import_three9.Vector3(),
    new import_three9.Vector3()
];
var SphericalGeometrySubdivisionModifier = /*#__PURE__*/ function(SubdivisionModifier) {
    _inherits(SphericalGeometrySubdivisionModifier, SubdivisionModifier);
    var _super = _createSuper(SphericalGeometrySubdivisionModifier);
    function SphericalGeometrySubdivisionModifier(angle) {
        var projection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : sphereProjection;
        _classCallCheck(this, SphericalGeometrySubdivisionModifier);
        var _this;
        _this = _super.call(this);
        _this.angle = angle;
        _this.projection = projection;
        return _this;
    }
    _createClass(SphericalGeometrySubdivisionModifier, [
        {
            key: "shouldSplitTriangle",
            value: function shouldSplitTriangle(a, b, c) {
                var aa = sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE2[0]);
                var bb = sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE2[1]);
                var cc = sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE2[2]);
                var alpha = aa.angleTo(bb);
                var beta = bb.angleTo(cc);
                var gamma = cc.angleTo(aa);
                var m = Math.max(alpha, Math.max(beta, gamma));
                if (m < this.angle) {
                    return void 0;
                }
                if (m === alpha) {
                    return 0;
                } else if (m === beta) {
                    return 1;
                } else if (m === gamma) {
                    return 2;
                }
                throw new Error("failed to split triangle");
            }
        }
    ]);
    return SphericalGeometrySubdivisionModifier;
}(SubdivisionModifier);
// src/geometry/WrapPolygon.ts
var import_three10 = require("three");
var ClipEdge2 = /*#__PURE__*/ function(ClippingEdge) {
    _inherits(ClipEdge2, ClippingEdge);
    var _super = _createSuper(ClipEdge2);
    function ClipEdge2(p0, p1, isInside) {
        _classCallCheck(this, ClipEdge2);
        var _this;
        _this = _super.call(this);
        _this.isInside = isInside;
        __publicField(_assertThisInitialized(_this), "p0");
        __publicField(_assertThisInitialized(_this), "p1");
        _this.p0 = new import_three10.Vector2().fromArray(p0);
        _this.p1 = new import_three10.Vector2().fromArray(p1);
        return _this;
    }
    _createClass(ClipEdge2, [
        {
            key: "inside",
            value: function inside(point, extent) {
                return this.isInside(point);
            }
        },
        {
            key: "computeIntersection",
            value: function computeIntersection(a, b, extent) {
                var result = new import_three10.Vector2();
                Math2D.intersectLines(a.x, a.y, b.x, b.y, this.p0.x, this.p0.y, this.p1.x, this.p1.y, result);
                return result;
            }
        }
    ]);
    return ClipEdge2;
}(ClippingEdge);
var ec2 = EarthConstants.EQUATORIAL_CIRCUMFERENCE;
var border2 = ec2 * 0.05;
var WRAP_MIDDLE_CLIP_EDGES2 = [
    new ClipEdge2([
        0 - border2,
        ec2
    ], [
        0 - border2,
        0
    ], function(p) {
        return p.x > 0 - border2;
    }),
    new ClipEdge2([
        ec2 + border2,
        0
    ], [
        ec2 + border2,
        ec2
    ], function(p) {
        return p.x < ec2 + border2;
    })
];
var WRAP_LEFT_CLIP_EDGES2 = [
    new ClipEdge2([
        -ec2 - border2,
        ec2
    ], [
        -ec2 - border2,
        0
    ], function(p) {
        return p.x > -ec2 - border2;
    }),
    new ClipEdge2([
        0 + border2,
        0
    ], [
        0 + border2,
        ec2
    ], function(p) {
        return p.x < 0 + border2;
    })
];
var WRAP_RIGHT_CLIP_EDGES2 = [
    new ClipEdge2([
        ec2 - border2,
        ec2
    ], [
        ec2 - border2,
        0
    ], function(p) {
        return p.x > ec2 - border2;
    }),
    new ClipEdge2([
        ec2 * 2 + border2,
        0
    ], [
        ec2 * 2 + border2,
        ec2
    ], function(p) {
        return p.x < ec2 * 2 + border2;
    })
];
// src/mapview/geometry/ProjectTilePlaneCorners.ts
var THREE37 = __toESM(require("three"));
function projectTilePlaneCorners(tile, projection) {
    var _geoBox = tile.geoBox, east = _geoBox.east, west = _geoBox.west, north = _geoBox.north, south = _geoBox.south;
    var sw = projection.projectPoint(new GeoCoordinates(south, west), new THREE37.Vector3());
    var se = projection.projectPoint(new GeoCoordinates(south, east), new THREE37.Vector3());
    var nw = projection.projectPoint(new GeoCoordinates(north, west), new THREE37.Vector3());
    var ne = projection.projectPoint(new GeoCoordinates(north, east), new THREE37.Vector3());
    return {
        sw: sw,
        se: se,
        nw: nw,
        ne: ne
    };
}
// src/mapview/MapMaterialAdapter.ts
var THREE45 = __toESM(require("three"));
// src/mapview/DecodedTileHelpers.ts
var THREE44 = __toESM(require("three"));
// src/mapview/geometry/DisplacedMesh.ts
var THREE40 = __toESM(require("three"));
// src/mapview/geometry/DisplacedBufferAttribute.ts
var THREE38 = __toESM(require("three"));
// src/mapview/geometry/VertexCache.ts
var Invalid = -1;
var VertexCache = /*#__PURE__*/ function() {
    function VertexCache(maxVertexCount) {
        _classCallCheck(this, VertexCache);
        this.maxVertexCount = maxVertexCount;
        __publicField(this, "m_cache", []);
        __publicField(this, "m_vertexCount", 0);
        __publicField(this, "m_oldestIdx", 0);
        __publicField(this, "m_newestIdx", 0);
        this.m_cache.length = this.maxVertexCount * 6 /* Count */ ;
        this.clear();
    }
    _createClass(VertexCache, [
        {
            key: "clear",
            value: function clear() {
                this.m_cache.fill(Invalid);
                this.m_vertexCount = 0;
            }
        },
        {
            key: "get",
            value: function get(vertexId, vertex) {
                var vertexIdx = this.find(vertexId);
                if (vertexIdx === void 0) {
                    return false;
                }
                this.promoteEntry(vertexIdx);
                this.getVertex(vertexIdx, vertex);
                return true;
            }
        },
        {
            key: "set",
            value: function set(vertexId, vertex) {
                var vertexIdx = Invalid;
                if (this.m_vertexCount < this.maxVertexCount) {
                    vertexIdx = this.m_vertexCount * 6 /* Count */ ;
                    this.m_vertexCount++;
                } else {
                    vertexIdx = this.m_oldestIdx;
                }
                if (this.m_vertexCount === 1) {
                    this.m_oldestIdx = this.m_newestIdx = vertexIdx;
                } else {
                    this.promoteEntry(vertexIdx);
                }
                this.setVertex(vertexIdx, vertexId, vertex);
            }
        },
        {
            key: "find",
            value: function find(vertexId) {
                var size = this.m_cache.length;
                for(var i = 0; i < size; i += 6 /* Count */ ){
                    if (this.m_cache[i] === vertexId) {
                        return i;
                    }
                }
                return void 0;
            }
        },
        {
            key: "promoteEntry",
            value: function promoteEntry(vertexIdx) {
                if (vertexIdx === this.m_newestIdx) {
                    return;
                }
                var newerIdx = this.getNewerIdx(vertexIdx);
                var olderIdx = this.getOlderIdx(vertexIdx);
                if (newerIdx !== Invalid) {
                    assert(this.getOlderIdx(newerIdx) === vertexIdx);
                    this.setOlderIdx(newerIdx, olderIdx);
                }
                if (olderIdx !== Invalid) {
                    assert(this.getNewerIdx(olderIdx) === vertexIdx);
                    this.setNewerIdx(olderIdx, newerIdx);
                }
                if (vertexIdx === this.m_oldestIdx) {
                    this.m_oldestIdx = newerIdx;
                }
                this.setNewerIdx(vertexIdx, Invalid);
                this.setOlderIdx(vertexIdx, this.m_newestIdx);
                assert(this.m_newestIdx !== Invalid);
                assert(this.getNewerIdx(this.m_newestIdx) === Invalid);
                this.setNewerIdx(this.m_newestIdx, vertexIdx);
                this.m_newestIdx = vertexIdx;
            }
        },
        {
            key: "getOlderIdx",
            value: function getOlderIdx(vertexIdx) {
                return this.m_cache[vertexIdx + 1 /* OlderIdx */ ];
            }
        },
        {
            key: "setOlderIdx",
            value: function setOlderIdx(vertexIdx, olderIdx) {
                this.m_cache[vertexIdx + 1 /* OlderIdx */ ] = olderIdx;
            }
        },
        {
            key: "getNewerIdx",
            value: function getNewerIdx(vertexIdx) {
                return this.m_cache[vertexIdx + 2 /* NewerIdx */ ];
            }
        },
        {
            key: "setNewerIdx",
            value: function setNewerIdx(vertexIdx, newerIdx) {
                this.m_cache[vertexIdx + 2 /* NewerIdx */ ] = newerIdx;
            }
        },
        {
            key: "getVertex",
            value: function getVertex(vertexIdx, vertex) {
                vertex.x = this.m_cache[vertexIdx + 3 /* X */ ];
                vertex.y = this.m_cache[vertexIdx + 4 /* Y */ ];
                vertex.z = this.m_cache[vertexIdx + 5 /* Z */ ];
            }
        },
        {
            key: "setVertex",
            value: function setVertex(vertexIdx, vertexId, vertex) {
                this.m_cache[vertexIdx] = vertexId;
                this.m_cache[vertexIdx + 3 /* X */ ] = vertex.x;
                this.m_cache[vertexIdx + 4 /* Y */ ] = vertex.y;
                this.m_cache[vertexIdx + 5 /* Z */ ] = vertex.z;
            }
        }
    ]);
    return VertexCache;
}();
// src/mapview/geometry/DisplacedBufferAttribute.ts
var _DisplacedBufferAttribute = /*#__PURE__*/ function(_BufferAttribute) {
    _inherits(_DisplacedBufferAttribute, _BufferAttribute);
    var _super = _createSuper(_DisplacedBufferAttribute);
    function _DisplacedBufferAttribute(originalAttribute, m_normals, m_uvs, displacementMap) {
        _classCallCheck(this, _DisplacedBufferAttribute);
        var _this;
        _this = _super.call(this, originalAttribute.array, originalAttribute.itemSize, originalAttribute.normalized);
        _this.originalAttribute = originalAttribute;
        _this.m_normals = m_normals;
        _this.m_uvs = m_uvs;
        __publicField(_assertThisInitialized(_this), "m_texture");
        __publicField(_assertThisInitialized(_this), "m_textureWidth", 0);
        __publicField(_assertThisInitialized(_this), "m_textureHeight", 0);
        __publicField(_assertThisInitialized(_this), "m_cache", new VertexCache(_DisplacedBufferAttribute.MAX_CACHE_SIZE));
        __publicField(_assertThisInitialized(_this), "m_lastBufferIndex");
        __publicField(_assertThisInitialized(_this), "m_lastPos", new THREE38.Vector3());
        __publicField(_assertThisInitialized(_this), "m_tmpNormal", new THREE38.Vector3());
        _this.resetTexture(displacementMap);
        return _this;
    }
    _createClass(_DisplacedBufferAttribute, [
        {
            key: "reset",
            value: function reset(originalAttribute, normals, uvs, displacementMap) {
                this.array = originalAttribute.array;
                this.itemSize = originalAttribute.itemSize;
                this.count = this.array.length / this.itemSize;
                this.normalized = originalAttribute.normalized;
                this.originalAttribute = originalAttribute;
                this.m_normals = normals;
                this.m_uvs = uvs;
                this.m_cache.clear();
                this.m_lastBufferIndex = void 0;
                this.resetTexture(displacementMap);
            }
        },
        {
            key: "getX",
            value: function getX(index) {
                return this.getDisplacedCoordinate(index).x;
            }
        },
        {
            key: "getY",
            value: function getY(index) {
                return this.getDisplacedCoordinate(index).y;
            }
        },
        {
            key: "getZ",
            value: function getZ(index) {
                return this.getDisplacedCoordinate(index).z;
            }
        },
        {
            key: "resetTexture",
            value: function resetTexture(displacementMap) {
                this.m_texture = new Float32Array(displacementMap.image.data.buffer);
                this.m_textureWidth = displacementMap.image.width;
                this.m_textureHeight = displacementMap.image.height;
            }
        },
        {
            key: "getDisplacedCoordinate",
            value: function getDisplacedCoordinate(bufferIndex) {
                if (bufferIndex === this.m_lastBufferIndex) {
                    return this.m_lastPos;
                }
                this.m_lastBufferIndex = bufferIndex;
                if (this.m_cache.get(bufferIndex, this.m_lastPos)) {
                    return this.m_lastPos;
                }
                this.displacePosition(bufferIndex);
                this.m_cache.set(bufferIndex, this.m_lastPos);
                return this.m_lastPos;
            }
        },
        {
            key: "displacePosition",
            value: function displacePosition(bufferIndex) {
                this.m_lastPos.fromBufferAttribute(this.originalAttribute, bufferIndex);
                var normals = this.m_normals;
                this.m_tmpNormal.fromBufferAttribute(normals, bufferIndex);
                var uvs = this.m_uvs;
                var u = THREE38.MathUtils.clamp(uvs.getX(bufferIndex), 0, 1);
                var v = THREE38.MathUtils.clamp(uvs.getY(bufferIndex), 0, 1);
                var displacement = sampleBilinear(this.m_texture, this.m_textureWidth, this.m_textureHeight, u, v);
                this.m_lastPos.add(this.m_tmpNormal.multiplyScalar(displacement));
            }
        }
    ]);
    return _DisplacedBufferAttribute;
}(THREE38.BufferAttribute);
var DisplacedBufferAttribute = _DisplacedBufferAttribute;
__publicField(DisplacedBufferAttribute, "MAX_CACHE_SIZE", 6);
// src/mapview/geometry/DisplacedBufferGeometry.ts
var THREE39 = __toESM(require("three"));
var tmpV12 = new THREE39.Vector3();
var tmpV2 = new THREE39.Vector3();
var tmpBox = new THREE39.Box3();
function displaceBox(box, displacementRange, displacementDir) {
    tmpBox.copy(box);
    var tmpNormalMin = tmpV12.copy(displacementDir);
    var tmpNormalMax = tmpV2.copy(tmpNormalMin);
    box.translate(tmpNormalMin.multiplyScalar(displacementRange.min)).union(tmpBox.translate(tmpNormalMax.multiplyScalar(displacementRange.max)));
    return box;
}
var DisplacedBufferGeometry = /*#__PURE__*/ function(_BufferGeometry) {
    _inherits(DisplacedBufferGeometry, _BufferGeometry);
    var _super = _createSuper(DisplacedBufferGeometry);
    function DisplacedBufferGeometry(originalGeometry, displacementMap, displacementRange, displacedPositions) {
        _classCallCheck(this, DisplacedBufferGeometry);
        var _this;
        _this = _super.call(this);
        _this.originalGeometry = originalGeometry;
        _this.displacementRange = displacementRange;
        __publicField(_assertThisInitialized(_this), "m_displacedPositions");
        __publicField(_assertThisInitialized(_this), "m_originalBoundingBox", new THREE39.Box3());
        if (!displacedPositions) {
            _this.m_displacedPositions = new DisplacedBufferAttribute(originalGeometry.attributes.position, originalGeometry.attributes.normal, originalGeometry.attributes.uv, displacementMap);
        } else {
            _this.m_displacedPositions = displacedPositions;
        }
        _this.resetAttributes();
        return _this;
    }
    _createClass(DisplacedBufferGeometry, [
        {
            key: "reset",
            value: function reset(geometry, displacementMap, displacementRange) {
                this.originalGeometry = geometry;
                var positions = geometry.attributes.position;
                var normals = geometry.attributes.normal;
                var uvs = geometry.attributes.uv;
                this.m_displacedPositions.reset(positions, normals, uvs, displacementMap);
                var displacementRangeChanged = this.displacementRange.min !== displacementRange.min || this.displacementRange.max !== displacementRange.max;
                this.displacementRange = displacementRange;
                this.resetAttributes();
                this.resetBoundingVolumes(displacementRangeChanged);
            }
        },
        {
            key: "computeBoundingBox",
            value: function computeBoundingBox() {
                if (this.originalGeometry.boundingBox === null) {
                    this.originalGeometry.computeBoundingBox();
                }
                var origBBox = this.m_originalBoundingBox.copy(this.originalGeometry.boundingBox);
                if (this.boundingBox === null) {
                    this.boundingBox = origBBox.clone();
                } else {
                    this.boundingBox.copy(origBBox);
                }
                displaceBox(this.boundingBox, this.displacementRange, tmpV12.fromBufferAttribute(this.attributes.normal, 0));
            }
        },
        {
            key: "computeBoundingSphere",
            value: function computeBoundingSphere() {
                if (this.boundingBox === null) {
                    this.computeBoundingBox();
                }
                if (this.boundingSphere === null) {
                    this.boundingSphere = new THREE39.Sphere();
                }
                this.boundingBox.getBoundingSphere(this.boundingSphere);
            }
        },
        {
            key: "needsBoundingBoxUpdate",
            value: function needsBoundingBoxUpdate(displacementRangeChanged) {
                return displacementRangeChanged || this.boundingBox !== null && (!this.originalGeometry.boundingBox || !this.m_originalBoundingBox.equals(this.originalGeometry.boundingBox));
            }
        },
        {
            key: "resetBoundingVolumes",
            value: function resetBoundingVolumes(displacementRangeChanged) {
                if (this.needsBoundingBoxUpdate(displacementRangeChanged)) {
                    this.computeBoundingBox();
                    if (this.boundingSphere) {
                        this.computeBoundingSphere();
                    }
                }
            }
        },
        {
            key: "resetAttributes",
            value: function resetAttributes() {
                this.index = this.originalGeometry.index;
                this.groups = this.originalGeometry.groups;
                this.drawRange = this.originalGeometry.drawRange;
                this.attributes = _objectSpread({}, this.originalGeometry.attributes);
                this.attributes.position = this.m_displacedPositions;
            }
        }
    ]);
    return DisplacedBufferGeometry;
}(THREE39.BufferGeometry);
// src/mapview/geometry/DisplacedMesh.ts
function isDisplacementMaterial(material) {
    var isDisplacementFeature = hasDisplacementFeature(material);
    assert(isDisplacementFeature, "Material does not support displacement maps.");
    return isDisplacementFeature;
}
function isDataTextureMap(map) {
    if (!map) {
        return false;
    }
    var isDataTexture = _instanceof(map, THREE40.DataTexture);
    assert(isDataTexture, "Material does not support displacement maps.");
    return isDataTexture;
}
var _DisplacedMesh = /*#__PURE__*/ function(_Mesh) {
    _inherits(_DisplacedMesh, _Mesh);
    var _super = _createSuper(_DisplacedMesh);
    function _DisplacedMesh(geometry, material, m_getDisplacementRange, m_raycastStrategy) {
        _classCallCheck(this, _DisplacedMesh);
        var _this;
        _this = _super.call(this, geometry, material);
        _this.m_getDisplacementRange = m_getDisplacementRange;
        _this.m_raycastStrategy = m_raycastStrategy;
        __publicField(_assertThisInitialized(_this), "displacedGeometry");
        return _this;
    }
    _createClass(_DisplacedMesh, [
        {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
                var firstMaterial = this.firstMaterial;
                if (!isDisplacementMaterial(firstMaterial) || !isDataTextureMap(firstMaterial.displacementMap)) {
                    _get(_getPrototypeOf(_DisplacedMesh.prototype), "raycast", this).call(this, raycaster, intersects);
                    return;
                }
                var displacementMap = firstMaterial.displacementMap;
                var displacementRange = _objectSpread({}, this.m_getDisplacementRange());
                assert(_instanceof(this.geometry, THREE40.BufferGeometry), "Unsupported geometry type.");
                var geometry = this.geometry;
                if (this.displacedGeometry) {
                    this.displacedGeometry.reset(geometry, displacementMap, displacementRange);
                } else {
                    this.displacedGeometry = new DisplacedBufferGeometry(geometry, displacementMap, displacementRange, _DisplacedMesh.getDisplacedPositionAttribute(geometry, displacementMap));
                }
                this.geometry = this.displacedGeometry;
                if (this.m_raycastStrategy) {
                    this.m_raycastStrategy(this, raycaster, intersects);
                } else {
                    _get(_getPrototypeOf(_DisplacedMesh.prototype), "raycast", this).call(this, raycaster, intersects);
                }
                _set(_getPrototypeOf(_DisplacedMesh.prototype), "geometry", this.displacedGeometry.originalGeometry, this, true);
            }
        },
        {
            key: "firstMaterial",
            get: function get() {
                return Array.isArray(this.material) ? this.material[0] : this.material;
            }
        }
    ], [
        {
            key: "getDisplacedPositionAttribute",
            value: function getDisplacedPositionAttribute(geometry, displacementMap) {
                if (!_DisplacedMesh.displacedPositions) {
                    _DisplacedMesh.displacedPositions = new DisplacedBufferAttribute(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);
                } else {
                    _DisplacedMesh.displacedPositions.reset(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);
                }
                return _DisplacedMesh.displacedPositions;
            }
        }
    ]);
    return _DisplacedMesh;
}(THREE40.Mesh);
var DisplacedMesh = _DisplacedMesh;
__publicField(DisplacedMesh, "displacedPositions");
// src/mapview/geometry/SolidLineMesh.ts
var THREE41 = __toESM(require("three"));
var tmpSphere = new THREE41.Sphere();
var tmpInverseMatrix = new THREE41.Matrix4();
var tmpRay = new THREE41.Ray();
var tmpLine1 = new THREE41.Line3();
var tmpBox2 = new THREE41.Box3();
var tmpOBB = new OrientedBox3();
var tmpPlane = new THREE41.Plane();
var tmpV13 = new THREE41.Vector3();
var tmpV22 = new THREE41.Vector3();
var tmpV3 = new THREE41.Vector3();
var tmpV4 = new THREE41.Vector3();
var SEGMENT_STRIDE = 6;
var VERTEX_STRIDE = 2;
function isSolidLineMaterial(material) {
    return Array.isArray(material) ? material.every(function(mat) {
        return _instanceof(mat, SolidLineMaterial);
    }) : _instanceof(material, SolidLineMaterial);
}
function getAttributeInfo(attribute) {
    var isBufferAttribute = attribute.isBufferAttribute === true;
    var data2 = isBufferAttribute ? attribute : attribute.data;
    return {
        data: data2,
        version: data2.version
    };
}
function attributeChanged(attribute, attrInfo) {
    var isBufferAttribute = attribute.isBufferAttribute === true;
    var data2 = isBufferAttribute ? attribute : attribute.data;
    return attrInfo === void 0 || attrInfo.data !== data2 || attribute.isBufferAttribute && attrInfo.version !== data2.version;
}
function computeFeatureBoundingSphere(geometry, featureBeginIndex, featureEndIndex) {
    var displacementRange;
    if (_instanceof(geometry, DisplacedBufferGeometry)) {
        displacementRange = geometry.displacementRange;
        geometry = geometry.originalGeometry;
    }
    var attributes = geometry.attributes;
    var pos = attributes.position;
    var indices = geometry.index.array;
    var sphere = new THREE41.Sphere();
    var bbox = tmpBox2.makeEmpty();
    var vertex = tmpV13;
    for(var i = featureBeginIndex; i < featureEndIndex; i += SEGMENT_STRIDE){
        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i]));
        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i + VERTEX_STRIDE]));
    }
    if (displacementRange) {
        var normal = tmpV22;
        normal.fromBufferAttribute(geometry.attributes.normal, 0);
        return displaceBox(bbox, displacementRange, normal).getBoundingSphere(sphere);
    }
    return bbox.getBoundingSphere(sphere);
}
function intersectExtrudedLine(ray, line, vExtrusion, normal, hWidth) {
    var obb = tmpOBB;
    line.getCenter(obb.position);
    line.delta(obb.xAxis).normalize();
    obb.yAxis.copy(vExtrusion);
    obb.zAxis.copy(normal);
    obb.extents.set(line.distance() / 2, hWidth, hWidth);
    if (obb.contains(ray.origin)) {
        return 0;
    }
    var ref;
    return (ref = obb.intersectsRay(ray)) !== null && ref !== void 0 ? ref : Infinity;
}
function intersectClosestEndCap(ray, line, hWidth) {
    var sphere = new THREE41.Sphere(line.start, hWidth);
    var startCapT = sphere.containsPoint(ray.origin) ? 0 : ray.intersectSphere(sphere, tmpV4) ? tmpV4.sub(ray.origin).length() : Infinity;
    sphere.center.copy(line.end);
    var endCapT = sphere.containsPoint(ray.origin) ? 0 : ray.intersectSphere(sphere, tmpV4) ? tmpV4.sub(ray.origin).length() : Infinity;
    return Math.min(startCapT, endCapT);
}
function intersectLine(ray, line, vExtrusion, hWidth, hWidthSq, plane, interPlane, outInterLine) {
    if (interPlane.equals(ray.origin) && ray.direction.dot(plane.normal) === 0) {
        var extrLineT = intersectExtrudedLine(ray, line, vExtrusion, plane.normal, hWidth);
        var endCapT = intersectClosestEndCap(ray, line, hWidth);
        var minT = Math.min(extrLineT, endCapT);
        if (minT === Infinity) {
            return false;
        }
        ray.at(minT, outInterLine);
        return true;
    }
    var distSq = interPlane.distanceToSquared(line.closestPointToPoint(interPlane, true, tmpV4));
    if (distSq > hWidthSq) {
        return false;
    }
    outInterLine.copy(interPlane);
    return true;
}
function intersectFeature(mesh, raycaster, localRay, halfWidth, lHalfWidth, lHalfWidthSq, beginIdx, endIdx, bSphere, intersections) {
    var vExt = tmpV13;
    var plane = tmpPlane;
    var interPlane = tmpV22;
    var line = tmpLine1;
    var geometry = mesh.geometry;
    var attributes = geometry.attributes;
    var position = attributes.position;
    var bitangent = attributes.biTangent;
    var indices = geometry.index.array;
    tmpSphere.copy(bSphere);
    tmpSphere.applyMatrix4(mesh.matrixWorld);
    tmpSphere.radius += halfWidth;
    if (!raycaster.ray.intersectsSphere(tmpSphere)) {
        return;
    }
    for(var i = beginIdx; i < endIdx; i += SEGMENT_STRIDE){
        var a = indices[i];
        var b = indices[i + VERTEX_STRIDE];
        line.start.fromBufferAttribute(position, a);
        line.end.fromBufferAttribute(position, b);
        vExt.set(bitangent.getX(a), bitangent.getY(a), bitangent.getZ(a)).normalize();
        plane.setFromCoplanarPoints(line.start, tmpV3.copy(line.start).add(vExt), line.end);
        if (plane.normal.manhattanLength() === 0) {
            continue;
        }
        if (!localRay.intersectPlane(plane, interPlane)) {
            continue;
        }
        var interLine = tmpV3;
        if (!intersectLine(localRay, line, vExt, lHalfWidth, lHalfWidthSq, plane, interPlane, interLine)) {
            continue;
        }
        var interLineWorld = interLine.applyMatrix4(mesh.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(interLineWorld);
        if (distance < raycaster.near || distance > raycaster.far) {
            continue;
        }
        intersections.push({
            distance: distance,
            point: interLineWorld.clone(),
            index: i,
            object: mesh
        });
    }
}
var singleFeatureStart = [
    0
];
var MAX_SCALE_RATIO_DIFF = 0.01;
function intersectGroup(mesh, material, raycaster, localRay, firstFeatureIdx, groupEndIdx, intersections) {
    var bVolumes = mesh.userData.feature.boundingVolumes;
    assert(_instanceof(mesh.geometry, THREE41.BufferGeometry), "Unsupported geometry type.");
    var geometry = mesh.geometry;
    assert(isSolidLineMaterial(material), "Unsupported material type");
    var solidLineMaterial = material;
    var halfWidth = (solidLineMaterial.lineWidth + solidLineMaterial.outlineWidth) / 2;
    assert(Math.abs(1 - mesh.scale.x / mesh.scale.y) < MAX_SCALE_RATIO_DIFF);
    assert(Math.abs(1 - mesh.scale.x / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);
    assert(Math.abs(1 - mesh.scale.y / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);
    var localHalfWidth = halfWidth / ((mesh.scale.x + mesh.scale.y + mesh.scale.z) / 3);
    var localHalfWidthSq = localHalfWidth * localHalfWidth;
    var _starts;
    var featureStarts = (_starts = mesh.userData.feature.starts) !== null && _starts !== void 0 ? _starts : singleFeatureStart;
    var featureIdx = firstFeatureIdx;
    var beginIdx = featureStarts[featureIdx];
    var lastFeatureIdx = featureStarts.length - 1;
    while(beginIdx < groupEndIdx){
        var bVolumeIdx = featureIdx;
        var endIdx = featureIdx < lastFeatureIdx ? featureStarts[++featureIdx] : groupEndIdx;
        if (bVolumeIdx >= bVolumes.length) {
            bVolumes.push(computeFeatureBoundingSphere(geometry, beginIdx, endIdx));
        }
        intersectFeature(mesh, raycaster, localRay, halfWidth, localHalfWidth, localHalfWidthSq, beginIdx, endIdx, bVolumes[bVolumeIdx], intersections);
        beginIdx = endIdx;
    }
    return featureIdx;
}
var SolidLineMesh = /*#__PURE__*/ function(_Mesh) {
    _inherits(SolidLineMesh, _Mesh);
    var _super = _createSuper(SolidLineMesh);
    function SolidLineMesh(geometry, material) {
        _classCallCheck(this, SolidLineMesh);
        return _super.call(this, geometry, material);
    }
    _createClass(SolidLineMesh, [
        {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
                SolidLineMesh.raycast(this, raycaster, intersects);
            }
        }
    ], [
        {
            key: "raycast",
            value: function raycast(mesh, raycaster, intersections) {
                assert(_instanceof(mesh.geometry, THREE41.BufferGeometry), "Unsupported geometry type");
                var geometry = mesh.geometry;
                assert(geometry.index !== null, "Geometry does not have indices");
                var matrixWorld = mesh.matrixWorld;
                tmpInverseMatrix.copy(matrixWorld).invert();
                var localRay = tmpRay.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
                if (mesh.userData.feature === void 0) {
                    mesh.userData.feature = {};
                }
                var positionAttribute = geometry.attributes["position"];
                var attributeInfo = mesh.userData.feature.attributeInfo;
                if (attributeInfo === void 0 || mesh.userData.feature.boundingVolumes === void 0 || attributeChanged(positionAttribute, attributeInfo)) {
                    mesh.userData.feature.boundingVolumes = [];
                    mesh.userData.feature.attributeInfo = getAttributeInfo(positionAttribute);
                }
                var indices = geometry.index.array;
                if (Array.isArray(mesh.material)) {
                    var nextFeatureIdx = 0;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = geometry.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var group = _step.value;
                            var material = mesh.material[group.materialIndex];
                            var groupEndIdx = group.start + group.count;
                            nextFeatureIdx = intersectGroup(mesh, material, raycaster, localRay, nextFeatureIdx, groupEndIdx, intersections);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else {
                    intersectGroup(mesh, mesh.material, raycaster, localRay, 0, indices.length, intersections);
                }
            }
        }
    ]);
    return SolidLineMesh;
}(THREE41.Mesh);
// src/mapview/MapViewPoints.ts
var THREE42 = __toESM(require("three"));
var MapViewPoints = /*#__PURE__*/ function(_Points) {
    _inherits(MapViewPoints, _Points);
    var _super = _createSuper(MapViewPoints);
    function MapViewPoints() {
        _classCallCheck(this, MapViewPoints);
        var _this;
        _this = _super.call.apply(_super, [
            this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assertThisInitialized(_this), "enableRayTesting", true);
        return _this;
    }
    _createClass(MapViewPoints, [
        {
            key: "raycast",
            value: function raycast(raycaster, intersects) {
                var _this = this;
                if (!this.enableRayTesting) {
                    return;
                }
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var ndc = raycaster.ray.origin.clone().add(raycaster.ray.direction).project(raycaster.camera);
                var mouseCoords = ndcToScreen(ndc, raycaster);
                var testPoint = function(point2, index2) {
                    var pointInfo = getPointInfo(point2, matrixWorld, raycaster);
                    if (pointInfo.pointIsOnScreen) {
                        _this.testPoint(point2, pointInfo.absoluteScreenPosition, mouseCoords, index2, pointInfo.distance, intersects);
                    }
                };
                var point = new THREE42.Vector3();
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for(var i = 0, il = indices.length; i < il; i++){
                        testPoint(point.fromArray(positions, indices[i] * 3), i);
                    }
                } else {
                    for(var i1 = 0, l = positions.length / 3; i1 < l; i1++){
                        testPoint(point.fromArray(positions, i1 * 3), i1);
                    }
                }
            }
        }
    ]);
    return MapViewPoints;
}(THREE42.Points);
function ndcToScreen(ndc, raycaster) {
    return new THREE42.Vector2(ndc.x + 1, 1 - ndc.y).divideScalar(2).multiply(raycaster.canvasSize).ceil();
}
function getPointInfo(point, matrixWorld, raycaster) {
    var worldPosition = point.clone().applyMatrix4(matrixWorld);
    var distance = worldPosition.distanceTo(raycaster.ray.origin);
    var ndc = worldPosition.project(raycaster.camera);
    var pointIsOnScreen = ndc.x < 1 && ndc.x > -1 && ndc.y < 1 && ndc.y > -1;
    if (pointIsOnScreen) {
        var absoluteScreenPosition = ndcToScreen(ndc, raycaster);
        return {
            absoluteScreenPosition: absoluteScreenPosition,
            pointIsOnScreen: pointIsOnScreen,
            distance: distance
        };
    }
    return {
        pointIsOnScreen: pointIsOnScreen
    };
}
var Circles = /*#__PURE__*/ function(MapViewPoints) {
    _inherits(Circles, MapViewPoints);
    var _super = _createSuper(Circles);
    function Circles() {
        _classCallCheck(this, Circles);
        return _super.apply(this, arguments);
    }
    _createClass(Circles, [
        {
            key: "testPoint",
            value: function testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
                var dx = screenPosition.x - pickCoordinates.x;
                var dy = screenPosition.y - pickCoordinates.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                var radius = this.material.size / 2;
                if (dist <= radius) {
                    intersects.push({
                        point: point,
                        distance: distance,
                        index: index,
                        object: this
                    });
                }
            }
        }
    ]);
    return Circles;
}(MapViewPoints);
var Squares = /*#__PURE__*/ function(MapViewPoints) {
    _inherits(Squares, MapViewPoints);
    var _super = _createSuper(Squares);
    function Squares() {
        _classCallCheck(this, Squares);
        return _super.apply(this, arguments);
    }
    _createClass(Squares, [
        {
            key: "testPoint",
            value: function testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
                var dx = screenPosition.x - pickCoordinates.x;
                var dy = screenPosition.y - pickCoordinates.y;
                var halfSize = this.material.size / 2;
                if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {
                    intersects.push({
                        point: point,
                        distance: distance,
                        index: index,
                        object: this
                    });
                }
            }
        }
    ]);
    return Squares;
}(MapViewPoints);
// src/mapview/ThemeHelpers.ts
var THREE43 = __toESM(require("three"));
function toPixelFormat(format) {
    switch(format){
        case "Alpha":
            return THREE43.AlphaFormat;
        case "RGB":
            return THREE43.RGBFormat;
        case "RGBA":
            return THREE43.RGBAFormat;
        case "Luminance":
            return THREE43.LuminanceFormat;
        case "LuminanceAlpha":
            return THREE43.LuminanceAlphaFormat;
        case "Depth":
            return THREE43.DepthFormat;
        case "DepthStencil":
            return THREE43.DepthStencilFormat;
        case "Red":
            return THREE43.RedFormat;
        default:
            throw new Error("invalid pixel format: ".concat(format));
    }
}
function toTextureDataType(dataType) {
    switch(dataType){
        case "UnsignedByte":
            return THREE43.UnsignedByteType;
        case "Byte":
            return THREE43.ByteType;
        case "Short":
            return THREE43.ShortType;
        case "UnsignedShort":
            return THREE43.UnsignedShortType;
        case "Int":
            return THREE43.IntType;
        case "UnsignedInt":
            return THREE43.UnsignedIntType;
        case "Float":
            return THREE43.FloatType;
        case "HalfFloat":
            return THREE43.HalfFloatType;
        default:
            throw new Error("invalid texture data type: ".concat(dataType));
    }
}
function toWrappingMode(mode) {
    switch(mode){
        case "clamp":
            return THREE43.ClampToEdgeWrapping;
        case "repeat":
            return THREE43.RepeatWrapping;
        case "mirror":
            return THREE43.MirroredRepeatWrapping;
        default:
            throw new Error("invalid wrapping mode: ".concat(mode));
    }
}
function toTextureFilter(filter) {
    switch(filter){
        case "nearest":
            return THREE43.NearestFilter;
        case "nearestMipMapNearest":
            return THREE43.NearestMipMapNearestFilter;
        case "nearestMipMapLinear":
            return THREE43.NearestMipMapLinearFilter;
        case "linear":
            return THREE43.LinearFilter;
        case "linearMipMapNearest":
            return THREE43.LinearMipMapNearestFilter;
        case "linearMipMapLinear":
            return THREE43.LinearMipMapLinearFilter;
        default:
            throw new Error("invalid texture filter: ".concat(filter));
    }
}
function createLight(lightDescription) {
    switch(lightDescription.type){
        case "ambient":
            {
                var light = new THREE43.AmbientLight(lightDescription.color, lightDescription.intensity);
                light.name = lightDescription.name;
                return light;
            }
        case "directional":
            {
                var light1 = new THREE43.DirectionalLight(lightDescription.color, lightDescription.intensity);
                light1.name = lightDescription.name;
                if (lightDescription.castShadow !== void 0) {
                    light1.castShadow = lightDescription.castShadow;
                }
                if (light1.castShadow) {
                    light1.shadow.bias = 1e-5;
                    light1.shadow.mapSize.width = 1024;
                    light1.shadow.mapSize.height = 1024;
                }
                light1.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);
                light1.position.normalize();
                return light1;
            }
    }
}
// src/mapview/DecodedTileHelpers.ts
var logger5 = LoggerManager.instance.create("DecodedTileHelpers");
function createTextureFromURL(url, onLoad, onError, isObjectURL) {
    var texture = new THREE44.TextureLoader().load(url, onLoad, void 0, onError);
    if (isObjectURL) {
        texture.addEventListener("dispose", function() {
            URL.revokeObjectURL(url);
        });
    }
}
function createTextureFromRawImage(textureBuffer, onLoad, onError) {
    var properties = textureBuffer.dataTextureProperties;
    if (properties) {
        var textureDataType = properties.type ? toTextureDataType(properties.type) : void 0;
        var buffer = getTextureBuffer(textureBuffer.buffer, textureDataType);
        var texture = new THREE44.DataTexture(buffer, properties.width, properties.height, properties.format ? toPixelFormat(properties.format) : void 0, textureDataType);
        onLoad(texture);
    } else {
        onError("no data texture properties provided.");
    }
}
function initTextureProperties(texture, properties) {
    if (!properties) {
        return;
    }
    if (properties.wrapS !== void 0) {
        texture.wrapS = toWrappingMode(properties.wrapS);
    }
    if (properties.wrapT !== void 0) {
        texture.wrapT = toWrappingMode(properties.wrapT);
    }
    if (properties.magFilter !== void 0) {
        texture.magFilter = toTextureFilter(properties.magFilter);
    }
    if (properties.minFilter !== void 0) {
        texture.minFilter = toTextureFilter(properties.minFilter);
    }
    if (properties.flipY !== void 0) {
        texture.flipY = properties.flipY;
    }
    if (properties.repeatU !== void 0) {
        texture.repeat.x = properties.repeatU;
    }
    if (properties.repeatV !== void 0) {
        texture.repeat.y = properties.repeatV;
    }
}
function createTexture(material, texturePropertyName, options) {
    var technique = options.technique;
    var textureProperty = technique[texturePropertyName];
    if (textureProperty === void 0) {
        return void 0;
    }
    var texturePromise = new Promise(function(resolve, reject) {
        var onLoad = function(texture) {
            var properties = technique[texturePropertyName + "Properties"];
            initTextureProperties(texture, properties);
            material[texturePropertyName] = texture;
            material.needsUpdate = true;
            resolve(texture);
        };
        var onError = function(error) {
            logger5.error("#createMaterial: Failed to load texture: ", error);
            reject(error);
        };
        if (Expr3.isExpr(textureProperty)) {
            textureProperty = getPropertyValue(textureProperty, options.env);
            if (!textureProperty) {
                onLoad(new THREE44.Texture());
                return;
            }
        }
        if (typeof textureProperty === "string") {
            createTextureFromURL(textureProperty, onLoad, onError, false);
        } else if (isTextureBuffer(textureProperty)) {
            if (textureProperty.type === "image/raw") {
                createTextureFromRawImage(textureProperty, onLoad, onError);
            } else {
                var textureBlob = new Blob([
                    textureProperty.buffer
                ], {
                    type: textureProperty.type
                });
                createTextureFromURL(URL.createObjectURL(textureBlob), onLoad, onError, true);
            }
        } else if (typeof textureProperty === "object" && (textureProperty.nodeName === "IMG" || textureProperty.nodeName === "CANVAS")) {
            onLoad(new THREE44.CanvasTexture(textureProperty));
        }
    });
    return texturePromise;
}
function createMaterial(rendererCapabilities, options, onTextureCreated) {
    var technique = options.technique;
    var Constructor = getMaterialConstructor(technique, options.shadowsEnabled === true);
    var settings = {};
    if (Constructor === void 0) {
        return void 0;
    }
    if (_instanceof(Constructor.prototype, RawShaderMaterial2)) {
        settings.rendererCapabilities = rendererCapabilities;
        if (Constructor !== HighPrecisionLineMaterial) {
            settings.fog = options.fog;
        }
    }
    if (options.shadowsEnabled === true && technique.name === "fill") {
        settings.removeDiffuseLight = true;
    }
    var material = new Constructor(settings);
    if (technique.id !== void 0) {
        material.name = technique.id;
    }
    if (isExtrudedPolygonTechnique(technique)) {
        ;
        material.flatShading = true;
    }
    material.depthTest = isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;
    if (supportsTextures(technique)) {
        TEXTURE_PROPERTY_KEYS.forEach(function(texturePropertyName) {
            var texturePromise = createTexture(material, texturePropertyName, options);
            if (texturePromise) {
                onTextureCreated === null || onTextureCreated === void 0 ? void 0 : onTextureCreated(texturePromise);
            }
        });
    }
    if (isShaderTechnique(technique)) {
        applyShaderTechniqueToMaterial(technique, material);
    } else {
        MapMaterialAdapter.create(material, getMainMaterialStyledProps(technique));
    }
    return material;
}
function getBufferAttribute(attribute) {
    switch(attribute.type){
        case "float":
            return new THREE44.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);
        case "uint8":
            return new THREE44.BufferAttribute(new Uint8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint16":
            return new THREE44.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint32":
            return new THREE44.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int8":
            return new THREE44.BufferAttribute(new Int8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int16":
            return new THREE44.BufferAttribute(new Int16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int32":
            return new THREE44.BufferAttribute(new Int32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        default:
            throw new Error("unsupported buffer of type ".concat(attribute.type));
    }
}
function usesObject3D(technique) {
    var name2 = technique.name;
    return name2 !== void 0 && name2 !== "text" && name2 !== "labeled-icon" && name2 !== "line-marker" && name2 !== "label-rejection-line";
}
function buildObject(technique, geometry, material, tile, elevationEnabled) {
    assert(technique.name !== void 0);
    switch(technique.name){
        case "extruded-line":
        case "standard":
        case "extruded-polygon":
        case "fill":
            return elevationEnabled ? new DisplacedMesh(geometry, material, function() {
                return {
                    min: tile.elevationRange.minElevation,
                    max: tile.elevationRange.maxElevation
                };
            }) : new THREE44.Mesh(geometry, material);
        case "terrain":
            return new THREE44.Mesh(geometry, material);
        case "dashed-line":
        case "solid-line":
            return elevationEnabled ? new DisplacedMesh(geometry, material, function() {
                return {
                    min: tile.elevationRange.minElevation,
                    max: tile.elevationRange.maxElevation
                };
            }, SolidLineMesh.raycast) : new SolidLineMesh(geometry, material);
        case "circles":
            return new Circles(geometry, material);
        case "squares":
            return new Squares(geometry, material);
        case "line":
            return new THREE44.LineSegments(geometry, material);
        case "segments":
            return new THREE44.LineSegments(geometry, material);
        case "shader":
            {
                assert(isShaderTechnique(technique), "Invalid technique");
                switch(technique.primitive){
                    case "line":
                        return new THREE44.Line(geometry, material);
                    case "segments":
                        return new THREE44.LineSegments(geometry, material);
                    case "point":
                        return new THREE44.Points(geometry, material);
                    case "mesh":
                        return new THREE44.Mesh(geometry, material);
                }
            }
    }
    assert(false, "Invalid technique");
    return new THREE44.Object3D();
}
var BASE_TECHNIQUE_NON_MATERIAL_PROPS = [
    "name",
    "id",
    "renderOrder",
    "transient"
];
function getMaterialConstructor(technique, shadowsEnabled) {
    if (technique.name === void 0) {
        return void 0;
    }
    switch(technique.name){
        case "extruded-line":
            if (!isExtrudedLineTechnique(technique)) {
                throw new Error("Invalid extruded-line technique");
            }
            return technique.shading === "standard" ? MapMeshStandardMaterial : MapMeshBasicMaterial;
        case "standard":
        case "terrain":
        case "extruded-polygon":
            return MapMeshStandardMaterial;
        case "dashed-line":
        case "solid-line":
            return SolidLineMaterial;
        case "fill":
            return shadowsEnabled ? MapMeshStandardMaterial : MapMeshBasicMaterial;
        case "squares":
            return THREE44.PointsMaterial;
        case "circles":
            return CirclePointsMaterial;
        case "line":
        case "segments":
            return THREE44.LineBasicMaterial;
        case "shader":
            return THREE44.ShaderMaterial;
        case "text":
        case "labeled-icon":
        case "line-marker":
        case "label-rejection-line":
            return void 0;
    }
}
function getMainMaterialStyledProps(technique) {
    var automaticAttributes = getTechniqueAutomaticAttrs(technique);
    switch(technique.name){
        case "dashed-line":
        case "solid-line":
            {
                var baseProps = pick(technique, automaticAttributes);
                var _lineWidth;
                baseProps.lineWidth = buildMetricValueEvaluator((_lineWidth = technique.lineWidth) !== null && _lineWidth !== void 0 ? _lineWidth : 0, technique.metricUnit);
                baseProps.outlineWidth = buildMetricValueEvaluator(technique.outlineWidth, technique.metricUnit);
                baseProps.dashSize = buildMetricValueEvaluator(technique.dashSize, technique.metricUnit);
                baseProps.gapSize = buildMetricValueEvaluator(technique.gapSize, technique.metricUnit);
                baseProps.offset = buildMetricValueEvaluator(technique.offset, technique.metricUnit);
                return baseProps;
            }
        case "fill":
            return pick(technique, automaticAttributes);
        case "standard":
        case "terrain":
        case "extruded-polygon":
            {
                var baseProps1 = pick(technique, automaticAttributes);
                if (technique.vertexColors !== true) {
                    baseProps1.color = technique.color;
                }
                return baseProps1;
            }
        case "circles":
        case "squares":
            return pick(technique, automaticAttributes);
        case "extruded-line":
            return pick(technique, [
                "color",
                "wireframe",
                "transparent",
                "opacity",
                "polygonOffset",
                "polygonOffsetFactor",
                "polygonOffsetUnits"
            ].concat(_toConsumableArray(automaticAttributes)));
        case "line":
        case "segments":
            return pick(technique, automaticAttributes);
        default:
            return {};
    }
}
function buildMetricValueEvaluator(value2, metricUnit) {
    if (value2 === void 0 || value2 === null) {
        return value2;
    }
    if (typeof value2 === "string") {
        if (value2.endsWith("px")) {
            metricUnit = "Pixel";
            value2 = Number.parseFloat(value2);
        } else if (value2.endsWith("m")) {
            value2 = Number.parseFloat(value2);
        }
    }
    if (metricUnit === "Pixel") {
        return function(context) {
            var ref;
            var pixelToWorld = (ref = context.env.lookup("$pixelToMeters")) !== null && ref !== void 0 ? ref : 1;
            var evaluated = getPropertyValue(value2, context.env);
            return pixelToWorld * evaluated;
        };
    } else {
        return value2;
    }
}
function evaluateBaseColorProperty(technique, env) {
    var baseColorProp = getBaseColorProp(technique);
    if (baseColorProp !== void 0) {
        return evaluateColorProperty(baseColorProp, env);
    }
    return void 0;
}
function applyShaderTechniqueToMaterial(technique, material) {
    if (technique.transparent) {
        enableBlending(material);
    } else {
        disableBlending(material);
    }
    var params = technique.params;
    var baseColorPropName = getBaseColorPropName(technique);
    var hasBaseColor = baseColorPropName && baseColorPropName in technique.params;
    var props = Object.getOwnPropertyNames(params).filter(function(propertyName) {
        if (baseColorPropName === propertyName || hasBaseColor && TRANSPARENCY_PROPERTY_KEYS.includes(propertyName)) {
            return false;
        }
        var prop = propertyName;
        if (prop === "name") {
            return false;
        }
        return true;
    });
    props.forEach(function(propertyName) {
        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);
    });
    if (hasBaseColor) {
        var propColor = baseColorPropName;
        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);
    }
}
function applyTechniquePropertyToMaterial(material, propertyName, techniqueAttrValue, env) {
    var m = material;
    if (_instanceof(m[propertyName], THREE44.Color)) {
        applySecondaryColorToMaterial(material[propertyName], techniqueAttrValue, env);
    } else {
        var value2 = evaluateProperty(techniqueAttrValue, env);
        if (value2 !== null) {
            m[propertyName] = value2;
        }
    }
}
function applySecondaryColorToMaterial(materialColor, techniqueColor, env) {
    var value2 = evaluateColorProperty(techniqueColor, env);
    if (value2 === void 0) {
        return;
    }
    if (ColorUtils.hasAlphaInHex(value2)) {
        logger5.warn("Used RGBA value for technique color without transparency support!");
        value2 = ColorUtils.removeAlphaFromHex(value2);
    }
    materialColor.setHex(value2);
}
function applyBaseColorToMaterial(material, materialColor, technique, techniqueColor, env) {
    var colorValue = evaluateColorProperty(techniqueColor, env);
    if (colorValue === void 0) {
        return;
    }
    var ref = ColorUtils.getRgbaFromHex(colorValue), r = ref.r, g = ref.g, b = ref.b, a = ref.a;
    var tech = technique;
    var opacity = a;
    if (tech.opacity !== void 0) {
        opacity *= evaluateProperty(tech.opacity, env);
    }
    opacity = THREE44.MathUtils.clamp(opacity, 0, 1);
    if (_instanceof(material, RawShaderMaterial2)) {
        material.setOpacity(opacity);
    } else {
        material.opacity = opacity;
    }
    materialColor.setRGB(r, g, b);
    var opaque = opacity >= 1;
    if (!opaque) {
        enableBlending(material);
    } else {
        disableBlending(material);
    }
}
function evaluateProperty(value2, env) {
    if (env !== void 0 && Expr3.isExpr(value2)) {
        value2 = getPropertyValue(value2, env);
    }
    return value2;
}
function evaluateColorProperty(value2, env) {
    value2 = evaluateProperty(value2, env);
    if (value2 === void 0 || value2 === null) {
        return void 0;
    }
    if (typeof value2 === "number") {
        return value2;
    }
    if (typeof value2 === "string") {
        var parsed = parseStringEncodedColor(value2);
        if (parsed !== void 0) {
            return parsed;
        }
    }
    logger5.error("Unsupported color format: '".concat(value2, "'"));
    return void 0;
}
function getBaseColorProp(technique) {
    var baseColorPropName = getBaseColorPropName(technique);
    if (baseColorPropName !== void 0) {
        if (!isShaderTechnique(technique)) {
            var propColor = baseColorPropName;
            return technique[propColor];
        } else {
            var params = technique.params;
            var propColor1 = baseColorPropName;
            return params[propColor1];
        }
    }
    return void 0;
}
function getBaseColorPropName(technique) {
    var ref;
    return (ref = getTechniqueDescriptor(technique)) === null || ref === void 0 ? void 0 : ref.attrTransparencyColor;
}
function getTextureBuffer(buffer, textureDataType) {
    if (textureDataType === void 0) {
        return new Uint8Array(buffer);
    }
    switch(textureDataType){
        case THREE44.UnsignedByteType:
            return new Uint8Array(buffer);
        case THREE44.ByteType:
            return new Int8Array(buffer);
        case THREE44.ShortType:
            return new Int16Array(buffer);
        case THREE44.UnsignedShortType:
            return new Uint16Array(buffer);
        case THREE44.IntType:
            return new Int32Array(buffer);
        case THREE44.UnsignedIntType:
            return new Uint32Array(buffer);
        case THREE44.FloatType:
            return new Float32Array(buffer);
        case THREE44.HalfFloatType:
            return new Uint16Array(buffer);
    }
    throw new Error("Unsupported texture data type");
}
// src/mapview/MapMaterialAdapter.ts
function isTextureProperty(propertyName) {
    return TEXTURE_PROPERTY_KEYS.includes(propertyName);
}
var MapMaterialAdapter = /*#__PURE__*/ function() {
    function MapMaterialAdapter(material, styledProperties) {
        _classCallCheck(this, MapMaterialAdapter);
        __publicField(this, "material");
        __publicField(this, "styledProperties");
        __publicField(this, "currentStyledProperties");
        __publicField(this, "m_lastUpdateFrameNumber", -1);
        __publicField(this, "m_dynamicProperties");
        __publicField(this, "tmpColor", new THREE45.Color());
        this.material = material;
        this.styledProperties = styledProperties;
        this.currentStyledProperties = {};
        this.m_dynamicProperties = [];
        for(var propName in styledProperties){
            if (!styledProperties.hasOwnProperty(propName)) {
                continue;
            }
            var propDefinition = styledProperties[propName];
            if (Expr3.isExpr(propDefinition) || typeof propDefinition === "function") {
                this.m_dynamicProperties.push([
                    propName,
                    propDefinition
                ]);
            } else {
                this.currentStyledProperties[propName] = propDefinition;
            }
        }
        this.setupStaticProperties();
    }
    _createClass(MapMaterialAdapter, [
        {
            key: "toJSON",
            value: function toJSON() {
                return {
                    styledProperties: this.styledProperties
                };
            }
        },
        {
            key: "ensureUpdated",
            value: function ensureUpdated(context) {
                if (this.m_lastUpdateFrameNumber === context.frameNumber) {
                    return false;
                }
                this.m_lastUpdateFrameNumber = context.frameNumber;
                return this.updateDynamicProperties(context);
            }
        },
        {
            key: "setupStaticProperties",
            value: function setupStaticProperties() {
                var updateBaseColor = false;
                for(var propName in this.styledProperties){
                    if (!this.styledProperties.hasOwnProperty(propName)) {
                        continue;
                    }
                    var currentValue = this.currentStyledProperties[propName];
                    if (currentValue === void 0 || currentValue === null) {
                        continue;
                    }
                    if (propName === "color" || propName === "opacity") {
                        updateBaseColor = true;
                    } else if (!isTextureProperty(propName)) {
                        this.applyMaterialGenericProp(propName, currentValue);
                    }
                }
                if (updateBaseColor) {
                    var _color;
                    var color = (_color = this.currentStyledProperties.color) !== null && _color !== void 0 ? _color : 16711680;
                    var _opacity;
                    var opacity = (_opacity = this.currentStyledProperties.opacity) !== null && _opacity !== void 0 ? _opacity : 1;
                    this.applyMaterialBaseColor(color, opacity);
                }
            }
        },
        {
            key: "updateDynamicProperties",
            value: function updateDynamicProperties(context) {
                var somethingChanged = false;
                if (this.m_dynamicProperties.length > 0) {
                    var updateBaseColor = false;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = this.m_dynamicProperties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _value = _slicedToArray(_step.value, 2), propName = _value[0], propDefinition = _value[1];
                            var newValue = Expr3.isExpr(propDefinition) ? getPropertyValue(propDefinition, context.env) : propDefinition(context);
                            if (newValue === this.currentStyledProperties[propName]) {
                                continue;
                            }
                            this.currentStyledProperties[propName] = newValue;
                            if (propName === "color" || propName === "opacity") {
                                updateBaseColor = true;
                            } else if (isTextureProperty(propName)) {
                                this.applyMaterialTextureProp(propName, newValue);
                                somethingChanged = true;
                            } else {
                                this.applyMaterialGenericProp(propName, newValue);
                                somethingChanged = true;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    if (updateBaseColor) {
                        var _color;
                        var color = (_color = this.currentStyledProperties.color) !== null && _color !== void 0 ? _color : 16711680;
                        var _opacity;
                        var opacity = (_opacity = this.currentStyledProperties.opacity) !== null && _opacity !== void 0 ? _opacity : 1;
                        this.applyMaterialBaseColor(color, opacity);
                        somethingChanged = true;
                    }
                }
                return somethingChanged;
            }
        },
        {
            key: "applyMaterialTextureProp",
            value: function applyMaterialTextureProp(propName, value2) {
                var m = this.material;
                if (!m[propName] || value2 === null) {
                    return;
                }
                var oldTexture = m[propName];
                var newTexture;
                if (typeof value2 === "string") {
                    newTexture = new THREE45.TextureLoader().load(value2, function(texture) {
                        m[propName] = texture;
                    });
                } else if (typeof value2 === "object") {
                    var element = value2;
                    var isImage = element.nodeName === "IMG";
                    var isCanvas = element.nodeName === "CANVAS";
                    if (isImage || isCanvas) {
                        newTexture = new THREE45.CanvasTexture(element);
                        if (isImage && !element.complete) {
                            var onLoad = function() {
                                m[propName] = newTexture;
                                element.removeEventListener("load", onLoad);
                            };
                            element.addEventListener("load", onLoad);
                        } else {
                            m[propName] = newTexture;
                        }
                    }
                }
                if (newTexture) {
                    newTexture.wrapS = oldTexture.wrapS;
                    newTexture.wrapT = oldTexture.wrapT;
                    newTexture.magFilter = oldTexture.magFilter;
                    newTexture.minFilter = oldTexture.minFilter;
                    newTexture.flipY = oldTexture.flipY;
                    newTexture.repeat = oldTexture.repeat;
                }
            }
        },
        {
            key: "applyMaterialGenericProp",
            value: function applyMaterialGenericProp(propName, value2) {
                var m = this.material;
                if (_instanceof(m[propName], THREE45.Color)) {
                    var colorValue = value2;
                    if (typeof colorValue !== "number") {
                        var parsed = evaluateColorProperty(colorValue);
                        if (parsed === void 0) {
                            return;
                        }
                        colorValue = parsed;
                    }
                    var rgbValue = ColorUtils.removeAlphaFromHex(colorValue);
                    this.tmpColor.set(rgbValue);
                    value2 = this.tmpColor;
                }
                m[propName] = value2;
            }
        },
        {
            key: "applyMaterialBaseColor",
            value: function applyMaterialBaseColor(color, opacity) {
                if (typeof color !== "number") {
                    var parsed = evaluateColorProperty(color);
                    if (parsed === void 0) {
                        return;
                    }
                    color = parsed;
                }
                var ref = ColorUtils.getRgbaFromHex(color !== null && color !== void 0 ? color : 16711680), r = ref.r, g = ref.g, b = ref.b, a = ref.a;
                var actualOpacity = a * THREE45.MathUtils.clamp(opacity !== null && opacity !== void 0 ? opacity : 1, 0, 1);
                if (_instanceof(this.material, RawShaderMaterial2)) {
                    this.material.setOpacity(actualOpacity);
                } else {
                    this.material.opacity = actualOpacity;
                }
                ;
                this.material.color.setRGB(r, g, b);
                var opaque = actualOpacity >= 1;
                if (!opaque) {
                    enableBlending(this.material);
                } else {
                    disableBlending(this.material);
                }
            }
        }
    ], [
        {
            key: "get",
            value: function get(material) {
                var ref;
                var mapAdapter = (ref = material.userData) === null || ref === void 0 ? void 0 : ref.mapAdapter;
                if (_instanceof(mapAdapter, MapMaterialAdapter)) {
                    return mapAdapter;
                } else if (mapAdapter !== void 0) {
                    return void 0;
                } else {
                    return void 0;
                }
            }
        },
        {
            key: "install",
            value: function install(objData) {
                if (!objData.material.userData) {
                    objData.material.userData = {};
                }
                return objData.material.userData.mapAdapter = objData;
            }
        },
        {
            key: "create",
            value: function create(material, styledProperties) {
                return MapMaterialAdapter.install(new MapMaterialAdapter(material, styledProperties));
            }
        },
        {
            key: "ensureUpdated",
            value: function ensureUpdated(material, context) {
                var ref;
                var ref1;
                return (ref1 = (ref = MapMaterialAdapter.get(material)) === null || ref === void 0 ? void 0 : ref.ensureUpdated(context)) !== null && ref1 !== void 0 ? ref1 : false;
            }
        }
    ]);
    return MapMaterialAdapter;
}();
// src/mapview/MapObjectAdapter.ts
var MapObjectAdapter = /*#__PURE__*/ function() {
    function MapObjectAdapter(object, params) {
        _classCallCheck(this, MapObjectAdapter);
        __publicField(this, "object");
        __publicField(this, "technique");
        __publicField(this, "kind");
        __publicField(this, "dataSource");
        __publicField(this, "level");
        __publicField(this, "m_pickability");
        __publicField(this, "m_lastUpdateFrameNumber", -1);
        __publicField(this, "m_notCompletlyTransparent", true);
        this.object = object;
        this.technique = params.technique;
        this.kind = params.kind;
        this.dataSource = params.dataSource;
        var _pickability;
        this.m_pickability = (_pickability = params.pickability) !== null && _pickability !== void 0 ? _pickability : "only-visible" /* onlyVisible */ ;
        this.m_notCompletlyTransparent = this.getObjectMaterials().some(function(material) {
            return material.opacity > 0;
        });
        this.level = params.level;
    }
    _createClass(MapObjectAdapter, [
        {
            key: "toJSON",
            value: function toJSON() {
                return {
                    kind: this.kind,
                    technique: this.technique
                };
            }
        },
        {
            key: "ensureUpdated",
            value: function ensureUpdated(context) {
                if (this.m_lastUpdateFrameNumber === context.frameNumber) {
                    return false;
                }
                this.m_lastUpdateFrameNumber = context.frameNumber;
                return this.updateMaterials(context);
            }
        },
        {
            key: "isVisible",
            value: function isVisible() {
                return this.object.visible && this.m_notCompletlyTransparent;
            }
        },
        {
            key: "isPickable",
            value: function isPickable() {
                return this.pickability === "only-visible" /* onlyVisible */  && this.isVisible() || this.m_pickability === "all" /* all */ ;
            }
        },
        {
            key: "pickability",
            get: function get() {
                return this.m_pickability;
            }
        },
        {
            key: "updateMaterials",
            value: function updateMaterials(context) {
                var somethingChanged = false;
                var materials = this.getObjectMaterials();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = materials[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var material = _step.value;
                        var changed = MapMaterialAdapter.ensureUpdated(material, context);
                        somethingChanged = somethingChanged || changed;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (somethingChanged) {
                    this.m_notCompletlyTransparent = materials.some(function(material) {
                        return material.opacity > 0;
                    });
                }
                return somethingChanged;
            }
        },
        {
            key: "getObjectMaterials",
            value: function getObjectMaterials() {
                var object = this.object;
                return Array.isArray(object.material) ? object.material : object.material !== void 0 ? [
                    object.material
                ] : [];
            }
        }
    ], [
        {
            key: "get",
            value: function get(object) {
                var ref;
                return _instanceof((ref = object.userData) === null || ref === void 0 ? void 0 : ref.mapAdapter, MapObjectAdapter) ? object.userData.mapAdapter : void 0;
            }
        },
        {
            key: "install",
            value: function install(objData) {
                if (!objData.object.userData) {
                    objData.object.userData = {};
                }
                return objData.object.userData.mapAdapter = objData;
            }
        },
        {
            key: "create",
            value: function create(object, params) {
                return MapObjectAdapter.install(new MapObjectAdapter(object, params));
            }
        },
        {
            key: "ensureUpdated",
            value: function ensureUpdated(object, context) {
                var ref;
                var ref1;
                return (ref1 = (ref = MapObjectAdapter.get(object)) === null || ref === void 0 ? void 0 : ref.ensureUpdated(context)) !== null && ref1 !== void 0 ? ref1 : false;
            }
        }
    ]);
    return MapObjectAdapter;
}();
// src/mapview/geometry/RegisterTileObject.ts
function registerTileObject(tile, object, geometryKind, mapAdapterParams) {
    var kind = _instanceof(geometryKind, Set) ? Array.from(geometryKind.values()) : Array.isArray(geometryKind) ? geometryKind : [
        geometryKind
    ];
    MapObjectAdapter.create(object, _objectSpread({
        dataSource: tile.dataSource,
        kind: kind,
        level: tile.tileKey.level
    }, mapAdapterParams));
    if (object.userData === void 0) {
        object.userData = {};
    }
    var userData = object.userData;
    userData.tileKey = tile.tileKey;
    userData.dataSource = tile.dataSource.name;
    userData.kind = kind;
    tile.resetVisibilityCounter();
}
// src/mapview/geometry/AddGroundPlane.ts
var tmpV = new THREE46.Vector3();
function addGroundPlane(tile, renderOrder) {
    var materialOrColor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : tile.mapView.clearColor, opacity = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, createTexCoords = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, receiveShadow = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : tile.mapView.shadowsEnabled, createMultiLod = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : tile.mapView.enableMixedLod !== false;
    var mesh = createGroundPlane(tile, createTexCoords, receiveShadow, materialOrColor, createMultiLod, opacity);
    mesh.receiveShadow = receiveShadow;
    mesh.renderOrder = renderOrder;
    registerTileObject(tile, mesh, GeometryKind.Background, {
        pickability: "transient" /* transient */ 
    });
    tile.objects.push(mesh);
    return mesh;
}
function createGroundPlane(tile, createTexCoords, receiveShadow, materialOrColor, createMultiLod, opacity) {
    var dataSource = tile.dataSource, projection = tile.projection;
    var sourceProjection = dataSource.getTilingScheme().projection;
    var shouldSubdivide = projection.type === 1 /* Spherical */ ;
    var useLocalTargetCoords = !shouldSubdivide;
    var material = typeof materialOrColor === "number" ? createGroundPlaneMaterial(new THREE46.Color(materialOrColor), receiveShadow, projection.type === 1 /* Spherical */ , opacity) : materialOrColor;
    var geometry = createGroundPlaneGeometry(tile, useLocalTargetCoords, createTexCoords, receiveShadow);
    if (!shouldSubdivide) {
        return new THREE46.Mesh(geometry, material);
    }
    var geometries = [];
    var sphericalModifier = new SphericalGeometrySubdivisionModifier(THREE46.MathUtils.degToRad(10), sourceProjection);
    if (!createMultiLod) {
        sphericalModifier.modify(geometry);
        toLocalTargetCoords(geometry, sourceProjection, tile);
        return new THREE46.Mesh(geometry, material);
    }
    for(var zoomLevelOffset = 0; zoomLevelOffset < 4; ++zoomLevelOffset){
        var subdivision = Math.pow(2, zoomLevelOffset);
        var zoomLevelGeometry = geometry.clone();
        if (subdivision > 1) {
            var edgeModifier = new EdgeLengthGeometrySubdivisionModifier(subdivision, tile.geoBox, 0 /* All */ , sourceProjection);
            edgeModifier.modify(zoomLevelGeometry);
        }
        sphericalModifier.modify(zoomLevelGeometry);
        toLocalTargetCoords(zoomLevelGeometry, sourceProjection, tile);
        geometries.push(zoomLevelGeometry);
    }
    return new LodMesh(geometries, material);
}
function toLocalTargetCoords(geom, srcProjection, tile) {
    var attr = geom.getAttribute("position");
    var oldArray = attr.array;
    var newArray = new Float32Array(oldArray.length);
    for(var i = 0; i < attr.array.length; i += 1){
        tmpV.fromBufferAttribute(attr, i);
        tile.projection.reprojectPoint(srcProjection, tmpV, tmpV).sub(tile.center);
        tmpV.toArray(newArray, i * 3);
    }
    attr.array = newArray;
    attr.needsUpdate = true;
}
function createGroundPlaneGeometry(tile, useLocalTargetCoords, createTexCoords, receiveShadow) {
    var dataSource = tile.dataSource, projection = tile.projection;
    var sourceProjection = dataSource.getTilingScheme().projection;
    var tmpV6 = new THREE46.Vector3();
    var geometry = new THREE46.BufferGeometry();
    var tileCorners = projectTilePlaneCorners(tile, sourceProjection);
    var cornersArray = [
        tileCorners.sw,
        tileCorners.se,
        tileCorners.nw,
        tileCorners.ne
    ];
    if (useLocalTargetCoords) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = cornersArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var corner = _step.value;
                projection.reprojectPoint(sourceProjection, corner, corner).sub(tile.center);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    var bufferArray = useLocalTargetCoords ? new Float32Array(12) : new Float64Array(12);
    var posAttr = new THREE46.BufferAttribute(bufferArray, 3).copyVector3sArray(cornersArray);
    geometry.setAttribute("position", posAttr);
    if (receiveShadow) {
        sourceProjection.surfaceNormal(tileCorners.sw, tmpV6).negate();
        var normAttr = new THREE46.BufferAttribute(new Float32Array(12), 3).copyVector3sArray(Array(4).fill(tmpV6));
        geometry.setAttribute("normal", normAttr);
    }
    geometry.setIndex(new THREE46.BufferAttribute(new Uint16Array([
        0,
        1,
        2,
        2,
        1,
        3
    ]), 1));
    if (createTexCoords) {
        var uvAttr = new THREE46.BufferAttribute(new Float32Array([
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ]), 2);
        geometry.setAttribute("uv", uvAttr);
    }
    return geometry;
}
function createGroundPlaneMaterial(color, receiveShadow, depthWrite, opacity) {
    if (receiveShadow) {
        return new MapMeshStandardMaterial({
            color: color,
            visible: true,
            depthWrite: depthWrite,
            removeDiffuseLight: true,
            opacity: opacity
        });
    } else {
        return new MapMeshBasicMaterial({
            color: color,
            visible: true,
            depthWrite: depthWrite,
            opacity: opacity
        });
    }
}
// src/mapview/BackgroundDataSource.ts
var _BackgroundDataSource = /*#__PURE__*/ function(DataSource) {
    _inherits(_BackgroundDataSource, DataSource);
    var _super = _createSuper(_BackgroundDataSource);
    function _BackgroundDataSource() {
        _classCallCheck(this, _BackgroundDataSource);
        var _this;
        _this = _super.call(this, {
            name: "background"
        });
        __publicField(_assertThisInitialized(_this), "m_tilingScheme", _BackgroundDataSource.DEFAULT_TILING_SCHEME);
        _this.cacheable = true;
        _this.addGroundPlane = true;
        _this.enablePicking = false;
        return _this;
    }
    _createClass(_BackgroundDataSource, [
        {
            key: "updateStorageLevelOffset",
            value: function updateStorageLevelOffset() {
                var _this = this;
                var storageLevelOffset;
                this.mapView.dataSources.forEach(function(ds) {
                    if (ds === _this) {
                        return;
                    }
                    var tilingScheme = ds.getTilingScheme();
                    if (tilingScheme === _this.m_tilingScheme) {
                        storageLevelOffset = storageLevelOffset === void 0 ? ds.storageLevelOffset : Math.max(storageLevelOffset, ds.storageLevelOffset);
                    }
                });
                if (storageLevelOffset === void 0) {
                    storageLevelOffset = 0;
                }
                if (storageLevelOffset !== this.storageLevelOffset) {
                    this.storageLevelOffset = storageLevelOffset;
                    this.mapView.clearTileCache(this.name);
                }
            }
        },
        {
            key: "setTheme",
            value: function setTheme(theme, languages) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _this.mapView.clearTileCache(_this.name);
                            case 1:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "setTilingScheme",
            value: function setTilingScheme(tilingScheme) {
                var newScheme = tilingScheme !== null && tilingScheme !== void 0 ? tilingScheme : _BackgroundDataSource.DEFAULT_TILING_SCHEME;
                if (newScheme === this.m_tilingScheme) {
                    return;
                }
                this.m_tilingScheme = newScheme;
                this.updateStorageLevelOffset();
                this.mapView.clearTileCache(this.name);
            }
        },
        {
            key: "getTilingScheme",
            value: function getTilingScheme() {
                return this.m_tilingScheme;
            }
        },
        {
            key: "getTile",
            value: function getTile(tileKey) {
                var tile = new Tile(this, tileKey);
                tile.forceHasGeometry(true);
                addGroundPlane(tile, _BackgroundDataSource.GROUND_RENDER_ORDER);
                return tile;
            }
        }
    ]);
    return _BackgroundDataSource;
}(DataSource);
var BackgroundDataSource = _BackgroundDataSource;
__publicField(BackgroundDataSource, "GROUND_RENDER_ORDER", Number.MIN_SAFE_INTEGER);
__publicField(BackgroundDataSource, "DEFAULT_TILING_SCHEME", webMercatorTilingScheme);
// src/mapview/CameraMovementDetector.ts
var import_three11 = require("three");
var DEFAULT_THROTTLING_TIMEOUT = 300;
var CameraMovementDetector = /*#__PURE__*/ function() {
    function CameraMovementDetector(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {
        var _this = this;
        _classCallCheck(this, CameraMovementDetector);
        this.m_throttlingTimeout = m_throttlingTimeout;
        this.m_movementStartedFunc = m_movementStartedFunc;
        this.m_movementFinishedFunc = m_movementFinishedFunc;
        __publicField(this, "m_lastAttitude");
        __publicField(this, "m_lastCameraPos", new import_three11.Vector3());
        __publicField(this, "m_newCameraPos", new import_three11.Vector3());
        __publicField(this, "m_cameraMovedLastFrame");
        __publicField(this, "m_throttlingTimerId");
        __publicField(this, "m_movementDetectorDeadline", 0);
        __publicField(this, "onDeadlineTimer", function() {
            _this.m_throttlingTimerId = void 0;
            var now2 = performance.now();
            if (now2 >= _this.m_movementDetectorDeadline) {
                _this.movementFinished();
            } else {
                _this.startMovementFinishedTimer(now2);
            }
        });
        if (this.m_throttlingTimeout === void 0) {
            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;
        }
    }
    _createClass(CameraMovementDetector, [
        {
            key: "checkCameraMoved",
            value: function checkCameraMoved(mapView, now2) {
                var newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);
                var newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
                if (this.m_lastAttitude === void 0) {
                    this.m_lastCameraPos.copy(newCameraPos);
                    this.m_lastAttitude = newAttitude;
                    return false;
                }
                var cameraMoved = !this.m_lastCameraPos.equals(newCameraPos) || newAttitude.yaw !== this.m_lastAttitude.yaw || newAttitude.pitch !== this.m_lastAttitude.pitch || newAttitude.roll !== this.m_lastAttitude.roll;
                if (cameraMoved) {
                    this.m_lastCameraPos.copy(newCameraPos);
                    this.m_lastAttitude = newAttitude;
                }
                if (cameraMoved !== this.m_cameraMovedLastFrame) {
                    if (cameraMoved) {
                        this.movementStarted();
                    }
                    this.m_cameraMovedLastFrame = cameraMoved;
                }
                if (cameraMoved) {
                    this.m_movementDetectorDeadline = now2 + this.m_throttlingTimeout;
                    this.startMovementFinishedTimer(now2);
                }
                return this.m_cameraMovedLastFrame;
            }
        },
        {
            key: "clear",
            value: function clear(mapView) {
                var newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
                this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);
                var newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);
                this.m_lastAttitude = newAttitude;
            }
        },
        {
            key: "forceMoved",
            value: function forceMoved() {
                this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);
            }
        },
        {
            key: "cameraIsMoving",
            get: function get() {
                return this.m_throttlingTimerId !== void 0;
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                this.removeMovementFinishedTimer();
                this.m_movementStartedFunc = void 0;
                this.m_movementFinishedFunc = void 0;
            }
        },
        {
            key: "cameraMovedLastFrame",
            get: function get() {
                return this.m_cameraMovedLastFrame === true;
            }
        },
        {
            key: "movementStarted",
            value: function movementStarted() {
                if (this.m_movementStartedFunc !== void 0) {
                    this.m_movementStartedFunc();
                }
            }
        },
        {
            key: "movementFinished",
            value: function movementFinished() {
                this.removeMovementFinishedTimer();
                if (this.m_movementFinishedFunc !== void 0) {
                    this.m_movementFinishedFunc();
                }
            }
        },
        {
            key: "startMovementFinishedTimer",
            value: function startMovementFinishedTimer(now2) {
                if (this.m_throttlingTimerId === void 0) {
                    var remainingTime = Math.max(0, this.m_movementDetectorDeadline - now2);
                    this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);
                }
            }
        },
        {
            key: "removeMovementFinishedTimer",
            value: function removeMovementFinishedTimer() {
                if (this.m_throttlingTimerId !== void 0) {
                    clearTimeout(this.m_throttlingTimerId);
                    this.m_throttlingTimerId = void 0;
                }
            }
        }
    ]);
    return CameraMovementDetector;
}();
// src/mapview/ClipPlanesEvaluator.ts
var THREE47 = __toESM(require("three"));
var epsilon = 1e-6;
var SphericalProj;
(function(SphericalProj2) {
    var getHorizonDistance = function getHorizonDistance(d, r) {
        return d - r < epsilon ? 0 : Math.sqrt(d * d - r * r);
    };
    var getFarDistanceFromElevatedHorizon = function getFarDistanceFromElevatedHorizon(camera, d, minR, maxR) {
        var t = getHorizonDistance(d, minR);
        var te = getHorizonDistance(maxR, minR);
        var normalToTanAngle = Math.asin(minR / d);
        var fwdToTanAngle = Math.abs(normalToTanAngle - SphericalProj2.getNormalToFwdAngle(camera));
        var far = Math.cos(fwdToTanAngle) * (t + te);
        return far;
    };
    var getProjNearPlaneTanDistance = function getProjNearPlaneTanDistance(camera, bottomFov, R) {
        var fwdDir = camera.getWorldDirection(tmpVectors[0]);
        var camToTanVec = tmpVectors[1].copy(fwdDir).multiplyScalar(-R).sub(camera.position);
        var near = camToTanVec.dot(fwdDir);
        var cosTanDirToFwdDir = near / camToTanVec.length();
        return cosTanDirToFwdDir > Math.cos(bottomFov) ? near : void 0;
    };
    var getProjSphereIntersectionDistance = function getProjSphereIntersectionDistance(camera, ndcDir, R) {
        raycaster.setFromCamera(ndcDir, camera);
        sphere.radius = R;
        var intersection = raycaster.ray.intersectSphere(sphere, tmpVectors[0]);
        return intersection !== null ? intersection.sub(camera.position).dot(camera.getWorldDirection(tmpVectors[1])) : void 0;
    };
    var getNormalToFwdAngle = function getNormalToFwdAngle(camera) {
        var camToOriginDir = tmpVectors[0].copy(camera.position).negate().normalize();
        var cosAngle = camToOriginDir.dot(camera.getWorldDirection(tmpVectors[1]));
        return Math.acos(THREE47.MathUtils.clamp(cosAngle, -1, 1));
    };
    var tmpVectors = [
        new THREE47.Vector3(),
        new THREE47.Vector3()
    ];
    var raycaster = new THREE47.Raycaster();
    var sphere = new THREE47.Sphere(new THREE47.Vector3(), EarthConstants.EQUATORIAL_RADIUS);
    SphericalProj2.getFarDistanceFromElevatedHorizon = getFarDistanceFromElevatedHorizon;
    SphericalProj2.getProjNearPlaneTanDistance = getProjNearPlaneTanDistance;
    SphericalProj2.getProjSphereIntersectionDistance = getProjSphereIntersectionDistance;
    SphericalProj2.getNormalToFwdAngle = getNormalToFwdAngle;
})(SphericalProj || (SphericalProj = {}));
var ElevationBasedClipPlanesEvaluator = /*#__PURE__*/ function() {
    function ElevationBasedClipPlanesEvaluator(maxElevation, minElevation) {
        _classCallCheck(this, ElevationBasedClipPlanesEvaluator);
        __publicField(this, "m_maxElevation");
        __publicField(this, "m_minElevation");
        assert(maxElevation >= minElevation);
        this.m_minElevation = minElevation;
        this.m_maxElevation = maxElevation;
    }
    _createClass(ElevationBasedClipPlanesEvaluator, [
        {
            key: "maxElevation",
            get: function get() {
                return this.m_maxElevation;
            },
            set: function set(elevation) {
                this.m_maxElevation = elevation;
                this.m_minElevation = Math.min(elevation, this.m_minElevation);
            }
        },
        {
            key: "minElevation",
            get: function get() {
                return this.m_minElevation;
            },
            set: function set(elevation) {
                this.m_minElevation = elevation;
                this.m_maxElevation = Math.max(elevation, this.m_maxElevation);
            }
        }
    ]);
    return ElevationBasedClipPlanesEvaluator;
}();
var TopViewClipPlanesEvaluator = /*#__PURE__*/ function(ElevationBasedClipPlanesEvaluator) {
    _inherits(TopViewClipPlanesEvaluator, ElevationBasedClipPlanesEvaluator);
    var _super = _createSuper(TopViewClipPlanesEvaluator);
    function TopViewClipPlanesEvaluator() {
        var maxElevation = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EarthConstants.MAX_BUILDING_HEIGHT, minElevation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, nearMin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, nearFarMarginRatio = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.05, farMaxRatio = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 6;
        _classCallCheck(this, TopViewClipPlanesEvaluator);
        var _this;
        _this = _super.call(this, maxElevation, minElevation);
        _this.nearMin = nearMin;
        _this.nearFarMarginRatio = nearFarMarginRatio;
        _this.farMaxRatio = farMaxRatio;
        __publicField(_assertThisInitialized(_this), "m_tmpVectors", [
            new THREE47.Vector3(),
            new THREE47.Vector3(),
            new THREE47.Vector3()
        ]);
        __publicField(_assertThisInitialized(_this), "m_tmpQuaternion", new THREE47.Quaternion());
        __publicField(_assertThisInitialized(_this), "m_minimumViewRange");
        assert(nearMin > 0);
        assert(nearFarMarginRatio >= 0);
        assert(farMaxRatio > 1);
        var nearFarMargin = nearFarMarginRatio * nearMin;
        _this.m_minimumViewRange = {
            near: nearMin,
            far: nearMin + nearFarMargin,
            minimum: _this.nearMin,
            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)
        };
        return _this;
    }
    _createClass(TopViewClipPlanesEvaluator, [
        {
            key: "evaluateClipPlanes",
            value: function evaluateClipPlanes(camera, projection, elevationProvider) {
                assert(_instanceof(camera, THREE47.PerspectiveCamera), "Unsupported camera type.");
                var persCamera = camera;
                if (projection.type === 1 /* Spherical */ ) {
                    return this.evaluateDistanceSphericalProj(persCamera, projection, elevationProvider);
                } else if (projection.type === 0 /* Planar */ ) {
                    return this.evaluateDistancePlanarProj(persCamera, projection, elevationProvider);
                }
                assert(false, "Unsupported projection type");
                return _objectSpread({}, this.minimumViewRange);
            }
        },
        {
            key: "minimumViewRange",
            get: function get() {
                return this.m_minimumViewRange;
            }
        },
        {
            key: "evaluateDistancePlanarProj",
            value: function evaluateDistancePlanarProj(camera, projection, elevationProvider) {
                assert(projection.type !== 1 /* Spherical */ );
                var nearPlane = this.nearMin;
                var farPlane = this.nearMin * this.farMaxRatio;
                var groundDistance = projection.groundDistance(camera.position);
                var farMax = groundDistance * this.farMaxRatio;
                nearPlane = groundDistance - this.maxElevation;
                farPlane = groundDistance - this.minElevation;
                nearPlane = Math.max(nearPlane, this.nearMin);
                farPlane = Math.min(farPlane, farMax);
                var nearFarMargin = this.nearFarMarginRatio * (nearPlane + farPlane) / 2;
                nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
                farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
                var viewRanges = {
                    near: nearPlane,
                    far: farPlane,
                    minimum: this.nearMin,
                    maximum: Math.max(farMax, farPlane)
                };
                return viewRanges;
            }
        },
        {
            key: "evaluateDistanceSphericalProj",
            value: function evaluateDistanceSphericalProj(camera, projection, elevationProvider) {
                assert(projection.type === 1 /* Spherical */ );
                var cameraAltitude = projection.groundDistance(camera.position);
                var nearPlane = cameraAltitude - this.maxElevation;
                var r = EarthConstants.EQUATORIAL_RADIUS;
                var d = Math.max(epsilon, camera.position.length());
                var alpha = Math.asin(r / d);
                var halfFovAngle = THREE47.MathUtils.degToRad(camera.fov / 2);
                if (camera.aspect > 1) {
                    halfFovAngle = MapViewUtils.calculateHorizontalFovByVerticalFov(halfFovAngle * 2, camera.aspect);
                }
                var maxR = r + this.maxElevation;
                var farTangent = SphericalProj.getFarDistanceFromElevatedHorizon(camera, d, r, maxR);
                var farPlane = halfFovAngle > alpha ? farTangent : this.getFovBasedFarPlane(camera, d, r, 2 * halfFovAngle, projection);
                var farMin = cameraAltitude - this.minElevation;
                var farMax = cameraAltitude * this.farMaxRatio;
                nearPlane = Math.max(nearPlane, this.nearMin);
                farPlane = Math.max(farPlane, farMin);
                var nearFarMargin = this.nearFarMarginRatio * (nearPlane + farPlane) / 2;
                nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
                farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
                var viewRanges = {
                    near: nearPlane,
                    far: farPlane,
                    minimum: this.nearMin,
                    maximum: farMax
                };
                return viewRanges;
            }
        },
        {
            key: "getFovBasedFarPlane",
            value: function getFovBasedFarPlane(camera, d, r, fovAngle, projection) {
                var dVec = camera.position;
                camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
                this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);
                var cameraFwdVec = this.m_tmpVectors[2];
                var tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);
                var cta = dVec.dot(tVec);
                if (cta < 0) {
                    var groundDistance = projection.groundDistance(camera.position);
                    return groundDistance * this.farMaxRatio;
                }
                var a2 = dVec.dot(dVec) - cta * cta;
                var r2 = r * r;
                assert(a2 <= r2, "Please use this evaluator only for top view camera poses.");
                var tota = Math.sqrt(r2 - a2);
                return cta - tota;
            }
        }
    ]);
    return TopViewClipPlanesEvaluator;
}(ElevationBasedClipPlanesEvaluator);
var TiltViewClipPlanesEvaluator = /*#__PURE__*/ function(TopViewClipPlanesEvaluator) {
    _inherits(TiltViewClipPlanesEvaluator, TopViewClipPlanesEvaluator);
    var _super = _createSuper(TiltViewClipPlanesEvaluator);
    function TiltViewClipPlanesEvaluator() {
        _classCallCheck(this, TiltViewClipPlanesEvaluator);
        var _this;
        _this = _super.call.apply(_super, [
            this
        ].concat(Array.prototype.slice.call(arguments)));
        __publicField(_assertThisInitialized(_this), "m_tmpV2", new THREE47.Vector2());
        return _this;
    }
    _createClass(TiltViewClipPlanesEvaluator, [
        {
            key: "evaluateDistancePlanarProj",
            value: function evaluateDistancePlanarProj(camera, projection, elevationProvider) {
                assert(projection.type !== 1 /* Spherical */ );
                var viewRanges = _objectSpread({}, this.minimumViewRange);
                var halfPiLimit = Math.PI / 2 - epsilon;
                var z = projection.groundDistance(camera.position);
                var cameraTilt = MapViewUtils.extractCameraTilt(camera, projection);
                var topFov = CameraUtils.getTopFov(camera);
                var bottomFov = CameraUtils.getBottomFov(camera);
                var topAngle = THREE47.MathUtils.clamp(cameraTilt + topFov, -halfPiLimit, halfPiLimit);
                var bottomAngle = THREE47.MathUtils.clamp(cameraTilt - bottomFov, -halfPiLimit, halfPiLimit);
                var topDist = Math.max(0, (z - this.minElevation) / Math.cos(topAngle));
                var bottomDist = Math.max(0, (z - this.maxElevation) / Math.cos(bottomAngle));
                viewRanges.near = bottomDist * Math.cos(bottomFov);
                viewRanges.far = topDist * Math.cos(topFov);
                return this.applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider);
            }
        },
        {
            key: "evaluateDistanceSphericalProj",
            value: function evaluateDistanceSphericalProj(camera, projection, elevationProvider) {
                assert(projection.type === 1 /* Spherical */ );
                var viewRanges = _objectSpread({}, this.minimumViewRange);
                viewRanges.near = this.computeNearDistSphericalProj(camera, projection);
                viewRanges.far = this.computeFarDistSphericalProj(camera, projection);
                return this.applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider);
            }
        },
        {
            key: "computeNearDistSphericalProj",
            value: function computeNearDistSphericalProj(camera, projection) {
                assert(projection.type === 1 /* Spherical */ );
                var defaultNear = projection.groundDistance(camera.position) - this.maxElevation;
                var cameraBelowMaxElevation = defaultNear <= 0;
                if (cameraBelowMaxElevation) {
                    return 0;
                }
                var maxR = EarthConstants.EQUATORIAL_RADIUS + this.maxElevation;
                var bottomFov = CameraUtils.getBottomFov(camera);
                var nearPlaneTanDist = SphericalProj.getProjNearPlaneTanDistance(camera, bottomFov, maxR);
                if (nearPlaneTanDist !== void 0) {
                    return nearPlaneTanDist;
                }
                CameraUtils.getPrincipalPoint(camera, this.m_tmpV2);
                var checkTopIntersection = this.m_tmpV2.y > 0;
                var bottomDist = SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.setComponent(1, -1), maxR);
                var topDist = checkTopIntersection ? SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.setComponent(1, 1), maxR) : Infinity;
                var near = Math.min(bottomDist !== null && bottomDist !== void 0 ? bottomDist : Infinity, topDist !== null && topDist !== void 0 ? topDist : Infinity);
                assert(near !== Infinity, "No reference point for near distance found");
                return near !== null && near !== void 0 ? near : defaultNear;
            }
        },
        {
            key: "computeFarDistSphericalProj",
            value: function computeFarDistSphericalProj(camera, projection) {
                assert(projection.type === 1 /* Spherical */ );
                var r = EarthConstants.EQUATORIAL_RADIUS;
                var minR = r + this.minElevation;
                var maxR = r + this.maxElevation;
                var d = camera.position.length();
                CameraUtils.getPrincipalPoint(camera, this.m_tmpV2);
                var isRightIntersectionFarther = this.m_tmpV2.x <= 0;
                var ndcX = isRightIntersectionFarther ? 1 : -1;
                var checkBottomIntersection = this.m_tmpV2.y > 0;
                var topDist = SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.set(ndcX, 1), minR);
                var bottomDist = checkBottomIntersection ? SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.set(ndcX, -1), minR) : 0;
                var largestDist = Math.max(topDist !== null && topDist !== void 0 ? topDist : Infinity, bottomDist !== null && bottomDist !== void 0 ? bottomDist : Infinity);
                if (largestDist !== Infinity) {
                    return largestDist;
                }
                return SphericalProj.getFarDistanceFromElevatedHorizon(camera, d, r, maxR);
            }
        },
        {
            key: "applyViewRangeConstraints",
            value: function applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider) {
                var distance = MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider).distance;
                var farMin = projection.groundDistance(camera.position) - this.minElevation;
                var farMax = distance * this.farMaxRatio;
                viewRanges.near = Math.max(viewRanges.near, this.nearMin);
                viewRanges.far = THREE47.MathUtils.clamp(viewRanges.far, farMin, farMax);
                var nearFarMargin = this.nearFarMarginRatio * (viewRanges.near + viewRanges.far) / 2;
                viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);
                viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);
                viewRanges.minimum = this.nearMin;
                viewRanges.maximum = farMax;
                return viewRanges;
            }
        }
    ]);
    return TiltViewClipPlanesEvaluator;
}(TopViewClipPlanesEvaluator);
var createDefaultClipPlanesEvaluator = function() {
    return new TiltViewClipPlanesEvaluator();
};
// src/mapview/composing/MapRenderingManager.ts
var THREE53 = __toESM(require("three"));
// src/mapview/composing/LowResRenderPass.ts
var THREE49 = __toESM(require("three"));
// src/mapview/composing/Pass.ts
var THREE48 = __toESM(require("three"));
var Pass = /*#__PURE__*/ function() {
    function Pass() {
        _classCallCheck(this, Pass);
        __publicField(this, "enabled", false);
        __publicField(this, "renderToScreen", false);
    }
    _createClass(Pass, [
        {
            key: "setSize",
            value: function setSize(width, height) {}
        },
        {
            key: "render",
            value: function render(renderer, scene, camera, writeBuffer, readBuffer, delta) {}
        }
    ]);
    return Pass;
}();
var RenderPass = /*#__PURE__*/ function(Pass) {
    _inherits(RenderPass, Pass);
    var _super = _createSuper(RenderPass);
    function RenderPass() {
        _classCallCheck(this, RenderPass);
        return _super.call(this);
    }
    _createClass(RenderPass, [
        {
            key: "render",
            value: function render(renderer, scene, camera, writeBuffer, readBuffer) {
                renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                renderer.render(scene, camera);
            }
        }
    ]);
    return RenderPass;
}(Pass);
var ShaderPass = /*#__PURE__*/ function(Pass) {
    _inherits(ShaderPass, Pass);
    var _super = _createSuper(ShaderPass);
    function ShaderPass(shader) {
        var textureID = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "tDiffuse";
        _classCallCheck(this, ShaderPass);
        var _this;
        _this = _super.call(this);
        _this.textureID = textureID;
        __publicField(_assertThisInitialized(_this), "uniforms");
        __publicField(_assertThisInitialized(_this), "material");
        __publicField(_assertThisInitialized(_this), "fsQuad");
        if (_instanceof(shader, THREE48.ShaderMaterial)) {
            _this.uniforms = shader.uniforms;
            _this.material = shader;
        } else {
            _this.uniforms = THREE48.UniformsUtils.clone(shader.uniforms);
            _this.material = new THREE48.ShaderMaterial({
                defines: _objectSpread({}, shader.defines),
                uniforms: _this.uniforms,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            });
        }
        _this.fsQuad = new FullScreenQuad(_this.material);
        return _this;
    }
    _createClass(ShaderPass, [
        {
            key: "render",
            value: function render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
                if (this.uniforms[this.textureID]) {
                    this.uniforms[this.textureID].value = readBuffer.texture;
                }
                this.fsQuad.material = this.material;
                renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                this.fsQuad.render(renderer);
            }
        }
    ]);
    return ShaderPass;
}(Pass);
var FullScreenQuad = /*#__PURE__*/ function() {
    function FullScreenQuad(material) {
        _classCallCheck(this, FullScreenQuad);
        __publicField(this, "m_mesh");
        __publicField(this, "m_camera");
        this.m_camera = new THREE48.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        var geometry = new THREE48.PlaneBufferGeometry(2, 2);
        this.m_mesh = new THREE48.Mesh(geometry, material);
    }
    _createClass(FullScreenQuad, [
        {
            key: "material",
            get: function get() {
                return this.m_mesh.material;
            },
            set: function set(value2) {
                this.m_mesh.material = value2;
            }
        },
        {
            key: "render",
            value: function render(renderer) {
                renderer.render(this.m_mesh, this.m_camera);
            }
        }
    ]);
    return FullScreenQuad;
}();
// src/mapview/composing/LowResRenderPass.ts
var LowResRenderPass = /*#__PURE__*/ function(Pass) {
    _inherits(LowResRenderPass, Pass);
    var _super = _createSuper(LowResRenderPass);
    function LowResRenderPass(lowResPixelRatio) {
        _classCallCheck(this, LowResRenderPass);
        var _this;
        _this = _super.call(this);
        _this.lowResPixelRatio = lowResPixelRatio;
        __publicField(_assertThisInitialized(_this), "m_renderTarget", null);
        __publicField(_assertThisInitialized(_this), "m_localCamera", new THREE49.OrthographicCamera(-1, 1, 1, -1, 0, 1));
        __publicField(_assertThisInitialized(_this), "m_quadScene", new THREE49.Scene());
        __publicField(_assertThisInitialized(_this), "m_quadUniforms", CopyShader.uniforms);
        __publicField(_assertThisInitialized(_this), "m_quadMaterial", new CopyMaterial(_this.m_quadUniforms));
        __publicField(_assertThisInitialized(_this), "m_quad", new THREE49.Mesh(new THREE49.PlaneBufferGeometry(2, 2), _this.m_quadMaterial));
        __publicField(_assertThisInitialized(_this), "m_pixelRatio");
        __publicField(_assertThisInitialized(_this), "m_savedWidth", 0);
        __publicField(_assertThisInitialized(_this), "m_savedHeight", 0);
        _this.m_quad.frustumCulled = false;
        _this.m_quadScene.add(_this.m_quad);
        _this.m_pixelRatio = lowResPixelRatio;
        return _this;
    }
    _createClass(LowResRenderPass, [
        {
            key: "dispose",
            value: function dispose() {
                this.m_quadMaterial.dispose();
                this.m_quad.geometry.dispose();
                if (this.m_renderTarget !== null) {
                    this.m_renderTarget.dispose();
                    this.m_renderTarget = null;
                }
            }
        },
        {
            key: "pixelRatio",
            get: function get() {
                return this.m_pixelRatio;
            },
            set: function set(ratio) {
                this.m_pixelRatio = ratio;
                if (this.m_renderTarget && this.pixelRatio !== void 0) {
                    this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));
                }
            }
        },
        {
            key: "render",
            value: function render(renderer, scene, camera, writeBuffer, readBuffer) {
                if (!this.enabled || this.pixelRatio === void 0) {
                    return;
                }
                if (this.m_renderTarget === null) {
                    this.m_savedWidth = readBuffer.width;
                    this.m_savedHeight = readBuffer.height;
                    this.m_renderTarget = new THREE49.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {
                        minFilter: THREE49.LinearFilter,
                        magFilter: THREE49.LinearFilter,
                        format: THREE49.RGBAFormat,
                        depthBuffer: true,
                        stencilBuffer: true
                    });
                    this.m_renderTarget.texture.name = "LowResRenderPass.sample";
                }
                this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
                this.m_quadUniforms.opacity.value = 1;
                var oldRenderTarget = renderer.getRenderTarget();
                renderer.setRenderTarget(this.m_renderTarget);
                renderer.clear();
                renderer.render(scene, camera);
                renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                renderer.clear();
                renderer.render(this.m_quadScene, this.m_localCamera);
                renderer.setRenderTarget(oldRenderTarget);
            }
        },
        {
            key: "setSize",
            value: function setSize(width, height) {
                this.m_savedWidth = width;
                this.m_savedHeight = height;
                if (this.m_renderTarget && this.pixelRatio !== void 0) {
                    this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));
                }
            }
        }
    ]);
    return LowResRenderPass;
}(Pass);
// src/mapview/composing/MSAARenderPass.ts
var THREE50 = __toESM(require("three"));
var MSAASampling = /* @__PURE__ */ function(MSAASampling2) {
    MSAASampling2[MSAASampling2["Level_0"] = 0] = "Level_0";
    MSAASampling2[MSAASampling2["Level_1"] = 1] = "Level_1";
    MSAASampling2[MSAASampling2["Level_2"] = 2] = "Level_2";
    MSAASampling2[MSAASampling2["Level_3"] = 3] = "Level_3";
    MSAASampling2[MSAASampling2["Level_4"] = 4] = "Level_4";
    MSAASampling2[MSAASampling2["Level_5"] = 5] = "Level_5";
    return MSAASampling2;
}(MSAASampling || {});
var _MSAARenderPass = /*#__PURE__*/ function(Pass) {
    _inherits(_MSAARenderPass, Pass);
    var _super = _createSuper(_MSAARenderPass);
    function _MSAARenderPass() {
        _classCallCheck(this, _MSAARenderPass);
        var _this;
        _this = _super.call(this);
        __publicField(_assertThisInitialized(_this), "samplingLevel", 1 /* Level_1 */ );
        __publicField(_assertThisInitialized(_this), "m_renderTarget", null);
        __publicField(_assertThisInitialized(_this), "m_localCamera", new THREE50.OrthographicCamera(-1, 1, 1, -1, 0, 1));
        __publicField(_assertThisInitialized(_this), "m_quadScene", new THREE50.Scene());
        __publicField(_assertThisInitialized(_this), "m_quadUniforms", CopyShader.uniforms);
        __publicField(_assertThisInitialized(_this), "m_quadMaterial", new MSAAMaterial(_this.m_quadUniforms));
        __publicField(_assertThisInitialized(_this), "m_quad", new THREE50.Mesh(new THREE50.PlaneBufferGeometry(2, 2), _this.m_quadMaterial));
        __publicField(_assertThisInitialized(_this), "m_tmpColor", new THREE50.Color());
        _this.m_quad.frustumCulled = false;
        _this.m_quadScene.add(_this.m_quad);
        return _this;
    }
    _createClass(_MSAARenderPass, [
        {
            key: "dispose",
            value: function dispose() {
                if (this.m_renderTarget !== null) {
                    this.m_renderTarget.dispose();
                    this.m_renderTarget = null;
                }
            }
        },
        {
            key: "render",
            value: function render(renderer, scene, camera, writeBuffer, readBuffer) {
                if (!this.enabled) {
                    return;
                }
                if (this.m_renderTarget === null) {
                    this.m_renderTarget = new THREE50.WebGLRenderTarget(readBuffer.width, readBuffer.height, {
                        minFilter: THREE50.LinearFilter,
                        magFilter: THREE50.LinearFilter,
                        format: THREE50.RGBAFormat
                    });
                    this.m_renderTarget.texture.name = "MSAARenderPass.sample";
                }
                this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
                var offsets = _MSAARenderPass.OffsetVectors[this.samplingLevel];
                var rendererClearColor = renderer.getClearColor(this.m_tmpColor);
                var oldClearColor = rendererClearColor !== void 0 ? rendererClearColor.getHex() : 0;
                var oldView = {
                    enabled: camera.view !== null && camera.view.enabled,
                    fullWidth: readBuffer.width,
                    fullHeight: readBuffer.height,
                    x: 0,
                    y: 0,
                    width: readBuffer.width,
                    height: readBuffer.height
                };
                if (oldView.enabled && camera.view !== null) {
                    oldView.fullWidth = camera.view.fullWidth;
                    oldView.fullHeight = camera.view.fullHeight;
                    oldView.x = camera.view.offsetX;
                    oldView.y = camera.view.offsetY;
                    oldView.width = camera.view.width;
                    oldView.height = camera.view.height;
                }
                var oldRenderTarget = renderer.getRenderTarget();
                for(var i = 0; i < offsets.length; i++){
                    var offset = offsets[i];
                    camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);
                    var uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;
                    var sampleWeight = 1 / offsets.length + uniformCenteredDistribution / 32;
                    this.m_quadUniforms.opacity.value = sampleWeight;
                    renderer.setRenderTarget(this.m_renderTarget);
                    renderer.clear();
                    renderer.render(scene, camera);
                    renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
                    if (i === 0) {
                        renderer.setClearColor(0);
                        renderer.clear();
                    }
                    renderer.render(this.m_quadScene, this.m_localCamera);
                    if (i === 0 && rendererClearColor !== void 0) {
                        renderer.setClearColor(oldClearColor);
                    }
                }
                renderer.setRenderTarget(oldRenderTarget);
                if (camera.view !== null) {
                    camera.view.enabled = oldView.enabled;
                    camera.view.offsetX = oldView.x;
                    camera.view.offsetY = oldView.y;
                }
            }
        },
        {
            key: "setSize",
            value: function setSize(width, height) {
                if (this.m_renderTarget) {
                    this.m_renderTarget.setSize(width, height);
                }
            }
        }
    ]);
    return _MSAARenderPass;
}(Pass);
var MSAARenderPass = _MSAARenderPass;
__publicField(MSAARenderPass, "OffsetVectors", [
    [
        [
            0,
            0
        ]
    ],
    [
        [
            4,
            4
        ],
        [
            -4,
            -4
        ]
    ],
    [
        [
            -2,
            -6
        ],
        [
            6,
            -2
        ],
        [
            -6,
            2
        ],
        [
            2,
            6
        ]
    ],
    [
        [
            1,
            -3
        ],
        [
            -1,
            3
        ],
        [
            5,
            1
        ],
        [
            -3,
            -5
        ],
        [
            -5,
            5
        ],
        [
            -7,
            -1
        ],
        [
            3,
            7
        ],
        [
            7,
            -7
        ]
    ],
    [
        [
            1,
            1
        ],
        [
            -1,
            -3
        ],
        [
            -3,
            2
        ],
        [
            4,
            -1
        ],
        [
            -5,
            -2
        ],
        [
            2,
            5
        ],
        [
            5,
            3
        ],
        [
            3,
            -5
        ],
        [
            -2,
            6
        ],
        [
            0,
            -7
        ],
        [
            -4,
            -6
        ],
        [
            -6,
            4
        ],
        [
            -8,
            0
        ],
        [
            7,
            -4
        ],
        [
            6,
            7
        ],
        [
            -7,
            -8
        ]
    ],
    [
        [
            -4,
            -7
        ],
        [
            -7,
            -5
        ],
        [
            -3,
            -5
        ],
        [
            -5,
            -4
        ],
        [
            -1,
            -4
        ],
        [
            -2,
            -2
        ],
        [
            -6,
            -1
        ],
        [
            -4,
            0
        ],
        [
            -7,
            1
        ],
        [
            -1,
            2
        ],
        [
            -6,
            3
        ],
        [
            -3,
            3
        ],
        [
            -7,
            6
        ],
        [
            -3,
            6
        ],
        [
            -5,
            7
        ],
        [
            -1,
            7
        ],
        [
            5,
            -7
        ],
        [
            1,
            -6
        ],
        [
            6,
            -5
        ],
        [
            4,
            -4
        ],
        [
            2,
            -3
        ],
        [
            7,
            -2
        ],
        [
            1,
            -1
        ],
        [
            4,
            -1
        ],
        [
            2,
            1
        ],
        [
            6,
            2
        ],
        [
            0,
            4
        ],
        [
            4,
            4
        ],
        [
            2,
            5
        ],
        [
            7,
            5
        ],
        [
            5,
            6
        ],
        [
            3,
            7
        ]
    ]
]);
// src/mapview/composing/Outline.ts
var THREE51 = __toESM(require("three"));
var vertexShaderChunk = "\n#ifdef USE_EXTRUSION\n  #ifndef HAS_EXTRUSION_PARS_VERTEX\n    #include <extrusion_pars_vertex>\n  #endif\n#endif\n\n#ifdef USE_FADING\n  #include <fading_pars_vertex>\n#endif\n\nuniform float outlineThickness;\n\nvec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\n    float thickness = outlineThickness;\n    const float ratio = 1.0;\n    vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\n    vec4 norm = normalize( pos - pos2 );\n    return pos + norm * thickness * pos.w * ratio;\n}";
var vertexShaderChunk2 = "\n#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )\n    #ifndef USE_ENVMAP\n        vec3 objectNormal = normalize( normal );\n    #endif\n#endif\n\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n\n#ifdef DECLARE_TRANSFORMED\n    vec3 transformed = vec3( position );\n#endif\n\n#ifdef USE_EXTRUSION\n #ifndef HAS_EXTRUSION_VERTEX\n  #include <extrusion_vertex>\n #endif\n#endif\n\n#ifdef USE_FADING\n  #include <fading_vertex>\n#endif\n\n#ifdef USE_EXTRUSION\n  gl_Position = calculateOutline( projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 ),\n      objectNormal, vec4( transformed, 1.0 ) );\n#else\n  gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\n#endif\n\n#include <fog_vertex>";
var fragmentShader2 = "\n#include <common>\n#include <fog_pars_fragment>\n\n#ifdef USE_EXTRUSION\n  #include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n  #include <fading_pars_fragment>\n#endif\n\nuniform vec3 outlineColor;\nuniform float outlineAlpha;\n\nvoid main() {\n\n    gl_FragColor = vec4( outlineColor, outlineAlpha );\n\n    #include <fog_fragment>\n\n    #ifdef USE_EXTRUSION\n      #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n      #include <fading_fragment>\n    #endif\n}";
var OutlineEffect = /*#__PURE__*/ function() {
    function OutlineEffect(m_renderer) {
        _classCallCheck(this, OutlineEffect);
        this.m_renderer = m_renderer;
        __publicField(this, "enabled", true);
        __publicField(this, "autoClear");
        __publicField(this, "domElement");
        __publicField(this, "shadowMap");
        __publicField(this, "m_defaultThickness", 0.02);
        __publicField(this, "m_defaultColor", new THREE51.Color(0, 0, 0));
        __publicField(this, "m_defaultAlpha", 1);
        __publicField(this, "m_defaultKeepAlive", false);
        __publicField(this, "m_ghostExtrudedPolygons", false);
        __publicField(this, "m_cache", {});
        __publicField(this, "m_removeThresholdCount", 60);
        __publicField(this, "m_originalMaterials", {});
        __publicField(this, "m_originalOnBeforeRenders", {});
        __publicField(this, "m_shaderIDs", {
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical"
        });
        __publicField(this, "m_uniformsChunk", {
            outlineThickness: {
                value: this.m_defaultThickness
            },
            outlineColor: {
                value: this.m_defaultColor
            },
            outlineAlpha: {
                value: this.m_defaultAlpha
            }
        });
        this.autoClear = m_renderer.autoClear;
        this.domElement = m_renderer.domElement;
        this.shadowMap = m_renderer.shadowMap;
    }
    _createClass(OutlineEffect, [
        {
            key: "thickness",
            set: function set(thickness) {
                this.m_defaultThickness = thickness;
                this.m_uniformsChunk.outlineThickness.value = thickness;
                this.m_cache = {};
            }
        },
        {
            key: "color",
            set: function set(color) {
                this.m_defaultColor.set(color);
                this.m_cache = {};
            }
        },
        {
            key: "ghostExtrudedPolygons",
            set: function set(ghost) {
                this.m_ghostExtrudedPolygons = ghost;
            }
        },
        {
            key: "clear",
            value: function clear(color, depth, stencil) {
                this.m_renderer.clear(color, depth, stencil);
            }
        },
        {
            key: "getPixelRatio",
            value: function getPixelRatio() {
                return this.m_renderer.getPixelRatio();
            }
        },
        {
            key: "setPixelRatio",
            value: function setPixelRatio(value2) {
                this.m_renderer.setPixelRatio(value2);
            }
        },
        {
            key: "getSize",
            value: function getSize(target) {
                return this.m_renderer.getSize(target);
            }
        },
        {
            key: "setSize",
            value: function setSize(width, height, updateStyle) {
                this.m_renderer.setSize(width, height, updateStyle);
            }
        },
        {
            key: "setViewport",
            value: function setViewport(x, y, width, height) {
                this.m_renderer.setViewport(x, y, width, height);
            }
        },
        {
            key: "setScissor",
            value: function setScissor(x, y, width, height) {
                this.m_renderer.setScissor(x, y, width, height);
            }
        },
        {
            key: "setScissorTest",
            value: function setScissorTest(boolean) {
                this.m_renderer.setScissorTest(boolean);
            }
        },
        {
            key: "setRenderTarget",
            value: function setRenderTarget(renderTarget) {
                this.m_renderer.setRenderTarget(renderTarget);
            }
        },
        {
            key: "render",
            value: function render(scene, camera) {
                if (this.m_ghostExtrudedPolygons) {
                    if (!this.enabled) {
                        this.m_renderer.render(scene, camera);
                        return;
                    }
                    var currentAutoClear = this.m_renderer.autoClear;
                    this.m_renderer.autoClear = this.autoClear;
                    this.m_renderer.render(scene, camera);
                    this.m_renderer.autoClear = currentAutoClear;
                }
                this.renderOutline(scene, camera);
            }
        },
        {
            key: "renderOutline",
            value: function renderOutline(scene, camera) {
                var currentAutoClear = this.m_renderer.autoClear;
                var currentSceneAutoUpdate = scene.autoUpdate;
                var currentSceneBackground = scene.background;
                var currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;
                scene.autoUpdate = false;
                scene.background = null;
                this.m_renderer.autoClear = false;
                this.m_renderer.shadowMap.enabled = false;
                scene.traverse(this.setOutlineMaterial.bind(this));
                this.m_renderer.render(scene, camera);
                scene.traverse(this.restoreOriginalMaterial.bind(this));
                this.cleanupCache();
                scene.autoUpdate = currentSceneAutoUpdate;
                scene.background = currentSceneBackground;
                this.m_renderer.autoClear = currentAutoClear;
                this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;
            }
        },
        {
            key: "createInvisibleMaterial",
            value: function createInvisibleMaterial() {
                return new THREE51.ShaderMaterial({
                    name: "invisible",
                    visible: false
                });
            }
        },
        {
            key: "createMaterial",
            value: function createMaterial(originalMaterial) {
                if (_instanceof(originalMaterial, EdgeMaterial) || originalMaterial.isDepthPrepassMaterial === true) {
                    return this.createInvisibleMaterial();
                }
                var shaderID = this.m_shaderIDs[originalMaterial.type];
                var originalVertexShader;
                var originalUniforms = originalMaterial.shaderUniforms !== void 0 ? originalMaterial.shaderUniforms : originalMaterial.uniforms;
                if (shaderID !== void 0) {
                    var shader = THREE51.ShaderLib[shaderID];
                    originalUniforms = shader.uniforms;
                    originalVertexShader = shader.vertexShader;
                } else if (originalMaterial.isRawShaderMaterial === true) {
                    originalVertexShader = originalMaterial.vertexShader;
                    if (!/attribute\s+vec3\s+position\s*;/.test(originalVertexShader) || !/attribute\s+vec3\s+normal\s*;/.test(originalVertexShader)) {
                        return this.createInvisibleMaterial();
                    }
                } else if (originalMaterial.isShaderMaterial === true) {
                    originalVertexShader = originalMaterial.vertexShader;
                } else {
                    return this.createInvisibleMaterial();
                }
                var isExtrusionMaterial = originalMaterial.shaderUniforms !== void 0 && originalMaterial.shaderUniforms.extrusionRatio !== void 0;
                var isFadingMaterial = FadingFeature.isDefined(originalMaterial);
                var uniforms = _objectSpread({}, originalUniforms, this.m_uniformsChunk);
                var vertexShader2 = originalVertexShader.replace(/void\s+main\s*\(\s*\)/, vertexShaderChunk + "\nvoid main()").replace(/\}\s*$/, vertexShaderChunk2 + "\n}").replace(/#include\s+<[\w_]*light[\w_]*>/g, "");
                var defines = {};
                if (!/vec3\s+transformed\s*=/.test(originalVertexShader) && !/#include\s+<begin_vertex>/.test(originalVertexShader)) {
                    ;
                    defines.DECLARE_TRANSFORMED = true;
                }
                if (isExtrusionMaterial) {
                    uniforms.extrusionRatio = {
                        value: ExtrusionFeatureDefs.DEFAULT_RATIO_MIN
                    };
                    defines.USE_EXTRUSION = 1;
                }
                if (isFadingMaterial) {
                    uniforms.fadeNear = {
                        value: originalUniforms.fadeNear !== void 0 ? originalUniforms.fadeNear.value : FadingFeature.DEFAULT_FADE_NEAR
                    };
                    uniforms.fadeFar = {
                        value: originalUniforms.fadeFar !== void 0 ? originalUniforms.fadeFar.value : FadingFeature.DEFAULT_FADE_FAR
                    };
                    defines.USE_FADING = 1;
                }
                var outlineMaterial = new THREE51.ShaderMaterial({
                    defines: defines,
                    uniforms: uniforms,
                    vertexShader: vertexShader2,
                    fragmentShader: fragmentShader2,
                    side: THREE51.BackSide,
                    morphTargets: false,
                    morphNormals: false,
                    fog: false,
                    blending: THREE51.CustomBlending,
                    blendSrc: THREE51.SrcAlphaFactor,
                    blendDst: THREE51.OneMinusSrcAlphaFactor,
                    blendSrcAlpha: THREE51.OneFactor,
                    blendDstAlpha: THREE51.OneMinusSrcAlphaFactor,
                    transparent: true,
                    polygonOffset: true,
                    polygonOffsetFactor: 10,
                    polygonOffsetUnits: 30
                });
                return outlineMaterial;
            }
        },
        {
            key: "getOutlineMaterialFromCache",
            value: function getOutlineMaterialFromCache(originalMaterial) {
                var data2 = this.m_cache[originalMaterial.uuid];
                if (data2 === void 0) {
                    data2 = {
                        material: this.createMaterial(originalMaterial),
                        used: true,
                        keepAlive: this.m_defaultKeepAlive,
                        count: 0
                    };
                    this.m_cache[originalMaterial.uuid] = data2;
                }
                data2.used = true;
                return data2.material;
            }
        },
        {
            key: "getOutlineMaterial",
            value: function getOutlineMaterial(originalMaterial) {
                var outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);
                this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;
                this.updateOutlineMaterial(outlineMaterial, originalMaterial);
                return outlineMaterial;
            }
        },
        {
            key: "setOutlineMaterial",
            value: function setOutlineMaterial(object) {
                if (object.material === void 0) {
                    return;
                }
                if (Array.isArray(object.material)) {
                    for(var i = 0, il = object.material.length; i < il; i++){
                        ;
                        object.material[i] = this.getOutlineMaterial(object.material[i]);
                    }
                } else {
                    ;
                    object.material = this.getOutlineMaterial(object.material);
                }
                this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
                object.onBeforeRender = chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));
            }
        },
        {
            key: "restoreOriginalMaterial",
            value: function restoreOriginalMaterial(object) {
                if (object.material === void 0) {
                    return;
                }
                if (Array.isArray(object.material)) {
                    for(var i = 0, il = object.material.length; i < il; i++){
                        ;
                        object.material[i] = this.m_originalMaterials[object.material[i].uuid];
                    }
                } else {
                    ;
                    object.material = this.m_originalMaterials[object.material.uuid];
                }
                object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];
            }
        },
        {
            key: "onBeforeRender",
            value: function onBeforeRender(renderer, scene, camera, geometry, material, group) {
                var originalMaterial = this.m_originalMaterials[material.uuid];
                if (originalMaterial === void 0) {
                    return;
                }
                this.updateUniforms(material, originalMaterial);
            }
        },
        {
            key: "updateUniforms",
            value: function updateUniforms(material, originalMaterial) {
                var ref;
                var outlineParameters = originalMaterial.userData.outlineParameters;
                var outlineUniforms = material.uniforms;
                outlineUniforms.outlineAlpha.value = originalMaterial.opacity;
                var originalUniforms = originalMaterial.shaderUniforms !== void 0 ? originalMaterial.shaderUniforms : originalMaterial.uniforms;
                if (outlineParameters !== void 0) {
                    if (outlineParameters.thickness !== void 0) {
                        outlineUniforms.outlineThickness.value = outlineParameters.thickness;
                    }
                    if (outlineParameters.color !== void 0) {
                        outlineUniforms.outlineColor.value.fromArray(outlineParameters.color);
                    }
                    if (outlineParameters.alpha !== void 0) {
                        outlineUniforms.outlineAlpha.value = outlineParameters.alpha;
                    }
                }
                if (originalUniforms !== void 0 && originalUniforms.extrusionRatio !== void 0) {
                    var value2 = originalMaterial.shaderUniforms.extrusionRatio.value;
                    material.extrusionRatio = value2;
                    material.uniforms.extrusionRatio.value = value2 !== void 0 ? value2 : ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
                }
                if (((ref = material.defines) === null || ref === void 0 ? void 0 : ref.USE_FADING) !== void 0 && originalUniforms.fadeNear !== void 0 && originalUniforms.fadeFar !== void 0 && originalUniforms.fadeFar.value >= 0) {
                    outlineUniforms.fadeNear.value = originalUniforms.fadeNear.value;
                    outlineUniforms.fadeFar.value = originalUniforms.fadeFar.value;
                }
            }
        },
        {
            key: "updateOutlineMaterial",
            value: function updateOutlineMaterial(material, originalMaterial) {
                if (material.name === "invisible") {
                    return;
                }
                var outlineParameters = originalMaterial.userData.outlineParameters;
                material.skinning = originalMaterial.skinning;
                material.morphTargets = originalMaterial.morphTargets;
                material.morphNormals = originalMaterial.morphNormals;
                material.fog = originalMaterial.fog;
                if (outlineParameters !== void 0) {
                    material.visible = originalMaterial.visible === false ? false : outlineParameters.visible !== void 0 ? outlineParameters.visible : true;
                    if (outlineParameters.keepAlive !== void 0) {
                        this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
                    }
                } else {
                    material.visible = originalMaterial.visible;
                }
                if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {
                    material.visible = false;
                }
            }
        },
        {
            key: "cleanupCache",
            value: function cleanupCache() {
                var keys;
                keys = Object.keys(this.m_originalMaterials);
                for(var i = 0, il = keys.length; i < il; i++){
                    this.m_originalMaterials[keys[i]] = void 0;
                }
                keys = Object.keys(this.m_originalOnBeforeRenders);
                for(var i1 = 0, il1 = keys.length; i1 < il1; i1++){
                    this.m_originalOnBeforeRenders[keys[i1]] = void 0;
                }
                keys = Object.keys(this.m_cache);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var key = _step.value;
                        if (this.m_cache[key].used === false) {
                            this.m_cache[key].count++;
                            if (this.m_cache[key].keepAlive === false && this.m_cache[key].count > this.m_removeThresholdCount) {
                                delete this.m_cache[key];
                            }
                        } else {
                            this.m_cache[key].used = false;
                            this.m_cache[key].count = 0;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        }
    ]);
    return OutlineEffect;
}();
// src/mapview/composing/UnrealBloomPass.ts
var THREE52 = __toESM(require("three"));
var BlurDirectionX = new THREE52.Vector2(1, 0);
var BlurDirectionY = new THREE52.Vector2(0, 1);
var BloomPass = /*#__PURE__*/ function(Pass) {
    _inherits(BloomPass, Pass);
    var _super = _createSuper(BloomPass);
    function BloomPass(resolution, strength, radius, threshold) {
        _classCallCheck(this, BloomPass);
        var _this;
        _this = _super.call(this);
        __publicField(_assertThisInitialized(_this), "strength");
        __publicField(_assertThisInitialized(_this), "radius");
        __publicField(_assertThisInitialized(_this), "threshold");
        __publicField(_assertThisInitialized(_this), "resolution", new THREE52.Vector2(256, 256));
        __publicField(_assertThisInitialized(_this), "m_renderTargetsHorizontal", []);
        __publicField(_assertThisInitialized(_this), "m_renderTargetsVertical", []);
        __publicField(_assertThisInitialized(_this), "m_nMips", 5);
        __publicField(_assertThisInitialized(_this), "m_highPassUniforms");
        __publicField(_assertThisInitialized(_this), "m_materialHighPassFilter");
        __publicField(_assertThisInitialized(_this), "m_separableBlurMaterials", []);
        __publicField(_assertThisInitialized(_this), "m_materialCopy");
        __publicField(_assertThisInitialized(_this), "m_copyUniforms");
        __publicField(_assertThisInitialized(_this), "m_compositeMaterial");
        __publicField(_assertThisInitialized(_this), "m_camera", new THREE52.OrthographicCamera(-1, 1, 1, -1, 0, 1));
        __publicField(_assertThisInitialized(_this), "m_scene", new THREE52.Scene());
        __publicField(_assertThisInitialized(_this), "m_basic", new THREE52.MeshBasicMaterial());
        __publicField(_assertThisInitialized(_this), "m_quad", new THREE52.Mesh(new THREE52.PlaneBufferGeometry(2, 2)));
        __publicField(_assertThisInitialized(_this), "m_bloomTintColors", [
            new THREE52.Vector3(1, 1, 1),
            new THREE52.Vector3(1, 1, 1),
            new THREE52.Vector3(1, 1, 1),
            new THREE52.Vector3(1, 1, 1),
            new THREE52.Vector3(1, 1, 1)
        ]);
        __publicField(_assertThisInitialized(_this), "m_renderTargetBright");
        _this.strength = strength;
        _this.radius = radius;
        _this.threshold = threshold;
        _this.resolution = resolution;
        _this.m_quad.frustumCulled = false;
        _this.m_scene.add(_this.m_quad);
        var pars = {
            minFilter: THREE52.LinearFilter,
            magFilter: THREE52.LinearFilter,
            format: THREE52.RGBAFormat
        };
        var resx = Math.round(_this.resolution.x / 2);
        var resy = Math.round(_this.resolution.y / 2);
        _this.m_renderTargetBright = new THREE52.WebGLRenderTarget(resx, resy, pars);
        _this.m_renderTargetBright.texture.name = "UnrealBloomPass.bright";
        _this.m_renderTargetBright.texture.generateMipmaps = false;
        for(var i = 0; i < _this.m_nMips; i++){
            var renderTargetHorizonal = new THREE52.WebGLRenderTarget(resx, resy, pars);
            renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
            renderTargetHorizonal.texture.generateMipmaps = false;
            _this.m_renderTargetsHorizontal.push(renderTargetHorizonal);
            var renderTargetVertical = new THREE52.WebGLRenderTarget(resx, resy, pars);
            renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
            renderTargetVertical.texture.generateMipmaps = false;
            _this.m_renderTargetsVertical.push(renderTargetVertical);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        _this.m_highPassUniforms = THREE52.UniformsUtils.clone(LuminosityHighPassShader.uniforms);
        _this.m_highPassUniforms["luminosityThreshold"].value = threshold;
        _this.m_highPassUniforms["smoothWidth"].value = 0.01;
        _this.m_materialHighPassFilter = new THREE52.ShaderMaterial({
            uniforms: _this.m_highPassUniforms,
            vertexShader: LuminosityHighPassShader.vertexShader,
            fragmentShader: LuminosityHighPassShader.fragmentShader,
            defines: {}
        });
        var kernelSizeArray = [
            3,
            5,
            7,
            9,
            11
        ];
        resx = Math.round(_this.resolution.x / 2);
        resy = Math.round(_this.resolution.y / 2);
        for(var i1 = 0; i1 < _this.m_nMips; i1++){
            _this.m_separableBlurMaterials.push(_this.getSeperableBlurMaterial(kernelSizeArray[i1]));
            _this.m_separableBlurMaterials[i1].uniforms["texSize"].value = new THREE52.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        _this.m_compositeMaterial = _this.getCompositeMaterial(_this.m_nMips);
        _this.m_compositeMaterial.uniforms["blurTexture1"].value = _this.m_renderTargetsVertical[0].texture;
        _this.m_compositeMaterial.uniforms["blurTexture2"].value = _this.m_renderTargetsVertical[1].texture;
        _this.m_compositeMaterial.uniforms["blurTexture3"].value = _this.m_renderTargetsVertical[2].texture;
        _this.m_compositeMaterial.uniforms["blurTexture4"].value = _this.m_renderTargetsVertical[3].texture;
        _this.m_compositeMaterial.uniforms["blurTexture5"].value = _this.m_renderTargetsVertical[4].texture;
        _this.m_compositeMaterial.uniforms["bloomStrength"].value = strength;
        _this.m_compositeMaterial.uniforms["bloomRadius"].value = 0.1;
        _this.m_compositeMaterial.needsUpdate = true;
        var bloomFactors = [
            1,
            0.8,
            0.6,
            0.4,
            0.2
        ];
        _this.m_compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
        _this.m_compositeMaterial.uniforms["bloomTintColors"].value = _this.m_bloomTintColors;
        _this.m_copyUniforms = THREE52.UniformsUtils.clone(CopyShader.uniforms);
        _this.m_copyUniforms["opacity"].value = 1;
        _this.m_materialCopy = new THREE52.ShaderMaterial({
            uniforms: _this.m_copyUniforms,
            vertexShader: CopyShader.vertexShader,
            fragmentShader: CopyShader.fragmentShader,
            blending: THREE52.AdditiveBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        return _this;
    }
    _createClass(BloomPass, [
        {
            key: "dispose",
            value: function dispose() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_renderTargetsHorizontal[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var rt = _step.value;
                        rt.dispose();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = this.m_renderTargetsVertical[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var rt1 = _step1.value;
                        rt1.dispose();
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                this.m_renderTargetBright.dispose();
            }
        },
        {
            key: "setSize",
            value: function setSize(width, height) {
                var resx = Math.round(width / 2);
                var resy = Math.round(height / 2);
                this.m_renderTargetBright.setSize(resx, resy);
                for(var i = 0; i < this.m_nMips; i++){
                    this.m_renderTargetsHorizontal[i].setSize(resx, resy);
                    this.m_renderTargetsVertical[i].setSize(resx, resy);
                    this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE52.Vector2(resx, resy);
                    resx = Math.round(resx / 2);
                    resy = Math.round(resy / 2);
                }
            }
        },
        {
            key: "render",
            value: function render(renderer, scene, camera, writeBuffer, readBuffer) {
                if (this.renderToScreen) {
                    this.m_quad.material = this.m_basic;
                    this.m_basic.map = readBuffer.texture;
                    renderer.setRenderTarget(null);
                    renderer.clear();
                    renderer.render(this.m_scene, this.m_camera);
                }
                this.m_highPassUniforms["tDiffuse"].value = readBuffer.texture;
                this.m_highPassUniforms["luminosityThreshold"].value = this.threshold;
                this.m_quad.material = this.m_materialHighPassFilter;
                renderer.setRenderTarget(this.m_renderTargetBright);
                renderer.clear();
                renderer.render(this.m_scene, this.m_camera);
                var inputRenderTarget = this.m_renderTargetBright;
                for(var i = 0; i < this.m_nMips; i++){
                    this.m_quad.material = this.m_separableBlurMaterials[i];
                    this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = inputRenderTarget.texture;
                    this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionX;
                    renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);
                    renderer.clear();
                    renderer.render(this.m_scene, this.m_camera);
                    this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = this.m_renderTargetsHorizontal[i].texture;
                    this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionY;
                    renderer.setRenderTarget(this.m_renderTargetsVertical[i]);
                    renderer.clear();
                    renderer.render(this.m_scene, this.m_camera);
                    inputRenderTarget = this.m_renderTargetsVertical[i];
                }
                this.m_quad.material = this.m_compositeMaterial;
                this.m_compositeMaterial.uniforms["bloomStrength"].value = this.strength;
                this.m_compositeMaterial.uniforms["bloomRadius"].value = this.radius;
                this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
                renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);
                renderer.clear();
                renderer.render(this.m_scene, this.m_camera);
                this.m_quad.material = this.m_materialCopy;
                this.m_copyUniforms["tDiffuse"].value = this.m_renderTargetsHorizontal[0].texture;
                if (this.renderToScreen) {
                    renderer.setRenderTarget(null);
                    renderer.render(this.m_scene, this.m_camera);
                } else {
                    renderer.setRenderTarget(readBuffer);
                    renderer.render(this.m_scene, this.m_camera);
                }
            }
        },
        {
            key: "getSeperableBlurMaterial",
            value: function getSeperableBlurMaterial(kernelRadius) {
                return new THREE52.ShaderMaterial({
                    defines: {
                        KERNEL_RADIUS: kernelRadius,
                        SIGMA: kernelRadius
                    },
                    uniforms: {
                        colorTexture: {
                            value: null
                        },
                        texSize: {
                            value: new THREE52.Vector2(0.5, 0.5)
                        },
                        direction: {
                            value: new THREE52.Vector2(0.5, 0.5)
                        }
                    },
                    vertexShader: "varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }",
                    fragmentShader: "#include <common>\n            varying vec2 vUv;\n            uniform sampler2D colorTexture;\n            uniform vec2 texSize;\n            uniform vec2 direction;\n\n            float gaussianPdf(in float x, in float sigma) {\n                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n            }\n            void main() {\n                vec2 invSize = 1.0 / texSize;\n                float fSigma = float(SIGMA);\n                float weightSum = gaussianPdf(0.0, fSigma);\n                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n                    float x = float(i);\n                    float w = gaussianPdf(x, fSigma);\n                    vec2 uvOffset = direction * invSize * x;\n                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n                    diffuseSum += (sample1 + sample2) * w;\n                    weightSum += 2.0 * w;\n                }\n                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n            }"
                });
            }
        },
        {
            key: "getCompositeMaterial",
            value: function getCompositeMaterial(nMips) {
                return new THREE52.ShaderMaterial({
                    defines: {
                        NUM_MIPS: nMips
                    },
                    uniforms: {
                        blurTexture1: {
                            value: null
                        },
                        blurTexture2: {
                            value: null
                        },
                        blurTexture3: {
                            value: null
                        },
                        blurTexture4: {
                            value: null
                        },
                        blurTexture5: {
                            value: null
                        },
                        dirtTexture: {
                            value: null
                        },
                        bloomStrength: {
                            value: 1
                        },
                        bloomFactors: {
                            value: null
                        },
                        bloomTintColors: {
                            value: null
                        },
                        bloomRadius: {
                            value: 0
                        }
                    },
                    vertexShader: "varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",
                    fragmentShader: "varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform sampler2D dirtTexture;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[NUM_MIPS];\n                uniform vec3 bloomTintColors[NUM_MIPS];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    gl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n                }"
                });
            }
        }
    ]);
    return BloomPass;
}(Pass);
// src/mapview/composing/MapRenderingManager.ts
var DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = 1 /* Level_1 */ ;
var DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = 4 /* Level_4 */ ;
var MapRenderingManager = /*#__PURE__*/ function() {
    function MapRenderingManager(width, height, lowResPixelRatio) {
        var antialiasSettings = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            msaaEnabled: false
        };
        _classCallCheck(this, MapRenderingManager);
        __publicField(this, "bloom", {
            enabled: false,
            strength: 1.5,
            radius: 0.4,
            threshold: 0.85
        });
        __publicField(this, "outline", {
            enabled: false,
            thickness: 5e-3,
            color: "#000000",
            ghostExtrudedPolygons: false,
            needsUpdate: false
        });
        __publicField(this, "vignette", {
            enabled: false,
            offset: 1,
            darkness: 1
        });
        __publicField(this, "sepia", {
            enabled: false,
            amount: 0.5
        });
        __publicField(this, "m_width", 1);
        __publicField(this, "m_height", 1);
        __publicField(this, "m_outlineEffect");
        __publicField(this, "m_msaaPass");
        __publicField(this, "m_renderPass", new RenderPass());
        __publicField(this, "m_target1", new THREE53.WebGLRenderTarget(1, 1));
        __publicField(this, "m_target2", new THREE53.WebGLRenderTarget(1, 1));
        __publicField(this, "m_bloomPass");
        __publicField(this, "m_sepiaPass", new ShaderPass(SepiaShader));
        __publicField(this, "m_vignettePass", new ShaderPass(VignetteShader));
        __publicField(this, "m_readBuffer");
        __publicField(this, "m_dynamicMsaaSamplingLevel");
        __publicField(this, "m_staticMsaaSamplingLevel");
        __publicField(this, "m_lowResPass");
        this.m_readBuffer = new THREE53.WebGLRenderTarget(width, height);
        this.m_msaaPass = new MSAARenderPass();
        this.m_msaaPass.enabled = antialiasSettings !== void 0 ? antialiasSettings.msaaEnabled === true : false;
        this.m_dynamicMsaaSamplingLevel = antialiasSettings.dynamicMsaaSamplingLevel === void 0 ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL : antialiasSettings.dynamicMsaaSamplingLevel;
        this.m_staticMsaaSamplingLevel = antialiasSettings.staticMsaaSamplingLevel === void 0 ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL : antialiasSettings.staticMsaaSamplingLevel;
        this.m_lowResPass = new LowResRenderPass(lowResPixelRatio);
        this.m_lowResPass.enabled = lowResPixelRatio !== void 0;
    }
    _createClass(MapRenderingManager, [
        {
            key: "updateOutline",
            value: function updateOutline(options) {
                this.outline.color = options.color;
                this.outline.thickness = options.thickness;
                this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;
                this.outline.needsUpdate = true;
            }
        },
        {
            key: "render",
            value: function render(renderer, scene, camera, isStaticFrame) {
                var target = null;
                if (!isStaticFrame && this.m_lowResPass.pixelRatio !== void 0) {
                    this.m_lowResPass.renderToScreen = true;
                    this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);
                    return;
                }
                var usePostEffects = this.bloom.enabled || this.outline.enabled || this.vignette.enabled || this.sepia.enabled;
                var activeTarget = null;
                if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
                    renderer.setRenderTarget(this.m_target1);
                    renderer.clearDepth();
                }
                if (this.m_msaaPass.enabled) {
                    this.m_msaaPass.samplingLevel = isStaticFrame ? this.m_staticMsaaSamplingLevel : this.m_dynamicMsaaSamplingLevel;
                    this.m_msaaPass.renderToScreen = !usePostEffects;
                    this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);
                } else {
                    if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
                        activeTarget = this.m_target1;
                        this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);
                    } else if (!this.outline.enabled || this.outline.enabled && !this.bloom.enabled) {
                        renderer.render(scene, camera);
                    }
                }
                if (this.outline.enabled) {
                    if (this.m_outlineEffect === void 0) {
                        this.m_outlineEffect = new OutlineEffect(renderer);
                    }
                    if (this.outline.needsUpdate) {
                        this.m_outlineEffect.color = this.outline.color;
                        this.m_outlineEffect.thickness = this.outline.thickness;
                        this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;
                        this.outline.needsUpdate = false;
                    }
                    var nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;
                    if (nextEffectEnabled) {
                        activeTarget = this.m_target1;
                    }
                    renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);
                    this.m_outlineEffect.render(scene, camera);
                }
                if (this.bloom.enabled) {
                    if (this.m_bloomPass === void 0) {
                        this.m_bloomPass = new BloomPass(new THREE53.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);
                    }
                    var nextEffectEnabled1 = this.vignette.enabled || this.sepia.enabled;
                    this.m_bloomPass.renderToScreen = !nextEffectEnabled1;
                    this.m_bloomPass.radius = this.bloom.radius;
                    this.m_bloomPass.strength = this.bloom.strength;
                    this.m_bloomPass.threshold = this.bloom.threshold;
                    this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);
                } else if (this.m_bloomPass !== void 0) {
                    this.m_bloomPass.dispose();
                    this.m_bloomPass = void 0;
                }
                if (this.vignette.enabled) {
                    var oldTarget = activeTarget;
                    var nextEffectEnabled2 = this.sepia.enabled;
                    this.m_vignettePass.uniforms.offset.value = this.vignette.offset;
                    this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;
                    this.m_vignettePass.renderToScreen = !nextEffectEnabled2;
                    if (nextEffectEnabled2) {
                        activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;
                    }
                    this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);
                }
                if (this.sepia.enabled) {
                    this.m_sepiaPass.renderToScreen = true;
                    this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;
                    this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);
                }
            }
        },
        {
            key: "setSize",
            value: function setSize(width, height) {
                this.m_readBuffer.setSize(width, height);
                this.m_msaaPass.setSize(width, height);
                if (this.m_bloomPass !== void 0) {
                    this.m_bloomPass.setSize(width, height);
                }
                this.m_lowResPass.setSize(width, height);
                this.m_target1.setSize(width, height);
                this.m_target2.setSize(width, height);
                this.m_width = width;
                this.m_height = height;
            }
        },
        {
            key: "lowResPixelRatio",
            get: function get() {
                return this.m_lowResPass.pixelRatio;
            },
            set: function set(pixelRatio) {
                this.m_lowResPass.pixelRatio = pixelRatio;
                this.m_lowResPass.enabled = pixelRatio !== void 0;
            }
        },
        {
            key: "dynamicMsaaSamplingLevel",
            get: function get() {
                return this.m_dynamicMsaaSamplingLevel;
            },
            set: function set(samplingLevel) {
                this.m_dynamicMsaaSamplingLevel = samplingLevel;
            }
        },
        {
            key: "msaaEnabled",
            get: function get() {
                return this.m_msaaPass.enabled;
            },
            set: function set(value2) {
                this.m_msaaPass.enabled = value2;
            }
        },
        {
            key: "staticMsaaSamplingLevel",
            get: function get() {
                return this.m_staticMsaaSamplingLevel;
            },
            set: function set(samplingLevel) {
                this.m_staticMsaaSamplingLevel = samplingLevel;
            }
        }
    ]);
    return MapRenderingManager;
}();
// src/mapview/ConcurrentWorkerSet.ts
var THREE54 = __toESM(require("three"));
// src/mapview/workers/WorkerBootstrapDefs.ts
function isWorkerBootstrapRequest(message) {
    return message && message.type === "worker-bootstrap-request" && Array.isArray(message.dependencies);
}
// src/mapview/workers/WorkerLoader.ts
var logger6 = LoggerManager.instance.create("WorkerLoader");
var _WorkerLoader = /*#__PURE__*/ function() {
    function _WorkerLoader() {
        _classCallCheck(this, _WorkerLoader);
    }
    _createClass(_WorkerLoader, null, [
        {
            key: "startWorker",
            value: function startWorker(scriptUrl) {
                var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e4;
                var _this = this;
                if (scriptUrl.startsWith("blob:")) {
                    return this.startWorkerImmediately(scriptUrl, timeout);
                }
                if (this.directlyFallbackToBlobBasedLoading) {
                    return this.startWorkerBlob(scriptUrl, timeout);
                }
                return this.startWorkerImmediately(scriptUrl, timeout).catch(function(error) {
                    if (typeof window !== "undefined") {
                        var pageUrl = window.location.href;
                        var fullScriptUrl = new URL(scriptUrl, pageUrl).href;
                        if (getUrlOrigin(fullScriptUrl) === getUrlOrigin(pageUrl)) {
                            throw error;
                        }
                        logger6.log("#startWorker: cross-origin worker construction failed, trying load with blob");
                        _this.directlyFallbackToBlobBasedLoading = true;
                        return _WorkerLoader.startWorkerBlob(scriptUrl, timeout);
                    } else {
                        throw error;
                    }
                });
            }
        },
        {
            key: "startWorkerImmediately",
            value: function startWorkerImmediately(scriptUrl, timeout) {
                try {
                    var worker = new Worker(scriptUrl);
                    return this.waitWorkerInitialized(worker, timeout);
                } catch (error) {
                    return Promise.reject(error);
                }
            }
        },
        {
            key: "startWorkerBlob",
            value: function startWorkerBlob(scriptUrl, timeout) {
                var _this = this;
                return this.fetchScriptSourceToBlobUrl(scriptUrl).then(function(blobUrl) {
                    return _this.startWorkerImmediately(blobUrl, timeout);
                });
            }
        },
        {
            key: "fetchScriptSourceToBlobUrl",
            value: function fetchScriptSourceToBlobUrl(scriptUrl) {
                var _this = this;
                var loadingPromise = this.sourceLoaderCache.get(scriptUrl);
                if (loadingPromise !== void 0) {
                    return loadingPromise;
                }
                loadingPromise = fetch(scriptUrl).then(function(response) {
                    return response.text();
                }).catch(function(error) {
                    throw new Error("WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ".concat(error));
                }).then(function(scriptSource) {
                    _this.sourceLoaderCache.delete(scriptUrl);
                    var blob = new Blob([
                        scriptSource
                    ], {
                        type: "application/javascript"
                    });
                    return URL.createObjectURL(blob);
                });
                this.sourceLoaderCache.set(scriptUrl, loadingPromise);
                return loadingPromise;
            }
        },
        {
            key: "waitWorkerInitialized",
            value: function waitWorkerInitialized(worker, timeout) {
                var _this = this;
                return new Promise(function(resolve, reject) {
                    var firstMessageCallback = function(event) {
                        var message = event.data;
                        if (isWorkerBootstrapRequest(message)) {
                            var dependencies = message.dependencies;
                            var resolvedDependencies = [];
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var dependency = _step.value;
                                    var resolved = _this.dependencyUrlMapping[dependency];
                                    if (!resolved) {
                                        cleanup();
                                        reject(new Error("#waitWorkerInitialized: Unable to resolve '".concat(dependency, "' as needed by worker script.")));
                                        return;
                                    }
                                    resolvedDependencies.push(resolved);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            var response = {
                                type: "worker-bootstrap-response",
                                resolvedDependencies: resolvedDependencies
                            };
                            worker.postMessage(response);
                            return;
                        }
                        cleanup();
                        resolve(worker);
                        setTimeout(function() {
                            worker.dispatchEvent(event);
                        }, 0);
                    };
                    var errorCallback = function(error) {
                        cleanup();
                        var message = "Error during worker initialization";
                        if (error.message) {
                            message = message + ": ".concat(error.message);
                        }
                        if (typeof error.filename === "string" && typeof error.lineno === "number") {
                            message = message + " in ".concat(error.filename, ":").concat(error.lineno);
                        }
                        reject(new Error(message));
                    };
                    var cleanup = function() {
                        clearTimeout(timerId);
                        worker.removeEventListener("message", firstMessageCallback);
                        worker.removeEventListener("error", errorCallback);
                    };
                    worker.addEventListener("error", errorCallback);
                    worker.addEventListener("message", firstMessageCallback);
                    var timerId = setTimeout(function() {
                        cleanup();
                        reject(new Error("Timeout exceeded when waiting for first message from worker."));
                    }, timeout);
                });
            }
        }
    ]);
    return _WorkerLoader;
}();
var WorkerLoader = _WorkerLoader;
__publicField(WorkerLoader, "directlyFallbackToBlobBasedLoading", false);
__publicField(WorkerLoader, "sourceLoaderCache", /* @__PURE__ */ new Map());
__publicField(WorkerLoader, "dependencyUrlMapping", {});
// src/mapview/ConcurrentWorkerSet.ts
var logger7 = LoggerManager.instance.create("ConcurrentWorkerSet");
function isLoggingMessage(message) {
    return message && typeof message.level === "number" && message.type === WORKERCHANNEL_MSG_TYPE;
}
var DEFAULT_WORKER_COUNT = 2;
var DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 1e4;
var ConcurrentWorkerSet = /*#__PURE__*/ function() {
    function ConcurrentWorkerSet(m_options) {
        var _this = this;
        _classCallCheck(this, ConcurrentWorkerSet);
        this.m_options = m_options;
        __publicField(this, "m_workerChannelLogger", LoggerManager.instance.create("WorkerChannel"));
        __publicField(this, "m_eventListeners", /* @__PURE__ */ new Map());
        __publicField(this, "m_workers", new Array());
        __publicField(this, "m_availableWorkers", new Array());
        __publicField(this, "m_workerPromises", new Array());
        __publicField(this, "m_workerCount");
        __publicField(this, "m_readyPromises", /* @__PURE__ */ new Map());
        __publicField(this, "m_requests", /* @__PURE__ */ new Map());
        __publicField(this, "m_workerRequestQueue", []);
        __publicField(this, "m_nextMessageId", 0);
        __publicField(this, "m_stopped", true);
        __publicField(this, "m_referenceCount", 0);
        __publicField(this, "onWorkerMessage", function(workerId, event) {
            if (WorkerServiceProtocol.isResponseMessage(event.data)) {
                var response = event.data;
                if (response.messageId === null) {
                    logger7.error("[".concat(_this.m_options.scriptUrl, "]: Bad ResponseMessage: no messageId"));
                    return;
                }
                var entry = _this.m_requests.get(response.messageId);
                if (entry === void 0) {
                    logger7.error("[".concat(_this.m_options.scriptUrl, "]: Bad ResponseMessage: invalid messageId"));
                    return;
                }
                if (workerId >= 0 && workerId < _this.m_workers.length) {
                    var worker = _this.m_workers[workerId];
                    _this.m_availableWorkers.push(worker);
                    _this.checkWorkerRequestQueue();
                } else {
                    logger7.error("[".concat(_this.m_options.scriptUrl, "]: onWorkerMessage: invalid workerId"));
                }
                if (response.errorMessage !== void 0) {
                    var error = new Error(response.errorMessage);
                    if (response.errorStack !== void 0) {
                        error.stack = response.errorStack;
                    }
                    entry.resolver(error);
                } else {
                    entry.resolver(void 0, response.response);
                }
            } else if (WorkerServiceProtocol.isInitializedMessage(event.data)) {
                var readyPromise = _this.getReadyPromise(event.data.service);
                if (++readyPromise.count === _this.m_workerPromises.length) {
                    readyPromise.resolve();
                }
            } else if (isLoggingMessage(event.data)) {
                switch(event.data.level){
                    case 0 /* Trace */ :
                        var _m_workerChannelLogger;
                        (_m_workerChannelLogger = _this.m_workerChannelLogger).trace.apply(_m_workerChannelLogger, _toConsumableArray(event.data.message));
                        break;
                    case 1 /* Debug */ :
                        var _m_workerChannelLogger1;
                        (_m_workerChannelLogger1 = _this.m_workerChannelLogger).debug.apply(_m_workerChannelLogger1, _toConsumableArray(event.data.message));
                        break;
                    case 2 /* Log */ :
                        var _m_workerChannelLogger2;
                        (_m_workerChannelLogger2 = _this.m_workerChannelLogger).log.apply(_m_workerChannelLogger2, _toConsumableArray(event.data.message));
                        break;
                    case 3 /* Info */ :
                        var _m_workerChannelLogger3;
                        (_m_workerChannelLogger3 = _this.m_workerChannelLogger).info.apply(_m_workerChannelLogger3, _toConsumableArray(event.data.message));
                        break;
                    case 4 /* Warn */ :
                        var _m_workerChannelLogger4;
                        (_m_workerChannelLogger4 = _this.m_workerChannelLogger).warn.apply(_m_workerChannelLogger4, _toConsumableArray(event.data.message));
                        break;
                    case 5 /* Error */ :
                        var _m_workerChannelLogger5;
                        (_m_workerChannelLogger5 = _this.m_workerChannelLogger).error.apply(_m_workerChannelLogger5, _toConsumableArray(event.data.message));
                        break;
                }
            } else {
                _this.eventHandler(event);
            }
        });
        this.start();
    }
    _createClass(ConcurrentWorkerSet, [
        {
            key: "addReference",
            value: function addReference() {
                this.m_referenceCount += 1;
                if (this.m_referenceCount === 1 && this.m_stopped) {
                    this.start();
                }
            }
        },
        {
            key: "removeReference",
            value: function removeReference() {
                this.m_referenceCount -= 1;
                if (this.m_referenceCount === 0) {
                    this.destroy();
                }
            }
        },
        {
            key: "start",
            value: function start(options) {
                var _this = this, _loop = function(workerId) {
                    var workerPromise = WorkerLoader.startWorker(_this.m_options.scriptUrl, timeout).then(function(worker) {
                        var listener = function(evt) {
                            _this1.onWorkerMessage(workerId, evt);
                        };
                        worker.addEventListener("message", listener);
                        _this1.m_workers.push(worker);
                        _this1.m_availableWorkers.push(worker);
                        return {
                            worker: worker,
                            listener: listener
                        };
                    });
                    _this.m_workerPromises.push(workerPromise);
                };
                var _this1 = this;
                if (options !== void 0) {
                    this.m_options = options;
                }
                if (!this.m_stopped) {
                    throw new Error("ConcurrentWorker set already started");
                }
                this.m_workerCount = getOptionValue(this.m_options.workerCount, typeof navigator !== "undefined" && navigator.hardwareConcurrency !== void 0 ? THREE54.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 2) : void 0, DEFAULT_WORKER_COUNT);
                var timeout = getOptionValue(this.m_options.workerConnectionTimeout, DEFAULT_WORKER_INITIALIZATION_TIMEOUT);
                for(var workerId = 0; workerId < this.m_workerCount; ++workerId)_loop(workerId);
                this.m_stopped = false;
            }
        },
        {
            key: "workerCount",
            get: function get() {
                return this.m_workerCount;
            }
        },
        {
            key: "stop",
            value: function stop() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _this.m_stopped = true;
                                _ctx.next = 3;
                                return _this.waitForAllResponses().then(function() {
                                    _this.terminateWorkers();
                                });
                            case 3:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "destroy",
            value: function destroy() {
                this.m_stopped = true;
                this.m_requests.forEach(function(entry) {
                    entry.resolver(new Error("worker destroyed"));
                });
                this.m_requests.clear();
                this.m_workerRequestQueue = [];
                this.terminateWorkers();
                this.m_eventListeners.clear();
            }
        },
        {
            key: "terminated",
            get: function get() {
                return this.m_workers.length === 0;
            }
        },
        {
            key: "connect",
            value: function connect(serviceId) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _this.ensureStarted();
                                _ctx.next = 3;
                                return Promise.all(_this.m_workerPromises);
                            case 3:
                                _ctx.next = 5;
                                return _this.getReadyPromise(serviceId).promise;
                            case 5:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 6:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "addEventListener",
            value: function addEventListener(serviceId, callback) {
                this.m_eventListeners.set(serviceId, callback);
            }
        },
        {
            key: "removeEventListener",
            value: function removeEventListener(serviceId) {
                this.m_eventListeners.delete(serviceId);
            }
        },
        {
            key: "invokeRequest",
            value: function invokeRequest(serviceId, request, transferList, requestController) {
                var _this = this;
                this.ensureStarted();
                var messageId = this.m_nextMessageId++;
                var resolver;
                var promise = new Promise(function(resolve, reject) {
                    resolver = function(error, response) {
                        _this.m_requests.delete(messageId);
                        if (error !== void 0) {
                            reject(error);
                        } else {
                            resolve(response);
                        }
                    };
                });
                this.m_requests.set(messageId, {
                    promise: promise,
                    resolver: resolver
                });
                var message = {
                    service: serviceId,
                    type: WorkerServiceProtocol.ServiceMessageName.Request,
                    messageId: messageId,
                    request: request
                };
                this.postRequestMessage(message, transferList, requestController);
                return promise;
            }
        },
        {
            key: "broadcastRequest",
            value: function broadcastRequest(serviceId, request, transferList) {
                var _this = this;
                var promises = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_workers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var worker = _step.value;
                        var messageId = this.m_nextMessageId++;
                        var resolver = void 0;
                        var promise = new Promise(function(resolve, reject) {
                            resolver = function(error, response) {
                                _this.m_requests.delete(messageId);
                                if (error !== void 0) {
                                    reject(error);
                                } else {
                                    resolve(response);
                                }
                            };
                        });
                        promises.push(promise);
                        this.m_requests.set(messageId, {
                            promise: promise,
                            resolver: resolver
                        });
                        var message = {
                            service: serviceId,
                            type: WorkerServiceProtocol.ServiceMessageName.Request,
                            messageId: messageId,
                            request: request
                        };
                        if (transferList !== void 0) {
                            worker.postMessage(message, transferList);
                        } else {
                            worker.postMessage(message);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return Promise.all(promises);
            }
        },
        {
            key: "broadcastMessage",
            value: function broadcastMessage(message, buffers) {
                this.ensureStarted();
                if (buffers !== void 0) {
                    this.m_workers.forEach(function(worker) {
                        return worker.postMessage(message, buffers);
                    });
                } else {
                    this.m_workers.forEach(function(worker) {
                        return worker.postMessage(message);
                    });
                }
            }
        },
        {
            key: "requestQueueSize",
            get: function get() {
                return this.m_workerRequestQueue.length;
            }
        },
        {
            key: "numWorkers",
            get: function get() {
                return this.m_workers.length;
            }
        },
        {
            key: "numIdleWorkers",
            get: function get() {
                return this.m_availableWorkers.length;
            }
        },
        {
            key: "eventHandler",
            value: function eventHandler(event) {
                if (typeof event.data.type !== "string") {
                    return;
                }
                this.dispatchEvent(event.data.type, event);
            }
        },
        {
            key: "postRequestMessage",
            value: function postRequestMessage(message, buffers, requestController) {
                this.ensureStarted();
                if (this.m_workers.length === 0) {
                    throw new Error("ConcurrentWorkerSet#postMessage: no workers started");
                }
                if (requestController !== void 0 && requestController.signal.aborted) {
                    var entry = this.m_requests.get(message.messageId);
                    if (entry === void 0) {
                        logger7.error("[".concat(this.m_options.scriptUrl, "]: Bad RequestMessage: invalid messageId"));
                        return;
                    }
                    var err = new Error("Aborted");
                    err.name = "AbortError";
                    entry.resolver(err, void 0);
                    return;
                }
                if (this.m_availableWorkers.length > 0) {
                    var worker = this.m_availableWorkers.pop();
                    if (buffers !== void 0) {
                        worker.postMessage(message, buffers);
                    } else {
                        worker.postMessage(message);
                    }
                } else {
                    if (requestController === void 0) {
                        requestController = new RequestController(0);
                    }
                    if (requestController.priority === 0) {
                        requestController.priority = -this.m_nextMessageId;
                    }
                    this.m_workerRequestQueue.unshift({
                        message: message,
                        buffers: buffers,
                        requestController: requestController
                    });
                }
            }
        },
        {
            key: "ensureStarted",
            value: function ensureStarted() {
                if (this.m_stopped) {
                    throw new Error("ConcurrentWorkerSet stopped");
                }
            }
        },
        {
            key: "waitForAllResponses",
            value: function waitForAllResponses() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var promises;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                promises = new Array();
                                _this.m_requests.forEach(function(entry) {
                                    promises.push(entry.promise);
                                });
                                _ctx.next = 4;
                                return Promise.all(promises);
                            case 4:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "dispatchEvent",
            value: function dispatchEvent(id, message) {
                var callback = this.m_eventListeners.get(id);
                if (callback === void 0) {
                    return;
                }
                callback(message);
            }
        },
        {
            key: "terminateWorkers",
            value: function terminateWorkers() {
                this.m_workerPromises.forEach(function(workerPromise) {
                    workerPromise.then(function(workerEntry) {
                        if (workerEntry === void 0) {
                            return;
                        }
                        workerEntry.worker.removeEventListener("message", workerEntry.listener);
                        workerEntry.worker.terminate();
                    });
                });
                this.m_workers = [];
                this.m_workerPromises = [];
                this.m_availableWorkers = [];
                this.m_readyPromises.clear();
            }
        },
        {
            key: "getReadyPromise",
            value: function getReadyPromise(id) {
                var _this = this;
                var readyPromise = this.m_readyPromises.get(id);
                if (readyPromise !== void 0) {
                    return readyPromise;
                }
                var newPromise = {
                    count: 0,
                    promise: void 0,
                    resolve: function() {},
                    reject: function(error) {
                        newPromise.error = error;
                    },
                    error: void 0
                };
                newPromise.promise = new Promise(function(resolve, reject) {
                    var that = newPromise;
                    if (that.error !== void 0) {
                        reject(that.error);
                    } else if (that.count === _this.m_workerPromises.length) {
                        resolve();
                    }
                    that.resolve = resolve;
                    that.reject = reject;
                });
                this.m_readyPromises.set(id, newPromise);
                return newPromise;
            }
        },
        {
            key: "checkWorkerRequestQueue",
            value: function checkWorkerRequestQueue() {
                if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {
                    return;
                }
                this.m_workerRequestQueue.sort(function(a, b) {
                    return a.requestController.priority - b.requestController.priority;
                });
                while(this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0){
                    var request = this.m_workerRequestQueue.pop();
                    this.postRequestMessage(request.message, request.buffers, request.requestController);
                }
            }
        }
    ]);
    return ConcurrentWorkerSet;
}();
// src/mapview/WorkerBasedDecoder.ts
var nextUniqueServiceId = 0;
var WorkerBasedDecoder = /*#__PURE__*/ function() {
    function WorkerBasedDecoder(workerSet, decoderServiceType) {
        _classCallCheck(this, WorkerBasedDecoder);
        this.workerSet = workerSet;
        this.decoderServiceType = decoderServiceType;
        __publicField(this, "serviceId");
        __publicField(this, "m_serviceCreated", false);
        this.workerSet.addReference();
        this.serviceId = "".concat(this.decoderServiceType, "-").concat(nextUniqueServiceId++);
    }
    _createClass(WorkerBasedDecoder, [
        {
            key: "dispose",
            value: function dispose() {
                if (this.m_serviceCreated) {
                    this.workerSet.broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                        type: WorkerServiceProtocol.Requests.DestroyService,
                        targetServiceId: this.serviceId
                    }).catch(function() {});
                }
                this.workerSet.removeReference();
            }
        },
        {
            key: "connect",
            value: function connect() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return _this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
                            case 2:
                                if (_this.m_serviceCreated) {
                                    _ctx.next = 6;
                                    break;
                                }
                                _ctx.next = 5;
                                return _this.workerSet.broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                                    type: WorkerServiceProtocol.Requests.CreateService,
                                    targetServiceType: _this.decoderServiceType,
                                    targetServiceId: _this.serviceId
                                });
                            case 5:
                                _this.m_serviceCreated = true;
                            case 6:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "decodeTile",
            value: function decodeTile(data2, tileKey, projection, requestController) {
                var tileKeyCode = tileKey.mortonCode();
                var message = {
                    type: WorkerDecoderProtocol.Requests.DecodeTileRequest,
                    tileKey: tileKeyCode,
                    data: data2,
                    projection: getProjectionName(projection)
                };
                var transferList = _instanceof(data2, ArrayBuffer) ? [
                    data2
                ] : void 0;
                return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
            }
        },
        {
            key: "getTileInfo",
            value: function getTileInfo(data2, tileKey, projection, requestController) {
                var tileKeyCode = tileKey.mortonCode();
                var message = {
                    type: WorkerDecoderProtocol.Requests.TileInfoRequest,
                    tileKey: tileKeyCode,
                    data: data2,
                    projection: getProjectionName(projection)
                };
                var transferList = _instanceof(data2, ArrayBuffer) ? [
                    data2
                ] : void 0;
                return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
            }
        },
        {
            key: "configure",
            value: function configure(options, customOptions) {
                var message = _objectSpreadProps(_objectSpread({
                    service: this.serviceId,
                    type: WorkerDecoderProtocol.DecoderMessageName.Configuration
                }, options), {
                    options: customOptions
                });
                this.workerSet.broadcastMessage(message);
            }
        },
        {
            key: "workerCount",
            get: function get() {
                return this.workerSet.workerCount;
            }
        }
    ]);
    return WorkerBasedDecoder;
}();
// src/mapview/ConcurrentDecoderFacade.ts
var _ConcurrentDecoderFacade = /*#__PURE__*/ function() {
    function _ConcurrentDecoderFacade() {
        _classCallCheck(this, _ConcurrentDecoderFacade);
    }
    _createClass(_ConcurrentDecoderFacade, null, [
        {
            key: "getTileDecoder",
            value: function getTileDecoder(decoderServiceType, scriptUrl, workerCount, workerConnectionTimeout) {
                var workerSet = this.getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout);
                return new WorkerBasedDecoder(workerSet, decoderServiceType);
            }
        },
        {
            key: "getWorkerSet",
            value: function getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout) {
                if (scriptUrl === void 0) {
                    scriptUrl = this.defaultScriptUrl;
                }
                var workerSet = this.workerSets[scriptUrl];
                if (workerSet === void 0) {
                    var workerConnectionTimeoutInMs = workerConnectionTimeout !== void 0 ? workerConnectionTimeout * 1e3 : void 0;
                    workerSet = new ConcurrentWorkerSet({
                        scriptUrl: scriptUrl,
                        workerCount: workerCount !== null && workerCount !== void 0 ? workerCount : this.defaultWorkerCount,
                        workerConnectionTimeout: workerConnectionTimeoutInMs
                    });
                    this.workerSets[scriptUrl] = workerSet;
                }
                return workerSet;
            }
        },
        {
            key: "destroyWorkerSet",
            value: function destroyWorkerSet(scriptUrl) {
                var workerSet = this.workerSets[scriptUrl];
                if (workerSet !== void 0) {
                    workerSet.destroy();
                    delete this.workerSets[scriptUrl];
                }
            }
        },
        {
            key: "destroy",
            value: function destroy() {
                var _this = this;
                Object.keys(this.workerSets).forEach(function(name2) {
                    _this.workerSets[name2].destroy();
                });
                this.workerSets = {};
            }
        },
        {
            key: "destroyIfTerminated",
            value: function destroyIfTerminated() {
                var _this = this;
                var allWorkerSetsTerminated = true;
                Object.keys(this.workerSets).forEach(function(name2) {
                    if (!_this.workerSets[name2].terminated) {
                        allWorkerSetsTerminated = false;
                    }
                });
                if (allWorkerSetsTerminated) {
                    _ConcurrentDecoderFacade.destroy();
                }
            }
        }
    ]);
    return _ConcurrentDecoderFacade;
}();
var ConcurrentDecoderFacade = _ConcurrentDecoderFacade;
__publicField(ConcurrentDecoderFacade, "defaultScriptUrl", "./decoder.bundle.js");
__publicField(ConcurrentDecoderFacade, "defaultWorkerCount");
__publicField(ConcurrentDecoderFacade, "workerSets", {});
// src/mapview/copyrights/CopyrightInfo.ts
var CopyrightInfo;
(function(CopyrightInfo2) {
    var mergeArrays = function mergeArrays(a, b) {
        var result = [];
        for(var _i = 0, _iter = [
            a,
            b
        ]; _i < _iter.length; _i++){
            var source = _iter[_i];
            if (source === void 0) {
                continue;
            }
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                var _loop = function(_iterator, _step) {
                    var sourceInfo = _step.value;
                    var existingInfo = result.find(function(findItem) {
                        return findItem.id === sourceInfo.id || findItem.label !== void 0 && findItem.label === sourceInfo.label;
                    });
                    if (existingInfo === void 0) {
                        result.push(_objectSpread({}, sourceInfo));
                    } else {
                        existingInfo.year = MathUtils.max2(sourceInfo.year, existingInfo.year);
                        existingInfo.label = getOptionValue(sourceInfo.label, existingInfo.label);
                        existingInfo.link = getOptionValue(sourceInfo.link, existingInfo.link);
                    }
                };
                for(var _iterator = source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
        return result;
    };
    var formatAsHtml = function formatAsHtml(copyrightInfo) {
        if (copyrightInfo.length === 0) {
            return "";
        }
        var filtered = copyrightInfo.filter(function(entry) {
            return entry.label !== "";
        });
        if (filtered.length === 0) {
            return "";
        }
        return "\xa9 " + filtered.map(function(entry) {
            var _label;
            var label = (_label = entry.label) !== null && _label !== void 0 ? _label : entry.id;
            var text = entry.year !== void 0 ? "".concat(entry.year, " ").concat(label) : label;
            var link = entry.link;
            return link ? '<a href="'.concat(link, '" target="_blank" rel="noreferrer noopener">').concat(text, "</a>") : "".concat(text);
        }).join(", ");
    };
    CopyrightInfo2.mergeArrays = mergeArrays;
    CopyrightInfo2.formatAsHtml = formatAsHtml;
})(CopyrightInfo || (CopyrightInfo = {}));
// src/mapview/EventDispatcher.ts
var EventDispatcher = /*#__PURE__*/ function() {
    function EventDispatcher() {
        _classCallCheck(this, EventDispatcher);
        __publicField(this, "m_listeners", /* @__PURE__ */ new Map());
    }
    _createClass(EventDispatcher, [
        {
            key: "dispose",
            value: function dispose() {
                this.removeAllEventListeners();
            }
        },
        {
            key: "hasEventListener",
            value: function hasEventListener(type, listener) {
                var listeners = this.m_listeners.get(type);
                if (listeners === void 0) {
                    return false;
                }
                return listener !== void 0 ? listeners.includes(listener) : true;
            }
        },
        {
            key: "addEventListener",
            value: function addEventListener(type, listener) {
                var listeners = this.m_listeners.get(type);
                if (listeners === void 0) {
                    listeners = [];
                    this.m_listeners.set(type, listeners);
                }
                if (!listeners.includes(listener)) {
                    listeners.push(listener);
                }
            }
        },
        {
            key: "removeEventListener",
            value: function removeEventListener(type, listener) {
                var listeners = this.m_listeners.get(type);
                if (listeners === void 0) {
                    return;
                }
                if (listener === void 0) {
                    this.m_listeners.delete(type);
                } else {
                    var index = listeners.indexOf(listener);
                    if (index !== -1) {
                        listeners.splice(index, 1);
                        if (listeners.length === 0) {
                            this.m_listeners.delete(type);
                        }
                    }
                }
            }
        },
        {
            key: "removeAllEventListeners",
            value: function removeAllEventListeners() {
                var events = Array.from(this.m_listeners.keys());
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var event = _step.value;
                        this.removeEventListener(event);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "eventTypes",
            get: function get() {
                return Array.from(this.m_listeners.keys());
            }
        },
        {
            key: "listeners",
            value: function listeners(type) {
                return this.m_listeners.get(type);
            }
        },
        {
            key: "dispatchEvent",
            value: function dispatchEvent(event) {
                var listeners = this.m_listeners.get(event.type);
                if (listeners !== void 0) {
                    event.target = this;
                    var array = listeners.slice(0);
                    for(var i = 0, l = array.length; i < l; i++){
                        array[i].call(this, event);
                    }
                }
            }
        }
    ]);
    return EventDispatcher;
}();
// src/mapview/FrustumIntersection.ts
var THREE56 = __toESM(require("three"));
// src/mapview/ElevationRangeSource.ts
var CalculationStatus = /* @__PURE__ */ function(CalculationStatus2) {
    CalculationStatus2[CalculationStatus2["PendingApproximate"] = 0] = "PendingApproximate";
    CalculationStatus2[CalculationStatus2["FinalPrecise"] = 1] = "FinalPrecise";
    return CalculationStatus2;
}(CalculationStatus || {});
// src/mapview/MapTileCuller.ts
var THREE55 = __toESM(require("three"));
var MapTileCuller = /*#__PURE__*/ function() {
    function MapTileCuller(m_camera) {
        _classCallCheck(this, MapTileCuller);
        this.m_camera = m_camera;
        __publicField(this, "m_globalFrustumMin", new THREE55.Vector3());
        __publicField(this, "m_globalFrustumMax", new THREE55.Vector3());
        __publicField(this, "m_frustumCorners", [
            new THREE55.Vector3(),
            new THREE55.Vector3(),
            new THREE55.Vector3(),
            new THREE55.Vector3(),
            new THREE55.Vector3(),
            new THREE55.Vector3(),
            new THREE55.Vector3(),
            new THREE55.Vector3()
        ]);
    }
    _createClass(MapTileCuller, [
        {
            key: "setup",
            value: function setup() {
                var frustumCorners = this.getFrustumCorners();
                var matrix = this.m_camera.matrixWorld;
                this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = frustumCorners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var frustumCorner = _step.value;
                        frustumCorner.applyMatrix4(matrix);
                        this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);
                        this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);
                        this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);
                        this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);
                        this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);
                        this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "frustumIntersectsTileBox",
            value: function frustumIntersectsTileBox(tileBounds) {
                var globalFrustumMin = this.m_globalFrustumMin;
                var globalFrustumMax = this.m_globalFrustumMax;
                if (globalFrustumMax.x < tileBounds.min.x || globalFrustumMax.y < tileBounds.min.y || globalFrustumMax.z < tileBounds.min.z || globalFrustumMin.x > tileBounds.max.x || globalFrustumMin.y > tileBounds.max.y || globalFrustumMin.z > tileBounds.max.z) {
                    return false;
                }
                return true;
            }
        },
        {
            key: "getFrustumCorners",
            value: function getFrustumCorners() {
                var addPoint = function addPoint(x, y, z) {
                    frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);
                };
                var frustumCorners = this.m_frustumCorners;
                var invProjMatrix = this.m_camera.projectionMatrixInverse;
                var cornerIndex = 0;
                var w = 1;
                var h = 1;
                var n = -1;
                var f = 1;
                addPoint(-w, -h, n);
                addPoint(w, -h, n);
                addPoint(-w, h, n);
                addPoint(w, h, n);
                addPoint(-w, -h, f);
                addPoint(w, -h, f);
                addPoint(-w, h, f);
                addPoint(w, h, f);
                return frustumCorners;
            }
        }
    ]);
    return MapTileCuller;
}();
// src/mapview/FrustumIntersection.ts
var tmpVectors3 = [
    new THREE56.Vector3(),
    new THREE56.Vector3()
];
var tmpVector4 = new THREE56.Vector4();
var TileKeyEntry = function TileKeyEntry(tileKey, area) {
    var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, elevationRange = arguments.length > 3 ? arguments[3] : void 0, distance = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    _classCallCheck(this, TileKeyEntry);
    this.tileKey = tileKey;
    this.area = area;
    this.offset = offset;
    this.elevationRange = elevationRange;
    this.distance = distance;
};
function getGeoBox(tilingScheme, childTileKey, offset) {
    var geoBox = tilingScheme.getGeoBox(childTileKey);
    var longitudeOffset = 360 * offset;
    geoBox.northEast.longitude += longitudeOffset;
    geoBox.southWest.longitude += longitudeOffset;
    return geoBox;
}
var FrustumIntersection = /*#__PURE__*/ function() {
    function FrustumIntersection(m_camera, mapView, m_extendedFrustumCulling, m_tileWrappingEnabled, m_enableMixedLod) {
        var m_tilePixelSize = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 256;
        _classCallCheck(this, FrustumIntersection);
        this.m_camera = m_camera;
        this.mapView = mapView;
        this.m_extendedFrustumCulling = m_extendedFrustumCulling;
        this.m_tileWrappingEnabled = m_tileWrappingEnabled;
        this.m_enableMixedLod = m_enableMixedLod;
        this.m_tilePixelSize = m_tilePixelSize;
        __publicField(this, "m_frustum", new THREE56.Frustum());
        __publicField(this, "m_viewProjectionMatrix", new THREE56.Matrix4());
        __publicField(this, "m_mapTileCuller");
        __publicField(this, "m_rootTileKeys", []);
        __publicField(this, "m_tileKeyEntries", /* @__PURE__ */ new Map());
        this.m_mapTileCuller = new MapTileCuller(m_camera);
    }
    _createClass(FrustumIntersection, [
        {
            key: "camera",
            get: function get() {
                return this.m_camera;
            }
        },
        {
            key: "projection",
            get: function get() {
                return this.mapView.projection;
            }
        },
        {
            key: "updateFrustum",
            value: function updateFrustum(projectionMatrixOverride) {
                this.m_viewProjectionMatrix.multiplyMatrices(projectionMatrixOverride !== void 0 ? projectionMatrixOverride : this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);
                this.m_frustum.setFromProjectionMatrix(this.m_viewProjectionMatrix);
                if (this.m_extendedFrustumCulling) {
                    this.m_mapTileCuller.setup();
                }
                this.computeRequiredInitialRootTileKeys(this.m_camera.position);
            }
        },
        {
            key: "compute",
            value: function compute(tilingScheme, elevationRangeSource, zoomLevels, dataSources) {
                this.m_tileKeyEntries.clear();
                assert(this.mapView.viewportHeight !== 0);
                var targetTileArea = Math.pow(this.m_tilePixelSize / this.mapView.viewportHeight, 2);
                var useElevationRangeSource = elevationRangeSource !== void 0 && elevationRangeSource.getTilingScheme() === tilingScheme;
                var obbIntersections = this.mapView.projection.type === 1 /* Spherical */  || useElevationRangeSource;
                var uniqueZoomLevels = new Set(zoomLevels);
                var minGeometryHeight = 0;
                var maxGeometryHeight = 0;
                dataSources.forEach(function(dataSource) {
                    minGeometryHeight = Math.min(minGeometryHeight, dataSource.minGeometryHeight);
                    maxGeometryHeight = Math.max(maxGeometryHeight, dataSource.maxGeometryHeight);
                });
                var cache6 = {
                    calculationFinal: true,
                    tileBounds: obbIntersections ? new OrientedBox3() : new THREE56.Box3()
                };
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = uniqueZoomLevels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var zoomLevel = _step.value;
                        this.m_tileKeyEntries.set(zoomLevel, /* @__PURE__ */ new Map());
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = this.m_rootTileKeys[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var tileEntry = _step1.value;
                        var tileKey = tileEntry.tileKey;
                        var offset = tileEntry.offset;
                        var tileKeyEntry = this.getTileKeyEntry(tileKey, offset, tilingScheme, cache6, minGeometryHeight, maxGeometryHeight, useElevationRangeSource ? elevationRangeSource : void 0);
                        if (tileKeyEntry !== void 0) {
                            var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                            try {
                                for(var _iterator2 = uniqueZoomLevels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                                    var zoomLevel1 = _step2.value;
                                    var tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel1);
                                    tileKeyEntries.set(TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset), tileKeyEntry);
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                        _iterator2.return();
                                    }
                                } finally{
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                var workList = _toConsumableArray(this.m_rootTileKeys.values());
                while(workList.length > 0){
                    var tileEntry1 = workList.pop();
                    if (tileEntry1 === void 0) {
                        break;
                    }
                    var tileKey1 = tileEntry1.tileKey;
                    var offset1 = tileEntry1.offset;
                    var subdivide = dataSources.some(function(ds, i) {
                        return ds.shouldSubdivide(zoomLevels[i], tileKey1);
                    });
                    if (!subdivide) {
                        continue;
                    }
                    if (this.m_enableMixedLod && tileEntry1.area < targetTileArea) {
                        continue;
                    }
                    var tileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset(tileKey1, offset1);
                    var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
                    try {
                        for(var _iterator3 = uniqueZoomLevels[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                            var zoomLevel2 = _step3.value;
                            if (tileKey1.level >= zoomLevel2) {
                                continue;
                            }
                            var tileKeyEntries1 = this.m_tileKeyEntries.get(zoomLevel2);
                            tileKeyEntries1.delete(tileKeyAndOffset);
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                                _iterator3.return();
                            }
                        } finally{
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                    var _iteratorNormalCompletion4 = true, _didIteratorError4 = false, _iteratorError4 = undefined;
                    try {
                        for(var _iterator4 = tilingScheme.getSubTileKeys(tileKey1)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true){
                            var subTileKey = _step4.value;
                            var subTileEntry = this.getTileKeyEntry(subTileKey, offset1, tilingScheme, cache6, minGeometryHeight, maxGeometryHeight, useElevationRangeSource ? elevationRangeSource : void 0);
                            if (subTileEntry !== void 0) {
                                var _iteratorNormalCompletion5 = true, _didIteratorError5 = false, _iteratorError5 = undefined;
                                try {
                                    for(var _iterator5 = uniqueZoomLevels[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true){
                                        var zoomLevel3 = _step5.value;
                                        if (subTileEntry.tileKey.level > zoomLevel3) {
                                            continue;
                                        }
                                        var subTileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset(subTileKey, offset1);
                                        this.m_tileKeyEntries.get(zoomLevel3).set(subTileKeyAndOffset, subTileEntry);
                                    }
                                } catch (err) {
                                    _didIteratorError5 = true;
                                    _iteratorError5 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                                            _iterator5.return();
                                        }
                                    } finally{
                                        if (_didIteratorError5) {
                                            throw _iteratorError5;
                                        }
                                    }
                                }
                                workList.push(subTileEntry);
                            }
                        }
                    } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                                _iterator4.return();
                            }
                        } finally{
                            if (_didIteratorError4) {
                                throw _iteratorError4;
                            }
                        }
                    }
                }
                return {
                    tileKeyEntries: this.m_tileKeyEntries,
                    calculationFinal: cache6.calculationFinal
                };
            }
        },
        {
            key: "getTileKeyEntry",
            value: function getTileKeyEntry(tileKey, offset, tilingScheme, cache6, minGeometryHeight, maxGeometryHeight, elevationRangeSource) {
                var geoBox = getGeoBox(tilingScheme, tileKey, offset);
                if (elevationRangeSource !== void 0) {
                    var range = elevationRangeSource.getElevationRange(tileKey);
                    geoBox.southWest.altitude = range.minElevation;
                    geoBox.northEast.altitude = range.maxElevation;
                    cache6.calculationFinal = cache6.calculationFinal && range.calculationStatus === 1 /* FinalPrecise */ ;
                }
                var _altitude;
                geoBox.southWest.altitude = ((_altitude = geoBox.southWest.altitude) !== null && _altitude !== void 0 ? _altitude : 0) + minGeometryHeight;
                var _altitude1;
                geoBox.northEast.altitude = ((_altitude1 = geoBox.northEast.altitude) !== null && _altitude1 !== void 0 ? _altitude1 : 0) + maxGeometryHeight;
                this.mapView.projection.projectBox(geoBox, cache6.tileBounds);
                var ref = this.computeTileAreaAndDistance(cache6.tileBounds), area = ref.area, distance = ref.distance;
                if (area > 0) {
                    return new TileKeyEntry(tileKey, area, offset, {
                        minElevation: geoBox.southWest.altitude,
                        maxElevation: geoBox.northEast.altitude
                    }, distance);
                }
                return void 0;
            }
        },
        {
            key: "computeTileAreaAndDistance",
            value: function computeTileAreaAndDistance(tileBounds) {
                if (_instanceof(tileBounds, THREE56.Box3)) {
                    if (this.m_extendedFrustumCulling && !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds) || !this.m_frustum.intersectsBox(tileBounds)) {
                        return {
                            area: 0,
                            distance: Infinity
                        };
                    }
                } else if (!tileBounds.intersects(this.m_frustum)) {
                    return {
                        area: 0,
                        distance: Infinity
                    };
                }
                var center = tileBounds.getCenter(tmpVectors3[0]);
                var projectedPoint = tmpVector4.set(center.x, center.y, center.z, 1).applyMatrix4(this.m_viewProjectionMatrix);
                var size = tileBounds.getSize(tmpVectors3[1]);
                var objectSize = 0.5 * size.length() / projectedPoint.w;
                return {
                    area: objectSize * objectSize,
                    distance: projectedPoint.z <= -projectedPoint.w ? -1 : projectedPoint.z >= projectedPoint.w ? 1 : projectedPoint.z / projectedPoint.w
                };
            }
        },
        {
            key: "computeRequiredInitialRootTileKeys",
            value: function computeRequiredInitialRootTileKeys(worldCenter) {
                this.m_rootTileKeys = [];
                var rootTileKey = TileKey.fromRowColumnLevel(0, 0, 0);
                var tileWrappingEnabled = this.mapView.projection.type === 0 /* Planar */ ;
                if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {
                    this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0));
                    return;
                }
                var worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);
                var startOffset = Math.round(worldGeoPoint.longitude / 360);
                var camera = this.m_camera;
                var cameraPitch = MapViewUtils.extractAttitude(this.mapView, camera).pitch;
                var aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
                var totalAngleRad = THREE56.MathUtils.degToRad(camera.fov * aspect / 2) + cameraPitch;
                var worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;
                var worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;
                var worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;
                var worldLeftPoint = new THREE56.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);
                var worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);
                var offsetRange = THREE56.MathUtils.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, 7);
                for(var offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++){
                    this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset));
                }
            }
        }
    ]);
    return FrustumIntersection;
}();
// src/mapview/geometry/TileGeometryManager.ts
var TileGeometryManager = /*#__PURE__*/ function() {
    function TileGeometryManager(mapView) {
        _classCallCheck(this, TileGeometryManager);
        this.mapView = mapView;
        __publicField(this, "enableFilterByKind", true);
        __publicField(this, "enabledKinds", new GeometryKindSet());
        __publicField(this, "disabledKinds", new GeometryKindSet());
        __publicField(this, "hiddenKinds", new GeometryKindSet());
        __publicField(this, "m_tileUpdateCallback");
        __publicField(this, "m_visibilityCounter", 1);
    }
    _createClass(TileGeometryManager, [
        {
            key: "enabledGeometryKinds",
            get: function get() {
                return this.enabledKinds;
            },
            set: function set(kinds) {
                this.enabledKinds = kinds;
            }
        },
        {
            key: "disabledGeometryKinds",
            get: function get() {
                return this.disabledKinds;
            },
            set: function set(kinds) {
                this.disabledKinds = kinds;
            }
        },
        {
            key: "hiddenGeometryKinds",
            get: function get() {
                return this.hiddenKinds;
            },
            set: function set(kinds) {
                this.hiddenKinds = kinds;
                this.incrementVisibilityCounter();
            }
        },
        {
            key: "visibilityCounter",
            get: function get() {
                return this.m_visibilityCounter;
            }
        },
        {
            key: "updateTiles",
            value: function updateTiles(tiles) {
                var prio = 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = tiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var tile = _step.value;
                        var tilePriority = prio++;
                        var updateDone = tile.updateGeometry(tilePriority, this.enableFilterByKind ? this.enabledGeometryKinds : void 0, this.enableFilterByKind ? this.disabledGeometryKinds : void 0);
                        if (updateDone && this.m_tileUpdateCallback) {
                            this.m_tileUpdateCallback(tile);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (this.updateTileObjectVisibility(tiles)) {
                    this.mapView.update();
                }
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.enabledKinds.clear();
                this.disabledKinds.clear();
                this.hiddenKinds.clear();
            }
        },
        {
            key: "enableKind",
            value: function enableKind(kind) {
                var addOrRemoveToEnabledSet = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);
            }
        },
        {
            key: "disableKind",
            value: function disableKind(kind) {
                var addOrRemoveToDisabledSet = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);
            }
        },
        {
            key: "hideKind",
            value: function hideKind(kind) {
                var addOrRemoveToHiddenSet = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                var visibilityHasChanged = false;
                if (Array.isArray(kind) || _instanceof(kind, Set)) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = kind[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var oneKind = _step.value;
                            var visibilityChange = this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);
                            visibilityHasChanged = visibilityHasChanged || visibilityChange;
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else {
                    visibilityHasChanged = this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);
                }
                if (visibilityHasChanged) {
                    this.incrementVisibilityCounter();
                }
            }
        },
        {
            key: "getAvailableKinds",
            value: function getAvailableKinds(tiles) {
                var visibleKinds = new GeometryKindSet();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = tiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var tile = _step.value;
                        var tileKinds = tile.loadedGeometryKinds;
                        if (tileKinds !== void 0) {
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = tileKinds[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var kind = _step1.value;
                                    visibleKinds.add(kind);
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return visibleKinds;
            }
        },
        {
            key: "updateTileObjectVisibility",
            value: function updateTileObjectVisibility(tiles) {
                var _this = this;
                var needUpdate = false;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = tiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var tile = _step.value;
                        if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {
                            continue;
                        }
                        tile.visibilityCounter = this.visibilityCounter;
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = tile.objects[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var object = _step1.value;
                                var objectAdapter = MapObjectAdapter.get(object);
                                var geometryKind = objectAdapter === null || objectAdapter === void 0 ? void 0 : objectAdapter.kind;
                                if (geometryKind !== void 0) {
                                    var nowVisible = !geometryKind.some(function(kind) {
                                        return _this.hiddenKinds.has(kind);
                                    });
                                    needUpdate = needUpdate || object.visible !== nowVisible;
                                    object.visible = nowVisible;
                                }
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return needUpdate;
            }
        },
        {
            key: "setTileUpdateCallback",
            value: function setTileUpdateCallback(callback) {
                this.m_tileUpdateCallback = callback;
            }
        },
        {
            key: "incrementVisibilityCounter",
            value: function incrementVisibilityCounter() {
                return ++this.m_visibilityCounter;
            }
        },
        {
            key: "enableDisableKinds",
            value: function enableDisableKinds(set, kind, addToSet) {
                if (Array.isArray(kind)) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = kind[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var oneKind = _step.value;
                            this.addRemove(set, oneKind, addToSet);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else if (_instanceof(kind, Set)) {
                    var kindSet = kind;
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = kindSet[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var oneKind1 = _step1.value;
                            this.addRemove(set, oneKind1, addToSet);
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                } else if (kind !== void 0) {
                    this.addRemove(set, kind, addToSet);
                }
            }
        },
        {
            key: "addRemove",
            value: function addRemove(kindsSet, kind, addToSet) {
                if (addToSet) {
                    if (!kindsSet.has(kind)) {
                        kindsSet.add(kind);
                        return true;
                    }
                } else {
                    if (kindsSet.has(kind)) {
                        kindsSet.delete(kind);
                        return true;
                    }
                }
                return false;
            }
        }
    ]);
    return TileGeometryManager;
}();
// src/mapview/image/Image.ts
var THREE58 = __toESM(require("three"));
// src/mapview/image/MipMapGenerator.ts
var THREE57 = __toESM(require("three"));
var isNode = true;
var MipMapGenerator = /*#__PURE__*/ function() {
    function MipMapGenerator() {
        _classCallCheck(this, MipMapGenerator);
        __publicField(this, "m_paddingCanvas");
        __publicField(this, "m_paddingContext");
        __publicField(this, "m_resizeCanvas");
        __publicField(this, "m_resizeContext");
        if (!isNode) {
            this.m_paddingCanvas = document.createElement("canvas");
            this.m_paddingContext = this.m_paddingCanvas.getContext("2d");
            this.m_resizeCanvas = document.createElement("canvas");
            this.m_resizeContext = this.m_resizeCanvas.getContext("2d");
        }
    }
    _createClass(MipMapGenerator, [
        {
            key: "generateTextureAtlasMipMap",
            value: function generateTextureAtlasMipMap(image) {
                if (isNode) {
                    throw new Error("MipMapGenerator only works in browser.");
                }
                if (image.image === void 0) {
                    throw new Error("Can not generate mip maps. Image data not loaded!");
                }
                var imageData = image.image;
                var mipMaps = [];
                var ref = MipMapGenerator.getPaddedSize(imageData.width, imageData.height), paddedWidth = ref.width, paddedHeight = ref.height;
                this.copyImageWithPadding(imageData, paddedWidth, paddedHeight);
                mipMaps.push(this.m_paddingContext.getImageData(0, 0, paddedWidth, paddedHeight));
                var width = paddedWidth * 0.5;
                var height = paddedHeight * 0.5;
                while(width >= 1 || height >= 1){
                    var mipMapLevel = mipMaps.length;
                    var previousImage = mipMaps[mipMapLevel - 1];
                    mipMaps.push(this.resizeImage(previousImage, Math.max(width, 1), Math.max(height, 1)));
                    width *= 0.5;
                    height *= 0.5;
                }
                return mipMaps;
            }
        },
        {
            key: "copyImageWithPadding",
            value: function copyImageWithPadding(image, width, height) {
                this.m_paddingCanvas.width = width;
                this.m_paddingCanvas.height = height;
                this.m_paddingContext.clearRect(0, 0, width, height);
                if (_instanceof(image, ImageData)) {
                    this.m_paddingContext.putImageData(image, 0, 0);
                } else {
                    this.m_paddingContext.drawImage(image, 0, 0);
                }
                if (image.width !== width) {
                    this.m_paddingContext.drawImage(this.m_paddingCanvas, image.width - 1, 0, 1, image.height, image.width, 0, width - image.width, image.height);
                }
                if (image.height !== height) {
                    this.m_paddingContext.drawImage(this.m_paddingCanvas, 0, image.height - 1, width, 1, 0, image.height, width, height - image.height);
                }
                return this.m_paddingCanvas;
            }
        },
        {
            key: "resizeImage",
            value: function resizeImage(image, width, height) {
                var paddedImage = this.copyImageWithPadding(image, image.width, image.height);
                this.m_resizeCanvas.width = width;
                this.m_resizeCanvas.height = height;
                this.m_resizeContext.clearRect(0, 0, width, height);
                this.m_resizeContext.drawImage(paddedImage, 0, 0, width, height);
                return this.m_resizeContext.getImageData(0, 0, width, height);
            }
        }
    ], [
        {
            key: "getPaddedSize",
            value: function getPaddedSize(width, height) {
                return {
                    width: THREE57.MathUtils.ceilPowerOfTwo(width),
                    height: THREE57.MathUtils.ceilPowerOfTwo(height)
                };
            }
        }
    ]);
    return MipMapGenerator;
}();
// src/mapview/image/Image.ts
var logger8 = LoggerManager.instance.create("loadImage");
var mipMapGenerator = new MipMapGenerator();
var ImageItem = /*#__PURE__*/ function() {
    function ImageItem(url, image) {
        _classCallCheck(this, ImageItem);
        this.url = url;
        this.image = image;
        __publicField(this, "mipMaps");
        __publicField(this, "cancelled");
        __publicField(this, "loadingPromise");
    }
    _createClass(ImageItem, [
        {
            key: "loaded",
            get: function get() {
                return this.image !== void 0 && this.mipMaps !== void 0;
            }
        },
        {
            key: "loading",
            get: function get() {
                return this.loadingPromise !== void 0;
            }
        },
        {
            key: "loadImage",
            value: function loadImage() {
                var _this = this;
                if (this.loaded) {
                    return Promise.resolve(this);
                }
                if (this.loading) {
                    return this.loadingPromise;
                }
                this.loadingPromise = new Promise(function(resolve, reject) {
                    if (_this.image) {
                        var image = _this.image;
                        if (_instanceof(image, HTMLImageElement) && !image.complete) {
                            image.addEventListener("load", _this.finalizeImage.bind(_this, image, resolve));
                            image.addEventListener("error", reject);
                        } else {
                            _this.finalizeImage(_this.image, resolve);
                        }
                        return;
                    }
                    logger8.debug("Loading image: ".concat(_this.url));
                    if (_this.cancelled === true) {
                        logger8.debug("Cancelled loading image: ".concat(_this.url));
                        resolve(void 0);
                    } else {
                        new THREE58.ImageLoader().load(_this.url, function(image) {
                            if (_this.cancelled === true) {
                                logger8.debug("Cancelled loading image: ".concat(_this.url));
                                resolve(void 0);
                                return;
                            }
                            _this.finalizeImage(image, resolve);
                        }, void 0, function(errorEvent) {
                            logger8.error("... loading image failed: ".concat(_this.url, " : ").concat(errorEvent));
                            _this.loadingPromise = void 0;
                            reject("... loading image failed: ".concat(_this.url, " : ").concat(errorEvent));
                        });
                    }
                });
                return this.loadingPromise;
            }
        },
        {
            key: "finalizeImage",
            value: function finalizeImage(image, resolve) {
                this.image = image;
                this.mipMaps = mipMapGenerator.generateTextureAtlasMipMap(this);
                this.loadingPromise = void 0;
                resolve(this);
            }
        }
    ]);
    return ImageItem;
}();
// src/mapview/image/ImageCache.ts
var _ImageCache = /*#__PURE__*/ function() {
    function _ImageCache() {
        _classCallCheck(this, _ImageCache);
        __publicField(this, "m_images", /* @__PURE__ */ new Map());
    }
    _createClass(_ImageCache, [
        {
            key: "registerImage",
            value: function registerImage(owner, url, image) {
                var imageCacheItem = this.findImageCacheItem(url);
                if (imageCacheItem) {
                    if (owner !== void 0 && !imageCacheItem.owners.includes(owner)) {
                        imageCacheItem.owners.push(owner);
                    }
                    return imageCacheItem.imageItem;
                }
                imageCacheItem = {
                    imageItem: new ImageItem(url, image),
                    owners: [
                        owner
                    ]
                };
                this.m_images.set(url, imageCacheItem);
                return imageCacheItem.imageItem;
            }
        },
        {
            key: "removeImage",
            value: function removeImage(url, owner) {
                var cacheItem = this.m_images.get(url);
                if (cacheItem !== void 0) {
                    this.unlinkCacheItem(cacheItem, owner);
                    return true;
                }
                return false;
            }
        },
        {
            key: "findImage",
            value: function findImage(url) {
                var cacheItem = this.m_images.get(url);
                if (cacheItem !== void 0) {
                    return cacheItem.imageItem;
                }
                return void 0;
            }
        },
        {
            key: "clear",
            value: function clear(owner) {
                var _this = this;
                this.m_images.forEach(function(cacheItem) {
                    _this.unlinkCacheItem(cacheItem, owner);
                });
            }
        },
        {
            key: "size",
            get: function get() {
                return this.m_images.size;
            }
        },
        {
            key: "findImageCacheItem",
            value: function findImageCacheItem(url) {
                return this.m_images.get(url);
            }
        },
        {
            key: "cancelLoading",
            value: function cancelLoading(imageItem) {
                if (imageItem.loading) {
                    imageItem.cancelled = true;
                }
            }
        },
        {
            key: "unlinkCacheItem",
            value: function unlinkCacheItem(cacheItem, owner) {
                var ownerIndex = cacheItem.owners.indexOf(owner);
                if (ownerIndex >= 0) {
                    cacheItem.owners.splice(ownerIndex, 1);
                }
                if (cacheItem.owners.length === 0) {
                    this.m_images.delete(cacheItem.imageItem.url);
                    this.cancelLoading(cacheItem.imageItem);
                }
            }
        }
    ], [
        {
            key: "instance",
            get: function get() {
                if (_ImageCache.m_instance === void 0) {
                    _ImageCache.m_instance = new _ImageCache();
                }
                return _ImageCache.m_instance;
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                _ImageCache.m_instance = void 0;
            }
        }
    ]);
    return _ImageCache;
}();
var ImageCache = _ImageCache;
__publicField(ImageCache, "m_instance");
// src/mapview/image/MapViewImageCache.ts
var MapViewImageCache = /*#__PURE__*/ function() {
    function MapViewImageCache() {
        _classCallCheck(this, MapViewImageCache);
        __publicField(this, "m_name2Url", /* @__PURE__ */ new Map());
        __publicField(this, "m_urlNameCount", /* @__PURE__ */ new Map());
    }
    _createClass(MapViewImageCache, [
        {
            key: "addImage",
            value: function addImage(name2, urlOrImage) {
                var startLoading = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                if (typeof urlOrImage === "string") {
                    var url = urlOrImage;
                    var imageItem = this.registerImage(name2, url);
                    return startLoading ? imageItem.loadImage() : imageItem;
                }
                var image = urlOrImage;
                return this.registerImage(name2, void 0, image);
            }
        },
        {
            key: "removeImage",
            value: function removeImage(name2) {
                var url = this.m_name2Url.get(name2);
                if (url !== void 0) {
                    this.m_name2Url.delete(name2);
                    var nameCount = 1;
                    if (name2 !== url) {
                        var result = this.m_urlNameCount.get(url);
                        assert(result !== void 0);
                        nameCount = result;
                        assert(nameCount > 0);
                    }
                    if (nameCount > 1) {
                        this.m_urlNameCount.set(url, nameCount - 1);
                    } else {
                        this.m_urlNameCount.delete(url);
                        ImageCache.instance.removeImage(url, this);
                    }
                    return true;
                }
                return false;
            }
        },
        {
            key: "findImageByName",
            value: function findImageByName(name2) {
                var url = this.m_name2Url.get(name2);
                if (url === void 0) {
                    return void 0;
                }
                return ImageCache.instance.findImage(url);
            }
        },
        {
            key: "clear",
            value: function clear() {
                ImageCache.instance.clear(this);
                this.m_name2Url.clear();
                this.m_urlNameCount.clear();
            }
        },
        {
            key: "registerImage",
            value: function registerImage(name2, url, image) {
                if (this.hasName(name2)) {
                    throw new Error("duplicate name in cache");
                }
                if (url === void 0) {
                    assert(image !== void 0);
                    url = name2;
                }
                if (url !== name2) {
                    var ref;
                    var nameCount = (ref = this.m_urlNameCount.get(url)) !== null && ref !== void 0 ? ref : 0;
                    this.m_urlNameCount.set(url, nameCount + 1);
                }
                this.m_name2Url.set(name2, url);
                return ImageCache.instance.registerImage(this, url, image);
            }
        },
        {
            key: "hasName",
            value: function hasName(name2) {
                return this.m_name2Url.get(name2) !== void 0;
            }
        }
    ]);
    return MapViewImageCache;
}();
// src/mapview/MapAnchors.ts
var THREE59 = __toESM(require("three"));
var MapAnchors = /*#__PURE__*/ function() {
    function MapAnchors() {
        _classCallCheck(this, MapAnchors);
        __publicField(this, "m_anchors", []);
        __publicField(this, "m_priorities", []);
    }
    _createClass(MapAnchors, [
        {
            key: "children",
            get: function get() {
                return this.m_anchors;
            }
        },
        {
            key: "add",
            value: function add(mapAnchor) {
                this.m_anchors.push(mapAnchor);
            }
        },
        {
            key: "remove",
            value: function remove(mapAnchor) {
                var index = this.m_anchors.findIndex(function(element) {
                    return element === mapAnchor;
                });
                if (index > -1) {
                    this.m_anchors.splice(index, 1);
                }
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_anchors.length = 0;
            }
        },
        {
            key: "setPriorities",
            value: function setPriorities(priorities) {
                this.m_priorities = priorities;
            }
        },
        {
            key: "update",
            value: function update(projection, cameraPosition, rootNode, overlayRootNode) {
                var _this = this;
                var worldPosition = new THREE59.Vector3();
                this.m_anchors.forEach(function(mapAnchor) {
                    if (mapAnchor.styleSet !== void 0) {
                        var ref;
                        var priority = (ref = _this.m_priorities) === null || ref === void 0 ? void 0 : ref.findIndex(function(entry) {
                            return entry.group === mapAnchor.styleSet && entry.category === mapAnchor.category;
                        });
                        if (priority !== void 0 && priority !== -1) {
                            mapAnchor.renderOrder = (priority + 1) * 10;
                        }
                    }
                    var anchor = mapAnchor.geoPosition !== void 0 ? mapAnchor.geoPosition : mapAnchor.anchor;
                    if (anchor !== void 0) {
                        if (isVector3Like(anchor)) {
                            worldPosition.set(anchor.x, anchor.y, anchor.z);
                        } else if (isGeoCoordinatesLike(anchor)) {
                            projection.projectPoint(anchor, worldPosition);
                        }
                        mapAnchor.position.copy(worldPosition).sub(cameraPosition);
                    }
                    if (mapAnchor.overlay === true) {
                        overlayRootNode.add(mapAnchor);
                    } else {
                        rootNode.add(mapAnchor);
                    }
                });
            }
        }
    ]);
    return MapAnchors;
}();
// src/mapview/MapViewEnvironment.ts
var THREE61 = __toESM(require("three"));
// src/mapview/MapViewFog.ts
var THREE60 = __toESM(require("three"));
var MapViewFog = /*#__PURE__*/ function() {
    function MapViewFog(m_scene) {
        _classCallCheck(this, MapViewFog);
        this.m_scene = m_scene;
        __publicField(this, "m_enabled", true);
        __publicField(this, "m_fog", new THREE60.Fog(0));
        __publicField(this, "m_fogIsDefined", false);
        __publicField(this, "m_cachedFog");
    }
    _createClass(MapViewFog, [
        {
            key: "enabled",
            get: function get() {
                return this.m_enabled;
            },
            set: function set(enableFog) {
                this.m_enabled = enableFog;
                if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {
                    this.add();
                } else if (!enableFog && this.m_scene.fog !== null) {
                    this.remove();
                }
            }
        },
        {
            key: "reset",
            value: function reset(fog) {
                this.m_cachedFog = fog;
                if (fog !== void 0 && fog.color !== void 0 && fog.startRatio !== void 0) {
                    this.m_fogIsDefined = true;
                    this.m_fog.color.set(fog.color);
                    if (this.m_enabled && this.m_scene.fog === null) {
                        this.add();
                    }
                } else {
                    this.m_fogIsDefined = false;
                    if (this.m_scene.fog !== null) {
                        this.remove();
                    }
                }
            }
        },
        {
            key: "update",
            value: function update(mapView, viewDistance) {
                if (this.m_scene.fog !== null && this.m_cachedFog !== void 0 && this.m_cachedFog && this.m_cachedFog.startRatio !== void 0 && (mapView.camera.far !== void 0 || viewDistance !== void 0)) {
                    var viewRange = viewDistance !== void 0 ? viewDistance : mapView.camera.far;
                    var horizontalDensity = 1;
                    var verticalDensity = 0;
                    var startRatio = this.m_cachedFog.startRatio;
                    var endRatio = 1;
                    assert(startRatio <= endRatio);
                    var t = Math.abs(Math.cos(mapView.tilt));
                    var density = MathUtils.smoothStep(horizontalDensity, verticalDensity, t);
                    this.m_fog.near = THREE60.MathUtils.lerp(viewRange * startRatio, viewRange, 1 - density);
                    this.m_fog.far = THREE60.MathUtils.lerp(viewRange * endRatio, viewRange, density);
                    this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);
                    this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);
                }
            }
        },
        {
            key: "add",
            value: function add() {
                this.m_scene.fog = this.m_fog;
                this.setFogInRawShaderMaterials(true);
            }
        },
        {
            key: "remove",
            value: function remove() {
                this.m_scene.fog = null;
                this.setFogInRawShaderMaterials(false);
            }
        },
        {
            key: "setFogInRawShaderMaterials",
            value: function setFogInRawShaderMaterials(enableFog) {
                this.m_scene.traverse(function(object) {
                    if (_instanceof(object, THREE60.Mesh)) {
                        var material = object.material;
                        if (_instanceof(material, THREE60.Material) && !_instanceof(material, HighPrecisionLineMaterial) && material.fog !== enableFog) {
                            material.fog = enableFog;
                            if (_instanceof(material, RawShaderMaterial2)) {
                                material.invalidateFog();
                            }
                        }
                    }
                });
            }
        }
    ]);
    return MapViewFog;
}();
// src/mapview/SkyCubemapTexture.ts
var import_three12 = require("three");
var logger9 = LoggerManager.instance.create("SkyCubemapTexture");
var SKY_CUBEMAP_FACE_COUNT = 6;
var SkyCubemapFaceId = /* @__PURE__ */ function(SkyCubemapFaceId2) {
    SkyCubemapFaceId2[SkyCubemapFaceId2["positiveX"] = 0] = "positiveX";
    SkyCubemapFaceId2[SkyCubemapFaceId2["negativeX"] = 1] = "negativeX";
    SkyCubemapFaceId2[SkyCubemapFaceId2["positiveY"] = 2] = "positiveY";
    SkyCubemapFaceId2[SkyCubemapFaceId2["negativeY"] = 3] = "negativeY";
    SkyCubemapFaceId2[SkyCubemapFaceId2["positiveZ"] = 4] = "positiveZ";
    SkyCubemapFaceId2[SkyCubemapFaceId2["negativeZ"] = 5] = "negativeZ";
    return SkyCubemapFaceId2;
}(SkyCubemapFaceId || {});
var SkyCubemapTexture = /*#__PURE__*/ function() {
    function SkyCubemapTexture(sky) {
        _classCallCheck(this, SkyCubemapTexture);
        __publicField(this, "m_skybox");
        var faces = this.createCubemapFaceArray(sky);
        this.m_skybox = faces !== void 0 ? new import_three12.CubeTextureLoader().load(faces) : new import_three12.CubeTexture();
    }
    _createClass(SkyCubemapTexture, [
        {
            key: "dispose",
            value: function dispose() {
                this.m_skybox.dispose();
            }
        },
        {
            key: "texture",
            get: function get() {
                return this.m_skybox;
            }
        },
        {
            key: "updateTexture",
            value: function updateTexture(sky) {
                var faces = this.createCubemapFaceArray(sky);
                if (faces === void 0) {
                    return;
                }
                this.m_skybox = new import_three12.CubeTextureLoader().load(faces);
            }
        },
        {
            key: "createCubemapFaceArray",
            value: function createCubemapFaceArray(sky) {
                var faces = [
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0
                ];
                for(var i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i){
                    var face = sky[SkyCubemapFaceId[i]];
                    if (face === void 0) {
                        logger9.error('Face "'.concat(SkyCubemapFaceId[i], '" was not defined.'));
                        return;
                    }
                    faces[i] = face;
                }
                return faces;
            }
        }
    ]);
    return SkyCubemapTexture;
}();
// src/mapview/SkyGradientTexture.ts
var import_three13 = require("three");
var DEFAULT_TEXTURE_SIZE = 512;
var DEFAULT_MONOMIAL_POWER = 1;
var cameraDir = [
    new import_three13.Vector3(1, 0, 0),
    new import_three13.Vector3(-1, 0, 0),
    new import_three13.Vector3(0, -1, 0),
    new import_three13.Vector3(0, 1, 0),
    new import_three13.Vector3(0, 0, 1),
    new import_three13.Vector3(0, 0, -1)
];
var cameraRight = [
    new import_three13.Vector3(0, 0, -1),
    new import_three13.Vector3(0, 0, 1),
    new import_three13.Vector3(1, 0, 0),
    new import_three13.Vector3(1, 0, 0),
    new import_three13.Vector3(1, 0, 0),
    new import_three13.Vector3(-1, 0, 0)
];
var cameraUp = [
    new import_three13.Vector3(0, 1, 0),
    new import_three13.Vector3(0, 1, 0),
    new import_three13.Vector3(0, 0, 1),
    new import_three13.Vector3(0, 0, -1),
    new import_three13.Vector3(0, 1, 0),
    new import_three13.Vector3(0, 1, 0)
];
var SkyGradientTexture = /*#__PURE__*/ function() {
    function SkyGradientTexture(sky, m_projectionType) {
        var m_height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_TEXTURE_SIZE;
        _classCallCheck(this, SkyGradientTexture);
        this.m_projectionType = m_projectionType;
        this.m_height = m_height;
        __publicField(this, "m_width");
        __publicField(this, "m_faceCount");
        __publicField(this, "m_faces");
        __publicField(this, "m_skybox");
        __publicField(this, "m_farClipPlaneDividedVertically");
        __publicField(this, "m_groundPlane");
        __publicField(this, "m_bottomMidFarPoint");
        __publicField(this, "m_topMidFarPoint");
        __publicField(this, "m_horizonPosition");
        __publicField(this, "m_farClipPlaneCorners");
        var topColor = new import_three13.Color(sky.topColor);
        var bottomColor = new import_three13.Color(sky.bottomColor);
        var groundColor = new import_three13.Color(sky.groundColor);
        this.m_width = this.m_projectionType === 0 /* Planar */  ? 1 : this.m_height;
        this.m_faceCount = this.m_projectionType === 0 /* Planar */  ? 1 : 6;
        this.m_faces = [];
        for(var i = 0; i < this.m_faceCount; ++i){
            var data2 = new Uint8Array(3 * this.m_width * this.m_height);
            this.fillTextureData(data2, i, topColor, bottomColor, groundColor, sky.monomialPower);
            var texture = new import_three13.DataTexture(data2, this.m_width, this.m_height, import_three13.RGBFormat);
            texture.needsUpdate = true;
            texture.unpackAlignment = 1;
            this.m_faces.push(texture);
        }
        if (this.m_projectionType === 1 /* Spherical */ ) {
            this.m_skybox = new import_three13.CubeTexture(this.m_faces);
            this.m_skybox.needsUpdate = true;
        } else {
            this.m_farClipPlaneDividedVertically = new import_three13.Line3();
            this.m_groundPlane = new import_three13.Plane(new import_three13.Vector3(0, 0, 1));
            this.m_bottomMidFarPoint = new import_three13.Vector3();
            this.m_topMidFarPoint = new import_three13.Vector3();
            this.m_horizonPosition = new import_three13.Vector3();
            this.m_farClipPlaneCorners = [
                new import_three13.Vector3(),
                new import_three13.Vector3(),
                new import_three13.Vector3(),
                new import_three13.Vector3()
            ];
        }
    }
    _createClass(SkyGradientTexture, [
        {
            key: "dispose",
            value: function dispose() {
                for(var i = 0; i < this.m_faceCount; ++i){
                    this.m_faces[i].dispose();
                }
                if (this.m_projectionType === 1 /* Spherical */ ) {
                    this.m_skybox.dispose();
                }
            }
        },
        {
            key: "texture",
            get: function get() {
                return this.m_projectionType === 0 /* Planar */  ? this.m_faces[0] : this.m_skybox;
            }
        },
        {
            key: "update",
            value: function update(camera) {
                if (this.m_projectionType === 0 /* Planar */ ) {
                    this.setHorizonPosition(camera);
                    this.updateTexturePosition();
                }
            }
        },
        {
            key: "updateTexture",
            value: function updateTexture(sky) {
                for(var i = 0; i < this.m_faceCount; ++i){
                    this.fillTextureData(this.m_faces[i].image.data, i, new import_three13.Color(sky.topColor), new import_three13.Color(sky.bottomColor), new import_three13.Color(sky.groundColor), sky.monomialPower);
                    this.m_faces[i].needsUpdate = true;
                }
                if (this.m_projectionType === 1 /* Spherical */ ) {
                    this.m_skybox.needsUpdate = true;
                }
            }
        },
        {
            key: "fillTextureData",
            value: function fillTextureData(data2, faceIdx, topColor, bottomColor, groundColor, monomialPower) {
                var color = new import_three13.Color();
                var dir = new import_three13.Vector3();
                var right = new import_three13.Vector3();
                var up = new import_three13.Vector3();
                var upDir = new import_three13.Vector3(0, 0, 1);
                for(var i = 0; i < this.m_height; ++i){
                    for(var j = 0; j < this.m_width; ++j){
                        if (this.m_projectionType === 1 /* Spherical */ ) {
                            var offsetX = right.copy(cameraRight[faceIdx]).multiplyScalar((j + 0.5) / this.m_width * 2 - 1);
                            var offsetY = up.copy(cameraUp[faceIdx]).multiplyScalar((i + 0.5) / this.m_height * 2 - 1);
                            dir.copy(cameraDir[faceIdx]).add(offsetX).add(offsetY).normalize();
                            var t = Math.max(upDir.dot(dir), 0);
                            color.copy(groundColor).lerp(bottomColor, Math.min(t * 100, 1)).lerp(topColor, Math.pow(t, getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER))).multiplyScalar(255);
                        } else {
                            var t1 = i / this.m_height;
                            if (i === 0) {
                                color.copy(groundColor).multiplyScalar(255);
                            } else {
                                color.copy(bottomColor).lerp(topColor, Math.pow(t1, getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER))).multiplyScalar(255);
                            }
                        }
                        data2[i * this.m_width * 3 + j * 3] = color.r;
                        data2[i * this.m_width * 3 + j * 3 + 1] = color.g;
                        data2[i * this.m_width * 3 + j * 3 + 2] = color.b;
                    }
                }
            }
        },
        {
            key: "setHorizonPosition",
            value: function setHorizonPosition(camera) {
                this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);
                this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);
                this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);
                this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);
                this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0]).add(this.m_farClipPlaneCorners[1]).multiplyScalar(0.5);
                this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2]).add(this.m_farClipPlaneCorners[3]).multiplyScalar(0.5);
                this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);
                var hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);
                if (!hasIntersection) {
                    this.m_horizonPosition.set(0, 0, 0);
                }
            }
        },
        {
            key: "updateTexturePosition",
            value: function updateTexturePosition() {
                var coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);
                var frustumHeight = this.m_farClipPlaneDividedVertically.distance();
                var skyRatio = coveredBySky / frustumHeight;
                var ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;
                this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);
            }
        }
    ]);
    return SkyGradientTexture;
}();
// src/mapview/SkyBackground.ts
var SkyBackground = /*#__PURE__*/ function() {
    function SkyBackground(m_sky, m_projectionType, camera) {
        _classCallCheck(this, SkyBackground);
        this.m_sky = m_sky;
        this.m_projectionType = m_projectionType;
        __publicField(this, "m_skyTexture");
        switch(this.m_sky.type){
            case "gradient":
                this.m_skyTexture = new SkyGradientTexture(this.m_sky, this.m_projectionType);
                this.updateCamera(camera);
                break;
            case "cubemap":
                {
                    this.m_skyTexture = new SkyCubemapTexture(this.m_sky);
                    break;
                }
        }
    }
    _createClass(SkyBackground, [
        {
            key: "dispose",
            value: function dispose() {
                this.m_skyTexture.dispose();
            }
        },
        {
            key: "texture",
            get: function get() {
                return this.m_skyTexture.texture;
            }
        },
        {
            key: "updateCamera",
            value: function updateCamera(camera) {
                if (this.m_sky.type === "gradient") {
                    ;
                    this.m_skyTexture.update(camera);
                }
            }
        },
        {
            key: "updateTexture",
            value: function updateTexture(params, projectionType) {
                var isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;
                switch(params.type){
                    case "gradient":
                        if (isSameSkyType) {
                            ;
                            this.m_skyTexture.updateTexture(params);
                        } else {
                            this.m_skyTexture = new SkyGradientTexture(params, projectionType);
                        }
                        break;
                    case "cubemap":
                        {
                            if (isSameSkyType) {
                                ;
                                this.m_skyTexture.updateTexture(params);
                            } else {
                                this.m_skyTexture = new SkyCubemapTexture(params);
                            }
                            break;
                        }
                }
                this.m_projectionType = projectionType;
                this.m_sky = params;
            }
        }
    ]);
    return SkyBackground;
}();
// src/mapview/MapViewEnvironment.ts
var logger10 = LoggerManager.instance.create("MapViewEnvironment");
var DEFAULT_CLEAR_COLOR = 16777215;
var cache = {
    vector3: [
        new THREE61.Vector3(),
        new THREE61.Vector3(),
        new THREE61.Vector3()
    ],
    frustumPoints: [
        new THREE61.Vector3(),
        new THREE61.Vector3(),
        new THREE61.Vector3(),
        new THREE61.Vector3(),
        new THREE61.Vector3(),
        new THREE61.Vector3(),
        new THREE61.Vector3(),
        new THREE61.Vector3()
    ]
};
var MapViewEnvironment = /*#__PURE__*/ function() {
    function MapViewEnvironment(m_mapView, options) {
        _classCallCheck(this, MapViewEnvironment);
        this.m_mapView = m_mapView;
        __publicField(this, "m_fog");
        __publicField(this, "m_skyBackground");
        __publicField(this, "m_createdLights");
        __publicField(this, "m_overlayCreatedLights");
        __publicField(this, "m_backgroundDataSource");
        this.m_fog = new MapViewFog(this.m_mapView.scene);
        if (options.addBackgroundDatasource !== false) {
            this.m_backgroundDataSource = new BackgroundDataSource();
            this.m_mapView.addDataSource(this.m_backgroundDataSource);
        }
        if (options.backgroundTilingScheme !== void 0 && this.m_backgroundDataSource !== void 0) {
            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);
        }
        this.updateClearColor();
    }
    _createClass(MapViewEnvironment, [
        {
            key: "lights",
            get: function get() {
                var _m_createdLights;
                return (_m_createdLights = this.m_createdLights) !== null && _m_createdLights !== void 0 ? _m_createdLights : [];
            }
        },
        {
            key: "fog",
            get: function get() {
                return this.m_fog;
            }
        },
        {
            key: "updateBackgroundDataSource",
            value: function updateBackgroundDataSource() {
                if (this.m_backgroundDataSource) {
                    this.m_backgroundDataSource.updateStorageLevelOffset();
                }
            }
        },
        {
            key: "clearBackgroundDataSource",
            value: function clearBackgroundDataSource() {
                if (this.m_backgroundDataSource !== void 0) {
                    this.m_mapView.clearTileCache(this.m_backgroundDataSource.name);
                }
            }
        },
        {
            key: "update",
            value: function update() {
                this.m_fog.update(this.m_mapView, this.m_mapView.viewRanges.maximum);
                if (this.m_skyBackground !== void 0 && this.m_mapView.projection.type === 0 /* Planar */ ) {
                    this.m_skyBackground.updateCamera(this.m_mapView.camera);
                }
                this.updateLights();
            }
        },
        {
            key: "updateClearColor",
            value: function updateClearColor(clearColor, clearAlpha) {
                if (clearColor !== void 0) {
                    this.m_mapView.renderer.setClearColor(new THREE61.Color(clearColor), clearAlpha);
                } else {
                    this.m_mapView.renderer.setClearColor(DEFAULT_CLEAR_COLOR, clearAlpha);
                }
            }
        },
        {
            key: "updateSkyBackground",
            value: function updateSkyBackground(sky, clearColor) {
                if (_instanceof(this.m_skyBackground, SkyBackground) && sky !== void 0) {
                    this.updateSkyBackgroundColors(sky, clearColor);
                } else if (this.m_skyBackground === void 0 && sky !== void 0) {
                    this.addNewSkyBackground(sky, clearColor);
                    return;
                } else if (_instanceof(this.m_skyBackground, SkyBackground) && sky === void 0) {
                    this.removeSkyBackGround();
                }
            }
        },
        {
            key: "updateLighting",
            value: function updateLighting(lights) {
                var _this = this;
                var ref;
                if (this.m_createdLights) {
                    this.m_createdLights.forEach(function(light) {
                        _this.m_mapView.scene.remove(light);
                    });
                }
                (ref = this.m_overlayCreatedLights) === null || ref === void 0 ? void 0 : ref.forEach(function(light) {
                    _this.m_mapView.overlayScene.remove(light);
                    if (_instanceof(light, THREE61.DirectionalLight)) {
                        _this.m_mapView.overlayScene.remove(light.target);
                    }
                });
                if (lights !== void 0) {
                    this.m_createdLights = [];
                    this.m_overlayCreatedLights = [];
                    lights.forEach(function(lightDescription) {
                        var light = createLight(lightDescription);
                        if (!light) {
                            logger10.warn("MapView: failed to create light ".concat(lightDescription.name, " of type ").concat(lightDescription.type));
                            return;
                        }
                        _this.m_mapView.scene.add(light);
                        if (light.isDirectionalLight) {
                            var directionalLight = light;
                            _this.m_mapView.scene.add(directionalLight.target);
                        }
                        _this.m_createdLights.push(light);
                        var clonedLight = light.clone();
                        _this.m_mapView.overlayScene.add(clonedLight);
                        if (_instanceof(clonedLight, THREE61.DirectionalLight)) {
                            _this.m_mapView.overlayScene.add(clonedLight.target.clone());
                        }
                    });
                }
            }
        },
        {
            key: "updateLights",
            value: function updateLights() {
                var _this = this;
                if (!this.m_mapView.shadowsEnabled || this.m_mapView.projection.type === 1 /* Spherical */  || this.m_createdLights === void 0 || this.m_createdLights.length === 0) {
                    return;
                }
                var points = [
                    {
                        x: -1,
                        y: -1,
                        z: -1
                    },
                    {
                        x: 1,
                        y: -1,
                        z: -1
                    },
                    {
                        x: -1,
                        y: 1,
                        z: -1
                    },
                    {
                        x: 1,
                        y: 1,
                        z: -1
                    },
                    {
                        x: -1,
                        y: -1,
                        z: 1
                    },
                    {
                        x: 1,
                        y: -1,
                        z: 1
                    },
                    {
                        x: -1,
                        y: 1,
                        z: 1
                    },
                    {
                        x: 1,
                        y: 1,
                        z: 1
                    }
                ];
                var transformedPoints = points.map(function(p, i) {
                    return _this.m_mapView.ndcToView(p, cache.frustumPoints[i]);
                });
                this.m_createdLights.forEach(function(element) {
                    var directionalLight = element;
                    if (directionalLight.isDirectionalLight === true) {
                        var lightDirection = cache.vector3[0];
                        lightDirection.copy(directionalLight.target.position);
                        lightDirection.sub(directionalLight.position);
                        lightDirection.normalize();
                        var normal = cache.vector3[1];
                        if (_this.m_mapView.projection.type === 0 /* Planar */ ) {
                            normal.set(0, 0, -1);
                        } else {}
                        var tilt = _this.m_mapView.tilt;
                        var cameraHeight = _this.m_mapView.targetDistance * Math.cos(THREE61.MathUtils.degToRad(tilt));
                        var lightPosHyp = cameraHeight / normal.dot(lightDirection);
                        directionalLight.target.position.copy(_this.m_mapView.worldTarget).sub(_this.m_mapView.camera.position);
                        directionalLight.position.copy(_this.m_mapView.worldTarget);
                        directionalLight.position.addScaledVector(lightDirection, -lightPosHyp);
                        directionalLight.position.sub(_this.m_mapView.camera.position);
                        directionalLight.updateMatrixWorld();
                        directionalLight.shadow.updateMatrices(directionalLight);
                        var camera = directionalLight.shadow.camera;
                        var pointsInLightSpace = transformedPoints.map(function(p) {
                            return _this.viewToLightSpace(p.clone(), camera);
                        });
                        var box = new THREE61.Box3();
                        pointsInLightSpace.forEach(function(point) {
                            box.expandByPoint(point);
                        });
                        camera.left = box.min.x;
                        camera.right = box.max.x;
                        camera.top = box.max.y;
                        camera.bottom = box.min.y;
                        camera.near = -box.max.z * 0.95;
                        camera.far = -box.min.z;
                        camera.updateProjectionMatrix();
                    }
                });
            }
        },
        {
            key: "addNewSkyBackground",
            value: function addNewSkyBackground(sky, clearColor) {
                if (sky.type === "gradient" && sky.groundColor === void 0) {
                    sky.groundColor = getOptionValue(clearColor, "#000000");
                }
                this.m_skyBackground = new SkyBackground(sky, this.m_mapView.projection.type, this.m_mapView.camera);
                this.m_mapView.scene.background = this.m_skyBackground.texture;
            }
        },
        {
            key: "removeSkyBackGround",
            value: function removeSkyBackGround() {
                this.m_mapView.scene.background = null;
                if (this.m_skyBackground !== void 0) {
                    this.m_skyBackground.dispose();
                    this.m_skyBackground = void 0;
                }
            }
        },
        {
            key: "updateSkyBackgroundColors",
            value: function updateSkyBackgroundColors(sky, clearColor) {
                if (sky.type === "gradient" && sky.groundColor === void 0) {
                    sky.groundColor = getOptionValue(clearColor, "#000000");
                }
                if (this.m_skyBackground !== void 0) {
                    var ref;
                    this.m_skyBackground.updateTexture(sky, this.m_mapView.projection.type);
                    this.m_mapView.scene.background = (ref = this.m_skyBackground) === null || ref === void 0 ? void 0 : ref.texture;
                }
            }
        },
        {
            key: "viewToLightSpace",
            value: function viewToLightSpace(viewPos, camera) {
                return viewPos.applyMatrix4(camera.matrixWorldInverse);
            }
        }
    ]);
    return MapViewEnvironment;
}();
// src/mapview/MapViewTaskScheduler.ts
var THREE62 = __toESM(require("three"));
// src/mapview/Statistics.ts
var logger11 = LoggerManager.instance.create("Statistics");
var RingBuffer = /*#__PURE__*/ function() {
    function RingBuffer(capacity) {
        _classCallCheck(this, RingBuffer);
        this.capacity = capacity;
        __publicField(this, "buffer");
        __publicField(this, "size");
        __publicField(this, "head");
        __publicField(this, "tail");
        this.buffer = new Array(capacity);
        this.capacity = capacity;
        this.head = this.tail = this.size = 0;
    }
    _createClass(RingBuffer, [
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = this.size = 0;
            }
        },
        {
            key: "enqOne",
            value: function enqOne(data2) {
                var next = this.head + 1;
                if (next >= this.capacity) {
                    next = 0;
                }
                if (this.size < this.capacity) {
                    this.size++;
                }
                this.buffer[this.head] = data2;
                this.head = next;
                if (this.size === this.capacity) {
                    this.tail = this.head;
                }
            }
        },
        {
            key: "enq",
            value: function enq() {
                for(var _len = arguments.length, data2 = new Array(_len), _key = 0; _key < _len; _key++){
                    data2[_key] = arguments[_key];
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = data2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var v = _step.value;
                        this.enqOne(v);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "deq",
            value: function deq() {
                if (this.size === 0) {
                    throw new Error("Ringbuffer underrun");
                }
                var data2 = this.buffer[this.tail];
                var next = this.tail + 1;
                if (next >= this.capacity) {
                    next = 0;
                }
                if (this.size > 0) {
                    this.size--;
                }
                this.tail = next;
                return data2;
            }
        },
        {
            key: "top",
            get: function get() {
                if (this.size === 0) {
                    throw new Error("Ringbuffer underrun");
                }
                return this.buffer[this.tail];
            }
        },
        {
            key: "bottom",
            get: function get() {
                if (this.size === 0) {
                    throw new Error("Ringbuffer underrun");
                }
                var previous = this.head - 1;
                if (previous < 0) {
                    previous = this.capacity - 1;
                }
                return this.buffer[previous];
            }
        },
        {
            key: "iterator",
            value: function iterator() {
                return new RingBuffer.Iterator(this);
            }
        },
        {
            key: "asArray",
            value: function asArray() {
                var array = new Array();
                for(var i = 0; i < this.size; i++){
                    array.push(this.buffer[(this.tail + i) % this.capacity]);
                }
                return array;
            }
        }
    ]);
    return RingBuffer;
}();
(function(RingBuffer2) {
    var Iterator = /*#__PURE__*/ function() {
        function Iterator(m_buffer) {
            var m_index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            _classCallCheck(this, Iterator);
            this.m_buffer = m_buffer;
            this.m_index = m_index;
        }
        _createClass(Iterator, [
            {
                key: "value",
                get: function get() {
                    return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];
                }
            },
            {
                key: "next",
                value: function next() {
                    this.m_index++;
                    return this.m_index < this.m_buffer.size;
                }
            }
        ]);
        return Iterator;
    }();
    RingBuffer2.Iterator = Iterator;
})(RingBuffer || (RingBuffer = {}));
var SimpleTimer = /*#__PURE__*/ function() {
    function SimpleTimer(statistics, name2) {
        _classCallCheck(this, SimpleTimer);
        this.statistics = statistics;
        this.name = name2;
        __publicField(this, "running", false);
        __publicField(this, "m_currentValue");
    }
    _createClass(SimpleTimer, [
        {
            key: "value",
            get: function get() {
                return this.m_currentValue;
            }
        },
        {
            key: "setValue",
            value: function setValue(val) {
                this.m_currentValue = val;
            }
        },
        {
            key: "reset",
            value: function reset() {
                this.m_currentValue = void 0;
            }
        },
        {
            key: "start",
            value: function start() {
                if (!this.statistics.enabled) {
                    return -1;
                }
                if (this.running) {
                    throw new Error("Timer '" + this.name + "' is already running");
                }
                this.running = true;
                return this.m_currentValue = PerformanceTimer.now();
            }
        },
        {
            key: "stop",
            value: function stop() {
                if (!this.statistics.enabled) {
                    return -1;
                }
                if (!this.running) {
                    throw new Error("Timer '" + this.name + "' has not been started");
                } else {
                    var _m_currentValue;
                    var t = PerformanceTimer.now() - ((_m_currentValue = this.m_currentValue) !== null && _m_currentValue !== void 0 ? _m_currentValue : 0);
                    this.m_currentValue = t;
                    this.setValue(t);
                    this.running = false;
                    return t;
                }
            }
        },
        {
            key: "now",
            value: function now() {
                if (!this.statistics.enabled) {
                    return -1;
                }
                if (!this.running) {
                    throw new Error("Timer '" + this.name + "' has not been started");
                } else {
                    var _m_currentValue;
                    var t = PerformanceTimer.now() - ((_m_currentValue = this.m_currentValue) !== null && _m_currentValue !== void 0 ? _m_currentValue : 0);
                    return t;
                }
            }
        }
    ]);
    return SimpleTimer;
}();
var SampledTimer = /*#__PURE__*/ function(SimpleTimer) {
    _inherits(SampledTimer, SimpleTimer);
    var _super = _createSuper(SampledTimer);
    function SampledTimer(statistics, name2) {
        _classCallCheck(this, SampledTimer);
        var _this;
        _this = _super.call(this, statistics, name2);
        _this.statistics = statistics;
        _this.name = name2;
        __publicField(_assertThisInitialized(_this), "numResets", 0);
        __publicField(_assertThisInitialized(_this), "maxNumSamples", 1e3);
        __publicField(_assertThisInitialized(_this), "samples", new RingBuffer(_this.maxNumSamples));
        return _this;
    }
    _createClass(SampledTimer, [
        {
            key: "reset",
            value: function reset() {
                _get(_getPrototypeOf(SampledTimer.prototype), "reset", this).call(this);
                this.getStats();
                this.samples.clear();
                this.numResets++;
            }
        },
        {
            key: "setValue",
            value: function setValue(val) {
                _get(_getPrototypeOf(SampledTimer.prototype), "setValue", this).call(this, val);
                if (val !== void 0) {
                    this.samples.enqOne(val);
                }
            }
        },
        {
            key: "getStats",
            value: function getStats() {
                return computeArrayStats(this.samples.asArray());
            }
        }
    ]);
    return SampledTimer;
}(SimpleTimer);
function computeArrayStats(samples) {
    if (samples.length === 0) {
        return void 0;
    }
    samples.sort(function(a, b) {
        return a - b;
    });
    var min = samples[0];
    var max = samples[samples.length - 1];
    var median;
    var median75;
    var median90;
    var median95;
    var median97;
    var median99;
    var median999;
    if (samples.length === 1) {
        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];
    } else if (samples.length === 2) {
        median = samples[0] * 0.5 + samples[1] * 0.5;
        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];
    } else {
        var mid = Math.floor(samples.length / 2);
        median = samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];
        var mid75 = Math.round(samples.length * 0.75) - 1;
        median75 = samples[mid75];
        var mid90 = Math.round(samples.length * 0.9) - 1;
        median90 = samples[mid90];
        var mid95 = Math.round(samples.length * 0.95) - 1;
        median95 = samples[mid95];
        var mid97 = Math.round(samples.length * 0.97) - 1;
        median97 = samples[mid97];
        var mid99 = Math.round(samples.length * 0.99) - 1;
        median99 = samples[mid99];
        var mid999 = Math.round(samples.length * 0.999) - 1;
        median999 = samples[mid999];
    }
    var sum = 0;
    for(var i = 0, l = samples.length; i < l; i++){
        sum += samples[i];
    }
    var avg = sum / samples.length;
    return {
        min: min,
        max: max,
        avg: avg,
        median: median,
        median75: median75,
        median90: median90,
        median95: median95,
        median97: median97,
        median99: median99,
        median999: median999,
        numSamples: samples.length
    };
}
function computeArrayAverage(samples) {
    if (samples.length === 0) {
        return void 0;
    }
    var sum = 0;
    for(var i = 0, l = samples.length; i < l; i++){
        sum += samples[i];
    }
    var avg = sum / samples.length;
    return avg;
}
var MultiStageTimer = /*#__PURE__*/ function() {
    function MultiStageTimer(statistics, name2, stages) {
        _classCallCheck(this, MultiStageTimer);
        this.statistics = statistics;
        this.name = name2;
        this.stages = stages;
        __publicField(this, "currentStage");
        if (stages.length < 1) {
            throw new Error("MultiStageTimer needs stages");
        }
        stages.forEach(function(stage) {
            if (!statistics.hasTimer(stage)) {
                throw new Error("Unknown timer: " + stage);
            }
        });
    }
    _createClass(MultiStageTimer, [
        {
            key: "value",
            get: function get() {
                return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;
            }
        },
        {
            key: "reset",
            value: function reset() {
                var _this = this;
                if (!this.statistics.enabled) {
                    return;
                }
                this.stages.forEach(function(stage) {
                    _this.statistics.getTimer(stage).reset();
                });
            }
        },
        {
            key: "start",
            value: function start() {
                this.stage = this.stages[0];
                var _value;
                return (_value = this.statistics.getTimer(this.stages[0]).value) !== null && _value !== void 0 ? _value : -1;
            }
        },
        {
            key: "stop",
            value: function stop() {
                this.stage = void 0;
                return this.value !== void 0 ? this.value : -1;
            }
        },
        {
            key: "stage",
            get: function get() {
                return this.currentStage;
            },
            set: function set(stage) {
                if (this.currentStage === stage) {
                    return;
                }
                if (this.statistics.enabled && this.currentStage !== void 0) {
                    this.statistics.getTimer(this.currentStage).stop();
                }
                this.currentStage = stage;
                if (this.statistics.enabled && this.currentStage !== void 0) {
                    this.statistics.getTimer(this.currentStage).start();
                }
            }
        }
    ]);
    return MultiStageTimer;
}();
var Statistics = /*#__PURE__*/ function() {
    function Statistics(name2) {
        var enabled = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        _classCallCheck(this, Statistics);
        this.name = name2;
        this.enabled = enabled;
        __publicField(this, "timers");
        __publicField(this, "nullTimer");
        this.timers = /* @__PURE__ */ new Map();
        this.nullTimer = new SimpleTimer(this, "<null>");
    }
    _createClass(Statistics, [
        {
            key: "createTimer",
            value: function createTimer(name2) {
                var keepSamples = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                var timer = keepSamples ? new SampledTimer(this, name2) : new SimpleTimer(this, name2);
                return this.addTimer(timer);
            }
        },
        {
            key: "addTimer",
            value: function addTimer(timer) {
                if (this.timers.get(timer.name) !== void 0) {
                    throw new Error("Duplicate timer name: '" + timer.name + "'");
                }
                this.timers.set(timer.name, timer);
                return timer;
            }
        },
        {
            key: "getTimer",
            value: function getTimer(name2) {
                if (!this.enabled) {
                    return this.nullTimer;
                }
                var t = this.timers.get(name2);
                return t === void 0 ? this.nullTimer : t;
            }
        },
        {
            key: "hasTimer",
            value: function hasTimer(name2) {
                var t = this.timers.get(name2);
                return t !== void 0;
            }
        },
        {
            key: "reset",
            value: function reset() {
                this.timers.forEach(function(timer) {
                    timer.reset();
                });
            }
        },
        {
            key: "log",
            value: function log(header, footer) {
                if (header !== void 0 || this.name !== void 0) {
                    logger11.log(header !== void 0 ? header : this.name);
                }
                var maxNameLength = 0;
                this.timers.forEach(function(timer) {
                    maxNameLength = Math.max(maxNameLength, timer.name.length);
                });
                var print = function(v) {
                    return v !== void 0 ? v.toFixed(5) : "?";
                };
                this.timers.forEach(function(timer) {
                    var s = timer.name + ": " + " ".repeat(maxNameLength - timer.name.length);
                    s += print(timer.value);
                    if (_instanceof(timer, SampledTimer)) {
                        var simpleStats = timer.getStats();
                        if (simpleStats !== void 0) {
                            s += "  [ min=".concat(print(simpleStats.min), ", max=").concat(print(simpleStats.max), ", avg=").concat(print(simpleStats.avg), ", med=").concat(print(simpleStats.median), ", med95=").concat(print(simpleStats.median95), ", med99=").concat(print(simpleStats.median99), ", N=").concat(print(simpleStats.numSamples), " ]");
                        }
                    }
                    logger11.log(s);
                });
                if (footer !== void 0) {
                    logger11.log(footer);
                }
            }
        }
    ]);
    return Statistics;
}();
var FrameStats = /*#__PURE__*/ function() {
    function FrameStats() {
        _classCallCheck(this, FrameStats);
        __publicField(this, "entries", /* @__PURE__ */ new Map());
        __publicField(this, "messages");
    }
    _createClass(FrameStats, [
        {
            key: "getValue",
            value: function getValue(name2) {
                return this.entries.get(name2);
            }
        },
        {
            key: "setValue",
            value: function setValue(name2, value2) {
                this.entries.set(name2, value2);
            }
        },
        {
            key: "addValue",
            value: function addValue(name2, value2) {
                var oldValue = this.entries.get(name2);
                this.entries.set(name2, value2 + (oldValue === void 0 ? 0 : oldValue));
            }
        },
        {
            key: "addMessage",
            value: function addMessage(message) {
                if (this.messages === void 0) {
                    this.messages = [];
                }
                this.messages.push(message);
            }
        },
        {
            key: "reset",
            value: function reset() {
                var _this = this;
                this.entries.forEach(function(value2, name2) {
                    _this.entries.set(name2, 0);
                });
                this.messages = void 0;
            }
        }
    ]);
    return FrameStats;
}();
var FrameStatsArray = /*#__PURE__*/ function() {
    function FrameStatsArray() {
        var capacity = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        _classCallCheck(this, FrameStatsArray);
        this.capacity = capacity;
        __publicField(this, "frameEntries", /* @__PURE__ */ new Map());
        __publicField(this, "messages");
        this.messages = new RingBuffer(capacity);
    }
    _createClass(FrameStatsArray, [
        {
            key: "length",
            get: function get() {
                return this.messages.size;
            }
        },
        {
            key: "reset",
            value: function reset() {
                this.frameEntries.forEach(function(buffer, name2) {
                    buffer.clear();
                });
                this.messages.clear();
            }
        },
        {
            key: "addFrame",
            value: function addFrame(frameStats) {
                var _this = this;
                var currentSize = this.length;
                var frameEntries = this.frameEntries;
                frameStats.entries.forEach(function(value2, name2) {
                    var buffer = frameEntries.get(name2);
                    if (buffer === void 0) {
                        buffer = new RingBuffer(_this.capacity);
                        for(var i = 0; i < currentSize; i++){
                            buffer.enqOne(0);
                        }
                        _this.frameEntries.set(name2, buffer);
                    }
                    buffer.enqOne(value2);
                });
                this.messages.enq(frameStats.messages);
            }
        },
        {
            key: "log",
            value: function log() {
                var maxNameLength = 0;
                this.frameEntries.forEach(function(buffer, name2) {
                    maxNameLength = Math.max(maxNameLength, name2.length);
                });
                var print = function(v) {
                    return v !== void 0 ? v.toFixed(5) : "?";
                };
                this.frameEntries.forEach(function(buffer, name2) {
                    var s = name2 + ": " + " ".repeat(maxNameLength - name2.length);
                    var simpleStats = computeArrayStats(buffer.asArray());
                    if (simpleStats !== void 0) {
                        s += "  [ min=".concat(print(simpleStats.min), ", max=").concat(print(simpleStats.max), ", avg=").concat(print(simpleStats.avg), ", med=").concat(print(simpleStats.median), ", med95=").concat(print(simpleStats.median95), ", med99=").concat(print(simpleStats.median99), ", N=").concat(print(simpleStats.numSamples), " ]");
                    }
                    logger11.log(s);
                });
            }
        }
    ]);
    return FrameStatsArray;
}();
var _PerformanceStatistics = /*#__PURE__*/ function() {
    function _PerformanceStatistics() {
        var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, maxNumFrames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
        _classCallCheck(this, _PerformanceStatistics);
        this.enabled = enabled;
        this.maxNumFrames = maxNumFrames;
        __publicField(this, "currentFrame", new FrameStats());
        __publicField(this, "appResults", /* @__PURE__ */ new Map());
        __publicField(this, "configs", /* @__PURE__ */ new Map());
        __publicField(this, "m_frameEvents");
        _PerformanceStatistics.m_instance = this;
        this.m_frameEvents = new FrameStatsArray(maxNumFrames);
    }
    _createClass(_PerformanceStatistics, [
        {
            key: "isFull",
            get: function get() {
                return this.m_frameEvents.length >= this.maxNumFrames;
            }
        },
        {
            key: "frameEvents",
            get: function get() {
                return this.m_frameEvents;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.clearFrames();
                this.configs.clear();
                this.appResults.clear();
            }
        },
        {
            key: "clearFrames",
            value: function clearFrames() {
                this.m_frameEvents.reset();
                this.currentFrame.reset();
            }
        },
        {
            key: "addWebGLInfo",
            value: function addWebGLInfo(webGlInfo) {
                if (webGlInfo.render !== void 0) {
                    this.currentFrame.setValue("gl.numCalls", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);
                    this.currentFrame.setValue("gl.numPoints", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);
                    this.currentFrame.setValue("gl.numLines", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);
                    this.currentFrame.setValue("gl.numTriangles", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);
                }
                if (webGlInfo.memory !== void 0) {
                    this.currentFrame.setValue("gl.numGeometries", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);
                    this.currentFrame.setValue("gl.numTextures", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);
                }
                if (webGlInfo.programs !== void 0) {
                    this.currentFrame.setValue("gl.numPrograms", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);
                }
            }
        },
        {
            key: "addMemoryInfo",
            value: function addMemoryInfo() {
                if (window !== void 0 && window.performance !== void 0) {
                    var memory = window.performance.memory;
                    if (memory !== void 0) {
                        this.currentFrame.setValue("memory.totalJSHeapSize", memory.totalJSHeapSize);
                        this.currentFrame.setValue("memory.usedJSHeapSize", memory.usedJSHeapSize);
                        this.currentFrame.setValue("memory.jsHeapSizeLimit", memory.jsHeapSizeLimit);
                    }
                }
            }
        },
        {
            key: "storeAndClearFrameInfo",
            value: function storeAndClearFrameInfo() {
                if (this.m_frameEvents.length >= this.maxNumFrames) {
                    return false;
                }
                this.m_frameEvents.addFrame(this.currentFrame);
                this.currentFrame.reset();
                return true;
            }
        },
        {
            key: "log",
            value: function log(header, footer) {
                logger11.log(header !== void 0 ? header : "PerformanceStatistics");
                var appResults = this.appResults;
                appResults.forEach(function(value2, name2) {
                    logger11.log(name2, value2);
                });
                var configs = this.configs;
                configs.forEach(function(value2, name2) {
                    logger11.log(name2, value2);
                });
                this.m_frameEvents.log();
                if (footer !== void 0) {
                    logger11.log(footer);
                }
            }
        },
        {
            key: "getAsPlainObject",
            value: function getAsPlainObject() {
                var onlyLastFrame = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                var appResults = {};
                var configs = {};
                var frames = {};
                var plainObject = {
                    configs: configs,
                    appResults: appResults,
                    frames: frames
                };
                var appResultValues = this.appResults;
                appResultValues.forEach(function(value2, name2) {
                    appResults[name2] = value2;
                });
                var configValues = this.configs;
                configValues.forEach(function(value2, name2) {
                    configs[name2] = value2;
                });
                if (onlyLastFrame) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = this.m_frameEvents.frameEntries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _value = _slicedToArray(_step.value, 2), name2 = _value[0], buffer = _value[1];
                            frames[name2] = buffer.bottom;
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else {
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = this.m_frameEvents.frameEntries[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var _value1 = _slicedToArray(_step1.value, 2), name21 = _value1[0], buffer1 = _value1[1];
                            frames[name21] = buffer1.asArray();
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                }
                plainObject.messages = this.m_frameEvents.messages.asArray();
                return plainObject;
            }
        },
        {
            key: "getLastFrameStatistics",
            value: function getLastFrameStatistics() {
                return this.getAsPlainObject(true);
            }
        },
        {
            key: "getAsSimpleFrameStatistics",
            value: function getAsSimpleFrameStatistics() {
                var onlyLastFrame = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                var configs = /* @__PURE__ */ new Map();
                var appResults = /* @__PURE__ */ new Map();
                var frames = /* @__PURE__ */ new Map();
                var simpleStatistics = {
                    configs: configs,
                    appResults: appResults,
                    frames: frames,
                    messages: this.m_frameEvents.messages.asArray()
                };
                var appResultValues = this.appResults;
                appResultValues.forEach(function(value2, name2) {
                    appResults.set(name2, value2);
                });
                var configValues = this.configs;
                configValues.forEach(function(value2, name2) {
                    configs.set(name2, value2);
                });
                if (onlyLastFrame) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = this.m_frameEvents.frameEntries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _value = _slicedToArray(_step.value, 2), name2 = _value[0], buffer = _value[1];
                            frames.set(name2, buffer.bottom);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else {
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = this.m_frameEvents.frameEntries[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var _value1 = _slicedToArray(_step1.value, 2), name21 = _value1[0], buffer1 = _value1[1];
                            frames.set(name21, buffer1.asArray());
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                }
                return simpleStatistics;
            }
        }
    ], [
        {
            key: "instance",
            get: function get() {
                if (_PerformanceStatistics.m_instance === void 0) {
                    _PerformanceStatistics.m_instance = new _PerformanceStatistics(false, 0);
                }
                return _PerformanceStatistics.m_instance;
            }
        }
    ]);
    return _PerformanceStatistics;
}();
var PerformanceStatistics = _PerformanceStatistics;
__publicField(PerformanceStatistics, "m_instance");
// src/mapview/MapViewTaskScheduler.ts
var DEFAULT_MAX_FPS = 60;
var DEFAULT_PROCESSING_ESTIMATE_TIME = 2;
var UPDATE_EVENT = {
    type: "update"
};
var MapViewTaskScheduler = /*#__PURE__*/ function(_EventDispatcher) {
    _inherits(MapViewTaskScheduler, _EventDispatcher);
    var _super = _createSuper(MapViewTaskScheduler);
    function MapViewTaskScheduler() {
        var m_maxFps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MAX_FPS;
        _classCallCheck(this, MapViewTaskScheduler);
        var _this;
        _this = _super.call(this);
        _this.m_maxFps = m_maxFps;
        __publicField(_assertThisInitialized(_this), "m_taskQueue");
        __publicField(_assertThisInitialized(_this), "m_throttlingEnabled", false);
        _this.m_taskQueue = new TaskQueue({
            groups: [
                "fetch" /* FETCH_AND_DECODE */ ,
                "create" /* CREATE */ 
            ],
            prioSortFn: function(a, b) {
                return a.getPriority() - b.getPriority();
            }
        });
        _this.maxFps = m_maxFps;
        return _this;
    }
    _createClass(MapViewTaskScheduler, [
        {
            key: "maxFps",
            get: function get() {
                return this.m_maxFps;
            },
            set: function set(fps) {
                this.m_maxFps = fps <= 0 ? DEFAULT_MAX_FPS : fps;
            }
        },
        {
            key: "taskQueue",
            get: function get() {
                return this.m_taskQueue;
            }
        },
        {
            key: "throttlingEnabled",
            get: function get() {
                return this.m_throttlingEnabled === true;
            },
            set: function set(enabled) {
                this.m_throttlingEnabled = enabled;
            }
        },
        {
            key: "requestUpdate",
            value: function requestUpdate() {
                this.dispatchEvent(UPDATE_EVENT);
            }
        },
        {
            key: "processPending",
            value: function processPending(frameStartTime) {
                var _this = this;
                var stats = PerformanceStatistics.instance;
                var currentFrameEvent = stats.enabled ? stats.currentFrame : void 0;
                var startTime;
                if (stats.enabled) {
                    startTime = PerformanceTimer.now();
                }
                this.m_taskQueue.update();
                var numItemsLeft = this.taskQueue.numItemsLeft();
                currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue("TaskScheduler.numPendingTasks", numItemsLeft);
                if (this.throttlingEnabled) {
                    var availableTime = this.spaceInFrame(frameStartTime);
                    availableTime = availableTime > 2 ? availableTime - 2 : availableTime;
                    currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue("TaskScheduler.estimatedAvailableTime", availableTime);
                    var counter = 0;
                    while(availableTime > 0 && numItemsLeft > 0){
                        var shouldProcess2 = function shouldProcess2(task) {
                            var ref;
                            var ref1;
                            availableTime -= (ref1 = (ref = task.estimatedProcessTime) === null || ref === void 0 ? void 0 : ref.call(task)) !== null && ref1 !== void 0 ? ref1 : DEFAULT_PROCESSING_ESTIMATE_TIME;
                            if (availableTime > 0 || counter === 1) {
                                return true;
                            }
                            return false;
                        };
                        var shouldProcess = shouldProcess2;
                        counter++;
                        ;
                        [
                            "create" /* CREATE */ ,
                            "fetch" /* FETCH_AND_DECODE */ 
                        ].forEach(function(tag) {
                            if (_this.m_taskQueue.numItemsLeft(tag)) {
                                _this.m_taskQueue.processNext(tag, shouldProcess2);
                            }
                        });
                        numItemsLeft = this.m_taskQueue.numItemsLeft();
                    }
                    numItemsLeft = this.m_taskQueue.numItemsLeft();
                    if (numItemsLeft > 0) {
                        currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue("TaskScheduler.pendingTasksNotYetProcessed", numItemsLeft);
                        this.requestUpdate();
                    }
                } else {
                    this.m_taskQueue.processNext("create" /* CREATE */ , void 0, this.m_taskQueue.numItemsLeft("create" /* CREATE */ ));
                    this.m_taskQueue.processNext("fetch" /* FETCH_AND_DECODE */ , void 0, this.m_taskQueue.numItemsLeft("fetch" /* FETCH_AND_DECODE */ ));
                }
                if (stats.enabled) {
                    currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue("TaskScheduler.pendingTasksTime", PerformanceTimer.now() - startTime);
                }
            }
        },
        {
            key: "clearQueuedTasks",
            value: function clearQueuedTasks() {
                this.m_taskQueue.clear();
            }
        },
        {
            key: "spaceInFrame",
            value: function spaceInFrame(frameStartTime) {
                var passedTime = (performance || Date).now() - frameStartTime;
                return Math.max(1e3 / this.m_maxFps - passedTime, 0);
            }
        }
    ]);
    return MapViewTaskScheduler;
}(THREE62.EventDispatcher);
// src/mapview/ThemeLoader.ts
var DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;
var ThemeLoader = /*#__PURE__*/ function() {
    function ThemeLoader() {
        _classCallCheck(this, ThemeLoader);
    }
    _createClass(ThemeLoader, null, [
        {
            key: "load",
            value: function load(theme, options) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var uriResolver, themeUrl, response, resolveDefinitions, _logger, contextLoader;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                options = options !== null && options !== void 0 ? options : {};
                                if (!(typeof theme === "string")) {
                                    _ctx.next = 16;
                                    break;
                                }
                                uriResolver = options.uriResolver;
                                themeUrl = uriResolver !== void 0 ? uriResolver.resolveUri(theme) : theme;
                                _ctx.next = 6;
                                return fetch(themeUrl, {
                                    signal: options.signal
                                });
                            case 6:
                                response = _ctx.sent;
                                if (response.ok) {
                                    _ctx.next = 9;
                                    break;
                                }
                                throw new Error("ThemeLoader#load: cannot load theme: ".concat(response.statusText));
                            case 9:
                                _ctx.next = 11;
                                return response.json();
                            case 11:
                                theme = _ctx.sent;
                                theme.url = themeUrl;
                                theme = _this.resolveUrls(theme, options);
                                _ctx.next = 17;
                                break;
                            case 16:
                                if (theme.url === void 0) {
                                    theme.url = getAppBaseUrl();
                                    theme = _this.resolveUrls(theme, options);
                                }
                            case 17:
                                theme.styles = getStyles(theme.styles);
                                if (!(theme === null || theme === void 0)) {
                                    _ctx.next = 20;
                                    break;
                                }
                                throw new Error("ThemeLoader#load: loaded resource is not valid JSON");
                            case 20:
                                resolveDefinitions = getOptionValue(options.resolveDefinitions, false);
                                _ctx.next = 23;
                                return ThemeLoader.resolveBaseThemes(theme, options);
                            case 23:
                                theme = _ctx.sent;
                                if (resolveDefinitions) {
                                    ;
                                    contextLoader = new ContextLogger((_logger = options.logger) !== null && _logger !== void 0 ? _logger : console, "when processing Theme ".concat(theme.url, ":"));
                                    ThemeLoader.resolveThemeReferences(theme, contextLoader);
                                }
                                return _ctx.abrupt("return", theme);
                            case 26:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "isThemeLoaded",
            value: function isThemeLoaded(theme) {
                return theme.extends === void 0 && !isStylesDictionary(theme.styles);
            }
        },
        {
            key: "loadAsync",
            value: function loadAsync(themeUrl) {
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return ThemeLoader.load(themeUrl);
                            case 2:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 3:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "resolveUrls",
            value: function resolveUrls(theme, options) {
                var _this = this;
                if (theme.url === void 0) {
                    return theme;
                }
                var childUrlResolver = composeUriResolvers(options === null || options === void 0 ? void 0 : options.uriResolver, new RelativeUriResolver(theme.url));
                var resolveIncludes = options === void 0 || !(options.resolveIncludeUris === false);
                if (theme.extends && resolveIncludes) {
                    theme.extends = (Array.isArray(theme.extends) ? theme.extends : [
                        theme.extends
                    ]).map(function(baseTheme) {
                        if (typeof baseTheme === "string") {
                            return childUrlResolver.resolveUri(baseTheme);
                        } else {
                            if (baseTheme.url !== void 0) {
                                return baseTheme;
                            } else {
                                baseTheme.url = theme.url;
                                return _this.resolveUrls(baseTheme, options);
                            }
                        }
                    });
                }
                var resolveResources = options === void 0 || !(options.resolveResourceUris === false);
                if (resolveResources) {
                    ThemeLoader.resolveResources(theme, childUrlResolver);
                }
                return theme;
            }
        },
        {
            key: "resolveThemeReferences",
            value: function resolveThemeReferences(theme, contextLogger) {
                if (theme.styles !== void 0) {
                    contextLogger.pushAttr("styles");
                    theme.styles = ThemeLoader.resolveStyles(getStyles(theme.styles), theme.definitions, contextLogger);
                    contextLogger.pop();
                    contextLogger.pop();
                }
                return theme;
            }
        },
        {
            key: "resolveStyles",
            value: function resolveStyles(styles, definitions, contextLogger) {
                var result = [];
                for(var index = 0; index < styles.length; ++index){
                    var currentStyle = styles[index];
                    contextLogger.pushIndex(index);
                    var resolvedStyle = ThemeLoader.resolveStyle(currentStyle, definitions, contextLogger);
                    if (resolvedStyle !== void 0) {
                        result.push(resolvedStyle);
                    } else {
                        contextLogger.warn("invalid style, ignored");
                    }
                    contextLogger.pop();
                }
                return result;
            }
        },
        {
            key: "resolveStyle",
            value: function resolveStyle(style, definitions, contextLogger) {
                if (Array.isArray(style.when)) {
                    contextLogger.pushAttr("when");
                    var resolvedWhen = this.resolveExpressionReferences(style.when, definitions, contextLogger);
                    contextLogger.pop();
                    if (resolvedWhen === void 0) {
                        return void 0;
                    }
                    style.when = resolvedWhen;
                }
                if (style.attr !== void 0) {
                    var attr = style.attr;
                    contextLogger.pushAttr("attr");
                    for(var prop in attr){
                        if (!attr.hasOwnProperty(prop)) {
                            continue;
                        }
                        var value2 = attr[prop];
                        if (!Array.isArray(value2)) {
                            continue;
                        }
                        contextLogger.pushAttr(prop);
                        var resolvedValue = this.resolveExpressionReferences(value2, definitions, contextLogger);
                        contextLogger.pop();
                        if (resolvedValue !== void 0) {
                            attr[prop] = resolvedValue;
                        } else {
                            delete attr[prop];
                        }
                    }
                    contextLogger.pop();
                }
                return style;
            }
        },
        {
            key: "resolveExpressionReferences",
            value: function resolveExpressionReferences(value2, definitions, contextLogger) {
                var failed = false;
                function resolveInternal(node) {
                    if (isJsonExprReference(node)) {
                        var defName = node[1];
                        var def = definitions && definitions[defName];
                        if (def === void 0) {
                            contextLogger.warn("invalid reference '".concat(defName, "' - not found"));
                            failed = true;
                            return void 0;
                        }
                        if (isJsonExpr(def)) {
                            return def;
                        }
                        return getDefinitionValue(def);
                    } else if (Array.isArray(node)) {
                        var result = _toConsumableArray(node);
                        for(var i = 1; i < result.length; ++i){
                            result[i] = resolveInternal(result[i]);
                        }
                        return result;
                    } else {
                        return node;
                    }
                }
                var r = resolveInternal(value2);
                if (failed) {
                    return void 0;
                }
                return r;
            }
        },
        {
            key: "resolveBaseThemes",
            value: function resolveBaseThemes(theme, options) {
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var maxInheritanceDepth, baseThemes, baseThemesMerged, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, baseTheme, actualBaseTheme;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                options = options !== null && options !== void 0 ? options : {};
                                if (!(theme.extends === void 0)) {
                                    _ctx.next = 3;
                                    break;
                                }
                                return _ctx.abrupt("return", theme);
                            case 3:
                                maxInheritanceDepth = getOptionValue(options.maxInheritanceDepth, DEFAULT_MAX_THEME_INTHERITANCE_DEPTH);
                                if (!(maxInheritanceDepth <= 0)) {
                                    _ctx.next = 6;
                                    break;
                                }
                                throw new Error("maxInheritanceDepth reached when attempting to load base theme");
                            case 6:
                                baseThemes = !Array.isArray(theme.extends) ? [
                                    theme.extends
                                ] : theme.extends;
                                delete theme.extends;
                                baseThemesMerged = {};
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 10;
                                _iterator = baseThemes[Symbol.iterator]();
                            case 12:
                                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                    _ctx.next = 21;
                                    break;
                                }
                                baseTheme = _step.value;
                                _ctx.next = 16;
                                return ThemeLoader.load(baseTheme, _objectSpreadProps(_objectSpread({}, options), {
                                    resolveDefinitions: false,
                                    maxInheritanceDepth: maxInheritanceDepth - 1
                                }));
                            case 16:
                                actualBaseTheme = _ctx.sent;
                                baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);
                            case 18:
                                _iteratorNormalCompletion = true;
                                _ctx.next = 12;
                                break;
                            case 21:
                                _ctx.next = 27;
                                break;
                            case 23:
                                _ctx.prev = 23;
                                _ctx.t0 = _ctx["catch"](10);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t0;
                            case 27:
                                _ctx.prev = 27;
                                _ctx.prev = 28;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 30:
                                _ctx.prev = 30;
                                if (!_didIteratorError) {
                                    _ctx.next = 33;
                                    break;
                                }
                                throw _iteratorError;
                            case 33:
                                return _ctx.finish(30);
                            case 34:
                                return _ctx.finish(27);
                            case 35:
                                return _ctx.abrupt("return", ThemeLoader.mergeThemes(theme, baseThemesMerged));
                            case 36:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            10,
                            23,
                            27,
                            35
                        ],
                        [
                            28,
                            ,
                            30,
                            34
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "mergeThemes",
            value: function mergeThemes(theme, baseTheme) {
                var definitions = _objectSpread({}, baseTheme.definitions, theme.definitions);
                var styles;
                var baseStyles = getStyles(baseTheme.styles);
                var themeStyles = getStyles(theme.styles);
                if (baseTheme.styles && theme.styles) {
                    var newStyles = [];
                    var styleIdMap = /* @__PURE__ */ new Map();
                    baseStyles.forEach(function(style) {
                        if (typeof style.id === "string") {
                            if (!styleIdMap.has(style.id)) {
                                styleIdMap.set(style.id, newStyles.length);
                            }
                        }
                        newStyles.push(style);
                    });
                    themeStyles.forEach(function(style) {
                        if (typeof style.extends === "string" && styleIdMap.has(style.extends)) {
                            var baseStyleIndex = styleIdMap.get(style.extends);
                            var baseStyle = newStyles[baseStyleIndex];
                            newStyles[baseStyleIndex] = _objectSpread({}, baseStyle, style);
                            newStyles[baseStyleIndex].extends = void 0;
                            return;
                        }
                        if (typeof style.id === "string" && styleIdMap.has(style.id)) {
                            var styleIndex = styleIdMap.get(style.id);
                            if (newStyles[styleIndex].styleSet === style.styleSet) {
                                newStyles[styleIndex] = style;
                            }
                            return;
                        }
                        newStyles.push(style);
                    });
                    styles = newStyles;
                } else if (baseTheme.styles) {
                    styles = _toConsumableArray(baseStyles);
                } else if (theme.styles) {
                    styles = _toConsumableArray(themeStyles);
                }
                return _objectSpreadProps(_objectSpread({}, baseTheme, theme, ThemeLoader.mergeImageTextures(theme, baseTheme)), {
                    definitions: definitions,
                    styles: styles
                });
            }
        },
        {
            key: "mergeImageTextures",
            value: function mergeImageTextures(theme, baseTheme) {
                var images = _objectSpread({}, baseTheme.images, theme.images);
                var imageTextures = [];
                if (!baseTheme.imageTextures && theme.imageTextures) {
                    imageTextures = theme.imageTextures;
                } else if (baseTheme.imageTextures && !theme.imageTextures) {
                    imageTextures = baseTheme.imageTextures;
                } else if (baseTheme.imageTextures && theme.imageTextures) {
                    imageTextures = theme.imageTextures.slice();
                    baseTheme.imageTextures.forEach(function(val) {
                        if (!imageTextures.find(function(param) {
                            var name2 = param.name;
                            return name2 === val.name;
                        })) {
                            imageTextures.push(val);
                        }
                    });
                }
                return {
                    images: images,
                    imageTextures: imageTextures
                };
            }
        },
        {
            key: "resolveResources",
            value: function resolveResources(theme, childUrlResolver) {
                if (theme.sky && theme.sky.type === "cubemap") {
                    for(var i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i){
                        var faceUrl = theme.sky[SkyCubemapFaceId[i]];
                        if (faceUrl !== void 0) {
                            ;
                            theme.sky[SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);
                        }
                    }
                }
                if (theme.images) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = Object.keys(theme.images)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var name2 = _step.value;
                            var image = theme.images[name2];
                            image.url = childUrlResolver.resolveUri(image.url);
                            if (image.atlas !== void 0) {
                                image.atlas = childUrlResolver.resolveUri(image.atlas);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                if (theme.fontCatalogs) {
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = theme.fontCatalogs[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var font = _step1.value;
                            font.url = childUrlResolver.resolveUri(font.url);
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                }
                if (theme.poiTables) {
                    var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                    try {
                        for(var _iterator2 = theme.poiTables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                            var poiTable = _step2.value;
                            poiTable.url = childUrlResolver.resolveUri(poiTable.url);
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                _iterator2.return();
                            }
                        } finally{
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }
                if (theme.styles !== void 0) {
                    var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
                    try {
                        var _loop = function(_iterator3, _step3) {
                            var style = _step3.value;
                            if (!style.attr) {
                                return "continue";
                            }
                            ;
                            [
                                "map",
                                "normalMap",
                                "displacementMap",
                                "roughnessMap"
                            ].forEach(function(texturePropertyName) {
                                var textureProperty = style.attr[texturePropertyName];
                                if (textureProperty && typeof textureProperty === "string") {
                                    ;
                                    style.attr[texturePropertyName] = childUrlResolver.resolveUri(textureProperty);
                                }
                            });
                        };
                        for(var _iterator3 = getStyles(theme.styles)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true)_loop(_iterator3, _step3);
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                                _iterator3.return();
                            }
                        } finally{
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                }
            }
        }
    ]);
    return ThemeLoader;
}();
// src/mapview/MapViewThemeManager.ts
var logger12 = LoggerManager.instance.create("MapViewThemeManager");
var MapViewThemeManager = /*#__PURE__*/ function() {
    function MapViewThemeManager(m_mapView, m_uriResolver) {
        _classCallCheck(this, MapViewThemeManager);
        this.m_mapView = m_mapView;
        this.m_uriResolver = m_uriResolver;
        __publicField(this, "m_imageCache");
        __publicField(this, "m_updatePromise");
        __publicField(this, "m_abortControllers", []);
        __publicField(this, "m_theme", {});
        this.m_imageCache = new MapViewImageCache();
    }
    _createClass(MapViewThemeManager, [
        {
            key: "setTheme",
            value: function setTheme(theme) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                if (_this.isUpdating()) {
                                    logger12.warn("Formerly set Theme is still updating, update will be canceled");
                                    _this.cancelThemeUpdate();
                                }
                                _this.m_updatePromise = _this.loadTheme(theme).then(function() {
                                    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(theme2) {
                                        return regeneratorRuntime.wrap(function _callee$(_ctx) {
                                            while(1)switch(_ctx.prev = _ctx.next){
                                                case 0:
                                                    _ctx.next = 2;
                                                    return _this.updateTheme(theme2);
                                                case 2:
                                                case "end":
                                                    return _ctx.stop();
                                            }
                                        }, _callee);
                                    }));
                                    return function(theme2) {
                                        return _ref.apply(this, arguments);
                                    };
                                }());
                                _ctx.next = 4;
                                return _this.m_updatePromise;
                            case 4:
                                _this.m_updatePromise = void 0;
                                return _ctx.abrupt("return", _this.m_theme);
                            case 6:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "getTheme",
            value: function getTheme() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                if (!_this.isUpdating()) {
                                    _ctx.next = 3;
                                    break;
                                }
                                _ctx.next = 3;
                                return _this.m_updatePromise;
                            case 3:
                                return _ctx.abrupt("return", _this.m_theme);
                            case 4:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "isUpdating",
            value: function isUpdating() {
                return this.m_updatePromise !== void 0;
            }
        },
        {
            key: "theme",
            get: function get() {
                return this.isUpdating() ? {} : this.m_theme;
            }
        },
        {
            key: "loadTheme",
            value: function loadTheme(theme) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var loadedTheme;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                loadedTheme = {};
                                if (!(typeof theme === "string" || !ThemeLoader.isThemeLoaded(theme))) {
                                    _ctx.next = 13;
                                    break;
                                }
                                _ctx.prev = 2;
                                _ctx.next = 5;
                                return ThemeLoader.load(theme, {
                                    uriResolver: _this.m_uriResolver,
                                    signal: _this.createAbortController().signal
                                });
                            case 5:
                                loadedTheme = _ctx.sent;
                                _ctx.next = 11;
                                break;
                            case 8:
                                _ctx.prev = 8;
                                _ctx.t0 = _ctx["catch"](2);
                                if (_ctx.t0.name === "AbortError") {
                                    logger12.warn("theme loading was aborted due to: ".concat(_ctx.t0));
                                } else {
                                    logger12.error("failed to load theme: ".concat(_ctx.t0));
                                }
                            case 11:
                                _ctx.next = 14;
                                break;
                            case 13:
                                {
                                    loadedTheme = theme;
                                }
                            case 14:
                                return _ctx.abrupt("return", loadedTheme);
                            case 15:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            2,
                            8
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "updateTheme",
            value: function updateTheme(theme) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var environment, _priorities, _styles, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, dataSource;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                environment = _this.m_mapView.sceneEnvironment;
                                _this.m_theme.fog = theme.fog;
                                _this.m_theme.sky = theme.sky;
                                environment.updateSkyBackground(theme.sky);
                                environment.fog.reset(theme.fog);
                                _this.m_theme.lights = theme.lights;
                                environment.updateLighting(theme.lights);
                                _this.m_theme.clearColor = theme.clearColor;
                                _this.m_theme.clearAlpha = theme.clearAlpha;
                                environment.updateClearColor(theme.clearColor, theme.clearAlpha);
                                _this.m_theme.images = theme.images;
                                _this.m_theme.imageTextures = theme.imageTextures;
                                _ctx.next = 14;
                                return _this.updateImages(theme.images, theme.imageTextures);
                            case 14:
                                _this.m_theme.poiTables = theme.poiTables;
                                _ctx.next = 17;
                                return _this.loadPoiTables(theme.poiTables);
                            case 17:
                                _this.m_theme.textStyles = theme.textStyles;
                                _this.m_theme.defaultTextStyle = theme.defaultTextStyle;
                                _this.m_theme.fontCatalogs = theme.fontCatalogs;
                                _ctx.next = 22;
                                return _this.m_mapView.resetTextRenderer(theme.fontCatalogs, theme.textStyles, theme.defaultTextStyle);
                            case 22:
                                if (Array.isArray(theme.priorities)) {
                                    _this.m_theme.priorities = theme.priorities;
                                }
                                ;
                                _this.m_mapView.mapAnchors.setPriorities((_priorities = theme.priorities) !== null && _priorities !== void 0 ? _priorities : []);
                                if (Array.isArray(theme.labelPriorities)) {
                                    _this.m_theme.labelPriorities = theme.labelPriorities;
                                }
                                if (_this.m_theme.styles === void 0) {
                                    _this.m_theme.styles = [];
                                }
                                ;
                                _this.m_theme.styles = (_styles = theme.styles) !== null && _styles !== void 0 ? _styles : [];
                                _this.m_theme.definitions = theme.definitions;
                                environment.clearBackgroundDataSource();
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 32;
                                _iterator = _this.m_mapView.dataSources[Symbol.iterator]();
                            case 34:
                                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                    _ctx.next = 41;
                                    break;
                                }
                                dataSource = _step.value;
                                _ctx.next = 38;
                                return dataSource.setTheme(_this.m_theme);
                            case 38:
                                _iteratorNormalCompletion = true;
                                _ctx.next = 34;
                                break;
                            case 41:
                                _ctx.next = 47;
                                break;
                            case 43:
                                _ctx.prev = 43;
                                _ctx.t0 = _ctx["catch"](32);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t0;
                            case 47:
                                _ctx.prev = 47;
                                _ctx.prev = 48;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 50:
                                _ctx.prev = 50;
                                if (!_didIteratorError) {
                                    _ctx.next = 53;
                                    break;
                                }
                                throw _iteratorError;
                            case 53:
                                return _ctx.finish(50);
                            case 54:
                                return _ctx.finish(47);
                            case 55:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            32,
                            43,
                            47,
                            55
                        ],
                        [
                            48,
                            ,
                            50,
                            54
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "updateCache",
            value: function updateCache() {
                this.updateImages(this.m_theme.images, this.m_theme.imageTextures);
                this.m_mapView.sceneEnvironment.updateLighting(this.m_theme.lights);
                this.m_mapView.sceneEnvironment.updateSkyBackground(this.m_theme.sky, this.m_theme.clearColor);
            }
        },
        {
            key: "imageCache",
            get: function get() {
                return this.m_imageCache;
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                this.m_imageCache.clear();
            }
        },
        {
            key: "loadPoiTables",
            value: function loadPoiTables(poiTables) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _this.m_mapView.poiTableManager.clear();
                                _ctx.next = 3;
                                return _this.m_mapView.poiTableManager.loadPoiTables(poiTables);
                            case 3:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "cancelThemeUpdate",
            value: function cancelThemeUpdate() {
                for(var i = 0; i < this.m_abortControllers.length; i++){
                    this.m_abortControllers[i].abort();
                }
                this.m_abortControllers = [];
                this.m_imageCache.clear();
                this.m_mapView.poiManager.clear();
                this.m_mapView.poiTableManager.clear();
            }
        },
        {
            key: "createAbortController",
            value: function createAbortController() {
                this.m_abortControllers.push(new AbortController());
                return this.m_abortControllers[this.m_abortControllers.length - 1];
            }
        },
        {
            key: "updateImages",
            value: function updateImages(images, imageTextures) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, name2, image;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _this.m_imageCache.clear();
                                _this.m_mapView.poiManager.clear();
                                if (!(images !== void 0)) {
                                    _ctx.next = 30;
                                    break;
                                }
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 4;
                                _iterator = Object.keys(images)[Symbol.iterator]();
                            case 6:
                                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                    _ctx.next = 16;
                                    break;
                                }
                                name2 = _step.value;
                                image = images[name2];
                                _this.m_imageCache.addImage(name2, image.url, image.preload === true);
                                if (!(typeof image.atlas === "string")) {
                                    _ctx.next = 13;
                                    break;
                                }
                                _ctx.next = 13;
                                return _this.m_mapView.poiManager.addTextureAtlas(name2, image.atlas, _this.createAbortController().signal);
                            case 13:
                                _iteratorNormalCompletion = true;
                                _ctx.next = 6;
                                break;
                            case 16:
                                _ctx.next = 22;
                                break;
                            case 18:
                                _ctx.prev = 18;
                                _ctx.t0 = _ctx["catch"](4);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t0;
                            case 22:
                                _ctx.prev = 22;
                                _ctx.prev = 23;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 25:
                                _ctx.prev = 25;
                                if (!_didIteratorError) {
                                    _ctx.next = 28;
                                    break;
                                }
                                throw _iteratorError;
                            case 28:
                                return _ctx.finish(25);
                            case 29:
                                return _ctx.finish(22);
                            case 30:
                                if (imageTextures !== void 0) {
                                    imageTextures.forEach(function(imageTexture) {
                                        _this.m_mapView.poiManager.addImageTexture(imageTexture);
                                    });
                                }
                            case 31:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            4,
                            18,
                            22,
                            30
                        ],
                        [
                            23,
                            ,
                            25,
                            29
                        ]
                    ]);
                }))();
            }
        }
    ]);
    return MapViewThemeManager;
}();
// src/mapview/PickHandler.ts
var THREE64 = __toESM(require("three"));
// src/mapview/PickingRaycaster.ts
var THREE63 = __toESM(require("three"));
function intersectObject(object, raycaster, intersects, recursive) {
    if (object.layers.test(raycaster.layers) && object.visible) {
        var mapObjectAdapter = MapObjectAdapter.get(object);
        if (!mapObjectAdapter || mapObjectAdapter.isPickable()) {
            object.raycast(raycaster, intersects);
        }
    }
    if (recursive === true) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = object.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var child = _step.value;
                intersectObject(child, raycaster, intersects, true);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
}
var PickingRaycaster = /*#__PURE__*/ function(_Raycaster) {
    _inherits(PickingRaycaster, _Raycaster);
    var _super = _createSuper(PickingRaycaster);
    function PickingRaycaster(canvasSize) {
        _classCallCheck(this, PickingRaycaster);
        var _this;
        _this = _super.call(this);
        _this.canvasSize = canvasSize;
        return _this;
    }
    _createClass(PickingRaycaster, [
        {
            key: "intersectObject",
            value: function intersectObject1(object, recursive, optionalTarget) {
                var intersects = optionalTarget !== null && optionalTarget !== void 0 ? optionalTarget : [];
                intersectObject(object, this, intersects, recursive);
                return intersects;
            }
        },
        {
            key: "intersectObjects",
            value: function intersectObjects(objects, recursive, optionalTarget) {
                var intersects = optionalTarget !== null && optionalTarget !== void 0 ? optionalTarget : [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var object = _step.value;
                        intersectObject(object, this, intersects, recursive);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return intersects;
            }
        }
    ]);
    return PickingRaycaster;
}(THREE63.Raycaster);
// src/mapview/PickListener.ts
function defaultSort(lhs, rhs) {
    var _dataSourceOrder;
    var lDataSourceOrder = (_dataSourceOrder = lhs.dataSourceOrder) !== null && _dataSourceOrder !== void 0 ? _dataSourceOrder : 0;
    var _dataSourceOrder1;
    var rDataSourceOrder = (_dataSourceOrder1 = rhs.dataSourceOrder) !== null && _dataSourceOrder1 !== void 0 ? _dataSourceOrder1 : 0;
    if (lDataSourceOrder !== rDataSourceOrder) {
        return rDataSourceOrder - lDataSourceOrder;
    }
    var eps = 1e-4;
    var distanceDiff = lhs.distance - rhs.distance;
    var haveRenderOrder = lhs.renderOrder !== void 0 && rhs.renderOrder !== void 0;
    if (Math.abs(distanceDiff) > eps || !haveRenderOrder) {
        return distanceDiff;
    }
    return rhs.renderOrder - lhs.renderOrder;
}
var PickListener = /*#__PURE__*/ function() {
    function PickListener(m_parameters) {
        _classCallCheck(this, PickListener);
        this.m_parameters = m_parameters;
        __publicField(this, "m_results", []);
        __publicField(this, "m_sorted", true);
        __publicField(this, "m_finished", true);
    }
    _createClass(PickListener, [
        {
            key: "addResult",
            value: function addResult(result) {
                var foundFeatureIdx = this.m_results.findIndex(function(otherResult) {
                    var ref, ref1, ref2, ref3;
                    var sameType = otherResult.type === result.type;
                    var dataSource = (ref1 = (ref = result.intersection) === null || ref === void 0 ? void 0 : ref.object.userData) === null || ref1 === void 0 ? void 0 : ref1.dataSource;
                    var sameDataSource = dataSource && ((ref3 = (ref2 = otherResult.intersection) === null || ref2 === void 0 ? void 0 : ref2.object.userData) === null || ref3 === void 0 ? void 0 : ref3.dataSource) === dataSource;
                    var sameId = result.featureId !== void 0 && otherResult.featureId === result.featureId;
                    var noId = result.featureId === void 0 && otherResult.featureId === void 0;
                    var sameUserData = result.userData && otherResult.userData === result.userData;
                    return sameType && sameDataSource && (sameId || noId && sameUserData);
                });
                if (foundFeatureIdx < 0) {
                    this.m_sorted = false;
                    this.m_finished = false;
                    this.m_results.push(result);
                    return;
                }
                var oldResult = this.m_results[foundFeatureIdx];
                if (defaultSort(result, oldResult) < 0) {
                    this.m_results[foundFeatureIdx] = result;
                    this.m_sorted = false;
                    this.m_finished = false;
                }
            }
        },
        {
            key: "done",
            get: function get() {
                return this.maxResults ? this.m_results.length >= this.maxResults : false;
            }
        },
        {
            key: "finish",
            value: function finish() {
                this.sortResults();
                if (this.maxResults && this.m_results.length > this.maxResults) {
                    this.m_results.length = this.maxResults;
                }
                this.m_finished = true;
            }
        },
        {
            key: "results",
            get: function get() {
                assert(this.m_finished, "finish() was not called before getting the results");
                return this.m_results;
            }
        },
        {
            key: "closestResult",
            get: function get() {
                this.sortResults();
                return this.m_results.length > 0 ? this.m_results[0] : void 0;
            }
        },
        {
            key: "furthestResult",
            get: function get() {
                this.sortResults();
                return this.m_results.length > 0 ? this.m_results[this.m_results.length - 1] : void 0;
            }
        },
        {
            key: "maxResults",
            get: function get() {
                var ref;
                var ref1;
                var maxCount = (ref1 = (ref = this.m_parameters) === null || ref === void 0 ? void 0 : ref.maxResultCount) !== null && ref1 !== void 0 ? ref1 : 0;
                return maxCount > 0 ? maxCount : void 0;
            }
        },
        {
            key: "sortResults",
            value: function sortResults() {
                if (this.m_sorted) {
                    return;
                }
                var zeroDistanceGroup = [];
                var nonZeroDistanceGroup = [];
                this.m_results.sort(defaultSort).forEach(function(result) {
                    return (result.distance === 0 ? zeroDistanceGroup : nonZeroDistanceGroup).push(result);
                });
                this.m_results = zeroDistanceGroup.concat(nonZeroDistanceGroup);
                this.m_sorted = true;
            }
        }
    ]);
    return PickListener;
}();
// src/mapview/PickHandler.ts
var PickObjectType = /* @__PURE__ */ function(PickObjectType2) {
    PickObjectType2[PickObjectType2["Unspecified"] = 0] = "Unspecified";
    PickObjectType2[PickObjectType2["Point"] = 1] = "Point";
    PickObjectType2[PickObjectType2["Line"] = 2] = "Line";
    PickObjectType2[PickObjectType2["Area"] = 3] = "Area";
    PickObjectType2[PickObjectType2["Text"] = 4] = "Text";
    PickObjectType2[PickObjectType2["Icon"] = 5] = "Icon";
    PickObjectType2[PickObjectType2["Object3D"] = 6] = "Object3D";
    return PickObjectType2;
}(PickObjectType || {});
var tmpV32 = new THREE64.Vector3();
var tmpOBB2 = new OrientedBox3();
function intersectDependentObjects(tile, intersects, rayCaster2, checkedDependencies, mapView) {
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = tile.dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var tileKey = _step.value;
            var mortonCode = tileKey.mortonCode();
            if (checkedDependencies.has(mortonCode)) {
                continue;
            }
            checkedDependencies.add(mortonCode);
            var otherTile = mapView.visibleTileSet.getCachedTile(tile.dataSource, tileKey, tile.offset, mapView.frameNumber);
            if (otherTile !== void 0) {
                rayCaster2.intersectObjects(otherTile.objects, true, intersects);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
var PickHandler = /*#__PURE__*/ function() {
    function PickHandler(mapView, camera) {
        var enablePickTechnique = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        _classCallCheck(this, PickHandler);
        this.mapView = mapView;
        this.camera = camera;
        this.enablePickTechnique = enablePickTechnique;
        __publicField(this, "m_pickingRaycaster");
        this.m_pickingRaycaster = new PickingRaycaster(mapView.renderer.getSize(new THREE64.Vector2()));
    }
    _createClass(PickHandler, [
        {
            key: "intersectMapObjects",
            value: function intersectMapObjects(x, y, parameters) {
                var ndc = this.mapView.getNormalizedScreenCoordinates(x, y);
                var rayCaster2 = this.setupRaycaster(x, y);
                var pickListener = new PickListener(parameters);
                if (this.mapView.textElementsRenderer !== void 0) {
                    var _canvas = this.mapView.canvas, clientWidth = _canvas.clientWidth, clientHeight = _canvas.clientHeight;
                    var screenX = ndc.x * clientWidth * 0.5;
                    var screenY = ndc.y * clientHeight * 0.5;
                    var scenePosition = new THREE64.Vector2(screenX, screenY);
                    this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickListener);
                }
                var intersects = [];
                var intersectedTiles = this.getIntersectedTiles(rayCaster2);
                var checkedDependencies = /* @__PURE__ */ new Set();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = intersectedTiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _step.value, tile = _value.tile, distance = _value.distance;
                        if (pickListener.done && pickListener.furthestResult.distance < distance) {
                            break;
                        }
                        intersects.length = 0;
                        rayCaster2.intersectObjects(tile.objects, true, intersects);
                        intersectDependentObjects(tile, intersects, rayCaster2, checkedDependencies, this.mapView);
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = intersects[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var intersect = _step1.value;
                                pickListener.addResult(this.createResult(intersect, tile));
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                intersects.length = 0;
                var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                try {
                    for(var _iterator2 = this.mapView.mapAnchors.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                        var child = _step2.value;
                        rayCaster2.intersectObject(child, true, intersects);
                        var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
                        try {
                            for(var _iterator3 = intersects[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                                var intersect1 = _step3.value;
                                pickListener.addResult(this.createResult(intersect1));
                            }
                        } catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                                    _iterator3.return();
                                }
                            } finally{
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                            _iterator2.return();
                        }
                    } finally{
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
                pickListener.finish();
                return pickListener.results;
            }
        },
        {
            key: "raycasterFromScreenPoint",
            value: function raycasterFromScreenPoint(x, y) {
                this.m_pickingRaycaster.setFromCamera(this.mapView.getNormalizedScreenCoordinates(x, y), this.camera);
                this.mapView.renderer.getSize(this.m_pickingRaycaster.canvasSize);
                return this.m_pickingRaycaster;
            }
        },
        {
            key: "createResult",
            value: function createResult(intersection, tile) {
                var ref, ref1, ref2;
                var pickResult = {
                    type: 0 /* Unspecified */ ,
                    point: intersection.point,
                    distance: intersection.distance,
                    dataSourceName: (ref = intersection.object.userData) === null || ref === void 0 ? void 0 : ref.dataSource,
                    dataSourceOrder: tile === null || tile === void 0 ? void 0 : (ref1 = tile.dataSource) === null || ref1 === void 0 ? void 0 : ref1.dataSourceOrder,
                    intersection: intersection,
                    tileKey: tile === null || tile === void 0 ? void 0 : tile.tileKey
                };
                if (intersection.object.userData === void 0 || intersection.object.userData.feature === void 0) {
                    return pickResult;
                }
                if (this.enablePickTechnique) {
                    pickResult.technique = intersection.object.userData.technique;
                }
                pickResult.renderOrder = (ref2 = intersection.object) === null || ref2 === void 0 ? void 0 : ref2.renderOrder;
                var featureData = intersection.object.userData.feature;
                this.addObjInfo(featureData, intersection, pickResult);
                if (pickResult.userData) {
                    var featureId = getFeatureId(pickResult.userData);
                    pickResult.featureId = featureId === 0 ? void 0 : featureId;
                }
                var pickObjectType;
                switch(featureData.geometryType){
                    case 1 /* Point */ :
                    case 4 /* Text */ :
                        pickObjectType = 1 /* Point */ ;
                        break;
                    case 2 /* Line */ :
                    case 6 /* ExtrudedLine */ :
                    case 3 /* SolidLine */ :
                    case 5 /* TextPath */ :
                        pickObjectType = 2 /* Line */ ;
                        break;
                    case 7 /* Polygon */ :
                    case 8 /* ExtrudedPolygon */ :
                        pickObjectType = 3 /* Area */ ;
                        break;
                    case 9 /* Object3D */ :
                        pickObjectType = 6 /* Object3D */ ;
                        break;
                    default:
                        pickObjectType = 0 /* Unspecified */ ;
                }
                pickResult.type = pickObjectType;
                return pickResult;
            }
        },
        {
            key: "getIntersectedTiles",
            value: function getIntersectedTiles(rayCaster2) {
                var _this = this;
                var tiles = new Array();
                var tileList = this.mapView.visibleTileSet.dataSourceTileList;
                tileList.forEach(function(dataSourceTileList) {
                    if (!dataSourceTileList.dataSource.enablePicking) {
                        return;
                    }
                    dataSourceTileList.renderedTiles.forEach(function(tile) {
                        tmpOBB2.copy(tile.boundingBox);
                        tmpOBB2.position.sub(_this.mapView.worldCenter);
                        var worldOffsetX = tile.computeWorldOffsetX();
                        tmpOBB2.position.x += worldOffsetX;
                        var distance = tmpOBB2.intersectsRay(rayCaster2.ray);
                        if (distance !== void 0) {
                            tiles.push({
                                tile: tile,
                                distance: distance
                            });
                        }
                    });
                });
                tiles.sort(function(lhs, rhs) {
                    return lhs.distance - rhs.distance;
                });
                return tiles;
            }
        },
        {
            key: "addObjInfo",
            value: function addObjInfo(featureData, intersect, pickResult) {
                if (featureData.objInfos === void 0) {
                    return;
                }
                if (_instanceof(pickResult.intersection.object, MapViewPoints)) {
                    pickResult.userData = featureData.objInfos[intersect.index];
                    return;
                }
                if (featureData.starts === void 0 || featureData.starts.length === 0 || typeof intersect.faceIndex !== "number" && intersect.index === void 0) {
                    if (featureData.objInfos.length === 1) {
                        pickResult.userData = featureData.objInfos[0];
                    }
                    return;
                }
                if (featureData.starts.length === 1) {
                    pickResult.userData = featureData.objInfos[0];
                    return;
                }
                var intersectIndex = typeof intersect.faceIndex === "number" ? intersect.faceIndex * 3 : intersect.index;
                var objInfosIndex = 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = featureData.starts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var featureStartIndex = _step.value;
                        if (featureStartIndex > intersectIndex) {
                            break;
                        }
                        objInfosIndex++;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                pickResult.userData = featureData.objInfos[objInfosIndex - 1];
            }
        },
        {
            key: "setupRaycaster",
            value: function setupRaycaster(x, y) {
                var camera = this.mapView.camera;
                var rayCaster2 = this.raycasterFromScreenPoint(x, y);
                var furthestIntersection = this.mapView.getWorldPositionAt(x, y, true);
                var furthestDistance = camera.position.distanceTo(furthestIntersection) / this.mapView.camera.getWorldDirection(tmpV32).dot(rayCaster2.ray.direction);
                rayCaster2.params.Line.threshold = MapViewUtils.calculateWorldSizeByFocalLength(this.mapView.focalLength, furthestDistance, 1);
                return rayCaster2;
            }
        }
    ]);
    return PickHandler;
}();
// src/mapview/poi/PoiManager.ts
var THREE85 = __toESM(require("three"));
// src/text-canvas/rendering/FontCatalog.ts
var THREE69 = __toESM(require("three"));
// src/text-canvas/utils/UnicodeUtils.ts
var UnicodeUtils;
(function(UnicodeUtils2) {
    var isWhiteSpace = function isWhiteSpace(codePoint) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = UnicodeUtils2.whiteSpaceRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var range = _step.value;
                if (codePoint >= range[0] && codePoint <= range[1]) {
                    return true;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return false;
    };
    var isNewLine = function isNewLine(codePoint) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = UnicodeUtils2.newLineRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var range = _step.value;
                if (codePoint >= range[0] && codePoint <= range[1]) {
                    return true;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return false;
    };
    var isPrintable = function isPrintable(codePoint) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = UnicodeUtils2.nonPrintableRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var range = _step.value;
                if (codePoint >= range[0] && codePoint <= range[1]) {
                    return false;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return true;
    };
    var getDirection = function getDirection(codePoint, block) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = UnicodeUtils2.weakBidirectionalRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var weakRange = _step.value;
                if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {
                    return 0.5 /* Weak */ ;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            for(var _iterator1 = UnicodeUtils2.neutralBidirectionalRanges[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var neutralRange = _step1.value;
                if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {
                    return 0 /* Neutral */ ;
                }
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
        var rtl = UnicodeUtils2.rtlBlocks.find(function(element) {
            return element === block;
        });
        if (rtl !== void 0) {
            return -1 /* RTL */ ;
        } else {
            return 1 /* LTR */ ;
        }
    };
    var isRtlMirrored = function isRtlMirrored(codePoint) {
        return UnicodeUtils2.rtlMirroredCodePoints.find(function(element) {
            return element === codePoint;
        }) !== void 0;
    };
    UnicodeUtils2.whiteSpaceRanges = [
        [
            9,
            9
        ],
        [
            32,
            32
        ],
        [
            5760,
            5760
        ],
        [
            8192,
            8198
        ],
        [
            8200,
            8202
        ],
        [
            8287,
            12288
        ],
        [
            6158,
            6158
        ],
        [
            8203,
            8205
        ]
    ];
    UnicodeUtils2.isWhiteSpace = isWhiteSpace;
    UnicodeUtils2.newLineRanges = [
        [
            10,
            13
        ],
        [
            133,
            133
        ],
        [
            8232,
            8233
        ]
    ];
    UnicodeUtils2.isNewLine = isNewLine;
    UnicodeUtils2.nonPrintableRanges = [
        [
            0,
            31
        ],
        [
            127,
            159
        ]
    ];
    UnicodeUtils2.isPrintable = isPrintable;
    var Direction;
    (function(Direction2) {
        Direction2[Direction2["Neutral"] = 0] = "Neutral";
        Direction2[Direction2["Weak"] = 0.5] = "Weak";
        Direction2[Direction2["LTR"] = 1] = "LTR";
        Direction2[Direction2["RTL"] = -1] = "RTL";
    })(Direction = UnicodeUtils2.Direction || (UnicodeUtils2.Direction = {}));
    UnicodeUtils2.rtlBlocks = [
        "Hebrew",
        "Alphabetic Presentation Forms",
        "Arabic",
        "Arabic Supplement",
        "Arabic Extended-A",
        "Arabic Presentation Forms-A",
        "Arabic Presentation Forms-B",
        "Arabic Mathematical Alphabetic Symbols",
        "Indic Siyaq Numbers",
        "Rumi Numeral Symbols",
        "Syriac",
        "Syriac Supplement",
        "Samaritan",
        "Mandaic",
        "Thaana",
        "Mende Kikakui",
        "NKo",
        "Adlam",
        "Hanifi Rohingya"
    ];
    UnicodeUtils2.neutralBidirectionalRanges = [
        [
            32,
            47
        ],
        [
            58,
            64
        ],
        [
            91,
            96
        ],
        [
            123,
            126
        ]
    ];
    UnicodeUtils2.weakBidirectionalRanges = [
        [
            48,
            57
        ],
        [
            1632,
            1641
        ],
        [
            1776,
            1785
        ]
    ];
    UnicodeUtils2.getDirection = getDirection;
    UnicodeUtils2.rtlMirroredCodePoints = [
        40,
        41,
        60,
        62,
        91,
        93,
        123,
        125
    ];
    UnicodeUtils2.isRtlMirrored = isRtlMirrored;
})(UnicodeUtils || (UnicodeUtils = {}));
// src/text-canvas/rendering/GlyphData.ts
var THREE65 = __toESM(require("three"));
var GlyphData = /*#__PURE__*/ function() {
    function GlyphData(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font) {
        var isReplacement = arguments.length > 13 && arguments[13] !== void 0 ? arguments[13] : false;
        _classCallCheck(this, GlyphData);
        this.codePoint = codePoint;
        this.block = block;
        this.width = width;
        this.height = height;
        this.advanceX = advanceX;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.texture = texture;
        this.font = font;
        this.isReplacement = isReplacement;
        __publicField(this, "character");
        __publicField(this, "direction");
        __publicField(this, "positions", []);
        __publicField(this, "sourceTextureCoordinates", []);
        __publicField(this, "dynamicTextureCoordinates", []);
        __publicField(this, "copyIndex", 0);
        __publicField(this, "isInCache", false);
        this.character = String.fromCodePoint(codePoint);
        this.direction = UnicodeUtils.getDirection(codePoint, block);
        var left = this.offsetX;
        var right = left + this.width;
        var top = font.metrics.lineHeight - this.offsetY;
        var bottom = top - this.height;
        this.positions.push(new THREE65.Vector3(left, bottom, 1), new THREE65.Vector3(right, bottom, 1), new THREE65.Vector3(left, top, 1), new THREE65.Vector3(right, top, 1));
        this.sourceTextureCoordinates.push(new THREE65.Vector2(u0, v0), new THREE65.Vector2(u1, v0), new THREE65.Vector2(u0, v1), new THREE65.Vector2(u1, v1));
        this.dynamicTextureCoordinates.push(new THREE65.Vector2(0, 0), new THREE65.Vector2(1, 0), new THREE65.Vector2(0, 1), new THREE65.Vector2(1, 1));
    }
    _createClass(GlyphData, [
        {
            key: "clone",
            value: function clone() {
                return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font, this.isReplacement);
            }
        }
    ]);
    return GlyphData;
}();
// src/text-canvas/rendering/GlyphTextureCache.ts
var THREE67 = __toESM(require("three"));
// src/text-canvas/rendering/TextMaterials.ts
var THREE66 = __toESM(require("three"));
var SdfShaderChunks = {
    sdf_attributes: "\n        attribute vec4 position;\n        attribute vec4 uv;\n        attribute vec4 color;\n        attribute vec4 bgColor;\n        ",
    sdf_varying: "\n        varying vec4 vColor;\n        varying float vWeight;\n        varying vec2 vUv;\n        varying float vRotation;\n        ",
    sdf_varying_computation: "\n        #if BG_TEXT\n        vColor = bgColor;\n        vWeight = uv.w;\n        #else\n        vColor = color;\n        vWeight = uv.z;\n        #endif\n        vUv = vec2(uv.xy);\n        vRotation = position.w;\n        ",
    sdf_frag_uniforms: "\n        uniform sampler2D sdfTexture;\n        uniform vec4 sdfParams;\n        ",
    sdf_sampling_functions: "\n        float median(float r, float g, float b) {\n            return max(min(r, g), min(max(r, g), b));\n        }\n\n        float getDistance(vec2 uvOffset) {\n            vec3 texSample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;\n            #if MSDF\n            return median(texSample.r, texSample.g, texSample.b);\n            #else\n            return texSample.r;\n            #endif\n        }\n\n        float getOpacity(vec2 uvOffset, float weight) {\n            vec2 uv = vUv + uvOffset;\n            vec2 rotatedUVs = abs(vec2(\n                cos(vRotation) * uv.x - sin(vRotation) * uv.y,\n                sin(vRotation) * uv.x + cos(vRotation) * uv.y));\n\n            float dx = dFdx(rotatedUVs.x) * sdfParams.x;\n            float dy = dFdy(rotatedUVs.y) * sdfParams.y;\n            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );\n\n            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;\n            return clamp(dist * toPixels + 0.5, 0.0, 1.0);\n        }\n        "
};
Object.assign(THREE66.ShaderChunk, SdfShaderChunks);
var clearVertexSource = "\n    attribute vec2 position;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }";
var clearFragmentSource = "\n    precision highp float;\n    precision highp int;\n\n    void main() {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }";
var copyVertexSource = "\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vUv;\n\n    void main() {\n        vUv = vec3(uv.xy, position.z);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }";
var copyFragmentSource = "\n    precision highp float;\n    precision highp int;\n\n    uniform float pageOffset;\n    uniform sampler2D page0;\n    uniform sampler2D page1;\n    uniform sampler2D page2;\n    uniform sampler2D page3;\n    uniform sampler2D page4;\n    uniform sampler2D page5;\n    uniform sampler2D page6;\n    uniform sampler2D page7;\n\n    varying vec3 vUv;\n\n    void main() {\n        vec4 texSample = vec4(0.0);\n        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;\n        else if (vUv.z < pageOffset + 1.0) texSample = texture2D(page0, vUv.xy);\n        else if (vUv.z < pageOffset + 2.0) texSample = texture2D(page1, vUv.xy);\n        else if (vUv.z < pageOffset + 3.0) texSample = texture2D(page2, vUv.xy);\n        else if (vUv.z < pageOffset + 4.0) texSample = texture2D(page3, vUv.xy);\n        else if (vUv.z < pageOffset + 5.0) texSample = texture2D(page4, vUv.xy);\n        else if (vUv.z < pageOffset + 6.0) texSample = texture2D(page5, vUv.xy);\n        else if (vUv.z < pageOffset + 7.0) texSample = texture2D(page6, vUv.xy);\n        else texSample = texture2D(page7, vUv.xy);\n\n        gl_FragColor = texSample;\n    }";
var sdfTextVertexSource = "\n    #include <sdf_attributes>\n    #include <sdf_varying>\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        #include <sdf_varying_computation>\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n    }";
var sdfTextFragmentSource = "\n    precision highp float;\n    precision highp int;\n\n    #include <sdf_varying>\n    #include <sdf_frag_uniforms>\n    #include <sdf_sampling_functions>\n\n    void main() {\n        vec4 color = vColor;\n        color.a *= getOpacity(vec2(0.0), vWeight);\n        if (color.a < 0.05) {\n            discard;\n        }\n        gl_FragColor = color;\n    }";
var RawShaderMaterial4 = /*#__PURE__*/ function(_RawShaderMaterial) {
    _inherits(RawShaderMaterial4, _RawShaderMaterial);
    var _super = _createSuper(RawShaderMaterial4);
    function RawShaderMaterial4(params) {
        _classCallCheck(this, RawShaderMaterial4);
        var isWebGL2 = (params === null || params === void 0 ? void 0 : params.rendererCapabilities.isWebGL2) === true;
        var shaderParams = params ? _objectSpreadProps(_objectSpread({}, params), {
            glslVersion: isWebGL2 ? THREE66.GLSL3 : THREE66.GLSL1,
            vertexShader: isWebGL2 && params.vertexShader ? convertVertexShaderToWebGL2(params.vertexShader) : params.vertexShader,
            fragmentShader: isWebGL2 && params.fragmentShader ? convertFragmentShaderToWebGL2(params.fragmentShader) : params.fragmentShader
        }) : void 0;
        if (shaderParams) {
            delete shaderParams.rendererCapabilities;
        }
        return _super.call(this, shaderParams);
    }
    return RawShaderMaterial4;
}(THREE66.RawShaderMaterial);
var GlyphClearMaterial = /*#__PURE__*/ function(RawShaderMaterial4) {
    _inherits(GlyphClearMaterial, RawShaderMaterial4);
    var _super = _createSuper(GlyphClearMaterial);
    function GlyphClearMaterial(params) {
        _classCallCheck(this, GlyphClearMaterial);
        var shaderParams = params ? {
            name: "GlyphClearMaterial",
            vertexShader: clearVertexSource,
            fragmentShader: clearFragmentSource,
            uniforms: {},
            depthTest: false,
            depthWrite: false,
            rendererCapabilities: params.rendererCapabilities
        } : void 0;
        return _super.call(this, shaderParams);
    }
    return GlyphClearMaterial;
}(RawShaderMaterial4);
var GlyphCopyMaterial = /*#__PURE__*/ function(RawShaderMaterial4) {
    _inherits(GlyphCopyMaterial, RawShaderMaterial4);
    var _super = _createSuper(GlyphCopyMaterial);
    function GlyphCopyMaterial(params) {
        _classCallCheck(this, GlyphCopyMaterial);
        var shaderParams = params ? {
            name: "GlyphCopyMaterial",
            vertexShader: copyVertexSource,
            fragmentShader: copyFragmentSource,
            uniforms: {
                pageOffset: new THREE66.Uniform(0),
                page0: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
                page1: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
                page2: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
                page3: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
                page4: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
                page5: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
                page6: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE),
                page7: new THREE66.Uniform(THREE66.Texture.DEFAULT_IMAGE)
            },
            depthTest: false,
            depthWrite: false,
            rendererCapabilities: params.rendererCapabilities
        } : void 0;
        return _super.call(this, shaderParams);
    }
    return GlyphCopyMaterial;
}(RawShaderMaterial4);
var SdfTextMaterial = /*#__PURE__*/ function(RawShaderMaterial4) {
    _inherits(SdfTextMaterial, RawShaderMaterial4);
    var _super = _createSuper(SdfTextMaterial);
    function SdfTextMaterial(params) {
        _classCallCheck(this, SdfTextMaterial);
        var _this;
        var shaderParams = params ? {
            name: "SdfTextMaterial",
            vertexShader: params.vertexSource !== void 0 ? params.vertexSource : sdfTextVertexSource,
            fragmentShader: params.fragmentSource !== void 0 ? params.fragmentSource : sdfTextFragmentSource,
            uniforms: {
                sdfTexture: new THREE66.Uniform(params.texture),
                sdfParams: new THREE66.Uniform(new THREE66.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))
            },
            defines: {
                MSDF: params.isMsdf ? 1 : 0,
                BG_TEXT: params.isBackground ? 1 : 0
            },
            depthTest: true,
            depthWrite: false,
            side: THREE66.DoubleSide,
            transparent: true,
            rendererCapabilities: params.rendererCapabilities
        } : void 0;
        _this = _super.call(this, shaderParams);
        _this.extensions.derivatives = true;
        return _this;
    }
    return SdfTextMaterial;
}(RawShaderMaterial4);
// src/text-canvas/rendering/GlyphTextureCache.ts
var MAX_NUM_COPY_PAGES = 8;
var MAX_TEXTURE_SIZE = 4096;
var GlyphTextureCache = /*#__PURE__*/ function() {
    function GlyphTextureCache(capacity, entryWidth, entryHeight) {
        _classCallCheck(this, GlyphTextureCache);
        this.capacity = capacity;
        this.entryWidth = entryWidth;
        this.entryHeight = entryHeight;
        __publicField(this, "m_cacheWidth");
        __publicField(this, "m_cacheHeight");
        __publicField(this, "m_textureSize");
        __publicField(this, "m_entryCache");
        __publicField(this, "m_scene");
        __publicField(this, "m_camera");
        __publicField(this, "m_rt");
        __publicField(this, "m_copyTextureSet");
        __publicField(this, "m_copyTransform");
        __publicField(this, "m_copyPositions");
        __publicField(this, "m_copyMaterial");
        __publicField(this, "m_copyVertexBuffer");
        __publicField(this, "m_copyPositionAttribute");
        __publicField(this, "m_copyUVAttribute");
        __publicField(this, "m_copyGeometry");
        __publicField(this, "m_copyMesh");
        __publicField(this, "m_copyGeometryDrawCount");
        __publicField(this, "m_clearMaterial");
        __publicField(this, "m_clearPositionAttribute");
        __publicField(this, "m_clearGeometry");
        __publicField(this, "m_clearMesh");
        __publicField(this, "m_clearGeometryDrawCount");
        var nRows = Math.floor(Math.sqrt(capacity));
        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;
        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;
        this.m_textureSize = new THREE67.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);
        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {
            console.warn("GlyphTextureCache texture size (" + this.m_textureSize.x + ", " + this.m_textureSize.y + ") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (" + MAX_TEXTURE_SIZE + ").\nThis could result in rendering errors on some devices.\nPlease consider reducing its capacity or input assets size.");
        }
        this.m_entryCache = new LRUCache(capacity);
        this.initCacheEntries();
        this.m_scene = new THREE67.Scene();
        this.m_camera = new THREE67.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);
        this.m_camera.position.z = 1;
        this.m_camera.updateMatrixWorld(false);
        this.m_rt = new THREE67.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {
            wrapS: THREE67.ClampToEdgeWrapping,
            wrapT: THREE67.ClampToEdgeWrapping,
            depthBuffer: false,
            stencilBuffer: false
        });
        this.m_copyTextureSet = /* @__PURE__ */ new Set();
        this.m_copyTransform = new THREE67.Matrix3();
        this.m_copyPositions = [];
        this.m_copyPositions.push(new THREE67.Vector2(), new THREE67.Vector2(), new THREE67.Vector2(), new THREE67.Vector2());
        this.m_copyVertexBuffer = new THREE67.InterleavedBuffer(new Float32Array(capacity * 20), 5);
        this.m_copyVertexBuffer.setUsage(THREE67.DynamicDrawUsage);
        this.m_copyPositionAttribute = new THREE67.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);
        this.m_copyUVAttribute = new THREE67.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);
        this.m_copyGeometry = new THREE67.BufferGeometry();
        this.m_copyGeometry.setAttribute("position", this.m_copyPositionAttribute);
        this.m_copyGeometry.setAttribute("uv", this.m_copyUVAttribute);
        var copyIndexBuffer = new THREE67.BufferAttribute(new Uint32Array(capacity * 6), 1);
        copyIndexBuffer.setUsage(THREE67.DynamicDrawUsage);
        this.m_copyGeometry.setIndex(copyIndexBuffer);
        this.m_copyMesh = new THREE67.Mesh(this.m_copyGeometry);
        this.m_copyMesh.frustumCulled = false;
        this.m_copyGeometryDrawCount = 0;
        this.m_clearPositionAttribute = new THREE67.BufferAttribute(new Float32Array(capacity * 8), 2);
        this.m_clearPositionAttribute.setUsage(THREE67.DynamicDrawUsage);
        this.m_clearGeometry = new THREE67.BufferGeometry();
        this.m_clearGeometry.setAttribute("position", this.m_clearPositionAttribute);
        var clearIndexBuffer = new THREE67.BufferAttribute(new Uint32Array(capacity * 6), 1);
        clearIndexBuffer.setUsage(THREE67.DynamicDrawUsage);
        this.m_clearGeometry.setIndex(clearIndexBuffer);
        this.m_clearMesh = new THREE67.Mesh(this.m_clearGeometry);
        this.m_clearMesh.frustumCulled = false;
        this.m_clearGeometryDrawCount = 0;
        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);
    }
    _createClass(GlyphTextureCache, [
        {
            key: "dispose",
            value: function dispose() {
                var ref, ref1;
                this.m_entryCache.clear();
                this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);
                this.m_rt.dispose();
                (ref = this.m_clearMaterial) === null || ref === void 0 ? void 0 : ref.dispose();
                (ref1 = this.m_copyMaterial) === null || ref1 === void 0 ? void 0 : ref1.dispose();
                this.m_copyTextureSet.clear();
                this.m_clearGeometry.dispose();
                this.m_copyGeometry.dispose();
            }
        },
        {
            key: "texture",
            get: function get() {
                return this.m_rt.texture;
            }
        },
        {
            key: "textureSize",
            get: function get() {
                return this.m_textureSize;
            }
        },
        {
            key: "add",
            value: function add(hash, glyph) {
                var entry = this.m_entryCache.get(hash);
                if (entry !== void 0) {
                    return;
                }
                var oldestEntry = this.m_entryCache.oldest;
                if (oldestEntry === null) {
                    throw new Error("GlyphTextureCache is uninitialized!");
                }
                this.clearCacheEntry(oldestEntry.value);
                this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);
            }
        },
        {
            key: "has",
            value: function has(hash) {
                return this.m_entryCache.has(hash);
            }
        },
        {
            key: "get",
            value: function get(hash) {
                return this.m_entryCache.get(hash);
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_copyGeometryDrawCount = 0;
                this.m_clearGeometryDrawCount = 0;
                this.m_entryCache.clear();
                this.m_copyTextureSet.clear();
                this.initCacheEntries();
            }
        },
        {
            key: "update",
            value: function update(renderer) {
                var oldRenderTarget = null;
                var willClearGeometry = this.m_clearGeometryDrawCount > 0;
                var willCopyGeometry = this.m_copyGeometryDrawCount > 0;
                if (willClearGeometry || willCopyGeometry) {
                    oldRenderTarget = renderer.getRenderTarget();
                    renderer.setRenderTarget(this.m_rt);
                }
                if (willClearGeometry) {
                    if (!this.m_clearMaterial) {
                        this.m_clearMaterial = new GlyphClearMaterial({
                            rendererCapabilities: renderer.capabilities
                        });
                        this.m_clearMesh.material = this.m_clearMaterial;
                    }
                    if (this.m_clearGeometry.index === null) {
                        throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
                    }
                    this.m_clearPositionAttribute.needsUpdate = true;
                    this.m_clearPositionAttribute.updateRange.offset = 0;
                    this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;
                    this.m_clearGeometry.index.needsUpdate = true;
                    this.m_clearGeometry.index.updateRange.offset = 0;
                    this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;
                    this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);
                    this.m_clearMesh.visible = true;
                    this.m_copyMesh.visible = false;
                    renderer.render(this.m_scene, this.m_camera);
                    this.m_clearGeometryDrawCount = 0;
                    this.m_clearMesh.visible = false;
                }
                if (willCopyGeometry) {
                    if (!this.m_copyMaterial) {
                        this.m_copyMaterial = new GlyphCopyMaterial({
                            rendererCapabilities: renderer.capabilities
                        });
                        this.m_copyMesh.material = this.m_copyMaterial;
                    }
                    if (this.m_copyGeometry.index === null) {
                        throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
                    }
                    this.m_copyVertexBuffer.needsUpdate = true;
                    this.m_copyVertexBuffer.updateRange.offset = 0;
                    this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;
                    this.m_copyGeometry.index.needsUpdate = true;
                    this.m_copyGeometry.index.updateRange.offset = 0;
                    this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;
                    this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);
                    this.m_copyMesh.visible = true;
                    var srcPages = Array.from(this.m_copyTextureSet);
                    var nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);
                    for(var copyIndex = 0; copyIndex < nCopies; copyIndex++){
                        var pageOffset = copyIndex * MAX_NUM_COPY_PAGES;
                        this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;
                        for(var i = 0; i < MAX_NUM_COPY_PAGES; i++){
                            var pageIndex = pageOffset + i;
                            if (pageIndex < this.m_copyTextureSet.size) {
                                this.m_copyMaterial.uniforms["page" + i].value = srcPages[pageIndex];
                            }
                        }
                        renderer.render(this.m_scene, this.m_camera);
                    }
                    this.m_copyTextureSet.clear();
                    this.m_copyGeometryDrawCount = 0;
                }
                if (willClearGeometry || willCopyGeometry) {
                    renderer.setRenderTarget(oldRenderTarget);
                }
            }
        },
        {
            key: "initCacheEntries",
            value: function initCacheEntries() {
                var dummyMetrics = {
                    size: 0,
                    distanceRange: 0,
                    base: 0,
                    lineHeight: 0,
                    lineGap: 0,
                    capHeight: 0,
                    xHeight: 0
                };
                var dummyFont = {
                    name: "",
                    metrics: dummyMetrics,
                    charset: ""
                };
                var dummyGlyphData = new GlyphData(0, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE67.Texture.DEFAULT_IMAGE, dummyFont);
                for(var i = 0; i < this.m_cacheHeight; i++){
                    for(var j = 0; j < this.m_cacheWidth; j++){
                        var dummyEntry = {
                            glyphData: dummyGlyphData,
                            location: new THREE67.Vector2(j, i)
                        };
                        this.m_entryCache.set("Dummy_".concat(i * this.m_cacheHeight + j), dummyEntry);
                    }
                }
            }
        },
        {
            key: "copyGlyphToCache",
            value: function copyGlyphToCache(hash, glyph, cacheLocation) {
                this.m_copyTextureSet.add(glyph.texture);
                var copyTextureIndex = 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_copyTextureSet.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var value2 = _step.value;
                        if (value2 === glyph.texture) {
                            break;
                        }
                        copyTextureIndex++;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                glyph.copyIndex = copyTextureIndex;
                this.m_copyTransform.set(1, 0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0, 1, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0, 0, 0);
                for(var i = 0; i < 4; ++i){
                    this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);
                    this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);
                }
                if (this.m_copyGeometryDrawCount >= this.capacity) {
                    return;
                }
                var baseVertex = this.m_copyGeometryDrawCount * 4;
                var baseIndex = this.m_copyGeometryDrawCount * 6;
                for(var i1 = 0; i1 < 4; ++i1){
                    this.m_copyPositionAttribute.setXYZ(baseVertex + i1, this.m_copyPositions[i1].x, this.m_copyPositions[i1].y, glyph.copyIndex);
                    this.m_copyUVAttribute.setXY(baseVertex + i1, glyph.sourceTextureCoordinates[i1].x, glyph.sourceTextureCoordinates[i1].y);
                }
                if (this.m_copyGeometry.index === null) {
                    throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
                }
                this.m_copyGeometry.index.setX(baseIndex, baseVertex);
                this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);
                this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);
                this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);
                this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);
                this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);
                ++this.m_copyGeometryDrawCount;
                var u0 = this.m_copyPositions[0].x / this.m_textureSize.x;
                var v0 = this.m_copyPositions[0].y / this.m_textureSize.y;
                var u1 = this.m_copyPositions[3].x / this.m_textureSize.x;
                var v1 = this.m_copyPositions[3].y / this.m_textureSize.y;
                glyph.dynamicTextureCoordinates[0].set(u0, v0);
                glyph.dynamicTextureCoordinates[1].set(u1, v0);
                glyph.dynamicTextureCoordinates[2].set(u0, v1);
                glyph.dynamicTextureCoordinates[3].set(u1, v1);
                glyph.isInCache = true;
                this.m_entryCache.set(hash, {
                    glyphData: glyph,
                    location: cacheLocation
                });
            }
        },
        {
            key: "clearCacheEntry",
            value: function clearCacheEntry(entry) {
                entry.glyphData.isInCache = false;
                this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);
                this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);
                this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
                this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
                if (this.m_clearGeometryDrawCount >= this.capacity) {
                    return;
                }
                var baseVertex = this.m_clearGeometryDrawCount * 4;
                var baseIndex = this.m_clearGeometryDrawCount * 6;
                for(var i = 0; i < 4; ++i){
                    this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);
                }
                if (this.m_clearGeometry.index === null) {
                    throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
                }
                this.m_clearGeometry.index.setX(baseIndex, baseVertex);
                this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);
                this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);
                this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);
                this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);
                this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);
                ++this.m_clearGeometryDrawCount;
            }
        }
    ]);
    return GlyphTextureCache;
}();
// src/text-canvas/rendering/TextStyle.ts
var THREE68 = __toESM(require("three"));
var FontStyle = /* @__PURE__ */ function(FontStyle2) {
    FontStyle2[FontStyle2["Regular"] = 0] = "Regular";
    FontStyle2[FontStyle2["Bold"] = 1] = "Bold";
    FontStyle2[FontStyle2["Italic"] = 2] = "Italic";
    FontStyle2[FontStyle2["BoldItalic"] = 3] = "BoldItalic";
    return FontStyle2;
}(FontStyle || {});
var FontVariant = /* @__PURE__ */ function(FontVariant2) {
    FontVariant2[FontVariant2["Regular"] = 0] = "Regular";
    FontVariant2[FontVariant2["AllCaps"] = 1] = "AllCaps";
    FontVariant2[FontVariant2["SmallCaps"] = 2] = "SmallCaps";
    return FontVariant2;
}(FontVariant || {});
var VerticalAlignment = /* @__PURE__ */ function(VerticalAlignment3) {
    VerticalAlignment3[VerticalAlignment3["Above"] = 0] = "Above";
    VerticalAlignment3[VerticalAlignment3["Center"] = -0.5] = "Center";
    VerticalAlignment3[VerticalAlignment3["Below"] = -1] = "Below";
    return VerticalAlignment3;
}(VerticalAlignment || {});
var HorizontalAlignment = /* @__PURE__ */ function(HorizontalAlignment3) {
    HorizontalAlignment3[HorizontalAlignment3["Left"] = 0] = "Left";
    HorizontalAlignment3[HorizontalAlignment3["Center"] = -0.5] = "Center";
    HorizontalAlignment3[HorizontalAlignment3["Right"] = -1] = "Right";
    return HorizontalAlignment3;
}(HorizontalAlignment || {});
var WrappingMode = /* @__PURE__ */ function(WrappingMode2) {
    WrappingMode2[WrappingMode2["None"] = 0] = "None";
    WrappingMode2[WrappingMode2["Character"] = 1] = "Character";
    WrappingMode2[WrappingMode2["Word"] = 2] = "Word";
    return WrappingMode2;
}(WrappingMode || {});
function hAlignFromPlacement(hP) {
    return hP;
}
function vAlignFromPlacement(vP) {
    return vP;
}
function hPlacementFromAlignment(hA) {
    return hA;
}
function vPlacementFromAlignment(vA) {
    return vA;
}
var DefaultTextStyle;
(function(DefaultTextStyle2) {
    DefaultTextStyle2.DEFAULT_FONT_NAME = "";
    DefaultTextStyle2.DEFAULT_FONT_SIZE = {
        unit: Object.freeze(1 /* Pixel */ ),
        size: Object.freeze(16),
        backgroundSize: Object.freeze(0)
    };
    DefaultTextStyle2.DEFAULT_FONT_STYLE = 0 /* Regular */ ;
    DefaultTextStyle2.DEFAULT_FONT_VARIANT = 0 /* Regular */ ;
    DefaultTextStyle2.DEFAULT_ROTATION = 0;
    DefaultTextStyle2.DEFAULT_COLOR = new THREE68.Color(0);
    DefaultTextStyle2.DEFAULT_OPACITY = 1;
    DefaultTextStyle2.DEFAULT_BACKGROUND_COLOR = new THREE68.Color(0);
    DefaultTextStyle2.DEFAULT_BACKGROUND_OPACITY = 0;
    DefaultTextStyle2.DEFAULT_TRACKING = 0;
    DefaultTextStyle2.DEFAULT_LEADING = 0;
    DefaultTextStyle2.DEFAULT_MAX_LINES = Infinity;
    DefaultTextStyle2.DEFAULT_LINE_WIDTH = Infinity;
    DefaultTextStyle2.DEFAULT_CANVAS_ROTATION = 0;
    DefaultTextStyle2.DEFAULT_LINE_ROTATION = 0;
    DefaultTextStyle2.DEFAULT_WRAPPING_MODE = 2 /* Word */ ;
    DefaultTextStyle2.DEFAULT_VERTICAL_ALIGNMENT = 0 /* Above */ ;
    DefaultTextStyle2.DEFAULT_HORIZONTAL_ALIGNMENT = 0 /* Left */ ;
    DefaultTextStyle2.DEFAULT_PLACEMENTS = [];
})(DefaultTextStyle || (DefaultTextStyle = {}));
var TextRenderStyle = /*#__PURE__*/ function() {
    function TextRenderStyle() {
        var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, TextRenderStyle);
        __publicField(this, "m_params");
        this.m_params = {
            fontName: params.fontName !== void 0 ? params.fontName : DefaultTextStyle.DEFAULT_FONT_NAME,
            fontSize: params.fontSize !== void 0 ? _objectSpread({}, params.fontSize) : {
                unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,
                size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,
                backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize
            },
            fontStyle: params.fontStyle !== void 0 ? params.fontStyle : DefaultTextStyle.DEFAULT_FONT_STYLE,
            fontVariant: params.fontVariant !== void 0 ? params.fontVariant : DefaultTextStyle.DEFAULT_FONT_VARIANT,
            rotation: params.rotation !== void 0 ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,
            color: params.color !== void 0 ? params.color.clone() : DefaultTextStyle.DEFAULT_COLOR.clone(),
            opacity: params.opacity !== void 0 ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,
            backgroundColor: params.backgroundColor !== void 0 ? params.backgroundColor.clone() : DefaultTextStyle.DEFAULT_BACKGROUND_COLOR.clone(),
            backgroundOpacity: params.backgroundOpacity !== void 0 ? params.backgroundOpacity : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY
        };
    }
    _createClass(TextRenderStyle, [
        {
            key: "params",
            get: function get() {
                return this.m_params;
            },
            set: function set(value2) {
                this.m_params = _objectSpread({}, this.m_params, value2);
            }
        },
        {
            key: "fontName",
            get: function get() {
                return this.m_params.fontName;
            },
            set: function set(value2) {
                this.m_params.fontName = value2;
            }
        },
        {
            key: "fontSize",
            get: function get() {
                return this.m_params.fontSize;
            },
            set: function set(value2) {
                this.m_params.fontSize = _objectSpread({}, value2);
            }
        },
        {
            key: "fontStyle",
            get: function get() {
                return this.m_params.fontStyle;
            },
            set: function set(value2) {
                this.m_params.fontStyle = value2;
            }
        },
        {
            key: "fontVariant",
            get: function get() {
                return this.m_params.fontVariant;
            },
            set: function set(value2) {
                this.m_params.fontVariant = value2;
            }
        },
        {
            key: "rotation",
            get: function get() {
                return this.m_params.rotation;
            },
            set: function set(value2) {
                this.m_params.rotation = value2;
            }
        },
        {
            key: "color",
            get: function get() {
                return this.m_params.color;
            },
            set: function set(value2) {
                this.m_params.color.copy(value2);
            }
        },
        {
            key: "backgroundColor",
            get: function get() {
                return this.m_params.backgroundColor;
            },
            set: function set(value2) {
                this.m_params.backgroundColor.copy(value2);
            }
        },
        {
            key: "opacity",
            get: function get() {
                return this.m_params.opacity;
            },
            set: function set(value2) {
                this.m_params.opacity = value2;
            }
        },
        {
            key: "backgroundOpacity",
            get: function get() {
                return this.m_params.backgroundOpacity;
            },
            set: function set(value2) {
                this.m_params.backgroundOpacity = value2;
            }
        },
        {
            key: "clone",
            value: function clone() {
                var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return new TextRenderStyle(_objectSpread({}, this.m_params, params));
            }
        },
        {
            key: "copy",
            value: function copy(source) {
                this.m_params.fontName = source.fontName;
                this.m_params.fontSize = _objectSpread({}, source.fontSize);
                this.m_params.fontStyle = source.fontStyle;
                this.m_params.fontVariant = source.fontVariant;
                this.m_params.rotation = source.rotation;
                this.m_params.color.copy(source.color);
                this.m_params.backgroundColor.copy(source.backgroundColor);
                this.m_params.opacity = source.opacity;
                this.m_params.backgroundOpacity = source.backgroundOpacity;
                return this;
            }
        }
    ]);
    return TextRenderStyle;
}();
var TextLayoutStyle = /*#__PURE__*/ function() {
    function TextLayoutStyle() {
        var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, TextLayoutStyle);
        __publicField(this, "m_params");
        var ref = resolvePlacementAndAlignment(params.horizontalAlignment, params.verticalAlignment, params.placements), horizontalAlignment = ref.horizontalAlignment, verticalAlignment = ref.verticalAlignment, placements = ref.placements;
        this.m_params = {
            tracking: params.tracking !== void 0 ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,
            leading: params.leading !== void 0 ? params.leading : DefaultTextStyle.DEFAULT_LEADING,
            maxLines: params.maxLines !== void 0 ? params.maxLines : DefaultTextStyle.DEFAULT_MAX_LINES,
            lineWidth: params.lineWidth !== void 0 ? params.lineWidth : DefaultTextStyle.DEFAULT_LINE_WIDTH,
            canvasRotation: params.canvasRotation !== void 0 ? params.canvasRotation : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,
            lineRotation: params.lineRotation !== void 0 ? params.lineRotation : DefaultTextStyle.DEFAULT_LINE_ROTATION,
            wrappingMode: params.wrappingMode !== void 0 ? params.wrappingMode : DefaultTextStyle.DEFAULT_WRAPPING_MODE,
            verticalAlignment: verticalAlignment,
            horizontalAlignment: horizontalAlignment,
            placements: placements
        };
    }
    _createClass(TextLayoutStyle, [
        {
            key: "params",
            get: function get() {
                return this.m_params;
            },
            set: function set(value2) {
                this.m_params = _objectSpread({}, this.m_params, value2);
            }
        },
        {
            key: "tracking",
            get: function get() {
                return this.m_params.tracking;
            },
            set: function set(value2) {
                this.m_params.tracking = value2;
            }
        },
        {
            key: "leading",
            get: function get() {
                return this.m_params.leading;
            },
            set: function set(value2) {
                this.m_params.leading = value2;
            }
        },
        {
            key: "maxLines",
            get: function get() {
                return this.m_params.maxLines;
            },
            set: function set(value2) {
                this.m_params.maxLines = value2;
            }
        },
        {
            key: "lineWidth",
            get: function get() {
                return this.m_params.lineWidth;
            },
            set: function set(value2) {
                this.m_params.lineWidth = value2;
            }
        },
        {
            key: "canvasRotation",
            get: function get() {
                return this.m_params.canvasRotation;
            },
            set: function set(value2) {
                this.m_params.canvasRotation = value2;
            }
        },
        {
            key: "lineRotation",
            get: function get() {
                return this.m_params.lineRotation;
            },
            set: function set(value2) {
                this.m_params.lineRotation = value2;
            }
        },
        {
            key: "wrappingMode",
            get: function get() {
                return this.m_params.wrappingMode;
            },
            set: function set(value2) {
                this.m_params.wrappingMode = value2;
            }
        },
        {
            key: "verticalAlignment",
            get: function get() {
                return this.m_params.verticalAlignment;
            },
            set: function set(value2) {
                this.m_params.verticalAlignment = value2;
            }
        },
        {
            key: "horizontalAlignment",
            get: function get() {
                return this.m_params.horizontalAlignment;
            },
            set: function set(value2) {
                this.m_params.horizontalAlignment = value2;
            }
        },
        {
            key: "placements",
            get: function get() {
                return this.m_params.placements;
            },
            set: function set(value2) {
                var ref = resolvePlacementAndAlignment(this.horizontalAlignment, this.verticalAlignment, value2), horizontalAlignment = ref.horizontalAlignment, verticalAlignment = ref.verticalAlignment, placements = ref.placements;
                this.m_params.horizontalAlignment = horizontalAlignment;
                this.m_params.verticalAlignment = verticalAlignment;
                this.m_params.placements = placements;
            }
        },
        {
            key: "clone",
            value: function clone() {
                var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return new TextLayoutStyle(_objectSpread({}, this.m_params, params));
            }
        },
        {
            key: "copy",
            value: function copy(other) {
                this.params = _objectSpread({}, other.params);
                return this;
            }
        }
    ]);
    return TextLayoutStyle;
}();
function resolvePlacementAndAlignment(hAlignment, vAlignment, placementsOpt) {
    var ref;
    var placements = (ref = placementsOpt === null || placementsOpt === void 0 ? void 0 : placementsOpt.map(function(v) {
        return _objectSpread({}, v);
    })) !== null && ref !== void 0 ? ref : DefaultTextStyle.DEFAULT_PLACEMENTS.map(function(v) {
        return _objectSpread({}, v);
    });
    var horizontalAlignment = placements.length > 0 ? hAlignFromPlacement(placements[0].h) : hAlignment !== null && hAlignment !== void 0 ? hAlignment : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;
    var verticalAlignment = placements.length > 0 ? vAlignFromPlacement(placements[0].v) : vAlignment !== null && vAlignment !== void 0 ? vAlignment : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;
    return {
        horizontalAlignment: horizontalAlignment,
        verticalAlignment: verticalAlignment,
        placements: placements
    };
}
// src/text-canvas/rendering/FontCatalog.ts
var ASSETS_PATH = "_Assets/";
var BOLD_ASSETS_PATH = "_BoldAssets/";
var ITALIC_ASSETS_PATH = "_ItalicAssets/";
var BOLD_ITALIC_ASSETS_PATH = "_BoldItalicAssets/";
var REPLACEMENT_PATH = "_Assets/Extra/";
var FontCatalog = /*#__PURE__*/ function() {
    function FontCatalog(url, name2, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {
        _classCallCheck(this, FontCatalog);
        this.url = url;
        this.name = name2;
        this.type = type;
        this.size = size;
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this.distanceRange = distanceRange;
        this.fonts = fonts;
        this.unicodeBlocks = unicodeBlocks;
        this.maxCodePointCount = maxCodePointCount;
        this.m_replacementGlyph = m_replacementGlyph;
        __publicField(this, "m_glyphTextureCache");
        __publicField(this, "m_loadingJson");
        __publicField(this, "m_loadingPages");
        __publicField(this, "m_loadingGlyphs");
        __publicField(this, "m_loadedJson");
        __publicField(this, "m_loadedPages");
        __publicField(this, "m_loadedGlyphs");
        __publicField(this, "showReplacementGlyphs", false);
        this.m_glyphTextureCache = new GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);
        this.m_loadingJson = /* @__PURE__ */ new Map();
        this.m_loadingPages = /* @__PURE__ */ new Map();
        this.m_loadingGlyphs = /* @__PURE__ */ new Map();
        this.m_loadedJson = /* @__PURE__ */ new Map();
        this.m_loadedPages = /* @__PURE__ */ new Map();
        this.m_loadedGlyphs = /* @__PURE__ */ new Map();
    }
    _createClass(FontCatalog, [
        {
            key: "dispose",
            value: function dispose() {
                this.fonts.length = 0;
                this.unicodeBlocks.length = 0;
                this.m_glyphTextureCache.dispose();
                this.m_loadingJson.clear();
                this.m_loadingPages.clear();
                this.m_loadingGlyphs.clear();
                this.m_loadedJson.clear();
                this.m_loadedPages.clear();
                this.m_loadedGlyphs.clear();
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_glyphTextureCache.clear();
                this.m_loadingJson.clear();
                this.m_loadingPages.clear();
                this.m_loadingGlyphs.clear();
                this.m_loadedJson.clear();
                this.m_loadedPages.clear();
                this.m_loadedGlyphs.clear();
            }
        },
        {
            key: "update",
            value: function update(renderer) {
                this.m_glyphTextureCache.update(renderer);
            }
        },
        {
            key: "texture",
            get: function get() {
                return this.m_glyphTextureCache.texture;
            }
        },
        {
            key: "textureSize",
            get: function get() {
                return this.m_glyphTextureCache.textureSize;
            }
        },
        {
            key: "isLoading",
            get: function get() {
                return this.m_loadingJson.size > 0 || this.m_loadingPages.size > 0 || this.m_loadingGlyphs.size > 0;
            }
        },
        {
            key: "loadBlock",
            value: function loadBlock(block, font, fontStyle, loadPages) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var assetsPath, jsonPath, json, jsonPromise, pagePromises, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, page;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                assetsPath = _this.getAssetsPath(fontStyle, font);
                                jsonPath = "".concat(assetsPath, "/").concat(block.name.replace(/ /g, "_"), ".json");
                                json = _this.m_loadedJson.get(jsonPath);
                                if (!(json === void 0)) {
                                    _ctx.next = 25;
                                    break;
                                }
                                jsonPromise = _this.m_loadingJson.get(jsonPath);
                                if (!(jsonPromise === void 0)) {
                                    _ctx.next = 22;
                                    break;
                                }
                                _ctx.prev = 6;
                                jsonPromise = FontCatalog.loadJSON(jsonPath);
                                _this.m_loadingJson.set(jsonPath, jsonPromise);
                                _ctx.next = 11;
                                return jsonPromise;
                            case 11:
                                json = _ctx.sent;
                                _this.m_loadingJson.delete(jsonPath);
                                _this.m_loadedJson.set(jsonPath, json);
                                _ctx.next = 20;
                                break;
                            case 16:
                                _ctx.prev = 16;
                                _ctx.t0 = _ctx["catch"](6);
                                console.error(_ctx.t0);
                                _this.m_loadingJson.delete(jsonPath);
                            case 20:
                                _ctx.next = 25;
                                break;
                            case 22:
                                _ctx.next = 24;
                                return jsonPromise;
                            case 24:
                                json = _ctx.sent;
                            case 25:
                                pagePromises = [];
                                if (!(loadPages === true)) {
                                    _ctx.next = 44;
                                    break;
                                }
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 28;
                                for(_iterator = json.pages[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    page = _step.value;
                                    pagePromises.push(_this.loadPage("".concat(assetsPath, "/").concat(page)));
                                }
                                _ctx.next = 36;
                                break;
                            case 32:
                                _ctx.prev = 32;
                                _ctx.t1 = _ctx["catch"](28);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t1;
                            case 36:
                                _ctx.prev = 36;
                                _ctx.prev = 37;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 39:
                                _ctx.prev = 39;
                                if (!_didIteratorError) {
                                    _ctx.next = 42;
                                    break;
                                }
                                throw _iteratorError;
                            case 42:
                                return _ctx.finish(39);
                            case 43:
                                return _ctx.finish(36);
                            case 44:
                                _ctx.next = 46;
                                return Promise.all(pagePromises);
                            case 46:
                                return _ctx.abrupt("return", json);
                            case 47:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            6,
                            16
                        ],
                        [
                            28,
                            32,
                            36,
                            44
                        ],
                        [
                            37,
                            ,
                            39,
                            43
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "removeBlock",
            value: function removeBlock(block, font, fontStyle) {
                var assetsPath = this.getAssetsPath(fontStyle, font);
                var jsonPath = "".concat(assetsPath, "/").concat(block.name.replace(/ /g, "_"), ".json");
                var json = this.m_loadedJson.get(jsonPath);
                if (json !== void 0) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = json.pages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var page = _step.value;
                            var pagePath = "".concat(assetsPath, "/").concat(page);
                            this.m_loadingPages.delete(pagePath);
                            this.m_loadedPages.delete(pagePath);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    this.m_loadingJson.delete(jsonPath);
                    this.m_loadedJson.delete(jsonPath);
                }
            }
        },
        {
            key: "loadCharset",
            value: function loadCharset(input, style) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var fontName, fontStyle, shouldTransform, charset, glyphPromises, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                fontName = style.fontName;
                                fontStyle = style.fontStyle;
                                shouldTransform = style.fontVariant === 1 /* AllCaps */  || style.fontVariant === 2 /* SmallCaps */ ;
                                charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\s\S](?=([\s\S]+))/g, function(c, s) {
                                    return s.indexOf(c) + 1 ? "" : c;
                                });
                                glyphPromises = [];
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 6;
                                _loop = function(_iterator, _step) {
                                    var char = _step.value;
                                    var codePoint = char.codePointAt(0);
                                    var font = _this.getFont(codePoint, fontName);
                                    var fontHash = "".concat(font.name, "_").concat(fontStyle);
                                    var glyphHash = "".concat(fontHash, "_").concat(codePoint);
                                    var fontGlyphMap = _this.m_loadedGlyphs.get(fontHash);
                                    if (fontGlyphMap === void 0) {
                                        fontGlyphMap = /* @__PURE__ */ new Map();
                                        _this.m_loadedGlyphs.set(fontHash, fontGlyphMap);
                                    }
                                    var glyph = fontGlyphMap.get(codePoint);
                                    if (glyph === void 0) {
                                        var glyphPromise = _this.m_loadingGlyphs.get(glyphHash);
                                        if (glyphPromise === void 0) {
                                            if (!font.charset.includes(String.fromCodePoint(codePoint))) {
                                                var replacementGlyph = _this.createReplacementGlyph(codePoint, char, font);
                                                fontGlyphMap.set(codePoint, replacementGlyph);
                                                _this.m_glyphTextureCache.add(glyphHash, replacementGlyph);
                                                return "continue";
                                            }
                                            var charUnicodeBlock = void 0;
                                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                            try {
                                                for(var _iterator1 = _this.unicodeBlocks[Symbol.iterator](), _step1; !(_iteratorNormalCompletion = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion = true){
                                                    var block = _step1.value;
                                                    if (codePoint >= block.min && codePoint <= block.max) {
                                                        charUnicodeBlock = block;
                                                        break;
                                                    }
                                                }
                                            } catch (err) {
                                                _didIteratorError = true;
                                                _iteratorError = err;
                                            } finally{
                                                try {
                                                    if (!_iteratorNormalCompletion && _iterator1.return != null) {
                                                        _iterator1.return();
                                                    }
                                                } finally{
                                                    if (_didIteratorError) {
                                                        throw _iteratorError;
                                                    }
                                                }
                                            }
                                            glyphPromise = _this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);
                                            _this.m_loadingGlyphs.set(glyphHash, glyphPromise);
                                            glyphPromise.then(function(loadedGlyph) {
                                                _this.m_loadingGlyphs.delete(glyphHash);
                                                fontGlyphMap.set(codePoint, loadedGlyph);
                                                _this.m_glyphTextureCache.add(glyphHash, loadedGlyph);
                                            });
                                        }
                                        glyphPromises.push(glyphPromise);
                                    } else if (!_this.m_glyphTextureCache.has(glyphHash)) {
                                        glyphPromises.push(Promise.resolve(glyph));
                                        _this.m_glyphTextureCache.add(glyphHash, glyph);
                                    }
                                };
                                for(_iterator = charset[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
                                _ctx.next = 15;
                                break;
                            case 11:
                                _ctx.prev = 11;
                                _ctx.t0 = _ctx["catch"](6);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t0;
                            case 15:
                                _ctx.prev = 15;
                                _ctx.prev = 16;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 18:
                                _ctx.prev = 18;
                                if (!_didIteratorError) {
                                    _ctx.next = 21;
                                    break;
                                }
                                throw _iteratorError;
                            case 21:
                                return _ctx.finish(18);
                            case 22:
                                return _ctx.finish(15);
                            case 23:
                                return _ctx.abrupt("return", Promise.all(glyphPromises));
                            case 24:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            6,
                            11,
                            15,
                            23
                        ],
                        [
                            16,
                            ,
                            18,
                            22
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "getGlyph",
            value: function getGlyph(codePoint, font, fontStyle) {
                var fontGlyphMap = this.m_loadedGlyphs.get("".concat(font.name, "_").concat(fontStyle));
                if (fontGlyphMap === void 0) {
                    return void 0;
                }
                return fontGlyphMap.get(codePoint);
            }
        },
        {
            key: "getGlyphs",
            value: function getGlyphs(input, style, letterCaseArray) {
                var result = [];
                var fontName = style.fontName;
                var fontStyle = style.fontStyle;
                var fontVariant = style.fontVariant;
                var shouldTransform = fontVariant === 1 /* AllCaps */  || fontVariant === 2 /* SmallCaps */ ;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var character = _step.value;
                        var transformedCharacter = shouldTransform ? character.toUpperCase() : character;
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = transformedCharacter[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var char = _step1.value;
                                var codePoint = char.codePointAt(0);
                                var font = this.getFont(codePoint, fontName);
                                var glyphData = this.getGlyph(codePoint, font, fontStyle);
                                if (glyphData !== void 0 && (!glyphData.isReplacement || this.showReplacementGlyphs)) {
                                    result.push(glyphData);
                                    if (letterCaseArray !== void 0) {
                                        letterCaseArray.push(char !== character);
                                    }
                                } else {
                                    return void 0;
                                }
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return result;
            }
        },
        {
            key: "getFont",
            value: function getFont(codePoint, fontName) {
                var selectedFontName = this.fonts[0].name;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.unicodeBlocks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var block = _step.value;
                        if (codePoint >= block.min && codePoint <= block.max) {
                            selectedFontName = fontName !== void 0 && block.fonts.find(function(element) {
                                return element === fontName;
                            }) !== void 0 ? fontName : block.fonts[0];
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return this.fonts.find(function(element) {
                    return element.name === selectedFontName;
                });
            }
        },
        {
            key: "updateMemoryUsage",
            value: function updateMemoryUsage(info) {
                var numBytes = 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.unicodeBlocks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var block = _step.value;
                        numBytes += (block.max - block.min) * 2;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;
                for(var page in this.m_loadedPages.entries){
                    if (this.m_loadedPages.get(page) !== void 0) {
                        var loadedPage = this.m_loadedPages.get(page);
                        if (loadedPage !== void 0) {
                            textureBytes += loadedPage.image.width * loadedPage.image.height * 4;
                        }
                    }
                }
                info.heapSize += numBytes + textureBytes;
                info.gpuSize += textureBytes;
            }
        },
        {
            key: "createReplacementGlyph",
            value: function createReplacementGlyph(codePoint, char, font) {
                var replacementGlyph = this.m_replacementGlyph.clone();
                replacementGlyph.codePoint = codePoint;
                replacementGlyph.character = char;
                replacementGlyph.font = font;
                replacementGlyph.isReplacement = UnicodeUtils.isPrintable(codePoint);
                return replacementGlyph;
            }
        },
        {
            key: "loadAssets",
            value: function loadAssets(codePoint, fontStyle, block, font) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var json, sourceGlyphData, assetsPath, texturePath, texture, glyphData;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return _this.loadBlock(block, font, fontStyle);
                            case 2:
                                json = _ctx.sent;
                                if (!(json === void 0)) {
                                    _ctx.next = 5;
                                    break;
                                }
                                return _ctx.abrupt("return", _this.m_replacementGlyph);
                            case 5:
                                sourceGlyphData = json.chars.find(function(char) {
                                    return char.id === codePoint;
                                });
                                assetsPath = _this.getAssetsPath(fontStyle, font);
                                texturePath = "".concat(assetsPath, "/").concat(json.pages[sourceGlyphData.page]);
                                _ctx.next = 10;
                                return _this.loadPage(texturePath);
                            case 10:
                                texture = _ctx.sent;
                                glyphData = new GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1 - sourceGlyphData.y / texture.image.height, texture, font);
                                return _ctx.abrupt("return", glyphData);
                            case 13:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "loadPage",
            value: function loadPage(pagePath) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var page, pagePromise;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                page = _this.m_loadedPages.get(pagePath);
                                if (!(page === void 0)) {
                                    _ctx.next = 20;
                                    break;
                                }
                                pagePromise = _this.m_loadingPages.get(pagePath);
                                if (!(pagePromise === void 0)) {
                                    _ctx.next = 17;
                                    break;
                                }
                                pagePromise = FontCatalog.loadTexture(pagePath);
                                _this.m_loadingPages.set(pagePath, pagePromise);
                                _ctx.next = 8;
                                return pagePromise;
                            case 8:
                                page = _ctx.sent;
                                page.wrapS = THREE69.ClampToEdgeWrapping;
                                page.wrapT = THREE69.ClampToEdgeWrapping;
                                page.minFilter = THREE69.NearestFilter;
                                page.needsUpdate = true;
                                if (_this.m_loadingPages.delete(pagePath)) {
                                    _this.m_loadedPages.set(pagePath, page);
                                }
                                _this.m_loadingPages.delete(pagePath);
                                _ctx.next = 20;
                                break;
                            case 17:
                                _ctx.next = 19;
                                return pagePromise;
                            case 19:
                                page = _ctx.sent;
                            case 20:
                                return _ctx.abrupt("return", page);
                            case 21:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "getAssetsPath",
            value: function getAssetsPath(fontStyle, font) {
                var fontStylePath = ASSETS_PATH;
                switch(fontStyle){
                    case 1 /* Bold */ :
                        if (font.bold !== void 0) {
                            fontStylePath = BOLD_ASSETS_PATH;
                        }
                        break;
                    case 2 /* Italic */ :
                        if (font.italic !== void 0) {
                            fontStylePath = ITALIC_ASSETS_PATH;
                        }
                        break;
                    case 3 /* BoldItalic */ :
                        if (font.boldItalic !== void 0) {
                            fontStylePath = BOLD_ITALIC_ASSETS_PATH;
                        } else if (font.italic !== void 0) {
                            fontStylePath = ITALIC_ASSETS_PATH;
                        } else if (font.bold !== void 0) {
                            fontStylePath = BOLD_ASSETS_PATH;
                        }
                        break;
                }
                return "".concat(this.url, "/").concat(this.name).concat(fontStylePath).concat(font.name);
            }
        }
    ], [
        {
            key: "load",
            value: function load(path, maxCodePointCount) {
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var url, fontCatalog, replacementDirUrl, replacementJson, replacementTexture, replacementFont, replacementGlyph, fontCatalogInfo;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                url = new URL(path, window.location.href);
                                _ctx.next = 3;
                                return FontCatalog.loadJSON(url.href);
                            case 3:
                                fontCatalog = _ctx.sent;
                                replacementDirUrl = new URL("".concat(fontCatalog.name).concat(REPLACEMENT_PATH), url);
                                _ctx.next = 7;
                                return FontCatalog.loadJSON(replacementDirUrl.href + "Specials.json");
                            case 7:
                                replacementJson = _ctx.sent;
                                _ctx.next = 10;
                                return FontCatalog.loadTexture(replacementDirUrl.href + "Specials.png");
                            case 10:
                                replacementTexture = _ctx.sent;
                                replacementTexture.wrapS = THREE69.ClampToEdgeWrapping;
                                replacementTexture.wrapT = THREE69.ClampToEdgeWrapping;
                                replacementTexture.minFilter = THREE69.NearestFilter;
                                replacementTexture.needsUpdate = true;
                                replacementFont = fontCatalog.fonts.find(function(font) {
                                    return font.name === "Extra";
                                });
                                replacementGlyph = new GlyphData(65533, "Specials", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0, 0, 1, 1, replacementTexture, replacementFont, true);
                                fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf("/")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);
                                return _ctx.abrupt("return", fontCatalogInfo);
                            case 19:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "loadTexture",
            value: function loadTexture(url) {
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return new Promise(function(resolve) {
                                    new THREE69.TextureLoader().load(url, resolve);
                                });
                            case 2:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 3:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "loadJSON",
            value: function loadJSON(url) {
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var response, rawJSON;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return fetch(url);
                            case 2:
                                response = _ctx.sent;
                                if (response.ok) {
                                    _ctx.next = 5;
                                    break;
                                }
                                throw new Error("".concat(url, " Status Text:  ").concat(response.statusText));
                            case 5:
                                _ctx.next = 7;
                                return response.text();
                            case 7:
                                rawJSON = _ctx.sent;
                                return _ctx.abrupt("return", JSON.parse(rawJSON));
                            case 9:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        }
    ]);
    return FontCatalog;
}();
// src/text-canvas/rendering/TextBufferObject.ts
var TextBufferObject = function TextBufferObject(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {
    _classCallCheck(this, TextBufferObject);
    this.glyphs = glyphs;
    this.buffer = buffer;
    this.bounds = bounds;
    this.characterBounds = characterBounds;
    this.textRenderStyle = textRenderStyle;
    this.textLayoutStyle = textLayoutStyle;
};
// src/text-canvas/rendering/TextGeometry.ts
var THREE70 = __toESM(require("three"));
var MAX_CAPACITY = 65536;
var VERTEX_BUFFER_STRIDE = 16;
var INDEX_BUFFER_STRIDE = 1;
var VERTICES_PER_QUAD = 4;
var INDICES_PER_QUAD = 6;
var QUAD_VERTEX_MEMORY_FOOTPRINT = VERTICES_PER_QUAD * VERTEX_BUFFER_STRIDE;
var QUAD_INDEX_MEMORY_FOOTPRINT = INDICES_PER_QUAD * INDEX_BUFFER_STRIDE;
var NUM_BYTES_PER_FLOAT = 4;
var NUM_BYTES_PER_INT32 = 4;
var TextGeometry = /*#__PURE__*/ function() {
    function TextGeometry(scene, material, backgroundMaterial, initialSize, capacity) {
        _classCallCheck(this, TextGeometry);
        this.scene = scene;
        __publicField(this, "capacity");
        __publicField(this, "m_currentCapacity");
        __publicField(this, "m_drawCount");
        __publicField(this, "m_updateOffset");
        __publicField(this, "m_vertexBuffer");
        __publicField(this, "m_positionAttribute");
        __publicField(this, "m_uvAttribute");
        __publicField(this, "m_colorAttribute");
        __publicField(this, "m_bgColorAttribute");
        __publicField(this, "m_indexBuffer");
        __publicField(this, "m_geometry");
        __publicField(this, "m_mesh");
        __publicField(this, "m_bgMesh");
        __publicField(this, "m_pickingDataArray", []);
        this.capacity = Math.min(capacity, MAX_CAPACITY);
        this.m_currentCapacity = Math.min(initialSize, capacity);
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_vertexBuffer = new THREE70.InterleavedBuffer(new Float32Array(this.m_currentCapacity * QUAD_VERTEX_MEMORY_FOOTPRINT), VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setUsage(THREE70.DynamicDrawUsage);
        this.m_positionAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        this.m_indexBuffer = new THREE70.BufferAttribute(new Uint32Array(this.m_currentCapacity * QUAD_INDEX_MEMORY_FOOTPRINT), INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setUsage(THREE70.DynamicDrawUsage);
        this.m_geometry = new THREE70.BufferGeometry();
        this.m_geometry.setAttribute("position", this.m_positionAttribute);
        this.m_geometry.setAttribute("uv", this.m_uvAttribute);
        this.m_geometry.setAttribute("color", this.m_colorAttribute);
        this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_mesh = new THREE70.Mesh(this.m_geometry, material);
        this.m_bgMesh = new THREE70.Mesh(this.m_geometry, backgroundMaterial);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.m_mesh.frustumCulled = false;
        this.m_bgMesh.frustumCulled = false;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
    _createClass(TextGeometry, [
        {
            key: "drawCount",
            get: function get() {
                return this.m_drawCount;
            }
        },
        {
            key: "mesh",
            get: function get() {
                return this.m_mesh;
            }
        },
        {
            key: "backgroundMesh",
            get: function get() {
                return this.m_bgMesh;
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                this.scene.remove(this.m_bgMesh, this.m_mesh);
                this.m_geometry.dispose();
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_drawCount = 0;
                this.m_updateOffset = 0;
                this.m_pickingDataArray.length = 0;
            }
        },
        {
            key: "update",
            value: function update() {
                if (this.drawCount > this.m_updateOffset) {
                    this.m_vertexBuffer.needsUpdate = true;
                    this.m_vertexBuffer.updateRange.offset = this.m_updateOffset * QUAD_VERTEX_MEMORY_FOOTPRINT;
                    this.m_vertexBuffer.updateRange.count = (this.m_drawCount - this.m_updateOffset) * QUAD_VERTEX_MEMORY_FOOTPRINT;
                    this.m_indexBuffer.needsUpdate = true;
                    this.m_indexBuffer.updateRange.offset = this.m_updateOffset * QUAD_INDEX_MEMORY_FOOTPRINT;
                    this.m_indexBuffer.updateRange.count = (this.m_drawCount - this.m_updateOffset) * QUAD_INDEX_MEMORY_FOOTPRINT;
                }
                this.m_updateOffset = this.m_drawCount;
                this.m_geometry.setDrawRange(0, this.m_drawCount * INDICES_PER_QUAD);
            }
        },
        {
            key: "add",
            value: function add(glyphData, corners, weight, bgWeight, mirrored, style) {
                if (this.m_drawCount >= this.capacity) {
                    return false;
                } else if (this.m_drawCount >= this.m_currentCapacity) {
                    var newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
                    this.resizeBuffers(newSize);
                }
                var baseVertex = this.m_drawCount * VERTICES_PER_QUAD;
                var baseIndex = this.m_drawCount * INDICES_PER_QUAD;
                for(var i = 0; i < VERTICES_PER_QUAD; ++i){
                    this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1 : 1) * style.rotation);
                    var mirroredUVIdx = mirrored ? (i + 1) % 2 + Math.floor(i / 2) * 2 : i;
                    this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);
                    this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);
                    this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);
                }
                this.m_indexBuffer.setX(baseIndex, baseVertex);
                this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);
                this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);
                this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);
                this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);
                this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);
                ++this.m_drawCount;
                return true;
            }
        },
        {
            key: "addToBuffer",
            value: function addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {
                for(var i = 0; i < VERTICES_PER_QUAD; ++i){
                    var vertexOffset = offset + VERTEX_BUFFER_STRIDE * i;
                    buffer[vertexOffset] = corners[i].x;
                    buffer[vertexOffset + 1] = corners[i].y;
                    buffer[vertexOffset + 2] = corners[i].z;
                    buffer[vertexOffset + 3] = (mirrored ? -1 : 1) * style.rotation;
                    var mirroredUVIdx = mirrored ? (i + 1) % 2 + Math.floor(i / 2) * 2 : i;
                    buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;
                    buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;
                    buffer[vertexOffset + 6] = weight;
                    buffer[vertexOffset + 7] = bgWeight;
                    buffer[vertexOffset + 8] = style.color.r;
                    buffer[vertexOffset + 9] = style.color.g;
                    buffer[vertexOffset + 10] = style.color.b;
                    buffer[vertexOffset + 11] = style.opacity;
                    buffer[vertexOffset + 12] = style.backgroundColor.r;
                    buffer[vertexOffset + 13] = style.backgroundColor.g;
                    buffer[vertexOffset + 14] = style.backgroundColor.b;
                    buffer[vertexOffset + 15] = style.backgroundOpacity;
                }
            }
        },
        {
            key: "addTextBufferObject",
            value: function addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {
                if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {
                    return false;
                } else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {
                    var newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
                    this.resizeBuffers(newSize);
                }
                var s = scale !== null && scale !== void 0 ? scale : 1;
                var r = rotation !== null && rotation !== void 0 ? rotation : 0;
                var cosR = Math.cos(r);
                var sinR = Math.sin(r);
                var offsetX = position !== void 0 ? position.x : 0;
                var offsetY = position !== void 0 ? position.y : 0;
                var offsetZ = 0;
                var buffer = textBufferObject.buffer;
                var rot = buffer[3];
                var rotSign = rot < 0 ? -1 : 1;
                var red = color !== void 0 ? color.r : buffer[8];
                var green = color !== void 0 ? color.g : buffer[9];
                var blue = color !== void 0 ? color.b : buffer[10];
                var alpha = opacity !== void 0 ? opacity : buffer[11];
                var bgRed = bgColor !== void 0 ? bgColor.r : buffer[12];
                var bgGreen = bgColor !== void 0 ? bgColor.g : buffer[13];
                var bgBlue = bgColor !== void 0 ? bgColor.b : buffer[14];
                var bgAlpha = bgOpacity !== void 0 ? bgOpacity : buffer[15];
                var targetOffset = this.m_drawCount * VERTICES_PER_QUAD;
                for(var i = 0; i < textBufferObject.glyphs.length; ++i){
                    var srcOffset = i * QUAD_VERTEX_MEMORY_FOOTPRINT;
                    var glyph = textBufferObject.glyphs[i];
                    if (!glyph.isInCache) {
                        return false;
                    }
                    var mirrored = buffer[srcOffset + 4] > buffer[srcOffset + VERTEX_BUFFER_STRIDE + 4];
                    var w = buffer[srcOffset + 6];
                    var bw = buffer[srcOffset + 7];
                    for(var j = 0; j < VERTICES_PER_QUAD; ++j){
                        var x = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE];
                        var y = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 1];
                        this.m_positionAttribute.setXYZW(targetOffset + i * VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 3] + rotSign * r);
                        var mirroredUVIdx = mirrored ? (j + 1) % 2 + Math.floor(j / 2) * 2 : j;
                        this.m_uvAttribute.setXYZW(targetOffset + i * VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);
                        this.m_colorAttribute.setXYZW(targetOffset + i * VERTICES_PER_QUAD + j, red, green, blue, alpha);
                        this.m_bgColorAttribute.setXYZW(targetOffset + i * VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);
                    }
                    this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD, (this.m_drawCount + i) * VERTICES_PER_QUAD);
                    this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 1, (this.m_drawCount + i) * VERTICES_PER_QUAD + 1);
                    this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 2, (this.m_drawCount + i) * VERTICES_PER_QUAD + 2);
                    this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 3, (this.m_drawCount + i) * VERTICES_PER_QUAD + 2);
                    this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 4, (this.m_drawCount + i) * VERTICES_PER_QUAD + 1);
                    this.m_indexBuffer.setX((this.m_drawCount + i) * INDICES_PER_QUAD + 5, (this.m_drawCount + i) * VERTICES_PER_QUAD + 3);
                }
                this.m_drawCount += textBufferObject.glyphs.length;
                return true;
            }
        },
        {
            key: "addPickingData",
            value: function addPickingData(startIdx, endIdx, pickingData) {
                if (this.m_pickingDataArray.length >= this.m_currentCapacity) {
                    return false;
                }
                this.m_pickingDataArray.push({
                    start: Math.min(startIdx, this.capacity),
                    end: Math.min(endIdx, this.capacity),
                    data: pickingData
                });
                return true;
            }
        },
        {
            key: "pick",
            value: function pick(screenPosition, pickCallback) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_pickingDataArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var pickingData = _step.value;
                        if (pickingData === void 0) {
                            return;
                        }
                        for(var i = pickingData.start; i < pickingData.end; ++i){
                            var positionIndex = i * VERTICES_PER_QUAD;
                            var minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                            if (screenPosition.x < minX) {
                                continue;
                            }
                            var maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                            if (screenPosition.x > maxX) {
                                continue;
                            }
                            var minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                            if (screenPosition.y < minY) {
                                continue;
                            }
                            var maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                            if (screenPosition.y > maxY) {
                                continue;
                            }
                            pickCallback(pickingData.data);
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "updateMemoryUsage",
            value: function updateMemoryUsage(info) {
                var numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT + this.m_indexBuffer.count * NUM_BYTES_PER_INT32;
                info.heapSize += numBytes;
                info.gpuSize += numBytes;
            }
        },
        {
            key: "resizeBuffers",
            value: function resizeBuffers(size) {
                this.m_currentCapacity = size;
                var newVertexBuffer = new Float32Array(size * QUAD_VERTEX_MEMORY_FOOTPRINT);
                newVertexBuffer.set(this.m_vertexBuffer.array);
                this.m_vertexBuffer = new THREE70.InterleavedBuffer(newVertexBuffer, VERTEX_BUFFER_STRIDE);
                this.m_vertexBuffer.setUsage(THREE70.DynamicDrawUsage);
                this.m_positionAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
                this.m_uvAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
                this.m_colorAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
                this.m_bgColorAttribute = new THREE70.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
                var newIndexBuffer = new Uint32Array(size * QUAD_INDEX_MEMORY_FOOTPRINT);
                newIndexBuffer.set(this.m_indexBuffer.array);
                this.m_indexBuffer = new THREE70.BufferAttribute(newIndexBuffer, INDEX_BUFFER_STRIDE);
                this.m_indexBuffer.setUsage(THREE70.DynamicDrawUsage);
                this.m_geometry.dispose();
                this.m_geometry = new THREE70.BufferGeometry();
                this.m_geometry.setAttribute("position", this.m_positionAttribute);
                this.m_geometry.setAttribute("uv", this.m_uvAttribute);
                this.m_geometry.setAttribute("color", this.m_colorAttribute);
                this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
                this.m_geometry.setIndex(this.m_indexBuffer);
                this.m_pickingDataArray.length = this.m_currentCapacity;
                this.scene.remove(this.m_bgMesh, this.m_mesh);
                this.m_mesh = new THREE70.Mesh(this.m_geometry, this.m_mesh.material);
                this.m_bgMesh = new THREE70.Mesh(this.m_geometry, this.m_bgMesh.material);
                this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
                this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
                this.m_mesh.frustumCulled = false;
                this.m_bgMesh.frustumCulled = false;
                this.scene.add(this.m_bgMesh, this.m_mesh);
            }
        }
    ]);
    return TextGeometry;
}();
// src/text-canvas/TextCanvas.ts
var THREE74 = __toESM(require("three"));
// src/text-canvas/typesetting/LineTypesetter.ts
var THREE72 = __toESM(require("three"));
// src/text-canvas/utils/TypesettingUtils.ts
var THREE71 = __toESM(require("three"));
var TypesettingUtils;
(function(TypesettingUtils2) {
    var getPixelSize = function getPixelSize(size, unit, originalSize) {
        var result = size;
        switch(unit){
            case 0 /* Em */ :
                result *= TypesettingUtils2.EM_TO_PX;
                break;
            case 2 /* Point */ :
                result *= TypesettingUtils2.PT_TO_PX;
                break;
            case 3 /* Percent */ :
                result *= 1 / 100 * originalSize;
                break;
        }
        return result;
    };
    var getSmallCapsScale = function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {
        var isSmallCaps = smallCapsTransformations[index] && fontVariant === 2 /* SmallCaps */ ;
        return isSmallCaps ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight : 1;
    };
    var getDirection = function getDirection(glyphs, offset) {
        var result = UnicodeUtils.Direction.LTR;
        var index = offset;
        while(glyphs[index].direction !== UnicodeUtils.Direction.LTR && glyphs[index].direction !== UnicodeUtils.Direction.RTL && index < glyphs.length - 1){
            ++index;
        }
        if (Math.abs(glyphs[index].direction) === 1) {
            result = glyphs[index].direction;
        }
        return result;
    };
    var computeGlyphTransform = function computeGlyphTransform(transform, position, scale, rotation, localRotation) {
        var cosAngle = Math.cos(rotation);
        var sinAngle = Math.sin(rotation);
        var localCosAngle = Math.cos(localRotation);
        var localSinAngle = Math.sin(localRotation);
        transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1);
    };
    var updateBounds = function updateBounds(corners, globalBounds, individualBounds) {
        var minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        var maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        var minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        var maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        if (individualBounds !== void 0) {
            if (individualBounds.array[individualBounds.offset] !== void 0) {
                individualBounds.array[individualBounds.offset].min.set(minX, minY);
                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);
            } else {
                individualBounds.array.push(new THREE71.Box2(new THREE71.Vector2(minX, minY), new THREE71.Vector2(maxX, maxY)));
            }
            ++individualBounds.offset;
        }
        globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));
        globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));
    };
    TypesettingUtils2.EM_TO_PX = 16;
    TypesettingUtils2.PT_TO_PX = 1.25;
    TypesettingUtils2.OBLIQUE_ANGLE = 0.174533;
    TypesettingUtils2.OBLIQUE_OFFSET = Math.tan(TypesettingUtils2.OBLIQUE_ANGLE);
    TypesettingUtils2.getPixelSize = getPixelSize;
    TypesettingUtils2.getSmallCapsScale = getSmallCapsScale;
    TypesettingUtils2.getDirection = getDirection;
    TypesettingUtils2.computeGlyphTransform = computeGlyphTransform;
    TypesettingUtils2.updateBounds = updateBounds;
})(TypesettingUtils || (TypesettingUtils = {}));
// src/text-canvas/typesetting/LineTypesetter.ts
var LineTypesetter = /*#__PURE__*/ function() {
    function LineTypesetter() {
        _classCallCheck(this, LineTypesetter);
        __publicField(this, "m_tempTransform");
        __publicField(this, "m_tempCorners");
        __publicField(this, "m_tempLineDirection");
        __publicField(this, "m_tempRunDirection");
        __publicField(this, "m_tempPixelSize");
        __publicField(this, "m_tempPixelBgSize");
        __publicField(this, "m_tempScale");
        __publicField(this, "m_tempSmallCaps");
        __publicField(this, "m_currentParams");
        this.m_tempTransform = new THREE72.Matrix3();
        this.m_tempCorners = [
            new THREE72.Vector3(),
            new THREE72.Vector3(),
            new THREE72.Vector3(),
            new THREE72.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1;
        this.m_tempPixelBgSize = 1;
        this.m_tempScale = 1;
        this.m_tempSmallCaps = false;
    }
    _createClass(LineTypesetter, [
        {
            key: "arrangeGlyphs",
            value: function arrangeGlyphs(params) {
                this.m_currentParams = params;
                this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
                this.m_tempRunDirection = this.m_tempLineDirection;
                this.m_tempPixelSize = TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
                this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
                this.m_tempPixelBgSize = Math.min(TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
                this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== void 0;
                this.m_currentParams.position.y += this.m_currentParams.textLayoutStyle.verticalAlignment * this.m_currentParams.glyphs[0].font.metrics.capHeight * this.m_tempScale;
                var isOnlyMeasured = this.m_currentParams.globalBounds !== void 0 && this.m_currentParams.vertexBuffer === void 0;
                var origin = this.m_currentParams.position.x;
                var lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight + this.m_currentParams.textLayoutStyle.leading;
                var lineStartIdx = 0;
                var glyphWrapIdx = 0;
                var wordWrapIdx = 0;
                var lineStartX = 0;
                var lineCurrX = 0;
                var glyphWrapX = 0;
                var wordWrapX = 0;
                var lineCount = 0;
                var isBidirectionalLine = false;
                for(var i = 0; i < this.m_currentParams.glyphs.length; ++i){
                    if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {
                        break;
                    }
                    var glyphData = this.m_currentParams.glyphs[i];
                    if (!glyphData.isInCache && !isOnlyMeasured) {
                        return false;
                    }
                    var isNewLine = UnicodeUtils.isNewLine(glyphData.codePoint);
                    var isWhiteSpace = UnicodeUtils.isWhiteSpace(glyphData.codePoint);
                    if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {
                        isBidirectionalLine = true;
                    }
                    if (UnicodeUtils.isPrintable(glyphData.codePoint)) {
                        lineCurrX += (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) * this.m_tempScale * (this.m_tempSmallCaps ? TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant) : 1);
                    }
                    if (i === lineStartIdx) {
                        lineStartX = lineCurrX;
                        glyphWrapX = lineCurrX;
                        wordWrapX = lineCurrX;
                    }
                    if (isNewLine || this.m_currentParams.textLayoutStyle.wrappingMode === 1 /* Character */  && lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth || this.m_currentParams.textLayoutStyle.wrappingMode === 2 /* Word */  && lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth && wordWrapX !== lineStartX) {
                        if (this.m_currentParams.textLayoutStyle.wrappingMode !== 0 /* None */ ) {
                            var wrapPointIdx = glyphWrapIdx;
                            var wrapPointX = glyphWrapX;
                            if (this.m_currentParams.textLayoutStyle.wrappingMode === 2 /* Word */  && wordWrapX !== lineStartX) {
                                wrapPointIdx = wordWrapIdx;
                                wrapPointX = wordWrapX;
                            }
                            lineCurrX = wrapPointX;
                            i = Math.min(isNewLine ? lineStartIdx === i ? wrapPointIdx : i : wrapPointIdx, this.m_currentParams.glyphs.length - 1);
                        }
                        var lineAlignment = this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine ? 1 + this.m_currentParams.textLayoutStyle.horizontalAlignment : this.m_currentParams.textLayoutStyle.horizontalAlignment;
                        this.m_currentParams.position.x = this.m_currentParams.position.x + lineCurrX * lineAlignment;
                        if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {
                            return false;
                        }
                        this.m_currentParams.position.y -= lineHeight * this.m_tempScale;
                        this.m_currentParams.position.x = origin;
                        while(i !== lineStartIdx && i + 1 < this.m_currentParams.glyphs.length && UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)){
                            ++i;
                        }
                        lineStartIdx = i + 1;
                        if (lineStartIdx === this.m_currentParams.glyphs.length) {
                            break;
                        }
                        if (isNewLine) {
                            this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);
                            this.m_tempRunDirection = this.m_tempLineDirection;
                        }
                        lineStartX = 0;
                        lineCurrX = 0;
                        glyphWrapIdx = lineStartIdx;
                        glyphWrapX = 0;
                        wordWrapIdx = lineStartIdx;
                        wordWrapX = 0;
                        isBidirectionalLine = false;
                        lineCount++;
                    } else if (this.m_currentParams.textLayoutStyle.wrappingMode !== 0 /* None */  && !isWhiteSpace) {
                        glyphWrapIdx = i;
                        glyphWrapX = lineCurrX;
                        if (this.m_currentParams.textLayoutStyle.wrappingMode === 2 /* Word */  && i + 1 < this.m_currentParams.glyphs.length && (UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) || UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {
                            wordWrapIdx = i;
                            wordWrapX = lineCurrX;
                        }
                    }
                }
                if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 && lineStartIdx <= this.m_currentParams.glyphs.length - 1) {
                    var offset = this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine ? 1 + this.m_currentParams.textLayoutStyle.horizontalAlignment : this.m_currentParams.textLayoutStyle.horizontalAlignment;
                    this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);
                    if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {
                        return false;
                    }
                }
                return true;
            }
        },
        {
            key: "placeLine",
            value: function placeLine(startIdx, endIdx, direction, isBidirectional) {
                if (!isBidirectional) {
                    return this.placeRun(startIdx, endIdx, direction);
                }
                var glyphDataArray = this.m_currentParams.glyphs;
                var smallCapsArray = this.m_currentParams.smallCapsArray;
                var textRenderStyle = this.m_currentParams.textRenderStyle;
                var textLayoutStyle = this.m_currentParams.textLayoutStyle;
                var position = this.m_currentParams.position;
                var isRTL = direction === UnicodeUtils.Direction.RTL;
                var origin = position.x;
                var offset = 0;
                var runStart = startIdx;
                for(var i = startIdx; i <= endIdx; ++i){
                    var glyphData = glyphDataArray[i];
                    if (glyphData.direction === -this.m_tempRunDirection) {
                        if (isRTL) {
                            position.x = origin + offset;
                        }
                        if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                            return false;
                        }
                        if (!isRTL) {
                            position.x = origin + offset;
                        }
                        runStart = i;
                        this.m_tempRunDirection *= -1;
                    } else if (glyphData.direction === UnicodeUtils.Direction.Neutral && this.m_tempRunDirection === -direction) {
                        var neutralIdx = i;
                        while(neutralIdx + 1 < glyphDataArray.length && Math.abs(glyphDataArray[neutralIdx].direction) !== 1){
                            ++neutralIdx;
                        }
                        if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                            if (isRTL) {
                                position.x = origin + offset;
                            }
                            if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                                return false;
                            }
                            if (!isRTL) {
                                position.x = origin + offset;
                            }
                            runStart = i;
                            this.m_tempRunDirection *= -1;
                        }
                    }
                    offset += (glyphData.advanceX + textLayoutStyle.tracking) * this.m_tempScale * (this.m_tempSmallCaps ? TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant) : 1) * direction;
                }
                if (runStart <= endIdx) {
                    if (isRTL) {
                        position.x = origin + offset;
                    }
                    if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {
                        return false;
                    }
                    if (!isRTL) {
                        position.x = origin + offset;
                    }
                }
                return true;
            }
        },
        {
            key: "placeRun",
            value: function placeRun(startIdx, endIdx, direction) {
                var glyphDataArray = this.m_currentParams.glyphs;
                var smallCapsArray = this.m_currentParams.smallCapsArray;
                var fontCatalog = this.m_currentParams.fontCatalog;
                var textRenderStyle = this.m_currentParams.textRenderStyle;
                var textLayoutStyle = this.m_currentParams.textLayoutStyle;
                var position = this.m_currentParams.position;
                var geometry = this.m_currentParams.geometry;
                var globalBounds = this.m_currentParams.globalBounds;
                var individualBounds = this.m_currentParams.individualBounds;
                var vertexBuffer = this.m_currentParams.vertexBuffer;
                var start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;
                var end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;
                for(var i = start; direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction){
                    var glyphData = glyphDataArray[i];
                    if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {
                        continue;
                    }
                    if (startIdx !== endIdx && i !== 0 && direction === UnicodeUtils.Direction.RTL && glyphData.direction === UnicodeUtils.Direction.Weak) {
                        var weakRunStart = i;
                        var weakGlyph = glyphDataArray[weakRunStart - 1];
                        while(weakRunStart !== startIdx && (weakGlyph.direction === UnicodeUtils.Direction.Weak || weakGlyph.direction === UnicodeUtils.Direction.Neutral && !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint))){
                            --weakRunStart;
                            weakGlyph = glyphDataArray[weakRunStart - 1];
                        }
                        this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);
                        i = weakRunStart;
                        continue;
                    }
                    var glyphFont = glyphData.font;
                    var glyphFontMetrics = glyphFont.metrics;
                    var fontStyle = textRenderStyle.fontStyle;
                    var isBoldEmulated = fontStyle === 1 /* Bold */  && glyphFont.bold === void 0 || fontStyle === 3 /* BoldItalic */  && glyphFont.bold === void 0 && glyphFont.boldItalic === void 0;
                    var isItalicEmulated = fontStyle === 2 /* Italic */  && glyphFont.italic === void 0 || fontStyle === 3 /* BoldItalic */  && glyphFont.italic === void 0 && glyphFont.boldItalic === void 0;
                    var isSmallCaps = this.m_tempSmallCaps ? smallCapsArray[i] && textRenderStyle.fontVariant === 2 /* SmallCaps */  : false;
                    var smallCapsScale = isSmallCaps ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight : 1;
                    var glyphScale = this.m_tempScale * smallCapsScale;
                    var emulationWeight = ((isBoldEmulated ? 0.02 : 0) + (isSmallCaps ? 0.01 : 0)) * (fontCatalog.size / fontCatalog.distanceRange);
                    var bgWeight = 0.5 * this.m_tempPixelBgSize / (fontCatalog.distanceRange * Math.max(glyphScale, 1));
                    var isMirrored = UnicodeUtils.isRtlMirrored(glyphData.codePoint) && direction === UnicodeUtils.Direction.RTL;
                    var verticalOffset = glyphFontMetrics.lineHeight - glyphFontMetrics.base - glyphFontMetrics.distanceRange * 0.5;
                    TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);
                    for(var j = 0; j < 4; ++j){
                        var glyphVertexPosition = glyphData.positions[j];
                        var horizontalOffset = isItalicEmulated && j > 1 ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size : 0;
                        this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                        this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
                    }
                    if (globalBounds === void 0 && vertexBuffer === void 0) {
                        if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                            return false;
                        }
                    } else {
                        if (globalBounds !== void 0) {
                            TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                        }
                        if (vertexBuffer !== void 0) {
                            geometry.addToBuffer(vertexBuffer, i * QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                        }
                    }
                    position.set(position.x + (glyphData.advanceX + textLayoutStyle.tracking) * glyphScale * Math.cos(textLayoutStyle.lineRotation), position.y + (glyphData.advanceX + textLayoutStyle.tracking) * glyphScale * Math.sin(textLayoutStyle.lineRotation), position.z);
                }
                return true;
            }
        }
    ]);
    return LineTypesetter;
}();
// src/text-canvas/typesetting/PathTypesetter.ts
var THREE73 = __toESM(require("three"));
var PathTypesetter = /*#__PURE__*/ function() {
    function PathTypesetter() {
        _classCallCheck(this, PathTypesetter);
        __publicField(this, "m_tempTransform");
        __publicField(this, "m_tempCorners");
        __publicField(this, "m_tempLineDirection");
        __publicField(this, "m_tempRunDirection");
        __publicField(this, "m_tempPixelSize");
        __publicField(this, "m_tempPixelBgSize");
        __publicField(this, "m_tempScale");
        __publicField(this, "m_tempSmallCaps");
        __publicField(this, "m_tempPathPosition");
        __publicField(this, "m_tempPathLength");
        __publicField(this, "m_tempPathOffset");
        __publicField(this, "m_currentParams");
        this.m_tempTransform = new THREE73.Matrix3();
        this.m_tempCorners = [
            new THREE73.Vector3(),
            new THREE73.Vector3(),
            new THREE73.Vector3(),
            new THREE73.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1;
        this.m_tempPixelBgSize = 1;
        this.m_tempScale = 1;
        this.m_tempSmallCaps = false;
        this.m_tempPathPosition = new THREE73.Vector3();
        this.m_tempPathLength = 0;
        this.m_tempPathOffset = 0;
    }
    _createClass(PathTypesetter, [
        {
            key: "arrangeGlyphs",
            value: function arrangeGlyphs(params) {
                this.m_currentParams = params;
                this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
                this.m_tempRunDirection = this.m_tempLineDirection;
                this.m_tempPixelSize = TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
                this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
                this.m_tempPixelBgSize = Math.min(TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
                this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== void 0;
                this.m_tempPathLength = this.m_currentParams.path.getLength();
                this.m_tempPathOffset = 0;
                var isOnlyMeasured = this.m_currentParams.globalBounds !== void 0 && this.m_currentParams.vertexBuffer === void 0;
                var isBidirectional = false;
                var pathWidth = 0;
                for(var i = 0; i < this.m_currentParams.glyphs.length; ++i){
                    var glyphData = this.m_currentParams.glyphs[i];
                    if (!glyphData.isInCache && !isOnlyMeasured) {
                        return false;
                    }
                    if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {
                        continue;
                    }
                    if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {
                        isBidirectional = true;
                    }
                    pathWidth += (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) * this.m_tempScale * (this.m_tempSmallCaps ? TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant) : 1);
                }
                this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment + this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth / this.m_tempPathLength, 0), 1);
                return this.placeLine(this.m_tempLineDirection, isBidirectional);
            }
        },
        {
            key: "placeLine",
            value: function placeLine(direction, isBidirectional) {
                if (!isBidirectional) {
                    return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);
                }
                var glyphDataArray = this.m_currentParams.glyphs;
                var runStart = 0;
                for(var i = runStart; i < glyphDataArray.length; ++i){
                    var glyphData = glyphDataArray[i];
                    if (glyphData.direction === -this.m_tempRunDirection) {
                        if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                            return false;
                        }
                        runStart = i;
                        this.m_tempRunDirection *= -1;
                    } else if (glyphData.direction === UnicodeUtils.Direction.Neutral && this.m_tempRunDirection === -direction) {
                        var neutralIdx = i;
                        while(neutralIdx + 1 < glyphDataArray.length && Math.abs(glyphDataArray[neutralIdx].direction) !== 1){
                            ++neutralIdx;
                        }
                        if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                            if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                                return false;
                            }
                            runStart = i;
                            this.m_tempRunDirection *= -1;
                        }
                    }
                }
                if (runStart < glyphDataArray.length) {
                    if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                }
                return true;
            }
        },
        {
            key: "placeRun",
            value: function placeRun(startIdx, endIdx, direction) {
                var glyphDataArray = this.m_currentParams.glyphs;
                var smallCapsArray = this.m_currentParams.smallCapsArray;
                var fontCatalog = this.m_currentParams.fontCatalog;
                var textRenderStyle = this.m_currentParams.textRenderStyle;
                var textLayoutStyle = this.m_currentParams.textLayoutStyle;
                var position = this.m_currentParams.position;
                var geometry = this.m_currentParams.geometry;
                var globalBounds = this.m_currentParams.globalBounds;
                var individualBounds = this.m_currentParams.individualBounds;
                var vertexBuffer = this.m_currentParams.vertexBuffer;
                var path = this.m_currentParams.path;
                var defaultGlyphRotation = textRenderStyle.rotation;
                var normalDisplacement = textLayoutStyle.verticalAlignment * glyphDataArray[0].font.metrics.capHeight * this.m_tempScale;
                var start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;
                var end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;
                for(var i = start; direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction){
                    var glyphData = glyphDataArray[i];
                    if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {
                        continue;
                    }
                    if (startIdx !== endIdx && i !== 0 && direction === UnicodeUtils.Direction.RTL && glyphData.direction === UnicodeUtils.Direction.Weak) {
                        var weakRunStart = i;
                        var weakGlyph = glyphDataArray[weakRunStart - 1];
                        while(weakRunStart !== startIdx && (weakGlyph.direction === UnicodeUtils.Direction.Weak || weakGlyph.direction === UnicodeUtils.Direction.Neutral && !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint))){
                            --weakRunStart;
                            weakGlyph = glyphDataArray[weakRunStart - 1];
                        }
                        this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);
                        i = weakRunStart;
                        continue;
                    }
                    var glyphFont = glyphData.font;
                    var glyphFontMetrics = glyphFont.metrics;
                    var fontStyle = textRenderStyle.fontStyle;
                    var isBoldEmulated = fontStyle === 1 /* Bold */  && glyphFont.bold === void 0 || fontStyle === 3 /* BoldItalic */  && glyphFont.bold === void 0 && glyphFont.boldItalic === void 0;
                    var isItalicEmulated = fontStyle === 2 /* Italic */  && glyphFont.italic === void 0 || fontStyle === 3 /* BoldItalic */  && glyphFont.italic === void 0 && glyphFont.boldItalic === void 0;
                    var isSmallCaps = this.m_tempSmallCaps ? smallCapsArray[i] && textRenderStyle.fontVariant === 2 /* SmallCaps */  : false;
                    var smallCapsScale = isSmallCaps ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight : 1;
                    var glyphScale = this.m_tempScale * smallCapsScale;
                    var emulationWeight = ((isBoldEmulated ? 0.02 : 0) + (isSmallCaps ? 0.01 : 0)) * (fontCatalog.size / fontCatalog.distanceRange);
                    var bgWeight = 0.5 * this.m_tempPixelBgSize / (fontCatalog.distanceRange * Math.max(glyphScale, 1));
                    var isMirrored = UnicodeUtils.isRtlMirrored(glyphData.codePoint) && direction === UnicodeUtils.Direction.RTL;
                    var verticalOffset = glyphFontMetrics.lineHeight - glyphFontMetrics.base - glyphFontMetrics.distanceRange * 0.5;
                    var textPoint = path.getPoint(this.m_tempPathOffset);
                    if (textPoint === null) {
                        return this.m_currentParams.pathOverflow;
                    }
                    var tangent = path.getTangent(this.m_tempPathOffset);
                    var normal = new THREE73.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);
                    var angle = Math.atan2(tangent.y, tangent.x);
                    this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);
                    textRenderStyle.rotation = defaultGlyphRotation + angle;
                    TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0, textRenderStyle.rotation);
                    for(var j = 0; j < 4; ++j){
                        var glyphVertexPosition = glyphData.positions[j];
                        var horizontalOffset = isItalicEmulated && j > 1 ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size : 0;
                        this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                        this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
                        this.m_tempCorners[j].x -= position.x;
                        this.m_tempCorners[j].y -= position.y;
                    }
                    if (globalBounds === void 0 && vertexBuffer === void 0) {
                        if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                            return false;
                        }
                    } else {
                        if (globalBounds !== void 0) {
                            TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                        }
                        if (vertexBuffer !== void 0) {
                            geometry.addToBuffer(vertexBuffer, i * QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                        }
                    }
                    textRenderStyle.rotation = defaultGlyphRotation;
                    this.m_tempPathOffset += (glyphData.advanceX + textLayoutStyle.tracking) * glyphScale / this.m_tempPathLength;
                }
                return true;
            }
        }
    ]);
    return PathTypesetter;
}();
// src/text-canvas/utils/MaterialUtils.ts
function createSdfTextMaterial(params) {
    return new SdfTextMaterial({
        texture: params.fontCatalog.texture,
        textureSize: params.fontCatalog.textureSize,
        size: params.fontCatalog.size,
        distanceRange: params.fontCatalog.distanceRange,
        isMsdf: params.fontCatalog.type === "msdf",
        isBackground: params.isBackground === true,
        vertexSource: params.vertexSource,
        fragmentSource: params.fragmentSource,
        rendererCapabilities: params.rendererCapabilities
    });
}
// src/text-canvas/TextCanvas.ts
var tempTextPosition = new THREE74.Vector3();
var tempTextBounds = {
    array: [
        new THREE74.Box2()
    ],
    offset: 0
};
var tempVertexBuffer = new Float32Array();
var DEFAULT_TEXT_CANVAS_LAYER = 0;
var _TextCanvas = /*#__PURE__*/ function() {
    function _TextCanvas(params) {
        _classCallCheck(this, _TextCanvas);
        __publicField(this, "minGlyphCount");
        __publicField(this, "maxGlyphCount");
        __publicField(this, "name");
        __publicField(this, "m_renderer");
        __publicField(this, "m_fontCatalog");
        __publicField(this, "m_currentTextRenderStyle");
        __publicField(this, "m_currentTextLayoutStyle");
        __publicField(this, "m_material");
        __publicField(this, "m_bgMaterial");
        __publicField(this, "m_ownsMaterial");
        __publicField(this, "m_ownsBgMaterial");
        __publicField(this, "m_defaultLayer");
        __publicField(this, "m_layers");
        __publicField(this, "m_lineTypesetter");
        __publicField(this, "m_pathTypesetter");
        this.m_renderer = params.renderer;
        this.m_fontCatalog = params.fontCatalog;
        this.minGlyphCount = params.minGlyphCount;
        this.maxGlyphCount = params.maxGlyphCount;
        this.name = params.name;
        if (params.material === void 0) {
            this.m_ownsMaterial = true;
            this.m_material = createSdfTextMaterial({
                fontCatalog: params.fontCatalog,
                rendererCapabilities: this.m_renderer.capabilities
            });
        } else {
            this.m_ownsMaterial = false;
            this.m_material = params.material;
        }
        if (params.backgroundMaterial === void 0) {
            this.m_ownsBgMaterial = true;
            this.m_bgMaterial = createSdfTextMaterial({
                fontCatalog: params.fontCatalog,
                isBackground: true,
                rendererCapabilities: this.m_renderer.capabilities
            });
        } else {
            this.m_ownsBgMaterial = false;
            this.m_bgMaterial = params.backgroundMaterial;
        }
        this.m_defaultLayer = {
            id: DEFAULT_TEXT_CANVAS_LAYER,
            storage: new TextGeometry(new THREE74.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
        };
        this.m_layers = [
            this.m_defaultLayer
        ];
        this.m_currentTextRenderStyle = new TextRenderStyle().copy(_TextCanvas.defaultTextRenderStyle);
        this.m_currentTextLayoutStyle = new TextLayoutStyle().copy(_TextCanvas.defaultTextLayoutStyle);
        this.m_lineTypesetter = new LineTypesetter();
        this.m_pathTypesetter = new PathTypesetter();
    }
    _createClass(_TextCanvas, [
        {
            key: "fontCatalog",
            get: function get() {
                return this.m_fontCatalog;
            },
            set: function set(value2) {
                this.m_fontCatalog = value2;
                var material = this.m_material;
                material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
                material.uniforms.sdfParams.value = new THREE74.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
                material.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1 : 0;
                var bgMaterial = this.m_bgMaterial;
                bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
                bgMaterial.uniforms.sdfParams.value = new THREE74.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
                bgMaterial.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1 : 0;
            }
        },
        {
            key: "material",
            get: function get() {
                return this.m_material;
            },
            set: function set(value2) {
                if (this.m_ownsMaterial) {
                    this.m_material.dispose();
                    this.m_ownsMaterial = false;
                }
                this.m_material = value2;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var layer = _step.value;
                        layer.storage.mesh.material = this.m_material;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "backgroundMaterial",
            get: function get() {
                return this.m_bgMaterial;
            },
            set: function set(value2) {
                if (this.m_ownsBgMaterial) {
                    this.m_bgMaterial.dispose();
                    this.m_ownsBgMaterial = false;
                }
                this.m_bgMaterial = value2;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var layer = _step.value;
                        layer.storage.backgroundMesh.material = this.m_bgMaterial;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "textRenderStyle",
            get: function get() {
                return this.m_currentTextRenderStyle;
            },
            set: function set(style) {
                this.m_currentTextRenderStyle.copy(style);
            }
        },
        {
            key: "textLayoutStyle",
            get: function get() {
                return this.m_currentTextLayoutStyle;
            },
            set: function set(style) {
                this.m_currentTextLayoutStyle.copy(style);
            }
        },
        {
            key: "clear",
            value: function clear() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var layer = _step.value;
                        layer.storage.clear();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                this.m_currentTextRenderStyle.copy(_TextCanvas.defaultTextRenderStyle);
                this.m_currentTextLayoutStyle.copy(_TextCanvas.defaultTextLayoutStyle);
            }
        },
        {
            key: "render",
            value: function render(camera, lowerLayerId, higherLayerId, target, clear) {
                this.m_fontCatalog.update(this.m_renderer);
                var oldTarget = null;
                if (target !== void 0) {
                    oldTarget = this.m_renderer.getRenderTarget();
                    this.m_renderer.setRenderTarget(target);
                }
                if (clear === true) {
                    this.m_renderer.clear(true);
                }
                for(var i = 0; i < this.m_layers.length; i++){
                    var layer = this.m_layers[i];
                    if (layer.id >= (lowerLayerId !== null && lowerLayerId !== void 0 ? lowerLayerId : 0)) {
                        if (higherLayerId === void 0 || layer.id < higherLayerId) {
                            layer.storage.update();
                            this.m_renderer.render(layer.storage.scene, camera);
                        } else {
                            break;
                        }
                    }
                }
                if (target !== void 0) {
                    this.m_renderer.setRenderTarget(oldTarget);
                }
            }
        },
        {
            key: "addLayer",
            value: function addLayer(layerId) {
                var result = this.getLayer(layerId);
                if (result === void 0) {
                    result = {
                        id: layerId,
                        storage: new TextGeometry(new THREE74.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
                    };
                    this.m_layers.push(result);
                    this.m_layers.sort(function(a, b) {
                        return a.id - b.id;
                    });
                }
                return result;
            }
        },
        {
            key: "getLayer",
            value: function getLayer(layerId) {
                return this.m_layers.find(function(layer) {
                    return layer.id === layerId;
                });
            }
        },
        {
            key: "getAllLayers",
            value: function getAllLayers() {
                return this.m_layers;
            }
        },
        {
            key: "measureText",
            value: function measureText(text, outputBounds, params) {
                tempTextPosition.set(0, 0, 0);
                var path;
                var pathOverflow;
                var upperCaseArray;
                var outputCharacterBounds;
                if (params !== void 0) {
                    path = params.path;
                    pathOverflow = params.pathOverflow;
                    outputCharacterBounds = params.outputCharacterBounds;
                    if (params.path !== void 0) {
                        var pathOrigin = params.path.getPoint(0);
                        if (pathOrigin === null) {
                            return false;
                        }
                        tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0);
                    }
                    if (params.letterCaseArray) {
                        upperCaseArray = params.letterCaseArray;
                    }
                }
                return this.placeText({
                    input: text,
                    layer: this.m_defaultLayer,
                    textPath: path,
                    textPathOverflow: pathOverflow,
                    bounds: outputBounds,
                    individualBounds: outputCharacterBounds,
                    letterCaseArray: upperCaseArray
                });
            }
        },
        {
            key: "addText",
            value: function addText(text, position, params) {
                tempTextPosition.copy(position);
                var path;
                var pathOverflow;
                var upperCaseArray;
                var targetLayer = this.m_defaultLayer;
                if (params !== void 0) {
                    path = params.path;
                    pathOverflow = params.pathOverflow;
                    if (params.layer !== void 0) {
                        var tempLayer = this.getLayer(params.layer);
                        if (tempLayer === void 0) {
                            tempLayer = this.addLayer(params.layer);
                        }
                        targetLayer = tempLayer;
                    }
                    if (params.path !== void 0) {
                        tempTextPosition.set(0, 0, tempTextPosition.z);
                    }
                    if (params.letterCaseArray) {
                        upperCaseArray = params.letterCaseArray;
                    }
                }
                var prevDrawCount = targetLayer.storage.drawCount;
                var result = this.placeText({
                    input: text,
                    textPath: path,
                    textPathOverflow: pathOverflow,
                    layer: targetLayer,
                    letterCaseArray: upperCaseArray
                });
                if (result && params !== void 0) {
                    if (params.updatePosition === true) {
                        position.copy(tempTextPosition);
                    }
                    if (params.pickingData !== void 0) {
                        targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
                    }
                } else if (!result) {
                    ;
                    targetLayer.storage.m_drawCount = prevDrawCount;
                }
                return result;
            }
        },
        {
            key: "createTextBufferObject",
            value: function createTextBufferObject(text, params) {
                tempTextPosition.set(0, 0, 0);
                var glyphArray;
                var upperCaseArray;
                var smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === 2 /* SmallCaps */ ;
                if (typeof text !== "string") {
                    glyphArray = text;
                    if (params !== void 0 && params.letterCaseArray) {
                        upperCaseArray = params.letterCaseArray;
                    }
                } else {
                    upperCaseArray = [];
                    glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : void 0);
                    if (glyphArray === void 0) {
                        return void 0;
                    }
                }
                var path;
                var pathOverflow;
                var textBounds;
                var characterBounds;
                var renderStyle;
                var layoutStyle;
                if (params !== void 0) {
                    path = params.path;
                    pathOverflow = params.pathOverflow;
                    if (params.outputBounds === true) {
                        textBounds = new THREE74.Box2();
                    }
                    if (params.outputCharacterBounds === true) {
                        characterBounds = [];
                    }
                    if (params.storeStyles === true) {
                        renderStyle = this.m_currentTextRenderStyle.clone();
                        layoutStyle = this.m_currentTextLayoutStyle.clone();
                    }
                }
                this.placeText({
                    input: text,
                    layer: this.m_defaultLayer,
                    computeTextBuffer: true,
                    textPath: path,
                    textPathOverflow: pathOverflow,
                    bounds: textBounds,
                    individualBounds: characterBounds,
                    letterCaseArray: upperCaseArray
                });
                return new TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);
            }
        },
        {
            key: "addTextBufferObject",
            value: function addTextBufferObject(textBufferObject, params) {
                var targetLayer = this.m_defaultLayer;
                var position;
                var scale;
                var rotation;
                var color;
                var opacity;
                var bgColor;
                var bgOpacity;
                if (params !== void 0) {
                    var ref;
                    if (params.layer !== void 0) {
                        var tempLayer = this.getLayer(params.layer);
                        if (tempLayer === void 0) {
                            tempLayer = this.addLayer(params.layer);
                        }
                        targetLayer = tempLayer;
                    }
                    position = (ref = params.position) === null || ref === void 0 ? void 0 : ref.clone();
                    scale = params.scale;
                    rotation = params.rotation;
                    color = params.color;
                    opacity = params.opacity;
                    bgColor = params.backgroundColor;
                    bgOpacity = params.backgroundOpacity;
                }
                var prevDrawCount = targetLayer.storage.drawCount;
                var result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);
                if (result && params !== void 0) {
                    if (params.pickingData !== void 0) {
                        targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
                    }
                } else if (!result) {
                    ;
                    targetLayer.storage.m_drawCount = prevDrawCount;
                }
                return result;
            }
        },
        {
            key: "pickText",
            value: function pickText(position, callback) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var layer = _step.value;
                        layer.storage.pick(position, callback);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "getMemoryUsage",
            value: function getMemoryUsage(info) {
                this.m_fontCatalog.updateMemoryUsage(info);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var layer = _step.value;
                        layer.storage.updateMemoryUsage(info);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "placeText",
            value: function placeText(params) {
                if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {
                    if (params.bounds !== void 0) {
                        params.bounds.min.set(0, 0);
                        params.bounds.max.set(0, 0);
                    }
                    if (params.individualBounds !== void 0) {
                        params.individualBounds.length = 0;
                    }
                    return true;
                }
                var glyphArray;
                var smallCapsTransformations;
                var smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === 2 /* SmallCaps */ ;
                if (typeof params.input !== "string") {
                    glyphArray = params.input;
                    if (params.letterCaseArray) {
                        smallCapsTransformations = params.letterCaseArray;
                    }
                } else {
                    smallCapsTransformations = [];
                    glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : void 0);
                    if (glyphArray === void 0) {
                        return false;
                    }
                }
                var glyphBounds;
                if (params.individualBounds !== void 0) {
                    tempTextBounds.array = params.individualBounds;
                    tempTextBounds.offset = 0;
                    glyphBounds = tempTextBounds;
                }
                if (params.bounds !== void 0) {
                    params.bounds.min.set(Infinity, Infinity);
                    params.bounds.max.set(-Infinity, -Infinity);
                }
                if (params.computeTextBuffer === true) {
                    tempVertexBuffer = new Float32Array(glyphArray.length * QUAD_VERTEX_MEMORY_FOOTPRINT);
                }
                var isPath = params.textPath !== void 0;
                var typesettingParams = {
                    glyphs: glyphArray,
                    fontCatalog: this.m_fontCatalog,
                    textRenderStyle: this.m_currentTextRenderStyle,
                    textLayoutStyle: this.m_currentTextLayoutStyle,
                    position: tempTextPosition,
                    geometry: params.layer.storage,
                    smallCapsArray: smallCapsEnabled ? smallCapsTransformations : void 0,
                    globalBounds: params.bounds,
                    individualBounds: glyphBounds,
                    vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : void 0
                };
                var result = true;
                if (isPath) {
                    Object.assign(typesettingParams, {
                        path: params.textPath,
                        pathOverflow: params.textPathOverflow === true
                    });
                    result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);
                } else {
                    result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);
                }
                if (glyphBounds !== void 0) {
                    glyphBounds.array.length = glyphBounds.offset;
                }
                return result;
            }
        }
    ]);
    return _TextCanvas;
}();
var TextCanvas = _TextCanvas;
__publicField(TextCanvas, "defaultTextRenderStyle", new TextRenderStyle());
__publicField(TextCanvas, "defaultTextLayoutStyle", new TextLayoutStyle());
// src/text-canvas/utils/ContextualArabicConverter.ts
var _ContextualArabicConverter = /*#__PURE__*/ function() {
    function _ContextualArabicConverter() {
        _classCallCheck(this, _ContextualArabicConverter);
        __publicField(this, "m_singleCharactersMap", /* @__PURE__ */ new Map());
        __publicField(this, "m_combinedCharactersMap", /* @__PURE__ */ new Map());
        __publicField(this, "m_neutralCharacters");
        this.m_singleCharactersMap.set(1569, [
            void 0,
            void 0,
            void 0
        ]);
        this.m_singleCharactersMap.set(1570, [
            void 0,
            void 0,
            65154
        ]);
        this.m_singleCharactersMap.set(1571, [
            void 0,
            void 0,
            65156
        ]);
        this.m_singleCharactersMap.set(1572, [
            void 0,
            void 0,
            65158
        ]);
        this.m_singleCharactersMap.set(1573, [
            void 0,
            void 0,
            65160
        ]);
        this.m_singleCharactersMap.set(1574, [
            65163,
            65164,
            65162
        ]);
        this.m_singleCharactersMap.set(1575, [
            void 0,
            void 0,
            65166
        ]);
        this.m_singleCharactersMap.set(1576, [
            65169,
            65170,
            65168
        ]);
        this.m_singleCharactersMap.set(1577, [
            void 0,
            void 0,
            65172
        ]);
        this.m_singleCharactersMap.set(1578, [
            65175,
            65176,
            65174
        ]);
        this.m_singleCharactersMap.set(1579, [
            65179,
            65180,
            65178
        ]);
        this.m_singleCharactersMap.set(1580, [
            65183,
            65184,
            65182
        ]);
        this.m_singleCharactersMap.set(1581, [
            65187,
            65188,
            65186
        ]);
        this.m_singleCharactersMap.set(1582, [
            65191,
            65192,
            65190
        ]);
        this.m_singleCharactersMap.set(1583, [
            void 0,
            void 0,
            65194
        ]);
        this.m_singleCharactersMap.set(1584, [
            void 0,
            void 0,
            65196
        ]);
        this.m_singleCharactersMap.set(1585, [
            void 0,
            void 0,
            65198
        ]);
        this.m_singleCharactersMap.set(1586, [
            void 0,
            void 0,
            65200
        ]);
        this.m_singleCharactersMap.set(1587, [
            65203,
            65204,
            65202
        ]);
        this.m_singleCharactersMap.set(1588, [
            65207,
            65208,
            65206
        ]);
        this.m_singleCharactersMap.set(1589, [
            65211,
            65212,
            65210
        ]);
        this.m_singleCharactersMap.set(1590, [
            65215,
            65216,
            65214
        ]);
        this.m_singleCharactersMap.set(1591, [
            65219,
            65220,
            65218
        ]);
        this.m_singleCharactersMap.set(1592, [
            65223,
            65224,
            65222
        ]);
        this.m_singleCharactersMap.set(1593, [
            65227,
            65228,
            65226
        ]);
        this.m_singleCharactersMap.set(1594, [
            65231,
            65232,
            65230
        ]);
        this.m_singleCharactersMap.set(1600, [
            1600,
            1600,
            1600
        ]);
        this.m_singleCharactersMap.set(1601, [
            65235,
            65236,
            65234
        ]);
        this.m_singleCharactersMap.set(1602, [
            65239,
            65240,
            65238
        ]);
        this.m_singleCharactersMap.set(1603, [
            65243,
            65244,
            65242
        ]);
        this.m_singleCharactersMap.set(1604, [
            65247,
            65248,
            65246
        ]);
        this.m_singleCharactersMap.set(1605, [
            65251,
            65252,
            65250
        ]);
        this.m_singleCharactersMap.set(1606, [
            65255,
            65256,
            65254
        ]);
        this.m_singleCharactersMap.set(1607, [
            65259,
            65260,
            65258
        ]);
        this.m_singleCharactersMap.set(1608, [
            void 0,
            void 0,
            65262
        ]);
        this.m_singleCharactersMap.set(1609, [
            void 0,
            void 0,
            65264
        ]);
        this.m_singleCharactersMap.set(1610, [
            65267,
            65268,
            65266
        ]);
        this.m_singleCharactersMap.set(1662, [
            64344,
            64345,
            64343
        ]);
        this.m_singleCharactersMap.set(1740, [
            64510,
            64511,
            64509
        ]);
        this.m_singleCharactersMap.set(1670, [
            64380,
            64381,
            64379
        ]);
        this.m_singleCharactersMap.set(1705, [
            64400,
            64401,
            64399
        ]);
        this.m_singleCharactersMap.set(1711, [
            64404,
            64405,
            64403
        ]);
        this.m_singleCharactersMap.set(1688, [
            void 0,
            void 0,
            64395
        ]);
        this.m_combinedCharactersMap.set(1604, /* @__PURE__ */ new Map());
        this.m_combinedCharactersMap.get(1604).set(1570, [
            65269,
            65270
        ]);
        this.m_combinedCharactersMap.get(1604).set(1571, [
            65271,
            65272
        ]);
        this.m_combinedCharactersMap.get(1604).set(1573, [
            65273,
            65274
        ]);
        this.m_combinedCharactersMap.get(1604).set(1575, [
            65275,
            65276
        ]);
        this.m_neutralCharacters = [
            1552,
            1554,
            1555,
            1556,
            1557,
            1611,
            1612,
            1613,
            1614,
            1615,
            1616,
            1617,
            1618,
            1619,
            1620,
            1621,
            1622,
            1623,
            1624,
            1648,
            1750,
            1751,
            1752,
            1753,
            1754,
            1755,
            1756,
            1759,
            1760,
            1761,
            1762,
            1763,
            1764,
            1767,
            1768,
            1770,
            1771,
            1772,
            1773
        ];
    }
    _createClass(_ContextualArabicConverter, [
        {
            key: "convert",
            value: function convert(input) {
                var output = "";
                for(var i = 0; i < input.length; ++i){
                    var currentCodePoint = input.charCodeAt(i);
                    if (this.isArabicCharacter(currentCodePoint)) {
                        var prevIndex = i - 1;
                        for(; prevIndex >= 0; --prevIndex){
                            if (!this.isNeutral(input.charCodeAt(prevIndex))) {
                                break;
                            }
                        }
                        var prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : void 0;
                        if (prevCodePoint !== void 0) {
                            var prevMap = this.getCharacterMap(prevCodePoint);
                            if (prevMap === void 0 || prevMap[0 /* Initial */ ] === void 0 && prevMap[1 /* Medial */ ] === void 0) {
                                prevCodePoint = void 0;
                            }
                        }
                        var nextIndex = i + 1;
                        for(; nextIndex < input.length; ++nextIndex){
                            if (!this.isNeutral(input.charCodeAt(nextIndex))) {
                                break;
                            }
                        }
                        var nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : void 0;
                        if (nextCodePoint !== void 0) {
                            var nextMap = this.getCharacterMap(nextCodePoint);
                            if (nextMap === void 0 || nextMap[1 /* Medial */ ] === void 0 && nextMap[2 /* Final */ ] === void 0) {
                                nextCodePoint = void 0;
                            }
                        }
                        if (currentCodePoint === 1604 && nextCodePoint !== void 0 && (nextCodePoint === 1570 || nextCodePoint === 1571 || nextCodePoint === 1573 || nextCodePoint === 1575)) {
                            var combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);
                            if (prevCodePoint !== void 0) {
                                output += String.fromCharCode(combinedMap[1 /* Connected */ ]);
                            } else {
                                output += String.fromCharCode(combinedMap[0 /* Isolated */ ]);
                            }
                            ++i;
                            continue;
                        }
                        var map = this.getCharacterMap(currentCodePoint);
                        if (prevCodePoint !== void 0 && nextCodePoint !== void 0 && map[1 /* Medial */ ] !== void 0) {
                            output += String.fromCharCode(map[1 /* Medial */ ]);
                        } else if (prevCodePoint !== void 0 && map[2 /* Final */ ] !== void 0) {
                            output += String.fromCharCode(map[2 /* Final */ ]);
                        } else if (nextCodePoint !== void 0 && map[0 /* Initial */ ] !== void 0) {
                            output += String.fromCharCode(map[0 /* Initial */ ]);
                        } else {
                            output += String.fromCharCode(currentCodePoint);
                        }
                    } else {
                        output += String.fromCharCode(currentCodePoint);
                    }
                }
                return output;
            }
        },
        {
            key: "isArabicCharacter",
            value: function isArabicCharacter(codePoint) {
                return this.m_singleCharactersMap.has(codePoint);
            }
        },
        {
            key: "getCharacterMap",
            value: function getCharacterMap(codePoint) {
                return this.m_singleCharactersMap.get(codePoint);
            }
        },
        {
            key: "getCombinedCharacterMap",
            value: function getCombinedCharacterMap(codePoint, nextCodePoint) {
                var map = this.m_combinedCharactersMap.get(codePoint);
                if (map !== void 0) {
                    return map.get(nextCodePoint);
                }
                return void 0;
            }
        },
        {
            key: "isNeutral",
            value: function isNeutral(codePoint) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_neutralCharacters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var character = _step.value;
                        if (character === codePoint) {
                            return true;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return false;
            }
        }
    ], [
        {
            key: "instance",
            get: function get() {
                if (this.m_instance === void 0) {
                    this.m_instance = new _ContextualArabicConverter();
                }
                return this.m_instance;
            }
        }
    ]);
    return _ContextualArabicConverter;
}();
var ContextualArabicConverter = _ContextualArabicConverter;
__publicField(ContextualArabicConverter, "m_instance");
// src/mapview/ColorCache.ts
var THREE75 = __toESM(require("three"));
var _ColorCache = /*#__PURE__*/ function() {
    function _ColorCache() {
        _classCallCheck(this, _ColorCache);
        __publicField(this, "m_map", /* @__PURE__ */ new Map());
    }
    _createClass(_ColorCache, [
        {
            key: "getColor",
            value: function getColor(colorCode) {
                if (typeof colorCode === "number") {
                    colorCode = "#" + colorCode.toString(16).padStart(6, "0");
                }
                var color = this.m_map.get(colorCode);
                if (color !== void 0) {
                    return color;
                }
                color = new THREE75.Color(colorCode);
                this.m_map.set(colorCode, color);
                return color;
            }
        },
        {
            key: "size",
            get: function get() {
                return this.m_map.size;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_map.clear();
            }
        }
    ], [
        {
            key: "instance",
            get: function get() {
                return this.m_instance;
            }
        }
    ]);
    return _ColorCache;
}();
var ColorCache = _ColorCache;
__publicField(ColorCache, "m_instance", new _ColorCache());
// src/mapview/poi/PoiBuilder.ts
var logger13 = LoggerManager.instance.create("PoiBuilder");
function getImageTexture(technique, env) {
    return technique.imageTexture !== void 0 ? composeTechniqueTextureName(getPropertyValue(technique.imageTexture, env), technique) : void 0;
}
var PoiBuilder = /*#__PURE__*/ function() {
    function PoiBuilder(m_env) {
        _classCallCheck(this, PoiBuilder);
        this.m_env = m_env;
        __publicField(this, "m_iconMinZoomLevel");
        __publicField(this, "m_iconMaxZoomLevel");
        __publicField(this, "m_textMinZoomLevel");
        __publicField(this, "m_textMaxZoomLevel");
        __publicField(this, "m_technique");
        __publicField(this, "m_imageTextureName");
        __publicField(this, "m_shieldGroupIndex");
    }
    _createClass(PoiBuilder, [
        {
            key: "withTechnique",
            value: function withTechnique(technique) {
                this.m_imageTextureName = getImageTexture(technique, this.m_env);
                var _iconMinZoomLevel, ref;
                this.m_iconMinZoomLevel = (ref = getPropertyValue((_iconMinZoomLevel = technique.iconMinZoomLevel) !== null && _iconMinZoomLevel !== void 0 ? _iconMinZoomLevel : technique.minZoomLevel, this.m_env)) !== null && ref !== void 0 ? ref : void 0;
                var _iconMaxZoomLevel, ref1;
                this.m_iconMaxZoomLevel = (ref1 = getPropertyValue((_iconMaxZoomLevel = technique.iconMaxZoomLevel) !== null && _iconMaxZoomLevel !== void 0 ? _iconMaxZoomLevel : technique.maxZoomLevel, this.m_env)) !== null && ref1 !== void 0 ? ref1 : void 0;
                var _textMinZoomLevel, ref2;
                this.m_textMinZoomLevel = (ref2 = getPropertyValue((_textMinZoomLevel = technique.textMinZoomLevel) !== null && _textMinZoomLevel !== void 0 ? _textMinZoomLevel : technique.minZoomLevel, this.m_env)) !== null && ref2 !== void 0 ? ref2 : void 0;
                var _textMaxZoomLevel, ref3;
                this.m_textMaxZoomLevel = (ref3 = getPropertyValue((_textMaxZoomLevel = technique.textMaxZoomLevel) !== null && _textMaxZoomLevel !== void 0 ? _textMaxZoomLevel : technique.maxZoomLevel, this.m_env)) !== null && ref3 !== void 0 ? ref3 : void 0;
                this.m_technique = technique;
                return this;
            }
        },
        {
            key: "withIcon",
            value: function withIcon(imageTextureName, shieldGroupIndex) {
                if (imageTextureName !== void 0) {
                    this.m_imageTextureName = imageTextureName;
                }
                this.m_shieldGroupIndex = shieldGroupIndex;
                return this;
            }
        },
        {
            key: "build",
            value: function build(textElement) {
                assert(this.m_technique !== void 0);
                var technique = this.m_technique;
                var env = this.m_env;
                var imageTextureName = this.m_imageTextureName;
                var _poiName;
                var poiName = technique.poiTable !== void 0 ? (_poiName = technique.poiName) !== null && _poiName !== void 0 ? _poiName : imageTextureName : void 0;
                if (imageTextureName !== void 0 && poiName !== void 0) {
                    logger13.warn("Possible duplicate POI icon definition via imageTextureName and poiTable!");
                }
                if (imageTextureName === void 0 && poiName === void 0) {
                    var _minZoomLevel;
                    textElement.minZoomLevel = (_minZoomLevel = textElement.minZoomLevel) !== null && _minZoomLevel !== void 0 ? _minZoomLevel : this.m_textMinZoomLevel;
                    var _maxZoomLevel;
                    textElement.maxZoomLevel = (_maxZoomLevel = textElement.maxZoomLevel) !== null && _maxZoomLevel !== void 0 ? _maxZoomLevel : this.m_textMaxZoomLevel;
                    return void 0;
                }
                var textIsOptional = technique.textIsOptional === true;
                var iconIsOptional = technique.iconIsOptional === true;
                var renderTextDuringMovements = !(technique.renderTextDuringMovements === false);
                var _iconMayOverlap;
                var iconMayOverlap = (_iconMayOverlap = technique.iconMayOverlap) !== null && _iconMayOverlap !== void 0 ? _iconMayOverlap : technique.textMayOverlap;
                var _iconReserveSpace;
                var iconReserveSpace = (_iconReserveSpace = technique.iconReserveSpace) !== null && _iconReserveSpace !== void 0 ? _iconReserveSpace : technique.textReserveSpace;
                var iconColorRaw = getPropertyValue(technique.iconColor, env);
                var iconColor = iconColorRaw !== null ? ColorCache.instance.getColor(iconColorRaw) : void 0;
                var poiInfo = {
                    technique: technique,
                    imageTextureName: imageTextureName,
                    poiTableName: technique.poiTable,
                    poiName: poiName,
                    shieldGroupIndex: this.m_shieldGroupIndex,
                    textElement: textElement,
                    textIsOptional: textIsOptional,
                    iconIsOptional: iconIsOptional,
                    renderTextDuringMovements: renderTextDuringMovements,
                    mayOverlap: iconMayOverlap,
                    reserveSpace: iconReserveSpace,
                    iconBrightness: technique.iconBrightness,
                    iconColor: iconColor,
                    iconMinZoomLevel: this.m_iconMinZoomLevel,
                    iconMaxZoomLevel: this.m_iconMaxZoomLevel,
                    textMinZoomLevel: this.m_textMinZoomLevel,
                    textMaxZoomLevel: this.m_textMaxZoomLevel
                };
                return poiInfo;
            }
        }
    ]);
    return PoiBuilder;
}();
// src/mapview/text/TextElement.ts
var THREE76 = __toESM(require("three"));
// src/mapview/text/TextElementType.ts
var TextElementType = /* @__PURE__ */ function(TextElementType2) {
    TextElementType2[TextElementType2["PoiLabel"] = 0] = "PoiLabel";
    TextElementType2[TextElementType2["PathLabel"] = 1] = "PathLabel";
    TextElementType2[TextElementType2["LineMarker"] = 2] = "LineMarker";
    return TextElementType2;
}(TextElementType || {});
// src/mapview/text/TextElement.ts
function poiIsRenderable(poiInfo) {
    return poiInfo.buffer !== void 0;
}
var LoadingState = /* @__PURE__ */ function(LoadingState2) {
    LoadingState2[LoadingState2["Requested"] = 0] = "Requested";
    LoadingState2[LoadingState2["Loaded"] = 1] = "Loaded";
    LoadingState2[LoadingState2["Initialized"] = 2] = "Initialized";
    return LoadingState2;
}(LoadingState || {});
var TextElement = /*#__PURE__*/ function() {
    function TextElement(text, points, renderParams, layoutParams) {
        var priority = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, xOffset = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, yOffset = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0, featureId = arguments.length > 7 ? arguments[7] : void 0, style = arguments.length > 8 ? arguments[8] : void 0, fadeNear = arguments.length > 9 ? arguments[9] : void 0, fadeFar = arguments.length > 10 ? arguments[10] : void 0, tileOffset = arguments.length > 11 ? arguments[11] : void 0, offsetDirection = arguments.length > 12 ? arguments[12] : void 0, dataSourceName = arguments.length > 13 ? arguments[13] : void 0, dataSourceOrder = arguments.length > 14 ? arguments[14] : void 0;
        _classCallCheck(this, TextElement);
        this.text = text;
        this.points = points;
        this.renderParams = renderParams;
        this.layoutParams = layoutParams;
        this.priority = priority;
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.featureId = featureId;
        this.style = style;
        this.fadeNear = fadeNear;
        this.fadeFar = fadeFar;
        this.tileOffset = tileOffset;
        this.offsetDirection = offsetDirection;
        this.dataSourceName = dataSourceName;
        this.dataSourceOrder = dataSourceOrder;
        __publicField(this, "visible", true);
        __publicField(this, "minZoomLevel");
        __publicField(this, "maxZoomLevel");
        __publicField(this, "mayOverlap");
        __publicField(this, "reserveSpace");
        __publicField(this, "alwaysOnTop");
        __publicField(this, "ignoreDistance");
        __publicField(this, "distanceScale", 0.5);
        __publicField(this, "userData");
        __publicField(this, "renderOrder", 0);
        __publicField(this, "kind");
        __publicField(this, "loadingState");
        __publicField(this, "elevated", false);
        __publicField(this, "glyphs");
        __publicField(this, "glyphCaseArray");
        __publicField(this, "bounds");
        __publicField(this, "textBufferObject");
        __publicField(this, "dbgPathTooSmall");
        __publicField(this, "pathLengthSqr");
        __publicField(this, "textFadeTime");
        __publicField(this, "type");
        __publicField(this, "m_poiInfo");
        __publicField(this, "m_renderStyle");
        __publicField(this, "m_layoutStyle");
        if (_instanceof(renderParams, TextRenderStyle)) {
            this.renderStyle = renderParams;
        }
        if (_instanceof(layoutParams, TextLayoutStyle)) {
            this.layoutStyle = layoutParams;
        }
        this.type = _instanceof(points, THREE76.Vector3) ? 0 /* PoiLabel */  : 1 /* PathLabel */ ;
    }
    _createClass(TextElement, [
        {
            key: "position",
            get: function get() {
                if (_instanceof(this.points, Array)) {
                    var p = this.points[0];
                    return p;
                }
                return this.points;
            }
        },
        {
            key: "path",
            get: function get() {
                if (_instanceof(this.points, Array)) {
                    return this.points;
                }
                return void 0;
            }
        },
        {
            key: "textMayOverlap",
            get: function get() {
                return this.mayOverlap === true;
            },
            set: function set(mayOverlap) {
                this.mayOverlap = mayOverlap;
            }
        },
        {
            key: "textReservesSpace",
            get: function get() {
                return this.reserveSpace !== false;
            },
            set: function set(reserveSpace) {
                this.reserveSpace = reserveSpace;
            }
        },
        {
            key: "poiInfo",
            get: function get() {
                return this.m_poiInfo;
            },
            set: function set(poiInfo) {
                this.m_poiInfo = poiInfo;
                if (poiInfo !== void 0) {
                    if (this.path !== void 0) {
                        this.type = 2 /* LineMarker */ ;
                    }
                    var poiRenderOrder = this.renderOrder !== void 0 ? this.renderOrder : 0;
                    poiInfo.renderOrder = poiRenderOrder;
                }
            }
        },
        {
            key: "renderStyle",
            get: function get() {
                return this.m_renderStyle;
            },
            set: function set(style) {
                this.m_renderStyle = style;
            }
        },
        {
            key: "layoutStyle",
            get: function get() {
                return this.m_layoutStyle;
            },
            set: function set(style) {
                this.m_layoutStyle = style;
            }
        },
        {
            key: "hasFeatureId",
            value: function hasFeatureId() {
                if (this.featureId === void 0) {
                    return false;
                }
                if (typeof this.featureId === "number") {
                    return this.featureId !== 0;
                }
                return this.featureId.length > 0;
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                var ref;
                var poiBuffer = (ref = this.poiInfo) === null || ref === void 0 ? void 0 : ref.buffer;
                if (poiBuffer) {
                    poiBuffer.decreaseRefCount();
                }
            }
        }
    ]);
    return TextElement;
}();
__publicField(TextElement, "HIGHEST_PRIORITY", Number.MAX_SAFE_INTEGER);
// src/mapview/text/TextElementsRenderer.ts
var THREE84 = __toESM(require("three"));
// src/mapview/DebugContext.ts
var THREE77 = __toESM(require("three"));
var isNode2 = typeof window === "undefined";
var _DebugOption = /*#__PURE__*/ function(_EventDispatcher) {
    _inherits(_DebugOption, _EventDispatcher);
    var _super = _createSuper(_DebugOption);
    function _DebugOption(value2) {
        _classCallCheck(this, _DebugOption);
        var _this;
        _this = _super.call(this);
        _this.value = value2;
        return _this;
    }
    _createClass(_DebugOption, [
        {
            key: "set",
            value: function set(value2, name2) {
                this.value = value2;
                this.dispatchEvent({
                    type: _DebugOption.SET_EVENT_TYPE,
                    name: name2,
                    value: value2
                });
            }
        }
    ]);
    return _DebugOption;
}(THREE77.EventDispatcher);
var DebugOption = _DebugOption;
__publicField(DebugOption, "SET_EVENT_TYPE", "set");
var DebugContext = /*#__PURE__*/ function() {
    function DebugContext() {
        _classCallCheck(this, DebugContext);
        __publicField(this, "m_optionsMap");
        this.m_optionsMap = /* @__PURE__ */ new Map();
        if (!isNode2 && typeof window !== "undefined" && window) {
            var debugInfo = window;
            debugInfo.__debugContext = this;
        }
    }
    _createClass(DebugContext, [
        {
            key: "setValue",
            value: function setValue(name2, value2) {
                var opt = this.m_optionsMap.get(name2);
                if (!opt) {
                    opt = new DebugOption(value2);
                    this.m_optionsMap.set(name2, opt);
                } else {
                    opt.set(value2, name2);
                }
            }
        },
        {
            key: "getValue",
            value: function getValue(name2) {
                var opt = this.m_optionsMap.get(name2);
                return opt ? opt.value : void 0;
            }
        },
        {
            key: "hasOption",
            value: function hasOption(name2) {
                return this.m_optionsMap.get(name2) !== void 0;
            }
        },
        {
            key: "addEventListener",
            value: function addEventListener(name2, listener) {
                var opt = this.m_optionsMap.get(name2);
                if (opt) {
                    opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);
                } else {
                    throw Error("Unknown option: " + name2);
                }
            }
        },
        {
            key: "hasEventListener",
            value: function hasEventListener(name2, listener) {
                var opt = this.m_optionsMap.get(name2);
                if (opt) {
                    return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);
                } else {
                    throw Error("Unknown option: " + name2);
                }
            }
        },
        {
            key: "removeEventListener",
            value: function removeEventListener(name2, listener) {
                var opt = this.m_optionsMap.get(name2);
                if (opt) {
                    opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);
                } else {
                    throw Error("Unknown option: " + name2);
                }
            }
        },
        {
            key: "options",
            get: function get() {
                return this.m_optionsMap;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_optionsMap.forEach(function(option) {
                    option.set(void 0, "");
                });
            }
        }
    ]);
    return DebugContext;
}();
var debugContext = new DebugContext();
// src/mapview/geometry/overlayOnElevation.ts
function overlayPosition(worldCoords, elevationProvider, displacementMap, projection) {
    var geoCoords = projection.unprojectPoint(worldCoords);
    if (displacementMap.geoBox.contains(geoCoords)) {
        geoCoords.altitude = elevationProvider.sampleHeight(geoCoords, displacementMap);
    } else {
        geoCoords.altitude = elevationProvider.getHeight(geoCoords, displacementMap.tileKey.level);
        if (geoCoords.altitude === void 0) {
            return false;
        }
    }
    projection.projectPoint(geoCoords, worldCoords);
    return true;
}
function overlayPath(path, elevationProvider, displacementMap, projection) {
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var position = _step.value;
            if (!overlayPosition(position, elevationProvider, displacementMap, projection)) {
                return false;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return true;
}
function overlayTextElement(textElement, elevationProvider, displacementMap, projection) {
    assert(!textElement.elevated);
    if (!displacementMap) {
        return;
    }
    textElement.elevated = textElement.path ? overlayPath(textElement.path, elevationProvider, displacementMap, projection) : overlayPosition(textElement.position, elevationProvider, displacementMap, projection);
}
// src/mapview/poi/PoiRenderer.ts
var THREE79 = __toESM(require("three"));
// src/mapview/poi/BoxBuffer.ts
var THREE78 = __toESM(require("three"));
// src/mapview/poi/PixelPicker.ts
function getPixelFromImage(xPos, yPos, image, canvas) {
    if (_instanceof(image, ImageData)) {
        var stride = image.data.length / (image.height * image.width);
        return getPixelFromImageData(image, xPos, yPos, stride);
    }
    if (!canvas) {
        canvas = document.createElement("canvas");
    }
    return getPixelFromCanvasImageSource(image, xPos, yPos, canvas);
}
function screenToUvCoordinates(screenX, screenY, box, uvBox) {
    var minX = box.x;
    var maxX = box.x + box.w;
    var minY = box.y;
    var maxY = box.y + box.h;
    var u = MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);
    var v = MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);
    return {
        u: u,
        v: v
    };
}
function getPixelFromCanvasImageSource(image, xPos, yPos, canvas) {
    var ref = _instanceof(image, SVGImageElement) ? image.getBBox() : image, width = ref.width, height = ref.height;
    if (xPos > width || xPos < 0 || yPos > height || yPos < 0) {
        return void 0;
    }
    var pixelData;
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext("2d");
    if (context !== null) {
        context.drawImage(image, 0, 0);
        pixelData = context.getImageData(xPos, yPos, 1, 1).data;
    }
    return pixelData;
}
function getPixelFromImageData(imgData, xPos, yPos, stride) {
    var getPixel = function(imageData, index, strd) {
        var i = index * strd;
        var d = imageData.data;
        var pixel = new Uint8ClampedArray(strd);
        for(var s = 0; s < strd; s++){
            pixel[0] = d[i + s];
        }
        return pixel;
    };
    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {
        return void 0;
    }
    return getPixel(imgData, yPos * imgData.width + xPos, stride);
}
// src/mapview/poi/BoxBuffer.ts
var START_BOX_BUFFER_SIZE = 0;
var MAX_BOX_BUFFER_SIZE = 32 * 1024;
var NUM_VERTICES_PER_ELEMENT = 4;
var NUM_INDICES_PER_ELEMENT = 6;
var NUM_POSITION_VALUES_PER_VERTEX = 3;
var NUM_COLOR_VALUES_PER_VERTEX = 4;
var NUM_UV_VALUES_PER_VERTEX = 4;
var NUM_INDEX_VALUES_PER_VERTEX = 1;
var NUM_BYTES_PER_FLOAT2 = 4;
var NUM_BYTES_PER_INT322 = 4;
var BoxBufferMesh = /*#__PURE__*/ function(_Mesh) {
    _inherits(BoxBufferMesh, _Mesh);
    var _super = _createSuper(BoxBufferMesh);
    function BoxBufferMesh(geometry, material) {
        _classCallCheck(this, BoxBufferMesh);
        var _this;
        _this = _super.call(this, geometry, material);
        _this.type = "BoxBufferMesh";
        return _this;
    }
    _createClass(BoxBufferMesh, [
        {
            key: "isEmpty",
            get: function get() {
                if (this.geometry === void 0) {
                    return true;
                } else {
                    var bufferGeometry = this.geometry;
                    return bufferGeometry.index === null || bufferGeometry.index.count === 0;
                }
            }
        }
    ]);
    return BoxBufferMesh;
}(THREE78.Mesh);
var BoxBuffer = /*#__PURE__*/ function() {
    function BoxBuffer(m_material) {
        var m_renderOrder = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, startElementCount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : START_BOX_BUFFER_SIZE, m_maxElementCount = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : MAX_BOX_BUFFER_SIZE;
        _classCallCheck(this, BoxBuffer);
        this.m_material = m_material;
        this.m_renderOrder = m_renderOrder;
        this.m_maxElementCount = m_maxElementCount;
        __publicField(this, "m_positionAttribute");
        __publicField(this, "m_colorAttribute");
        __publicField(this, "m_uvAttribute");
        __publicField(this, "m_indexAttribute");
        __publicField(this, "m_pickInfos");
        __publicField(this, "m_geometry");
        __publicField(this, "m_mesh");
        __publicField(this, "m_size", 0);
        this.resizeBuffer(startElementCount);
        this.m_pickInfos = new Array();
    }
    _createClass(BoxBuffer, [
        {
            key: "clone",
            value: function clone() {
                return new BoxBuffer(this.m_material, this.m_renderOrder);
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                if (this.m_geometry !== void 0) {
                    this.m_geometry.dispose();
                    this.m_geometry = void 0;
                }
                this.m_mesh = void 0;
            }
        },
        {
            key: "size",
            get: function get() {
                return this.m_size;
            }
        },
        {
            key: "reset",
            value: function reset() {
                if (this.m_positionAttribute !== void 0) {
                    this.m_positionAttribute.count = 0;
                    this.m_colorAttribute.count = 0;
                    this.m_uvAttribute.count = 0;
                    this.m_indexAttribute.count = 0;
                    this.m_pickInfos.length = 0;
                }
            }
        },
        {
            key: "canAddElements",
            value: function canAddElements() {
                var glyphCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                var indexAttribute = this.m_indexAttribute;
                if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >= indexAttribute.array.length) {
                    if (indexAttribute.array.length >= this.m_maxElementCount * NUM_INDICES_PER_ELEMENT) {
                        return false;
                    }
                    var newSize = Math.min(this.m_maxElementCount, this.size === 0 ? 256 : this.size * 2);
                    this.resize(newSize);
                }
                return true;
            }
        },
        {
            key: "saveState",
            value: function saveState() {
                var state = {
                    positionAttributeCount: this.m_positionAttribute.count,
                    colorAttributeCount: this.m_colorAttribute.count,
                    uvAttributeCount: this.m_uvAttribute.count,
                    indexAttributeCount: this.m_indexAttribute.count,
                    pickInfoCount: this.m_pickInfos.length
                };
                return state;
            }
        },
        {
            key: "restoreState",
            value: function restoreState(state) {
                this.m_positionAttribute.count = state.positionAttributeCount;
                this.m_colorAttribute.count = state.colorAttributeCount;
                this.m_uvAttribute.count = state.uvAttributeCount;
                this.m_indexAttribute.count = state.indexAttributeCount;
                this.m_pickInfos.length = state.pickInfoCount;
            }
        },
        {
            key: "addBox",
            value: function addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {
                if (!this.canAddElements()) {
                    return false;
                }
                var s0 = uvBox.s0, t0 = uvBox.t0, s1 = uvBox.s1, t1 = uvBox.t1;
                var x = screenBox.x, y = screenBox.y, w = screenBox.w, h = screenBox.h;
                var r = Math.round(color.r * opacity * 255);
                var g = Math.round(color.g * opacity * 255);
                var b = Math.round(color.b * opacity * 255);
                var a = Math.round(opacity * 255);
                var positionAttribute = this.m_positionAttribute;
                var colorAttribute = this.m_colorAttribute;
                var uvAttribute = this.m_uvAttribute;
                var indexAttribute = this.m_indexAttribute;
                var baseVertex = positionAttribute.count;
                var baseIndex = indexAttribute.count;
                positionAttribute.setXYZ(baseVertex, x, y, distance);
                positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);
                positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);
                positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);
                colorAttribute.setXYZW(baseVertex, r, g, b, a);
                colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);
                colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);
                colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);
                uvAttribute.setXY(baseVertex, s0, t0);
                uvAttribute.setXY(baseVertex + 1, s1, t0);
                uvAttribute.setXY(baseVertex + 2, s0, t1);
                uvAttribute.setXY(baseVertex + 3, s1, t1);
                indexAttribute.setX(baseIndex, baseVertex);
                indexAttribute.setX(baseIndex + 1, baseVertex + 1);
                indexAttribute.setX(baseIndex + 2, baseVertex + 2);
                indexAttribute.setX(baseIndex + 3, baseVertex + 2);
                indexAttribute.setX(baseIndex + 4, baseVertex + 1);
                indexAttribute.setX(baseIndex + 5, baseVertex + 3);
                positionAttribute.count += NUM_VERTICES_PER_ELEMENT;
                colorAttribute.count += NUM_VERTICES_PER_ELEMENT;
                uvAttribute.count += NUM_VERTICES_PER_ELEMENT;
                indexAttribute.count += NUM_INDICES_PER_ELEMENT;
                this.m_pickInfos.push(pickInfo);
                return true;
            }
        },
        {
            key: "updateBufferGeometry",
            value: function updateBufferGeometry() {
                var positionAttribute = this.m_positionAttribute;
                var colorAttribute = this.m_colorAttribute;
                var uvAttribute = this.m_uvAttribute;
                var indexAttribute = this.m_indexAttribute;
                if (positionAttribute.count > 0) {
                    positionAttribute.needsUpdate = true;
                    positionAttribute.updateRange.offset = 0;
                    positionAttribute.updateRange.count = positionAttribute.count * NUM_VERTICES_PER_ELEMENT;
                }
                if (colorAttribute.count > 0) {
                    colorAttribute.needsUpdate = true;
                    colorAttribute.updateRange.offset = 0;
                    colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;
                }
                if (uvAttribute.count > 0) {
                    uvAttribute.needsUpdate = true;
                    uvAttribute.updateRange.offset = 0;
                    uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;
                }
                if (indexAttribute.count > 0) {
                    indexAttribute.needsUpdate = true;
                    indexAttribute.updateRange.offset = 0;
                    indexAttribute.updateRange.count = indexAttribute.count;
                }
                if (this.m_geometry !== void 0) {
                    this.m_geometry.clearGroups();
                    this.m_geometry.addGroup(0, this.m_indexAttribute.count);
                }
            }
        },
        {
            key: "cleanUp",
            value: function cleanUp() {
                if (this.m_indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {
                    this.clearAttributes();
                }
            }
        },
        {
            key: "isEmpty",
            get: function get() {
                return this.m_mesh.isEmpty;
            }
        },
        {
            key: "mesh",
            get: function get() {
                if (this.m_mesh === void 0) {
                    this.resize();
                }
                return this.m_mesh;
            }
        },
        {
            key: "pickBoxes",
            value: function pickBoxes(screenPosition, pickCallback, image) {
                var n = this.m_pickInfos.length;
                var pickInfos = this.m_pickInfos;
                var positions = this.m_positionAttribute;
                var screenX = screenPosition.x;
                var screenY = screenPosition.y;
                for(var pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++){
                    var positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;
                    var minX = positions.getX(positionIndex);
                    if (screenX < minX) {
                        continue;
                    }
                    var maxX = positions.getX(positionIndex + 1);
                    if (screenX > maxX) {
                        continue;
                    }
                    var minY = positions.getY(positionIndex);
                    if (screenY < minY) {
                        continue;
                    }
                    var maxY = positions.getY(positionIndex + 2);
                    if (screenY > maxY) {
                        continue;
                    }
                    var box = new Math2D.Box(minX, minY, maxX - minX, maxY - minY);
                    if (image !== void 0 && pickInfos[pickInfoIndex].poiInfo !== void 0 && pickInfos[pickInfoIndex].poiInfo.uvBox !== void 0 && this.isPixelTransparent(image, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, document.createElement("canvas"))) {
                        continue;
                    }
                    if (pickInfos[pickInfoIndex] !== void 0) {
                        pickCallback(pickInfos[pickInfoIndex]);
                    }
                }
            }
        },
        {
            key: "resize",
            value: function resize(newSize, forceResize) {
                if (this.m_geometry !== void 0) {
                    this.m_geometry.dispose();
                }
                this.m_geometry = new THREE78.BufferGeometry();
                if (newSize !== void 0 && (forceResize === true || newSize > this.size)) {
                    this.resizeBuffer(newSize);
                }
                this.m_geometry.setAttribute("position", this.m_positionAttribute);
                this.m_geometry.setAttribute("color", this.m_colorAttribute);
                this.m_geometry.setAttribute("uv", this.m_uvAttribute);
                this.m_geometry.setIndex(this.m_indexAttribute);
                this.m_geometry.addGroup(0, this.m_indexAttribute.count);
                if (this.m_mesh === void 0) {
                    this.m_mesh = new BoxBufferMesh(this.m_geometry, this.m_material);
                    this.m_mesh.renderOrder = this.m_renderOrder;
                } else {
                    this.m_mesh.geometry = this.m_geometry;
                }
                return this.m_mesh;
            }
        },
        {
            key: "updateMemoryUsage",
            value: function updateMemoryUsage(info) {
                var numBytes = this.m_positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT2 + this.m_colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX + this.m_uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT2 + this.m_indexAttribute.count * NUM_BYTES_PER_INT322;
                info.heapSize += numBytes;
                info.gpuSize += numBytes;
            }
        },
        {
            key: "isPixelTransparent",
            value: function isPixelTransparent(image, xScreenPos, yScreenPos, box, uvBox, canvas) {
                var ref = screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox), u = ref.u, v = ref.v;
                var ref1 = _instanceof(image, SVGImageElement) ? image.getBBox() : image, width = ref1.width, height = ref1.height;
                var x = width * u;
                var y = height * v;
                var pixel = getPixelFromImage(x, y, image, canvas);
                return pixel !== void 0 && pixel[3] === 0;
            }
        },
        {
            key: "clearAttributes",
            value: function clearAttributes() {
                this.m_positionAttribute = void 0;
                this.m_colorAttribute = void 0;
                this.m_uvAttribute = void 0;
                this.m_indexAttribute = void 0;
                this.resize(START_BOX_BUFFER_SIZE, true);
            }
        },
        {
            key: "resizeBuffer",
            value: function resizeBuffer(newSize) {
                var newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);
                if (this.m_positionAttribute !== void 0 && this.m_positionAttribute.array.length > 0) {
                    var positionAttributeCount = this.m_positionAttribute.count;
                    newPositionArray.set(this.m_positionAttribute.array);
                    this.m_positionAttribute.array = newPositionArray;
                    this.m_positionAttribute.count = positionAttributeCount;
                } else {
                    this.m_positionAttribute = new THREE78.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);
                    this.m_positionAttribute.count = 0;
                    this.m_positionAttribute.setUsage(THREE78.DynamicDrawUsage);
                }
                var newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);
                if (this.m_colorAttribute !== void 0) {
                    var colorAttributeCount = this.m_colorAttribute.count;
                    newColorArray.set(this.m_colorAttribute.array);
                    this.m_colorAttribute.array = newColorArray;
                    this.m_colorAttribute.count = colorAttributeCount;
                } else {
                    this.m_colorAttribute = new THREE78.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);
                    this.m_colorAttribute.count = 0;
                    this.m_colorAttribute.setUsage(THREE78.DynamicDrawUsage);
                }
                var newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);
                if (this.m_uvAttribute !== void 0) {
                    var uvAttributeCount = this.m_uvAttribute.count;
                    newUvArray.set(this.m_uvAttribute.array);
                    this.m_uvAttribute.array = newUvArray;
                    this.m_uvAttribute.count = uvAttributeCount;
                } else {
                    this.m_uvAttribute = new THREE78.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);
                    this.m_uvAttribute.count = 0;
                    this.m_uvAttribute.setUsage(THREE78.DynamicDrawUsage);
                }
                var numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;
                var newIndexArray = numIndexValues > 65535 ? new Uint32Array(numIndexValues) : new Uint16Array(numIndexValues);
                if (this.m_indexAttribute !== void 0) {
                    var indexAttributeCount = this.m_indexAttribute.count;
                    newIndexArray.set(this.m_indexAttribute.array);
                    this.m_indexAttribute.array = newIndexArray;
                    this.m_indexAttribute.count = indexAttributeCount;
                } else {
                    this.m_indexAttribute = new THREE78.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);
                    this.m_indexAttribute.count = 0;
                    this.m_indexAttribute.setUsage(THREE78.DynamicDrawUsage);
                }
                this.m_size = newSize;
            }
        }
    ]);
    return BoxBuffer;
}();
// src/mapview/poi/PoiRenderer.ts
var logger14 = LoggerManager.instance.create("PoiRenderer");
var neutralColor = new THREE79.Color(1, 1, 1);
var tmpIconColor = new THREE79.Color();
var PoiBuffer = /*#__PURE__*/ function() {
    function PoiBuffer(buffer, layer, m_onDispose) {
        _classCallCheck(this, PoiBuffer);
        this.buffer = buffer;
        this.layer = layer;
        this.m_onDispose = m_onDispose;
        __publicField(this, "m_refCount", 0);
    }
    _createClass(PoiBuffer, [
        {
            key: "increaseRefCount",
            value: function increaseRefCount() {
                ++this.m_refCount;
                return this;
            }
        },
        {
            key: "decreaseRefCount",
            value: function decreaseRefCount() {
                assert(this.m_refCount > 0);
                if (--this.m_refCount === 0) {
                    this.dispose();
                }
                return this;
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                this.layer.scene.remove(this.buffer.mesh);
                this.buffer.dispose();
                this.m_onDispose();
            }
        }
    ]);
    return PoiBuffer;
}();
var _PoiBatch = /*#__PURE__*/ function() {
    function _PoiBatch(m_rendererCapabilities, imageItem, m_onDispose) {
        _classCallCheck(this, _PoiBatch);
        this.m_rendererCapabilities = m_rendererCapabilities;
        this.imageItem = imageItem;
        this.m_onDispose = m_onDispose;
        __publicField(this, "m_poiBuffers");
        __publicField(this, "m_material");
        var premultipliedAlpha = true;
        var texture = new THREE79.Texture(this.imageItem.image, THREE79.UVMapping, void 0, void 0, _PoiBatch.trilinear ? THREE79.LinearFilter : THREE79.LinearFilter, _PoiBatch.trilinear ? THREE79.LinearMipMapLinearFilter : THREE79.LinearFilter, THREE79.RGBAFormat);
        if (_PoiBatch.trilinear && this.imageItem.mipMaps) {
            texture.mipmaps = this.imageItem.mipMaps;
            texture.image = texture.mipmaps[0];
        }
        texture.flipY = false;
        texture.premultiplyAlpha = premultipliedAlpha;
        texture.needsUpdate = true;
        this.m_material = new IconMaterial({
            rendererCapabilities: this.m_rendererCapabilities,
            map: texture
        });
        this.m_poiBuffers = /* @__PURE__ */ new Map();
    }
    _createClass(_PoiBatch, [
        {
            key: "getBuffer",
            value: function getBuffer(layer) {
                var _this = this;
                var poiBuffer = this.m_poiBuffers.get(layer.id);
                if (poiBuffer) {
                    return poiBuffer.increaseRefCount();
                }
                var boxBuffer = new BoxBuffer(this.m_material, layer.id);
                var mesh = boxBuffer.mesh;
                mesh.frustumCulled = false;
                layer.scene.add(mesh);
                poiBuffer = new PoiBuffer(boxBuffer, layer, function() {
                    _this.disposeBuffer(layer.id);
                });
                this.m_poiBuffers.set(layer.id, poiBuffer);
                return poiBuffer.increaseRefCount();
            }
        },
        {
            key: "reset",
            value: function reset() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_poiBuffers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var poiBuffer = _step.value;
                        poiBuffer.buffer.reset();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "update",
            value: function update() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_poiBuffers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var poiBuffer = _step.value;
                        poiBuffer.buffer.updateBufferGeometry();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "pickBoxes",
            value: function pickBoxes(screenPosition, pickCallback, image) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_poiBuffers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var poiBuffer = _step.value;
                        poiBuffer.buffer.pickBoxes(screenPosition, pickCallback, image);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "updateMemoryUsage",
            value: function updateMemoryUsage(info) {
                if (this.imageItem.image !== void 0) {
                    var imageBytes = this.imageItem.image.width * this.imageItem.image.height * 4;
                    info.heapSize += imageBytes;
                    info.gpuSize += imageBytes;
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_poiBuffers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var poiBuffer = _step.value;
                        poiBuffer.buffer.updateMemoryUsage(info);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                this.m_poiBuffers.clear();
                this.m_material.map.dispose();
                this.m_material.dispose();
                this.m_onDispose();
            }
        },
        {
            key: "disposeBuffer",
            value: function disposeBuffer(renderOrder) {
                assert(this.m_poiBuffers.size > 0);
                this.m_poiBuffers.delete(renderOrder);
                if (this.m_poiBuffers.size === 0) {
                    this.dispose();
                }
            }
        }
    ]);
    return _PoiBatch;
}();
var PoiBatch = _PoiBatch;
__publicField(PoiBatch, "trilinear", true);
var PoiBatchRegistry = /*#__PURE__*/ function() {
    function PoiBatchRegistry(m_rendererCapabilities) {
        _classCallCheck(this, PoiBatchRegistry);
        this.m_rendererCapabilities = m_rendererCapabilities;
        __publicField(this, "m_batchMap", /* @__PURE__ */ new Map());
    }
    _createClass(PoiBatchRegistry, [
        {
            key: "registerPoi",
            value: function registerPoi(poiInfo, layer) {
                var _this = this;
                var imageItem = poiInfo.imageItem, imageTexture = poiInfo.imageTexture;
                if (!imageItem) {
                    return void 0;
                }
                assert(poiInfo.imageTextureName !== void 0);
                var ref;
                var batchKey = (ref = imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.image) !== null && ref !== void 0 ? ref : poiInfo.imageTextureName;
                var batch = this.m_batchMap.get(batchKey);
                if (batch === void 0) {
                    batch = new PoiBatch(this.m_rendererCapabilities, imageItem, function() {
                        _this.deleteBatch(batchKey);
                    });
                    this.m_batchMap.set(batchKey, batch);
                }
                return batch.getBuffer(layer);
            }
        },
        {
            key: "addPoi",
            value: function addPoi(poiInfo, screenBox, viewDistance, opacity) {
                if (poiInfo.isValid === false || !poiInfo.buffer) {
                    logger14.warn("PoiBatchRegistry: trying to add poiInfo without buffer prepared: ", poiInfo.poiName);
                    return;
                }
                assert(poiInfo.uvBox !== void 0);
                var color;
                if (poiInfo.iconBrightness !== void 0) {
                    color = tmpIconColor.setScalar(poiInfo.iconBrightness);
                    if (poiInfo.iconColor !== void 0) {
                        color = tmpIconColor.multiply(poiInfo.iconColor);
                    }
                } else if (poiInfo.iconColor !== void 0) {
                    color = poiInfo.iconColor;
                } else {
                    color = neutralColor;
                }
                poiInfo.buffer.buffer.addBox(screenBox, poiInfo.uvBox, color, opacity, viewDistance, poiInfo.textElement);
            }
        },
        {
            key: "reset",
            value: function reset() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_batchMap.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var batch = _step.value;
                        batch.reset();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "update",
            value: function update() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_batchMap.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var batch = _step.value;
                        batch.update();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "pickTextElements",
            value: function pickTextElements(screenPosition, pickCallback) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_batchMap.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var batch = _step.value;
                        batch.pickBoxes(screenPosition, pickCallback, batch.imageItem.image);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "updateMemoryUsage",
            value: function updateMemoryUsage(info) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_batchMap.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var batch = _step.value;
                        batch.updateMemoryUsage(info);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "deleteBatch",
            value: function deleteBatch(batchKey) {
                this.m_batchMap.delete(batchKey);
            }
        }
    ]);
    return PoiBatchRegistry;
}();
var missingTextureName = /* @__PURE__ */ new Map();
var SEARCH_CACHE_ATTEMPTS = 5;
function findImageItem(poiInfo, imageCaches, imageTexture) {
    assert(poiInfo.imageTextureName !== void 0);
    var imageTextureName = imageTexture ? imageTexture.image : poiInfo.imageTextureName;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = imageCaches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var imageCache = _step.value;
            var imageItem = imageCache.findImageByName(imageTextureName);
            if (imageItem) {
                missingTextureName.delete(imageTextureName);
                return imageItem;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    var missingTextureCount = missingTextureName.get(imageTextureName);
    missingTextureName.set(imageTextureName, missingTextureCount ? missingTextureCount + 1 : 0);
    if (missingTextureName.get(imageTextureName) === SEARCH_CACHE_ATTEMPTS) {
        var ref;
        logger14.error("PoiRenderer::findImageItem: No imageItem found with name:\n            '".concat((ref = imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.image) !== null && ref !== void 0 ? ref : imageTextureName, "'\n            after ").concat(SEARCH_CACHE_ATTEMPTS, " attempts."));
    }
    return void 0;
}
var PoiRenderer = /*#__PURE__*/ function() {
    function PoiRenderer(m_renderer, m_poiManager, m_imageCaches) {
        _classCallCheck(this, PoiRenderer);
        this.m_renderer = m_renderer;
        this.m_poiManager = m_poiManager;
        this.m_imageCaches = m_imageCaches;
        __publicField(this, "m_poiBatchRegistry");
        __publicField(this, "m_tempScreenBox", new Math2D.Box());
        __publicField(this, "m_layers", []);
        this.m_poiBatchRegistry = new PoiBatchRegistry(this.renderer.capabilities);
    }
    _createClass(PoiRenderer, [
        {
            key: "renderer",
            get: function get() {
                return this.m_renderer;
            }
        },
        {
            key: "prepareRender",
            value: function prepareRender(pointLabel, env) {
                var poiInfo = pointLabel.poiInfo;
                if (poiInfo === void 0) {
                    return false;
                }
                if (poiInfo.buffer === void 0) {
                    this.preparePoi(pointLabel, env);
                }
                return poiInfo.buffer !== void 0;
            }
        },
        {
            key: "reset",
            value: function reset() {
                this.m_poiBatchRegistry.reset();
            }
        },
        {
            key: "addPoi",
            value: function addPoi(poiInfo, screenPosition, screenCollisions, viewDistance, scale, allocateScreenSpace, opacity, env) {
                assert(poiInfo.buffer !== void 0);
                PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);
                if (allocateScreenSpace) {
                    screenCollisions.allocate(this.m_tempScreenBox);
                }
                if (opacity > 0) {
                    if (!poiInfo.buffer) {
                        this.preparePoi(poiInfo.textElement, env);
                    }
                    this.m_poiBatchRegistry.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);
                }
            }
        },
        {
            key: "update",
            value: function update() {
                this.m_poiBatchRegistry.update();
            }
        },
        {
            key: "addLayer",
            value: function addLayer(layerId) {
                var result = this.getLayer(layerId);
                if (result === void 0) {
                    result = {
                        id: layerId,
                        scene: new THREE79.Scene()
                    };
                    this.m_layers.push(result);
                    this.m_layers.sort(function(a, b) {
                        return a.id - b.id;
                    });
                }
                return result;
            }
        },
        {
            key: "getLayer",
            value: function getLayer(layerId) {
                return this.m_layers.find(function(layer) {
                    return layer.id === layerId;
                });
            }
        },
        {
            key: "layers",
            get: function get() {
                return this.m_layers;
            }
        },
        {
            key: "render",
            value: function render(camera, layer) {
                this.m_renderer.render(layer.scene, camera);
            }
        },
        {
            key: "pickTextElements",
            value: function pickTextElements(screenPosition, pickCallback) {
                this.m_poiBatchRegistry.pickTextElements(screenPosition, pickCallback);
            }
        },
        {
            key: "getMemoryUsage",
            value: function getMemoryUsage(info) {
                this.m_poiBatchRegistry.updateMemoryUsage(info);
            }
        },
        {
            key: "preparePoi",
            value: function preparePoi(pointLabel, env) {
                var _this = this;
                var poiInfo = pointLabel.poiInfo;
                if (!poiInfo || !pointLabel.visible) {
                    return;
                }
                if (poiInfo.buffer !== void 0 || poiInfo.isValid === false) {
                    return;
                }
                if (poiInfo.poiTableName !== void 0) {
                    if (this.m_poiManager.updatePoiFromPoiTable(pointLabel)) {
                        if (!pointLabel.visible) {
                            return;
                        }
                    } else {
                        return;
                    }
                }
                var imageTextureName = poiInfo.imageTextureName;
                if (imageTextureName === void 0) {
                    poiInfo.isValid = false;
                    return;
                }
                var imageTexture = this.m_poiManager.getImageTexture(imageTextureName);
                var imageItem = findImageItem(poiInfo, this.m_imageCaches, imageTexture);
                if (!imageItem) {
                    poiInfo.imageItem = null;
                    return;
                }
                if (imageItem.loaded) {
                    this.setupPoiInfo(poiInfo, imageItem, env, imageTexture);
                    return;
                }
                if (imageItem.loading) {
                    return;
                }
                imageItem.loadImage().then(function(loadedImageItem) {
                    if (loadedImageItem === null || loadedImageItem === void 0 ? void 0 : loadedImageItem.image) {
                        _this.setupPoiInfo(poiInfo, loadedImageItem, env, imageTexture);
                    }
                }).catch(function(error) {
                    logger14.error("preparePoi: Failed to load imageItem: '".concat(imageItem.url), error);
                    poiInfo.isValid = false;
                });
            }
        },
        {
            key: "setupPoiInfo",
            value: function setupPoiInfo(poiInfo, imageItem, env, imageTexture) {
                assert(poiInfo.uvBox === void 0);
                if (!imageItem.image) {
                    logger14.error("setupPoiInfo: No imageItem/imageData found");
                    poiInfo.isValid = false;
                    return;
                }
                var technique = poiInfo.technique;
                var imageWidth = imageItem.image.width;
                var imageHeight = imageItem.image.height;
                var paddedSize = MipMapGenerator.getPaddedSize(imageWidth, imageHeight);
                var trilinearFiltering = PoiBatch.trilinear && imageItem.mipMaps;
                var paddedImageWidth = trilinearFiltering ? paddedSize.width : imageWidth;
                var paddedImageHeight = trilinearFiltering ? paddedSize.height : imageHeight;
                var iconWidth = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.width) !== void 0 ? imageTexture.width : imageWidth;
                var iconHeight = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.height) !== void 0 ? imageTexture.height : imageHeight;
                var width = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.width) !== void 0 ? imageTexture.width : imageWidth;
                var height = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.height) !== void 0 ? imageTexture.height : imageHeight;
                var xOffset = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.xOffset) !== void 0 ? imageTexture.xOffset : 0;
                var yOffset = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.yOffset) !== void 0 ? imageTexture.yOffset : 0;
                var minS = xOffset / paddedImageWidth;
                var maxS = (xOffset + width) / paddedImageWidth;
                var minT = yOffset / paddedImageHeight;
                var maxT = (yOffset + height) / paddedImageHeight;
                var iconScaleH = technique.iconScale !== void 0 ? technique.iconScale : 1;
                var iconScaleV = technique.iconScale !== void 0 ? technique.iconScale : 1;
                var screenWidth = getPropertyValue(technique.screenWidth, env);
                if (screenWidth !== void 0 && screenWidth !== null) {
                    iconScaleV = iconScaleH = screenWidth / iconWidth;
                }
                var screenHeight = getPropertyValue(technique.screenHeight, env);
                if (screenHeight !== void 0 && screenHeight !== null) {
                    iconScaleV = screenHeight / iconHeight;
                    if (screenWidth !== void 0) {
                        iconScaleH = iconScaleV;
                    }
                }
                poiInfo.computedWidth = iconWidth * iconScaleH;
                poiInfo.computedHeight = iconHeight * iconScaleV;
                poiInfo.uvBox = {
                    s0: minS,
                    t0: maxT,
                    s1: maxS,
                    t1: minT
                };
                poiInfo.imageItem = imageItem;
                poiInfo.imageTexture = imageTexture;
                poiInfo.buffer = this.m_poiBatchRegistry.registerPoi(poiInfo, this.addLayer(poiInfo.renderOrder));
                poiInfo.isValid = true;
            }
        }
    ], [
        {
            key: "computeIconScreenBox",
            value: function computeIconScreenBox(poiInfo, screenPosition, scale, env) {
                var screenBox = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new Math2D.Box();
                assert(poiInfo.buffer !== void 0);
                var width = poiInfo.computedWidth * scale;
                var height = poiInfo.computedHeight * scale;
                var technique = poiInfo.technique;
                var iconXOffset = getPropertyValue(technique.iconXOffset, env);
                var iconYOffset = getPropertyValue(technique.iconYOffset, env);
                var centerX = screenPosition.x + (typeof iconXOffset === "number" ? iconXOffset : 0) * scale;
                var centerY = screenPosition.y + (typeof iconYOffset === "number" ? iconYOffset : 0) * scale;
                screenBox.x = centerX - width / 2;
                screenBox.y = centerY - height / 2;
                screenBox.w = width;
                screenBox.h = height;
                return screenBox;
            }
        }
    ]);
    return PoiRenderer;
}();
// src/mapview/ScreenCollisions.ts
var THREE80 = __toESM(require("three"));
var RBush = require("rbush");
var logger15 = LoggerManager.instance.create("ScreenCollisions");
var CollisionBox = /*#__PURE__*/ function(_Box) {
    _inherits(CollisionBox, _Box);
    var _super = _createSuper(CollisionBox);
    function CollisionBox(box) {
        _classCallCheck(this, CollisionBox);
        var _this;
        _this = _super.call(this);
        if (box !== void 0) {
            _this.copy(box);
        }
        return _this;
    }
    _createClass(CollisionBox, [
        {
            key: "copy",
            value: function copy(box) {
                if (_instanceof(box, Math2D.Box)) {
                    this.set(box.x, box.y, box.w, box.h);
                } else if (_instanceof(box, THREE80.Box2)) {
                    this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);
                } else {
                    this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);
                }
                return this;
            }
        },
        {
            key: "minX",
            get: function get() {
                return this.x;
            },
            set: function set(minX) {
                this.x = minX;
            }
        },
        {
            key: "maxX",
            get: function get() {
                return this.x + this.w;
            },
            set: function set(maxX) {
                this.w = maxX - this.x;
            }
        },
        {
            key: "minY",
            get: function get() {
                return this.y;
            },
            set: function set(minY) {
                this.y = minY;
            }
        },
        {
            key: "maxY",
            get: function get() {
                return this.y + this.h;
            },
            set: function set(maxY) {
                this.h = maxY - this.y;
            }
        }
    ]);
    return CollisionBox;
}(Math2D.Box);
var DetailedCollisionBox = /*#__PURE__*/ function(CollisionBox) {
    _inherits(DetailedCollisionBox, CollisionBox);
    var _super = _createSuper(DetailedCollisionBox);
    function DetailedCollisionBox(box, detailBoxes) {
        _classCallCheck(this, DetailedCollisionBox);
        var _this;
        _this = _super.call(this, box);
        _this.detailBoxes = detailBoxes;
        return _this;
    }
    return DetailedCollisionBox;
}(CollisionBox);
function isLineWithBound(box) {
    return box.line !== void 0;
}
var tmpCollisionBox = new CollisionBox();
var ScreenCollisions = /*#__PURE__*/ function() {
    function ScreenCollisions() {
        _classCallCheck(this, ScreenCollisions);
        __publicField(this, "screenBounds", new Math2D.Box());
        __publicField(this, "rtree", new RBush());
    }
    _createClass(ScreenCollisions, [
        {
            key: "reset",
            value: function reset() {
                this.rtree.clear();
            }
        },
        {
            key: "update",
            value: function update(width, height) {
                this.screenBounds.set(width / -2, height / -2, width, height);
                this.reset();
            }
        },
        {
            key: "allocate",
            value: function allocate(bounds) {
                var bbox = !_instanceof(bounds, CollisionBox) ? new CollisionBox(bounds) : bounds;
                this.rtree.insert(bbox);
            }
        },
        {
            key: "allocateIBoxes",
            value: function allocateIBoxes(bounds) {
                this.rtree.load(bounds);
            }
        },
        {
            key: "search",
            value: function search(box) {
                return this.rtree.search(box);
            }
        },
        {
            key: "isAllocated",
            value: function isAllocated(bounds) {
                var collisionBox = _instanceof(bounds, CollisionBox) ? bounds : tmpCollisionBox.copy(bounds);
                var results = this.search(collisionBox);
                return this.intersectsDetails(collisionBox, results);
            }
        },
        {
            key: "isVisible",
            value: function isVisible(bounds) {
                return this.screenBounds.intersects(bounds);
            }
        },
        {
            key: "isFullyVisible",
            value: function isFullyVisible(bounds) {
                return this.screenBounds.containsBox(bounds);
            }
        },
        {
            key: "intersectsDetails",
            value: function intersectsDetails(testBox, boxes) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = boxes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var box = _step.value;
                        if (_instanceof(box, DetailedCollisionBox)) {
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = box.detailBoxes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var detailBox = _step1.value;
                                    if (detailBox.intersects(testBox)) {
                                        return true;
                                    }
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        } else if (isLineWithBound(box)) {
                            var boundedLine = box;
                            if (this.intersectsLine(testBox, boundedLine)) {
                                return true;
                            }
                        } else {
                            return true;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return false;
            }
        },
        {
            key: "intersectsLine",
            value: function intersectsLine(bbox, boundedLine) {
                var line = boundedLine.line;
                var lineXDiffTransformed = line.end.x - line.start.x;
                var signBL;
                var signBR;
                var signTL;
                var signTR;
                if (lineXDiffTransformed !== 0) {
                    var lineYDiffTransformed = line.end.y - line.start.y;
                    var normalX = lineYDiffTransformed;
                    var normalY = -lineXDiffTransformed;
                    var D = line.start.y - lineYDiffTransformed / lineXDiffTransformed * line.start.x;
                    signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);
                    signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);
                    signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);
                    signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);
                } else {
                    signBL = Math.sign(bbox.minX - line.start.x);
                    signBR = Math.sign(bbox.maxX - line.start.x);
                    signTL = Math.sign(bbox.minX - line.start.x);
                    signTR = Math.sign(bbox.maxX - line.start.x);
                }
                return signBL !== signBR || signBL !== signTL || signBL !== signTR;
            }
        }
    ]);
    return ScreenCollisions;
}();
var ScreenCollisionsDebug = /*#__PURE__*/ function(ScreenCollisions) {
    _inherits(ScreenCollisionsDebug, ScreenCollisions);
    var _super = _createSuper(ScreenCollisionsDebug);
    function ScreenCollisionsDebug(debugCanvas) {
        _classCallCheck(this, ScreenCollisionsDebug);
        var _this;
        _this = _super.call(this);
        __publicField(_assertThisInitialized(_this), "m_renderContext", null);
        __publicField(_assertThisInitialized(_this), "m_renderingEnabled", false);
        __publicField(_assertThisInitialized(_this), "m_numAllocations", 0);
        __publicField(_assertThisInitialized(_this), "m_numSuccessfulTests", 0);
        __publicField(_assertThisInitialized(_this), "m_numFailedTests", 0);
        __publicField(_assertThisInitialized(_this), "m_numSuccessfulVisibilityTests", 0);
        __publicField(_assertThisInitialized(_this), "m_numFailedVisibilityTests", 0);
        if (debugCanvas !== void 0 && debugCanvas !== null) {
            _this.m_renderContext = debugCanvas.getContext("2d");
        }
        return _this;
    }
    _createClass(ScreenCollisionsDebug, [
        {
            key: "reset",
            value: function reset() {
                _get(_getPrototypeOf(ScreenCollisionsDebug.prototype), "reset", this).call(this);
                this.m_numAllocations = 0;
                this.m_numSuccessfulTests = 0;
                this.m_numFailedTests = 0;
                this.m_numSuccessfulVisibilityTests = 0;
                this.m_numFailedVisibilityTests = 0;
            }
        },
        {
            key: "update",
            value: function update(width, height) {
                if (this.m_renderingEnabled) {
                    logger15.log("Allocations: ".concat(this.m_numAllocations, " Successful Tests: ").concat(this.m_numSuccessfulTests, " Failed Tests: ").concat(this.m_numFailedTests, "  Successful Visibility Tests: ").concat(this.m_numSuccessfulVisibilityTests, "  Failed Visibility Tests: ").concat(this.m_numFailedVisibilityTests, " "));
                }
                _get(_getPrototypeOf(ScreenCollisionsDebug.prototype), "update", this).call(this, width, height);
                if (this.m_renderContext !== null) {
                    this.m_renderContext.canvas.width = width;
                    this.m_renderContext.canvas.height = height;
                }
                this.m_renderingEnabled = debugContext.getValue("DEBUG_SCREEN_COLLISIONS");
            }
        },
        {
            key: "allocate",
            value: function allocate(bounds) {
                _get(_getPrototypeOf(ScreenCollisionsDebug.prototype), "allocate", this).call(this, bounds);
                this.m_numAllocations++;
                if (this.m_renderingEnabled && this.m_renderContext !== null) {
                    this.m_renderContext.strokeStyle = "#6666ff";
                    this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y, bounds.w, -bounds.h);
                }
            }
        },
        {
            key: "allocateIBoxes",
            value: function allocateIBoxes(boundsArray) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = boundsArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var bounds = _step.value;
                        this.m_numAllocations++;
                        if (this.m_renderingEnabled && this.m_renderContext !== null) {
                            this.m_renderContext.strokeStyle = "#aa2222";
                            this.m_renderContext.strokeRect(bounds.minX - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.minY, bounds.maxX - bounds.minX, -(bounds.maxY - bounds.minY));
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                _get(_getPrototypeOf(ScreenCollisionsDebug.prototype), "allocateIBoxes", this).call(this, boundsArray);
            }
        },
        {
            key: "intersectsDetails",
            value: function intersectsDetails(testBox, boxes) {
                var collisionFound = _get(_getPrototypeOf(ScreenCollisionsDebug.prototype), "intersectsDetails", this).call(this, testBox, boxes);
                if (this.m_renderingEnabled && this.m_renderContext !== null) {
                    var padding = collisionFound ? 2 : 1;
                    this.m_renderContext.strokeStyle = collisionFound ? "#FF0000" : "#00ff00";
                    this.m_renderContext.strokeRect(testBox.x - this.screenBounds.x - padding, this.screenBounds.y + this.screenBounds.h - testBox.y + padding, testBox.w + 2 * padding, -testBox.h - 2 * padding);
                }
                if (collisionFound) {
                    this.m_numFailedTests++;
                } else {
                    this.m_numSuccessfulTests++;
                }
                return collisionFound;
            }
        },
        {
            key: "isVisible",
            value: function isVisible(bounds) {
                var visible = _get(_getPrototypeOf(ScreenCollisionsDebug.prototype), "isVisible", this).call(this, bounds);
                if (visible) {
                    this.m_numSuccessfulVisibilityTests++;
                } else {
                    this.m_numFailedVisibilityTests++;
                }
                return visible;
            }
        }
    ]);
    return ScreenCollisionsDebug;
}(ScreenCollisions);
// src/mapview/text/FontCatalogLoader.ts
var logger16 = LoggerManager.instance.create("FontCatalogLoader");
function loadFontCatalog(fontCatalogConfig, onSuccess, onError) {
    return _loadFontCatalog.apply(this, arguments);
}
function _loadFontCatalog() {
    _loadFontCatalog = _asyncToGenerator(regeneratorRuntime.mark(function _callee(fontCatalogConfig, onSuccess, onError) {
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    _ctx.next = 2;
                    return FontCatalog.load(fontCatalogConfig.url, 1024).then(onSuccess.bind(void 0, fontCatalogConfig.name)).catch(function(error) {
                        logger16.error("Failed to load FontCatalog: ", fontCatalogConfig.name, error);
                        if (onError) {
                            onError(error);
                        }
                    });
                case 2:
                    return _ctx.abrupt("return", _ctx.sent);
                case 3:
                case "end":
                    return _ctx.stop();
            }
        }, _callee);
    }));
    return _loadFontCatalog.apply(this, arguments);
}
// src/mapview/text/Placement.ts
var THREE81 = __toESM(require("three"));
var MIN_AVERAGE_CHAR_WIDTH = 5;
var tmpPosition = new THREE81.Vector3(0, 0, 0);
var tmpCameraDir = new THREE81.Vector3(0, 0, 0);
var tmpPointDir = new THREE81.Vector3(0, 0, 0);
var COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731;
function checkViewDistance(textElement, poiIndex, eyePos, eyeLookAt, projectionType, maxViewDistance) {
    var textDistance = computeViewDistance(textElement, poiIndex, eyePos, eyeLookAt);
    if (projectionType !== 1 /* Spherical */ ) {
        return textDistance <= maxViewDistance ? textDistance : void 0;
    }
    tmpPosition.copy(textElement.position).normalize();
    tmpCameraDir.copy(eyePos).normalize();
    var cosAlpha = tmpPosition.dot(tmpCameraDir);
    var viewDistance = cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance ? textDistance : void 0;
    return viewDistance;
}
function computeViewDistance(textElement, poiIndex, eyePosition, eyeLookAt) {
    var viewDistance;
    var path = textElement.path;
    if (path && path.length > 1) {
        if (poiIndex !== void 0 && path && path.length > poiIndex) {
            viewDistance = pointToPlaneDistance(path[poiIndex], eyePosition, eyeLookAt);
        } else {
            var viewDistance0 = pointToPlaneDistance(path[0], eyePosition, eyeLookAt);
            var viewDistance1 = pointToPlaneDistance(path[path.length - 1], eyePosition, eyeLookAt);
            viewDistance = Math.min(viewDistance0, viewDistance1);
        }
    } else {
        viewDistance = pointToPlaneDistance(textElement.position, eyePosition, eyeLookAt);
    }
    return viewDistance;
}
function pointToPlaneDistance(pointPos, planePos, planeNorm) {
    var labelCamVec = tmpPointDir.copy(pointPos).sub(planePos);
    return labelCamVec.dot(planeNorm);
}
function getMaxViewDistance(viewState, farDistanceLimitRatio) {
    return viewState.maxVisibilityDist * farDistanceLimitRatio;
}
var tmpPlacementPosition = new THREE81.Vector3();
function checkReadyForPlacement(textElement, poiIndex, viewState, poiManager, maxViewDistance) {
    var viewDistance;
    if (!textElement.visible) {
        return {
            result: 2 /* Invisible */ ,
            viewDistance: viewDistance
        };
    }
    if (!poiManager.updatePoiFromPoiTable(textElement)) {
        return {
            result: 1 /* NotReady */ ,
            viewDistance: viewDistance
        };
    }
    if (!textElement.visible || viewState.zoomLevel === textElement.maxZoomLevel || !MathUtils.isClamped(viewState.zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {
        return {
            result: 2 /* Invisible */ ,
            viewDistance: viewDistance
        };
    }
    viewDistance = maxViewDistance === void 0 ? computeViewDistance(textElement, poiIndex, viewState.worldCenter, viewState.lookAtVector) : checkViewDistance(textElement, poiIndex, viewState.worldCenter, viewState.lookAtVector, viewState.projection.type, maxViewDistance);
    if (viewDistance === void 0) {
        return {
            result: 3 /* TooFar */ ,
            viewDistance: viewDistance
        };
    }
    return {
        result: 0 /* Ok */ ,
        viewDistance: viewDistance
    };
}
function computePointTextOffset(textElement, textBounds, placement, scale, env) {
    var offset = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : new THREE81.Vector2();
    assert(textElement.type === 0 /* PoiLabel */  || textElement.type === 2 /* LineMarker */ );
    assert(textElement.layoutStyle !== void 0);
    offset.x = textElement.xOffset;
    offset.y = textElement.yOffset;
    switch(placement.h){
        case -1 /* Left */ :
            offset.x -= textBounds.max.x;
            break;
        case 0 /* Right */ :
            offset.x -= textBounds.min.x;
            break;
    }
    switch(placement.v){
        case 0 /* Top */ :
            offset.y -= textBounds.min.y;
            break;
        case -0.5 /* Center */ :
            offset.y -= 0.5 * (textBounds.max.y + textBounds.min.y);
            break;
        case -1 /* Bottom */ :
            offset.y -= textBounds.max.y;
            break;
    }
    if (textElement.poiInfo !== void 0 && poiIsRenderable(textElement.poiInfo)) {
        assert(textElement.poiInfo.computedWidth !== void 0);
        assert(textElement.poiInfo.computedHeight !== void 0);
        offset.x += textElement.poiInfo.computedWidth * (0.5 + placement.h);
        offset.y += textElement.poiInfo.computedHeight * (0.5 + placement.v);
        var hAlign = hPlacementFromAlignment(textElement.layoutStyle.horizontalAlignment);
        var vAlign = vPlacementFromAlignment(textElement.layoutStyle.verticalAlignment);
        if (hAlign !== placement.h || vAlign !== placement.v) {
            var technique = textElement.poiInfo.technique;
            var iconXOffset = getPropertyValue(technique.iconXOffset, env);
            var iconYOffset = getPropertyValue(technique.iconYOffset, env);
            iconXOffset = typeof iconXOffset === "number" ? iconXOffset : 0;
            iconYOffset = typeof iconYOffset === "number" ? iconYOffset : 0;
            var hAlignDiff = hAlign - placement.h;
            var vAlignDiff = vAlign - placement.v;
            var relOffsetX = iconXOffset - textElement.xOffset;
            var relOffsetY = iconYOffset - textElement.yOffset;
            var centerBased = hAlign === -0.5 /* Center */  || vAlign === -0.5 /* Center */ ;
            if (centerBased) {
                offset.x += 2 * Math.abs(hAlignDiff) * relOffsetX;
                offset.y -= 2 * vAlignDiff * Math.abs(relOffsetX);
                offset.y += 2 * Math.abs(vAlignDiff) * relOffsetY;
                offset.x -= 2 * hAlignDiff * Math.abs(relOffsetY);
            } else {
                offset.x += 2 * Math.min(Math.abs(hAlignDiff), 0.5) * relOffsetX;
                offset.y -= 2 * Math.sign(vAlignDiff) * Math.min(Math.abs(vAlignDiff), 0.5) * Math.abs(relOffsetX);
                offset.y += 2 * Math.min(Math.abs(vAlignDiff), 0.5) * relOffsetY;
                offset.x -= 2 * Math.sign(hAlignDiff) * Math.min(Math.abs(hAlignDiff), 0.5) * Math.abs(relOffsetY);
            }
        }
    }
    offset.multiplyScalar(scale);
    return offset;
}
var tmpBox3 = new THREE81.Box2();
var tmpBounds = new THREE81.Box2();
var tmpBoxes = [];
var tmpMeasurementParams = {};
var tmpCollisionBoxes = [];
var tmpCollisionBox2 = new CollisionBox();
var tmpScreenPosition = new THREE81.Vector2();
var tmpTextOffset = new THREE81.Vector2();
var tmp2DBox = new Math2D.Box();
var tmpCenter = new THREE81.Vector2();
var tmpSize = new THREE81.Vector2();
var persistentPointLabelTextMargin = new THREE81.Vector2(2, 2);
var newPointLabelTextMarginPercent = 0.1;
function placeIcon(iconRenderState, poiInfo, screenPosition, scaleFactor, env, screenCollisions) {
    PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, env, tmp2DBox);
    if (!screenCollisions.isVisible(tmp2DBox)) {
        return 2 /* Invisible */ ;
    }
    var iconSpaceAvailable = poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);
    return !iconSpaceAvailable ? 1 /* Rejected */  : 0 /* Ok */ ;
}
function placePointLabel(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {
    var multiAnchor = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
    assert(labelState.element.layoutStyle !== void 0);
    var layoutStyle = labelState.element.layoutStyle;
    multiAnchor = multiAnchor && layoutStyle.placements !== void 0 && layoutStyle.placements.length > 1;
    if (!multiAnchor) {
        return placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);
    } else {
        return placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);
    }
}
function placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {
    assert(labelState.element.layoutStyle !== void 0);
    var label = labelState.element;
    var persistent = labelState.visible;
    var lastPlacement = labelState.textPlacement;
    var placements = label.layoutStyle.placements;
    var placementsNum = placements.length;
    var matchIdx = placements.findIndex(function(p) {
        return p.h === lastPlacement.h && p.v === lastPlacement.v;
    });
    assert(matchIdx >= 0);
    var allInvisible = true;
    for(var i = matchIdx; i < placementsNum + matchIdx; ++i){
        var anchorPlacement = placements[i % placementsNum];
        var isLastPlacement = i === matchIdx && persistent;
        var placementResult = placePointLabelAtAnchor(labelState, screenPosition, anchorPlacement, scale, textCanvas, env, screenCollisions, !isLastPlacement, tmpPlacementPosition);
        if (placementResult === 0 /* Ok */ ) {
            outScreenPosition.copy(tmpPlacementPosition);
            return 0 /* Ok */ ;
        }
        if (isLastPlacement) {
            outScreenPosition.copy(tmpPlacementPosition);
        }
        allInvisible = allInvisible && placementResult === 2 /* Invisible */ ;
    }
    return allInvisible ? 2 /* Invisible */  : 1 /* Rejected */ ;
}
function placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {
    assert(labelState.element.layoutStyle !== void 0);
    var lastPlacement = labelState.textPlacement;
    var result = placePointLabelAtAnchor(labelState, screenPosition, lastPlacement, scale, textCanvas, env, screenCollisions, !labelState.visible, outScreenPosition);
    return result;
}
function placePointLabelAtAnchor(labelState, screenPosition, placement, scale, textCanvas, env, screenCollisions, forceInvalidation, outScreenPosition) {
    var label = labelState.element;
    assert(label.glyphs !== void 0);
    assert(label.layoutStyle !== void 0);
    var measureText = !label.bounds || forceInvalidation;
    var labelBounds = measureText ? tmpBounds : label.bounds;
    if (measureText) {
        applyTextPlacement(textCanvas, placement);
        tmpMeasurementParams.outputCharacterBounds = void 0;
        tmpMeasurementParams.path = void 0;
        tmpMeasurementParams.pathOverflow = false;
        tmpMeasurementParams.letterCaseArray = label.glyphCaseArray;
        textCanvas.measureText(label.glyphs, labelBounds, tmpMeasurementParams);
    }
    var textOffset = computePointTextOffset(label, labelBounds, placement, scale, env, tmpTextOffset).add(screenPosition);
    outScreenPosition.set(textOffset.x, textOffset.y, labelState.renderDistance);
    tmpBox3.copy(labelBounds).expandByVector(persistentPointLabelTextMargin).translate(textOffset);
    tmpBox3.getCenter(tmpCenter);
    tmpBox3.getSize(tmpSize);
    tmpSize.multiplyScalar(scale);
    tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);
    if (!screenCollisions.isVisible(tmp2DBox)) {
        return 2 /* Invisible */ ;
    }
    if (measureText) {
        tmpBox3.getSize(tmpSize);
        tmpSize.multiplyScalar(scale * (1 + newPointLabelTextMarginPercent));
        tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);
    }
    if (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox)) {
        return 1 /* Rejected */ ;
    }
    if (label.textReservesSpace) {
        screenCollisions.allocate(tmp2DBox);
    }
    if (measureText) {
        label.textBufferObject = void 0;
        label.bounds = label.bounds ? label.bounds.copy(labelBounds) : labelBounds.clone();
    } else {
        applyTextPlacement(textCanvas, placement);
    }
    labelState.textPlacement = placement;
    return 0 /* Ok */ ;
}
function applyTextPlacement(textCanvas, placement) {
    textCanvas.textLayoutStyle.horizontalAlignment = hAlignFromPlacement(placement.h);
    textCanvas.textLayoutStyle.verticalAlignment = vAlignFromPlacement(placement.v);
}
function placePathLabel(labelState, textPath, screenPosition, textCanvas, screenCollisions) {
    tmpMeasurementParams.path = textPath;
    tmpMeasurementParams.outputCharacterBounds = tmpBoxes;
    tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray;
    if (!textCanvas.measureText(labelState.element.glyphs, tmpBox3, tmpMeasurementParams)) {
        return 1 /* Rejected */ ;
    }
    tmpCollisionBox2.copy(tmpBox3.translate(screenPosition));
    if (!screenCollisions.isVisible(tmpCollisionBox2)) {
        return 2 /* Invisible */ ;
    }
    var checkGlyphCollision = false;
    var candidateBoxes;
    if (!labelState.element.textMayOverlap) {
        candidateBoxes = screenCollisions.search(tmpCollisionBox2);
        checkGlyphCollision = candidateBoxes.length > 0;
    }
    tmpCollisionBoxes.length = tmpBoxes.length;
    for(var i = 0; i < tmpBoxes.length; ++i){
        var glyphBox = tmpBoxes[i].translate(screenPosition);
        var collisionBox = tmpCollisionBoxes[i];
        if (collisionBox === void 0) {
            collisionBox = new CollisionBox(glyphBox);
            tmpCollisionBoxes[i] = collisionBox;
        } else {
            collisionBox.copy(glyphBox);
        }
        if (checkGlyphCollision && screenCollisions.intersectsDetails(collisionBox, candidateBoxes)) {
            return 1 /* Rejected */ ;
        }
    }
    if (labelState.element.textReservesSpace) {
        var collisionBox1 = new DetailedCollisionBox(tmpCollisionBox2, tmpCollisionBoxes.slice());
        tmpCollisionBoxes.length = 0;
        screenCollisions.allocate(collisionBox1);
    }
    return 0 /* Ok */ ;
}
function isPathLabelTooSmall(textElement, screenProjector, outScreenPoints) {
    assert(textElement.type === 1 /* PathLabel */ );
    outScreenPoints.length = 0;
    var anyPointVisible = false;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = textElement.points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var pt = _step.value;
            var screenPoint = anyPointVisible ? screenProjector.project(pt, tmpScreenPosition) : screenProjector.projectToScreen(pt, tmpScreenPosition);
            if (screenPoint === void 0) {
                continue;
            }
            anyPointVisible = true;
            outScreenPoints.push(tmpScreenPosition.clone());
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    if (!anyPointVisible) {
        return true;
    }
    var minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;
    tmpBox3.setFromPoints(outScreenPoints);
    var boxDiagonalSq = tmpBox3.max.sub(tmpBox3.min).lengthSq();
    if (boxDiagonalSq < minScreenSpace * minScreenSpace) {
        textElement.dbgPathTooSmall = true;
        return true;
    }
    return false;
}
var tmpOrientedBox = new OrientedBox3();
function getWorldPosition(poiLabel, projection, env, outWorldPosition) {
    var ref, ref1;
    var worldOffsetShiftValue = getPropertyValue((ref = poiLabel.poiInfo) === null || ref === void 0 ? void 0 : (ref1 = ref.technique) === null || ref1 === void 0 ? void 0 : ref1.worldOffset, env);
    outWorldPosition === null || outWorldPosition === void 0 ? void 0 : outWorldPosition.copy(poiLabel.position);
    if (worldOffsetShiftValue !== null && worldOffsetShiftValue !== void 0 && poiLabel.offsetDirection !== void 0) {
        projection.localTangentSpace(poiLabel.position, tmpOrientedBox);
        var offsetDirectionVector = tmpOrientedBox.yAxis;
        var offsetDirectionRad = THREE81.MathUtils.degToRad(poiLabel.offsetDirection);
        offsetDirectionVector.applyAxisAngle(tmpOrientedBox.zAxis.negate(), offsetDirectionRad);
        outWorldPosition.addScaledVector(tmpOrientedBox.yAxis, worldOffsetShiftValue);
    }
    return outWorldPosition;
}
// src/mapview/text/PlacementStats.ts
var PlacementStats = /*#__PURE__*/ function() {
    function PlacementStats(m_logger) {
        _classCallCheck(this, PlacementStats);
        this.m_logger = m_logger;
        __publicField(this, "totalGroups", 0);
        __publicField(this, "resortedGroups", 0);
        __publicField(this, "total", 0);
        __publicField(this, "uninitialized", 0);
        __publicField(this, "tooFar", 0);
        __publicField(this, "numNotVisible", 0);
        __publicField(this, "numPathTooSmall", 0);
        __publicField(this, "numCannotAdd", 0);
        __publicField(this, "numRenderedPoiIcons", 0);
        __publicField(this, "numRenderedPoiTexts", 0);
        __publicField(this, "numPoiTextsInvisible", 0);
        __publicField(this, "numRenderedTextElements", 0);
    }
    _createClass(PlacementStats, [
        {
            key: "clear",
            value: function clear() {
                this.totalGroups = 0;
                this.resortedGroups = 0;
                this.total = 0;
                this.uninitialized = 0;
                this.tooFar = 0;
                this.numNotVisible = 0;
                this.numPathTooSmall = 0;
                this.numCannotAdd = 0;
                this.numRenderedPoiIcons = 0;
                this.numRenderedPoiTexts = 0;
                this.numPoiTextsInvisible = 0;
                this.numRenderedTextElements = 0;
            }
        },
        {
            key: "log",
            value: function log() {
                var numNotRendered = this.uninitialized + this.numPoiTextsInvisible + this.tooFar + this.numNotVisible + this.numCannotAdd;
                this.m_logger.debug("Total groups", this.totalGroups);
                this.m_logger.debug("Resorted groups", this.resortedGroups);
                this.m_logger.debug("Total labels", this.total);
                this.m_logger.debug("Rendered labels", this.numRenderedTextElements);
                this.m_logger.debug("Rejected labels", numNotRendered);
                this.m_logger.debug("Unitialized labels", this.uninitialized);
                this.m_logger.debug("Rendered poi icons", this.numRenderedPoiIcons);
                this.m_logger.debug("Rendered poi texts", this.numRenderedPoiTexts);
                this.m_logger.debug("Poi text invisible", this.numPoiTextsInvisible);
                this.m_logger.debug("Too far", this.tooFar);
                this.m_logger.debug("Not visible", this.numNotVisible);
                this.m_logger.debug("Path too small", this.numPathTooSmall);
                this.m_logger.debug("Rejected, max glyphs reached", this.numCannotAdd);
            }
        }
    ]);
    return PlacementStats;
}();
// src/mapview/text/SimplePath.ts
var THREE82 = __toESM(require("three"));
var SimpleLineCurve = /*#__PURE__*/ function(_LineCurve) {
    _inherits(SimpleLineCurve, _LineCurve);
    var _super = _createSuper(SimpleLineCurve);
    function SimpleLineCurve(v1, v2) {
        _classCallCheck(this, SimpleLineCurve);
        var _this;
        _this = _super.call(this, v1, v2);
        __publicField(_assertThisInitialized(_this), "m_lengths");
        return _this;
    }
    _createClass(SimpleLineCurve, [
        {
            key: "getLengths",
            value: function getLengths() {
                if (this.m_lengths === void 0) {
                    this.m_lengths = [
                        0,
                        this.v2.distanceTo(this.v1)
                    ];
                }
                return this.m_lengths;
            }
        }
    ]);
    return SimpleLineCurve;
}(THREE82.LineCurve);
var PathParam = /*#__PURE__*/ function() {
    function PathParam(path, index, t) {
        _classCallCheck(this, PathParam);
        this.path = path;
        this.index = index;
        this.t = t;
        __publicField(this, "m_point");
    }
    _createClass(PathParam, [
        {
            key: "curve",
            get: function get() {
                return this.path.curves[this.index];
            }
        },
        {
            key: "point",
            get: function get() {
                if (this.m_point === void 0) {
                    this.m_point = this.curve.getPoint(this.t);
                }
                return this.m_point;
            }
        }
    ]);
    return PathParam;
}();
var SimplePath = /*#__PURE__*/ function(_Path) {
    _inherits(SimplePath, _Path);
    var _super = _createSuper(SimplePath);
    function SimplePath() {
        _classCallCheck(this, SimplePath);
        var _this;
        _this = _super.call(this);
        __publicField(_assertThisInitialized(_this), "m_cache");
        return _this;
    }
    _createClass(SimplePath, [
        {
            key: "getLengths",
            value: function getLengths() {
                if (this.m_cache) {
                    return this.m_cache;
                }
                var sum = 0;
                var lengths = new Array();
                lengths.push(0);
                this.curves.forEach(function(curve) {
                    var lineCurve = curve;
                    sum += lineCurve.v1.distanceTo(lineCurve.v2);
                    lengths.push(sum);
                });
                this.m_cache = lengths;
                return lengths;
            }
        },
        {
            key: "getParamAt",
            value: function getParamAt(t) {
                var distance = t * this.getLength();
                var curveLengths = this.getCurveLengths();
                for(var index = 0; index < curveLengths.length; ++index){
                    if (curveLengths[index] < distance) {
                        continue;
                    }
                    var diff = curveLengths[index] - distance;
                    var curve = this.curves[index];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return new PathParam(this, index, u);
                }
                return null;
            }
        }
    ]);
    return SimplePath;
}(THREE82.Path);
// src/mapview/text/TextCanvasFactory.ts
var TextCanvasFactory = /*#__PURE__*/ function() {
    function TextCanvasFactory(m_renderer) {
        _classCallCheck(this, TextCanvasFactory);
        this.m_renderer = m_renderer;
        __publicField(this, "m_minGlyphCount", 0);
        __publicField(this, "m_maxGlyphCount", 0);
    }
    _createClass(TextCanvasFactory, [
        {
            key: "setGlyphCountLimits",
            value: function setGlyphCountLimits(min, max) {
                this.m_minGlyphCount = min;
                this.m_maxGlyphCount = max;
            }
        },
        {
            key: "createTextCanvas",
            value: function createTextCanvas(fontCatalog, name2) {
                assert(this.m_maxGlyphCount > 0);
                return new TextCanvas({
                    renderer: this.m_renderer,
                    fontCatalog: fontCatalog,
                    minGlyphCount: this.m_minGlyphCount,
                    maxGlyphCount: this.m_maxGlyphCount,
                    name: name2
                });
            }
        }
    ]);
    return TextCanvasFactory;
}();
// src/mapview/text/TextElementsRendererOptions.ts
var DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;
var DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;
var DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;
var DEFAULT_MAX_DISTANCE_TO_BORDER = 0.2;
var MIN_GLYPH_COUNT = 1024;
var MAX_GLYPH_COUNT = 32768;
function initializeDefaultOptions(options) {
    if (options.minNumGlyphs === void 0) {
        options.minNumGlyphs = MIN_GLYPH_COUNT;
    }
    if (options.maxNumGlyphs === void 0) {
        options.maxNumGlyphs = MAX_GLYPH_COUNT;
    }
    if (options.labelDistanceScaleMin === void 0) {
        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;
    }
    if (options.labelDistanceScaleMax === void 0) {
        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;
    }
    if (options.maxDistanceRatioForTextLabels === void 0) {
        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
    }
    if (options.maxDistanceRatioForPoiLabels === void 0) {
        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
    }
    if (options.disableFading === void 0) {
        options.disableFading = false;
    }
    if (options.delayLabelsUntilMovementFinished === void 0) {
        options.delayLabelsUntilMovementFinished = true;
    }
    if (options.showReplacementGlyphs === void 0) {
        options.showReplacementGlyphs = false;
    }
    if (options.maxPoiDistanceToBorder === void 0) {
        options.maxPoiDistanceToBorder = DEFAULT_MAX_DISTANCE_TO_BORDER;
    }
}
// src/mapview/text/LayoutState.ts
var LayoutState = /*#__PURE__*/ function() {
    function LayoutState(placement) {
        _classCallCheck(this, LayoutState);
        __publicField(this, "m_hAlign", DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT);
        __publicField(this, "m_vAlign", DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT);
        this.textPlacement = placement;
    }
    _createClass(LayoutState, [
        {
            key: "textPlacement",
            get: function get() {
                return {
                    h: hPlacementFromAlignment(this.m_hAlign),
                    v: vPlacementFromAlignment(this.m_vAlign)
                };
            },
            set: function set(placement) {
                this.m_hAlign = hAlignFromPlacement(placement.h);
                this.m_vAlign = vAlignFromPlacement(placement.v);
            }
        },
        {
            key: "reset",
            value: function reset(layoutStyle) {
                this.m_hAlign = layoutStyle.horizontalAlignment;
                this.m_vAlign = layoutStyle.verticalAlignment;
            }
        },
        {
            key: "horizontalAlignment",
            get: function get() {
                return this.m_hAlign;
            }
        },
        {
            key: "verticalAlignment",
            get: function get() {
                return this.m_vAlign;
            }
        }
    ]);
    return LayoutState;
}();
// src/mapview/text/RenderState.ts
var THREE83 = __toESM(require("three"));
var DEFAULT_FADE_TIME = 800;
var RenderState = /*#__PURE__*/ function() {
    function RenderState() {
        var fadeTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_FADE_TIME;
        _classCallCheck(this, RenderState);
        this.fadeTime = fadeTime;
        __publicField(this, "value", 0);
        __publicField(this, "startTime", 0);
        __publicField(this, "opacity", 0);
        __publicField(this, "m_state", 0 /* Undefined */ );
    }
    _createClass(RenderState, [
        {
            key: "reset",
            value: function reset() {
                this.m_state = 0 /* Undefined */ ;
                this.value = 0;
                this.startTime = 0;
                this.opacity = 0;
            }
        },
        {
            key: "isUndefined",
            value: function isUndefined() {
                return this.m_state === 0 /* Undefined */ ;
            }
        },
        {
            key: "isFading",
            value: function isFading() {
                var fading = this.m_state === 1 /* FadingIn */  || this.m_state === -1 /* FadingOut */ ;
                return fading;
            }
        },
        {
            key: "isFadingIn",
            value: function isFadingIn() {
                var fadingIn = this.m_state === 1 /* FadingIn */ ;
                return fadingIn;
            }
        },
        {
            key: "isFadingOut",
            value: function isFadingOut() {
                var fadingOut = this.m_state === -1 /* FadingOut */ ;
                return fadingOut;
            }
        },
        {
            key: "isFadedIn",
            value: function isFadedIn() {
                var fadedIn = this.m_state === 2 /* FadedIn */ ;
                return fadedIn;
            }
        },
        {
            key: "isFadedOut",
            value: function isFadedOut() {
                var fadedOut = this.m_state === -2 /* FadedOut */ ;
                return fadedOut;
            }
        },
        {
            key: "isVisible",
            value: function isVisible() {
                return this.m_state !== -2 /* FadedOut */  && this.m_state !== 0 /* Undefined */  && this.opacity > 0;
            }
        },
        {
            key: "startFadeIn",
            value: function startFadeIn(time, disableFading) {
                if (this.m_state === 1 /* FadingIn */  || this.m_state === 2 /* FadedIn */ ) {
                    return;
                }
                if (disableFading === true) {
                    this.value = 1;
                    this.opacity = 1;
                    this.m_state = 2 /* FadedIn */ ;
                    this.startTime = time;
                    return;
                }
                if (this.m_state === -1 /* FadingOut */ ) {
                    this.value = 1 - this.value;
                    this.startTime = time - this.value * this.fadeTime;
                } else {
                    this.startTime = time;
                    this.value = 0;
                    this.opacity = 0;
                }
                this.m_state = 1 /* FadingIn */ ;
            }
        },
        {
            key: "startFadeOut",
            value: function startFadeOut(time) {
                if (this.m_state === -1 /* FadingOut */  || this.m_state === -2 /* FadedOut */  || this.m_state === 0 /* Undefined */ ) {
                    return;
                }
                if (this.m_state === 1 /* FadingIn */ ) {
                    this.startTime = time - this.value * this.fadeTime;
                    this.value = 1 - this.value;
                } else {
                    this.startTime = time;
                    this.value = 0;
                    this.opacity = 1;
                }
                this.m_state = -1 /* FadingOut */ ;
            }
        },
        {
            key: "updateFading",
            value: function updateFading(time, disableFading) {
                if (this.m_state !== 1 /* FadingIn */  && this.m_state !== -1 /* FadingOut */ ) {
                    return;
                }
                if (this.startTime === 0) {
                    this.startTime = time;
                }
                var fadingTime = time - this.startTime;
                var startValue = this.m_state === 1 /* FadingIn */  ? 0 : 1;
                var endValue = this.m_state === 1 /* FadingIn */  ? 1 : 0;
                if (disableFading || fadingTime >= this.fadeTime) {
                    this.value = 1;
                    this.opacity = endValue;
                    this.m_state = this.m_state === 1 /* FadingIn */  ? 2 /* FadedIn */  : -2 /* FadedOut */ ;
                } else {
                    this.value = fadingTime / this.fadeTime;
                    this.opacity = THREE83.MathUtils.clamp(MathUtils.smootherStep(startValue, endValue, this.value), 0, 1);
                    assert(this.isFading());
                }
            }
        }
    ]);
    return RenderState;
}();
// src/mapview/text/TextElementState.ts
var TextElementState = /*#__PURE__*/ function() {
    function TextElementState(element, positionIndex) {
        _classCallCheck(this, TextElementState);
        this.element = element;
        __publicField(this, "m_viewDistance");
        __publicField(this, "m_iconRenderState");
        __publicField(this, "m_textRenderState");
        __publicField(this, "m_textLayoutState");
        __publicField(this, "m_lineMarkerIndex");
        this.m_lineMarkerIndex = positionIndex;
    }
    _createClass(TextElementState, [
        {
            key: "initialized",
            get: function get() {
                return this.m_textRenderState !== void 0 || this.m_iconRenderState !== void 0;
            }
        },
        {
            key: "visible",
            get: function get() {
                if (this.m_textRenderState !== void 0 && this.m_textRenderState.isVisible()) {
                    return true;
                }
                var iconRenderState = this.iconRenderState;
                if (iconRenderState !== void 0 && iconRenderState.isVisible()) {
                    return true;
                }
                return false;
            }
        },
        {
            key: "textPlacement",
            get: function get() {
                var themeLayout = this.element.layoutStyle;
                var stateLayout = this.m_textLayoutState;
                var lastPlacement = stateLayout !== void 0 ? stateLayout.textPlacement : {
                    h: hPlacementFromAlignment(themeLayout.horizontalAlignment),
                    v: vPlacementFromAlignment(themeLayout.verticalAlignment)
                };
                return lastPlacement;
            },
            set: function set(placement) {
                if (this.m_textLayoutState === void 0 && this.isBaseTextPlacement(placement) === true) {
                    return;
                }
                if (this.m_textLayoutState === void 0) {
                    this.m_textLayoutState = new LayoutState(placement);
                } else {
                    this.m_textLayoutState.textPlacement = placement;
                }
            }
        },
        {
            key: "isBaseTextPlacement",
            value: function isBaseTextPlacement(placement) {
                var themeLayout = this.element.layoutStyle;
                if (themeLayout !== void 0) {
                    return hAlignFromPlacement(placement.h) === themeLayout.horizontalAlignment && vAlignFromPlacement(placement.v) === themeLayout.verticalAlignment;
                }
                return void 0;
            }
        },
        {
            key: "reset",
            value: function reset() {
                if (this.m_textRenderState !== void 0) {
                    this.m_textRenderState.reset();
                }
                if (this.m_textLayoutState !== void 0) {
                    if (this.element.layoutStyle !== void 0) {
                        this.m_textLayoutState.reset(this.element.layoutStyle);
                    } else {
                        this.m_textLayoutState = void 0;
                    }
                }
                if (this.iconRenderState) {
                    ;
                    this.m_iconRenderState.reset();
                }
                this.m_viewDistance = void 0;
                this.element.textBufferObject = void 0;
                this.element.bounds = void 0;
            }
        },
        {
            key: "replace",
            value: function replace(predecessor) {
                this.m_textRenderState = predecessor.m_textRenderState;
                this.m_textLayoutState = predecessor.m_textLayoutState;
                this.m_iconRenderState = predecessor.m_iconRenderState;
                predecessor.m_textRenderState = void 0;
                predecessor.m_textLayoutState = void 0;
                predecessor.m_iconRenderState = void 0;
                if (this.element.glyphs === void 0) {
                    this.element.glyphs = predecessor.element.glyphs;
                    this.element.glyphCaseArray = predecessor.element.glyphCaseArray;
                }
                this.element.bounds = void 0;
                this.element.textBufferObject = void 0;
            }
        },
        {
            key: "viewDistance",
            get: function get() {
                return this.m_viewDistance;
            }
        },
        {
            key: "update",
            value: function update(viewDistance) {
                if (!this.initialized && viewDistance !== void 0) {
                    this.initializeRenderStates();
                }
                this.setViewDistance(viewDistance);
            }
        },
        {
            key: "setViewDistance",
            value: function setViewDistance(viewDistance) {
                this.m_viewDistance = viewDistance;
            }
        },
        {
            key: "renderDistance",
            get: function get() {
                return this.element.alwaysOnTop === true ? 0 : this.m_viewDistance !== void 0 ? -this.m_viewDistance : 0;
            }
        },
        {
            key: "textRenderState",
            get: function get() {
                return this.m_textRenderState;
            }
        },
        {
            key: "iconRenderState",
            get: function get() {
                return this.m_iconRenderState;
            }
        },
        {
            key: "lineMarkerIndex",
            get: function get() {
                return this.m_lineMarkerIndex;
            }
        },
        {
            key: "position",
            get: function get() {
                return this.element.path !== void 0 && this.m_lineMarkerIndex !== void 0 ? this.element.path[this.m_lineMarkerIndex] : this.element.position;
            }
        },
        {
            key: "updateFading",
            value: function updateFading(time, disableFading) {
                if (this.m_textRenderState !== void 0) {
                    this.m_textRenderState.updateFading(time, disableFading);
                }
                if (this.iconRenderState !== void 0) {
                    this.iconRenderState.updateFading(time, disableFading);
                }
            }
        },
        {
            key: "initializeRenderStates",
            value: function initializeRenderStates() {
                assert(this.m_textRenderState === void 0);
                assert(this.m_textLayoutState === void 0);
                assert(this.m_iconRenderState === void 0);
                var textFadeTime = this.element.textFadeTime;
                this.m_textRenderState = new RenderState(textFadeTime);
                if (this.element.type === 0 /* PoiLabel */  || this.element.type === 2 /* LineMarker */ ) {
                    var ref;
                    var techniqueIconFadeTime = (ref = this.element.poiInfo) === null || ref === void 0 ? void 0 : ref.technique.iconFadeTime;
                    var iconFadeTime = techniqueIconFadeTime !== void 0 ? techniqueIconFadeTime * 1e3 : textFadeTime;
                    this.m_iconRenderState = new RenderState(iconFadeTime);
                }
            }
        }
    ]);
    return TextElementState;
}();
function isLineMarkerElementState(state) {
    return state.m_lineMarkerIndex !== void 0;
}
// src/mapview/text/TextElementGroupState.ts
var TextElementGroupState = /*#__PURE__*/ function() {
    function TextElementGroupState(group, tileKey, filter) {
        _classCallCheck(this, TextElementGroupState);
        this.group = group;
        this.tileKey = tileKey;
        __publicField(this, "m_textElementStates");
        __publicField(this, "m_visited", false);
        assert(group.elements.length > 0);
        var length = group.elements.length;
        this.m_textElementStates = [];
        this.m_visited = true;
        for(var i = 0; i < length; ++i){
            var textElement = group.elements[i];
            if (textElement.type === 2 /* LineMarker */  && textElement.path !== void 0) {
                var numPoints = textElement.path.length;
                for(var p = 0; p < numPoints; p++){
                    var state = new TextElementState(textElement, p);
                    var textDistance = filter(state);
                    state.update(textDistance);
                    this.m_textElementStates.push(state);
                }
            } else {
                var state1 = new TextElementState(textElement);
                var textDistance1 = filter(state1);
                state1.update(textDistance1);
                this.m_textElementStates.push(state1);
            }
        }
    }
    _createClass(TextElementGroupState, [
        {
            key: "visited",
            get: function get() {
                return this.m_visited;
            },
            set: function set(visited) {
                this.m_visited = visited;
            }
        },
        {
            key: "priority",
            get: function get() {
                return this.group.priority;
            }
        },
        {
            key: "updateFading",
            value: function updateFading(time, disableFading) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_textElementStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var elementState = _step.value;
                        if (elementState !== void 0) {
                            elementState.updateFading(time, disableFading);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "traverseVisibleElements",
            value: function traverseVisibleElements(visibleElementsCallback) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_textElementStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var elementState = _step.value;
                        if (elementState !== void 0 && elementState.visible) {
                            visibleElementsCallback(elementState);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "updateElements",
            value: function updateElements(filter) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_textElementStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var elementState = _step.value;
                        var textDistance = filter(elementState);
                        elementState.update(textDistance);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "size",
            get: function get() {
                return this.m_textElementStates.length;
            }
        },
        {
            key: "textElementStates",
            get: function get() {
                return this.m_textElementStates;
            }
        }
    ]);
    return TextElementGroupState;
}();
// src/mapview/text/TextElementStateCache.ts
var logger17 = LoggerManager.instance.create("TextElementsStateCache", {
    level: 2 /* Log */ 
});
function getDedupSqDistTolerance(zoomLevel) {
    var minSqTol = 100;
    var minSqTolLevel = 13;
    var maxLevelDelta = 4;
    var levelDelta = Math.min(maxLevelDelta, minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel)));
    return minSqTol << (levelDelta << 2);
}
var tmpCachedDuplicate = {
    entries: [],
    index: -1
};
function getCacheKey(element) {
    return element.hasFeatureId() ? element.featureId : element.text;
}
function findDuplicateById(elementState, candidates) {
    var element = elementState.element;
    var duplicateIndex = candidates.findIndex(function(entry) {
        return entry.element.tileOffset === element.tileOffset;
    });
    if (duplicateIndex === -1) {
        return -1;
    }
    var candidateElement = candidates[duplicateIndex];
    var candidate = candidateElement.element;
    assert(element.featureId === candidate.featureId);
    if (candidate.text !== element.text) {
        logger17.debug("Text feature id ".concat(element.featureId, ' collision between "').concat(element.text, " and              ").concat(candidate.text));
        return void 0;
    }
    return duplicateIndex;
}
function isBetterPathDuplicate(newCandidate, _newDistance, oldCandidate, _oldDistance) {
    if (newCandidate.pathLengthSqr === void 0) {
        return false;
    }
    if (oldCandidate.pathLengthSqr === void 0) {
        return false;
    }
    return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;
}
function isBetterPointDuplicate(_newCandidate, newDistance, _oldCandidate, oldDistance) {
    return newDistance < oldDistance;
}
function findDuplicateByText(elementState, candidates, zoomLevel) {
    var element = elementState.element;
    var maxSqDistError = getDedupSqDistTolerance(zoomLevel);
    var entryCount = candidates.length;
    var elementPosition = elementState.position;
    var elementVisible = elementState.visible;
    var isLineMarker = isLineMarkerElementState(elementState);
    var dupIndex = -1;
    var duplicate;
    var dupDistSquared = Infinity;
    var isBetterDuplicate = element.type === 1 /* PathLabel */  ? isBetterPathDuplicate : isBetterPointDuplicate;
    for(var i = 0; i < entryCount; ++i){
        var candidateEntry = candidates[i];
        var cachedElement = candidateEntry.element;
        var areDiffType = element.type !== cachedElement.type || isLineMarker !== isLineMarkerElementState(candidateEntry);
        var areBothVisible = elementVisible && candidateEntry.visible;
        if (areDiffType || areBothVisible) {
            continue;
        }
        var distSquared = elementPosition.distanceToSquared(cachedElement.position);
        if (distSquared > maxSqDistError) {
            continue;
        }
        if (duplicate === void 0 || isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)) {
            dupIndex = i;
            duplicate = cachedElement;
            dupDistSquared = distSquared;
        }
    }
    return dupIndex;
}
var TextElementStateCache = /*#__PURE__*/ function() {
    function TextElementStateCache() {
        _classCallCheck(this, TextElementStateCache);
        __publicField(this, "m_referenceMap", /* @__PURE__ */ new Map());
        __publicField(this, "m_sortedGroupStates");
        __publicField(this, "m_textMap", /* @__PURE__ */ new Map());
    }
    _createClass(TextElementStateCache, [
        {
            key: "getOrSet",
            value: function getOrSet(textElementGroup, tileKey, textElementFilter) {
                var groupState = this.get(textElementGroup);
                if (groupState !== void 0) {
                    groupState.updateElements(textElementFilter);
                    return [
                        groupState,
                        true
                    ];
                }
                groupState = new TextElementGroupState(textElementGroup, tileKey, textElementFilter);
                this.set(textElementGroup, groupState);
                return [
                    groupState,
                    false
                ];
            }
        },
        {
            key: "size",
            get: function get() {
                return this.m_referenceMap.size;
            }
        },
        {
            key: "cacheSize",
            get: function get() {
                return this.m_textMap.size;
            }
        },
        {
            key: "sortedGroupStates",
            get: function get() {
                if (this.m_sortedGroupStates === void 0) {
                    this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());
                    this.m_sortedGroupStates.sort(function(a, b) {
                        return b.group.priority - a.group.priority;
                    });
                }
                assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);
                return this.m_sortedGroupStates;
            }
        },
        {
            key: "update",
            value: function update(time, disableFading, findReplacements, zoomLevel) {
                var replaceCallback = findReplacements ? this.replaceElement.bind(this, zoomLevel) : void 0;
                var anyEviction = false;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_referenceMap.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), key = _value[0], groupState = _value[1];
                        if (groupState.visited) {
                            groupState.updateFading(time, disableFading);
                        } else {
                            if (findReplacements) {
                                groupState.traverseVisibleElements(replaceCallback);
                            }
                            this.m_referenceMap.delete(key);
                            this.m_sortedGroupStates = void 0;
                            anyEviction = true;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return anyEviction;
            }
        },
        {
            key: "clearVisited",
            value: function clearVisited() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_referenceMap.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var groupState = _step.value;
                        groupState.visited = false;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "clearTextCache",
            value: function clearTextCache() {
                this.m_textMap.clear();
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_referenceMap.clear();
                this.m_sortedGroupStates = void 0;
                this.m_textMap.clear();
            }
        },
        {
            key: "deduplicateElement",
            value: function deduplicateElement(zoomLevel, elementState) {
                var cacheResult = this.findDuplicate(elementState, zoomLevel);
                if (cacheResult === void 0) {
                    this.m_textMap.set(getCacheKey(elementState.element), [
                        elementState
                    ]);
                    return true;
                }
                if (cacheResult.index === -1) {
                    cacheResult.entries.push(elementState);
                    return true;
                }
                var cachedDuplicate = cacheResult.entries[cacheResult.index];
                if (!cachedDuplicate.visible && elementState.visible) {
                    cacheResult.entries[cacheResult.index] = elementState;
                    cachedDuplicate.reset();
                    return true;
                }
                return false;
            }
        },
        {
            key: "replaceElement",
            value: function replaceElement(zoomLevel, elementState) {
                assert(elementState.visible);
                var cacheResult = this.findDuplicate(elementState, zoomLevel);
                if (cacheResult === void 0 || cacheResult.index === -1) {
                    return false;
                }
                var replacement = cacheResult.entries[cacheResult.index];
                assert(!replacement.visible);
                replacement.replace(elementState);
                return true;
            }
        },
        {
            key: "get",
            value: function get(textElementGroup) {
                var groupState = this.m_referenceMap.get(textElementGroup);
                if (groupState !== void 0) {
                    groupState.visited = true;
                }
                return groupState;
            }
        },
        {
            key: "set",
            value: function set(textElementGroup, textElementGroupState) {
                assert(textElementGroup.elements.length > 0);
                this.m_referenceMap.set(textElementGroup, textElementGroupState);
                this.m_sortedGroupStates = void 0;
            }
        },
        {
            key: "findDuplicate",
            value: function findDuplicate(elementState, zoomLevel) {
                var element = elementState.element;
                var cachedEntries = this.m_textMap.get(getCacheKey(element));
                if (cachedEntries === void 0) {
                    return void 0;
                }
                tmpCachedDuplicate.entries = cachedEntries;
                var index = element.hasFeatureId() ? findDuplicateById(elementState, cachedEntries) : findDuplicateByText(elementState, cachedEntries, zoomLevel);
                if (index === void 0) {
                    element.featureId = void 0;
                    return this.findDuplicate(elementState, zoomLevel);
                }
                tmpCachedDuplicate.index = index;
                return tmpCachedDuplicate;
            }
        }
    ]);
    return TextElementStateCache;
}();
// src/mapview/text/TextStyleCache.ts
var logger18 = LoggerManager.instance.create("TextStyleCache");
var defaultTextRenderStyle = new TextRenderStyle({
    fontSize: {
        unit: 1 /* Pixel */ ,
        size: 32,
        backgroundSize: 8
    },
    color: ColorCache.instance.getColor("#6d7477"),
    opacity: 1,
    backgroundColor: ColorCache.instance.getColor("#f7fbfd"),
    backgroundOpacity: 0.5
});
var defaultTextLayoutStyle = new TextLayoutStyle({
    verticalAlignment: -0.5 /* Center */ ,
    horizontalAlignment: -0.5 /* Center */ ,
    placements: []
});
var DEFAULT_STYLE_NAME = "default";
var TextStyleCache = /*#__PURE__*/ function() {
    function TextStyleCache() {
        _classCallCheck(this, TextStyleCache);
        __publicField(this, "m_textStyles", /* @__PURE__ */ new Map());
        __publicField(this, "m_defaultStyle", {
            name: DEFAULT_STYLE_NAME,
            fontCatalog: void 0,
            renderParams: defaultTextRenderStyle.params,
            layoutParams: defaultTextLayoutStyle.params
        });
        this.updateDefaultTextStyle();
    }
    _createClass(TextStyleCache, [
        {
            key: "updateTextStyles",
            value: function updateTextStyles(textStyleDefinitions, defaultTextStyleDefinition) {
                var _this = this;
                this.m_textStyles.clear();
                textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions.forEach(function(element) {
                    _this.m_textStyles.set(element.name, _this.createTextElementStyle(element, element.name));
                });
                this.updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions);
            }
        },
        {
            key: "updateTextCanvases",
            value: function updateTextCanvases(textCanvases) {
                this.initializeTextCanvas(this.m_defaultStyle, textCanvases);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_textStyles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), style = _value[1];
                        this.initializeTextCanvas(style, textCanvases);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "getTextElementStyle",
            value: function getTextElementStyle(styleId) {
                var result;
                if (styleId === void 0) {
                    result = this.m_defaultStyle;
                } else {
                    result = this.m_textStyles.get(styleId);
                    if (result === void 0) {
                        result = this.m_defaultStyle;
                    }
                }
                return result;
            }
        },
        {
            key: "createRenderStyle",
            value: function createRenderStyle(tile, technique) {
                var mapView = tile.mapView;
                var zoomLevel = mapView.zoomLevel;
                var discreteZoomLevel = Math.floor(zoomLevel);
                var discreteZoomEnv = new MapEnv({
                    $zoom: discreteZoomLevel
                }, mapView.env);
                var defaultRenderParams = this.m_defaultStyle.renderParams;
                var defaultOpacity = getOptionValue(defaultRenderParams.opacity, 1);
                var opacity = getPropertyValue(getOptionValue(technique.opacity, defaultOpacity), discreteZoomEnv);
                var color;
                if (technique.color !== void 0) {
                    var hexColor = evaluateColorProperty(technique.color, discreteZoomEnv);
                    if (hexColor !== void 0) {
                        if (ColorUtils.hasAlphaInHex(hexColor)) {
                            var alpha = ColorUtils.getAlphaFromHex(hexColor);
                            opacity = opacity * alpha;
                            hexColor = ColorUtils.removeAlphaFromHex(hexColor);
                        }
                        color = ColorCache.instance.getColor(hexColor);
                    }
                }
                var defaultBackgroundSize = getOptionValue(defaultRenderParams.fontSize.backgroundSize, 0);
                var backgroundSize = getPropertyValue(getOptionValue(technique.backgroundSize, defaultBackgroundSize), discreteZoomEnv);
                var hasBackgroundDefined = technique.backgroundColor !== void 0 && technique.backgroundSize !== void 0 && backgroundSize > 0;
                var defaultBackgroundOpacity = getOptionValue(defaultRenderParams.backgroundOpacity, 0);
                var backgroundOpacity = getPropertyValue(getOptionValue(technique.backgroundOpacity, hasBackgroundDefined ? 1 : defaultBackgroundOpacity), discreteZoomEnv);
                var backgroundColor;
                if (technique.backgroundColor !== void 0) {
                    var hexBgColor = evaluateColorProperty(technique.backgroundColor, discreteZoomEnv);
                    if (hexBgColor !== void 0) {
                        if (ColorUtils.hasAlphaInHex(hexBgColor)) {
                            var alpha1 = ColorUtils.getAlphaFromHex(hexBgColor);
                            backgroundOpacity = backgroundOpacity * alpha1;
                            hexBgColor = ColorUtils.removeAlphaFromHex(hexBgColor);
                        }
                        backgroundColor = ColorCache.instance.getColor(hexBgColor);
                    }
                }
                var renderParams = {
                    fontName: getOptionValue(technique.fontName, defaultRenderParams.fontName),
                    fontSize: {
                        unit: 1 /* Pixel */ ,
                        size: getPropertyValue(getOptionValue(technique.size, defaultRenderParams.fontSize.size), discreteZoomEnv),
                        backgroundSize: backgroundSize
                    },
                    fontStyle: technique.fontStyle === "Regular" || technique.fontStyle === "Bold" || technique.fontStyle === "Italic" || technique.fontStyle === "BoldItalic" ? FontStyle[technique.fontStyle] : defaultRenderParams.fontStyle,
                    fontVariant: technique.fontVariant === "Regular" || technique.fontVariant === "AllCaps" || technique.fontVariant === "SmallCaps" ? FontVariant[technique.fontVariant] : defaultRenderParams.fontVariant,
                    rotation: getOptionValue(technique.rotation, defaultRenderParams.rotation),
                    color: getOptionValue(color, getOptionValue(defaultRenderParams.color, DefaultTextStyle.DEFAULT_COLOR)),
                    backgroundColor: getOptionValue(backgroundColor, getOptionValue(defaultRenderParams.backgroundColor, DefaultTextStyle.DEFAULT_BACKGROUND_COLOR)),
                    opacity: opacity,
                    backgroundOpacity: backgroundOpacity
                };
                var themeRenderParams = this.getTextElementStyle(technique.style).renderParams;
                var renderStyle = new TextRenderStyle(_objectSpread({}, themeRenderParams, renderParams));
                return renderStyle;
            }
        },
        {
            key: "createLayoutStyle",
            value: function createLayoutStyle(tile, technique) {
                var mapView = tile.mapView;
                var floorZoomLevel = Math.floor(tile.mapView.zoomLevel);
                var discreteZoomEnv = new MapEnv({
                    $zoom: floorZoomLevel
                }, mapView.env);
                var defaultLayoutParams = this.m_defaultStyle.layoutParams;
                var hAlignment = getPropertyValue(technique.hAlignment, discreteZoomEnv);
                var vAlignment = getPropertyValue(technique.vAlignment, discreteZoomEnv);
                var textPlacements = isPoiTechnique(technique) ? getPropertyValue(technique.placements, discreteZoomEnv) : null;
                var ref = parseAlignmentAndPlacements(hAlignment, vAlignment, textPlacements), horizontalAlignment = ref.horizontalAlignment, verticalAlignment = ref.verticalAlignment, placements = ref.placements;
                var wrapping = getPropertyValue(technique.wrappingMode, discreteZoomEnv);
                var wrappingMode = wrapping === "None" || wrapping === "Character" || wrapping === "Word" ? WrappingMode[wrapping] : defaultLayoutParams.wrappingMode;
                var ref1, ref2, ref3, ref4, ref5, ref6;
                var layoutParams = {
                    tracking: (ref1 = getPropertyValue(technique.tracking, discreteZoomEnv)) !== null && ref1 !== void 0 ? ref1 : defaultLayoutParams.tracking,
                    leading: (ref2 = getPropertyValue(technique.leading, discreteZoomEnv)) !== null && ref2 !== void 0 ? ref2 : defaultLayoutParams.leading,
                    maxLines: (ref3 = getPropertyValue(technique.maxLines, discreteZoomEnv)) !== null && ref3 !== void 0 ? ref3 : defaultLayoutParams.maxLines,
                    lineWidth: (ref4 = getPropertyValue(technique.lineWidth, discreteZoomEnv)) !== null && ref4 !== void 0 ? ref4 : defaultLayoutParams.lineWidth,
                    canvasRotation: (ref5 = getPropertyValue(technique.canvasRotation, discreteZoomEnv)) !== null && ref5 !== void 0 ? ref5 : defaultLayoutParams.canvasRotation,
                    lineRotation: (ref6 = getPropertyValue(technique.lineRotation, discreteZoomEnv)) !== null && ref6 !== void 0 ? ref6 : defaultLayoutParams.lineRotation,
                    wrappingMode: wrappingMode,
                    horizontalAlignment: horizontalAlignment,
                    verticalAlignment: verticalAlignment,
                    placements: placements
                };
                var themeLayoutParams = this.getTextElementStyle(technique.style);
                var layoutStyle = new TextLayoutStyle(_objectSpread({}, themeLayoutParams, layoutParams));
                return layoutStyle;
            }
        },
        {
            key: "updateDefaultTextStyle",
            value: function updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions) {
                this.m_defaultStyle.fontCatalog = void 0;
                var ref, ref1;
                var style = (ref1 = (ref = textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions.find(function(definition) {
                    return definition.name === DEFAULT_STYLE_NAME;
                })) !== null && ref !== void 0 ? ref : defaultTextStyleDefinition) !== null && ref1 !== void 0 ? ref1 : textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions[0];
                if (style) {
                    this.m_defaultStyle = this.createTextElementStyle(style, DEFAULT_STYLE_NAME);
                }
                this.m_defaultStyle.textCanvas = void 0;
            }
        },
        {
            key: "initializeTextCanvas",
            value: function initializeTextCanvas(style, textCanvases) {
                if (style.textCanvas) {
                    return;
                }
                if (style.fontCatalog !== void 0) {
                    var styledTextCanvas = textCanvases.get(style.fontCatalog);
                    style.textCanvas = styledTextCanvas;
                    if (textCanvases.has(style.fontCatalog) && !styledTextCanvas) {
                        logger18.info("fontCatalog(".concat(style.fontCatalog, "), not yet loaded"));
                        return;
                    }
                }
                if (style.textCanvas === void 0) {
                    if (style.fontCatalog !== void 0 && style.fontCatalog !== DEFAULT_FONT_CATALOG_NAME) {
                        logger18.warn("FontCatalog '".concat(style.fontCatalog, "' set in TextStyle\n                     '").concat(style.name, "' not found"));
                    }
                    var alternativeTextCanvas = textCanvases.get(DEFAULT_FONT_CATALOG_NAME);
                    if (!alternativeTextCanvas && textCanvases.size > 0) {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = textCanvases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var _value = _slicedToArray(_step.value, 2), canvas = _value[1];
                                if (canvas) {
                                    alternativeTextCanvas = canvas;
                                    break;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                    if (alternativeTextCanvas) {
                        style.textCanvas = alternativeTextCanvas;
                        if (style.fontCatalog !== void 0) {
                            var ref;
                            logger18.info("fontCatalog: '".concat(style.fontCatalog, "' not found,\n                      using default fontCatalog(").concat((ref = style.textCanvas) === null || ref === void 0 ? void 0 : ref.name, ")."));
                        }
                    }
                }
            }
        },
        {
            key: "createTextElementStyle",
            value: function createTextElementStyle(style, styleName) {
                var ref = parseAlignmentAndPlacements(style.hAlignment, style.vAlignment, style.placements), horizontalAlignment = ref.horizontalAlignment, verticalAlignment = ref.verticalAlignment, placements = ref.placements;
                var _backgroundSize;
                return {
                    name: styleName,
                    fontCatalog: getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),
                    renderParams: {
                        fontName: style.fontName,
                        fontSize: {
                            unit: 1 /* Pixel */ ,
                            size: 32,
                            backgroundSize: (_backgroundSize = style.backgroundSize) !== null && _backgroundSize !== void 0 ? _backgroundSize : 8
                        },
                        fontStyle: style.fontStyle === "Regular" || style.fontStyle === "Bold" || style.fontStyle === "Italic" || style.fontStyle === "BoldItalic" ? FontStyle[style.fontStyle] : void 0,
                        fontVariant: style.fontVariant === "Regular" || style.fontVariant === "AllCaps" || style.fontVariant === "SmallCaps" ? FontVariant[style.fontVariant] : void 0,
                        rotation: style.rotation,
                        color: style.color !== void 0 ? ColorCache.instance.getColor(style.color) : void 0,
                        backgroundColor: style.backgroundColor !== void 0 ? ColorCache.instance.getColor(style.backgroundColor) : void 0,
                        opacity: style.opacity,
                        backgroundOpacity: style.backgroundOpacity
                    },
                    layoutParams: {
                        tracking: style.tracking,
                        leading: style.leading,
                        maxLines: style.maxLines,
                        lineWidth: style.lineWidth,
                        canvasRotation: style.canvasRotation,
                        lineRotation: style.lineRotation,
                        wrappingMode: style.wrappingMode === "None" || style.wrappingMode === "Character" || style.wrappingMode === "Word" ? WrappingMode[style.wrappingMode] : 2 /* Word */ ,
                        verticalAlignment: verticalAlignment,
                        horizontalAlignment: horizontalAlignment,
                        placements: placements
                    }
                };
            }
        }
    ]);
    return TextStyleCache;
}();
function parseAlignmentAndPlacements(hAlignment, vAlignment, placementsTokens) {
    var placements = placementsTokens ? parseTechniquePlacements(placementsTokens) : void 0;
    return resolvePlacementAndAlignment(parseTechniqueHAlignValue(hAlignment), parseTechniqueVAlignValue(vAlignment), placements);
}
function parseTechniqueHAlignValue(hAlignment) {
    return hAlignment === "Left" || hAlignment === "Center" || hAlignment === "Right" ? HorizontalAlignment[hAlignment] : defaultTextLayoutStyle.horizontalAlignment;
}
function parseTechniqueVAlignValue(vAlignment) {
    return vAlignment === "Above" || vAlignment === "Center" || vAlignment === "Below" ? VerticalAlignment[vAlignment] : defaultTextLayoutStyle.verticalAlignment;
}
function parseTechniquePlacements(placementsString) {
    var placements = [];
    var placementsTokens = placementsString ? placementsString.toUpperCase().replace(" ", "").split(",") : [];
    placementsTokens.forEach(function(p) {
        var val = parseTechniquePlacementValue(p);
        if (val !== void 0) {
            placements.push(val);
        }
    });
    return placements;
}
function parseTechniquePlacementValue(p) {
    if (p.length < 1 || p.length > 2) {
        return void 0;
    }
    var textPlacement = {
        h: -0.5 /* Center */ ,
        v: -0.5 /* Center */ 
    };
    var modifier = p.charAt(0);
    var found = true;
    switch(modifier){
        case "T" /* Top */ :
        case "N" /* North */ :
            textPlacement.v = 0 /* Top */ ;
            break;
        case "B" /* Bottom */ :
        case "S" /* South */ :
            textPlacement.v = -1 /* Bottom */ ;
            break;
        default:
            found = false;
            if (p.length === 2) {
                return void 0;
            }
    }
    if (found && p.length === 1) {
        return textPlacement;
    }
    modifier = p.length === 1 ? p.charAt(0) : p.charAt(1);
    switch(modifier){
        case "R" /* Right */ :
        case "E" /* East */ :
            textPlacement.h = 0 /* Right */ ;
            break;
        case "L" /* Left */ :
        case "W" /* West */ :
            textPlacement.h = -1 /* Left */ ;
            break;
        default:
            return void 0;
    }
    return textPlacement;
}
// src/mapview/text/UpdateStats.ts
var UpdateStats = /*#__PURE__*/ function() {
    function UpdateStats(m_logger) {
        _classCallCheck(this, UpdateStats);
        this.m_logger = m_logger;
        __publicField(this, "tiles", 0);
        __publicField(this, "totalGroups", 0);
        __publicField(this, "newGroups", 0);
        __publicField(this, "totalLabels", 0);
        __publicField(this, "results", new Array(5 /* Count */ ));
        this.results.fill(0);
    }
    _createClass(UpdateStats, [
        {
            key: "clear",
            value: function clear() {
                this.tiles = 0;
                this.totalGroups = 0;
                this.newGroups = 0;
                this.totalLabels = 0;
                this.results.fill(0);
            }
        },
        {
            key: "log",
            value: function log() {
                this.m_logger.debug("Tiles", this.tiles);
                this.m_logger.debug("Total groups", this.totalGroups);
                this.m_logger.debug("New groups", this.newGroups);
                this.m_logger.debug("Total labels", this.totalLabels);
                this.m_logger.debug("Placed labels", this.results[0 /* Ok */ ]);
                this.m_logger.debug("Invisible", this.results[2 /* Invisible */ ]);
                this.m_logger.debug("Poi not ready", this.results[1 /* NotReady */ ]);
                this.m_logger.debug("Too far", this.results[3 /* TooFar */ ]);
                this.m_logger.debug("Duplicate", this.results[4 /* Duplicate */ ]);
            }
        }
    ]);
    return UpdateStats;
}();
// src/mapview/text/TextElementsRenderer.ts
var DEFAULT_FONT_CATALOG_NAME = "default";
var DEFAULT_TEXT_DISTANCE_SCALE = 0.5;
var OVERLOAD_LABEL_LIMIT = 2e4;
var OVERLOAD_UPDATED_LABEL_LIMIT = 100;
var OVERLOAD_UPDATE_TIME_LIMIT = 5;
var OVERLOAD_PLACE_TIME_LIMIT = 10;
var logger19 = LoggerManager.instance.create("TextElementsRenderer", {
    level: 2 /* Log */ 
});
var PRINT_LABEL_DEBUG_INFO = false;
var updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats(logger19) : void 0;
var placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats(logger19) : void 0;
var tempPosition = new THREE84.Vector3();
var tempScreenPosition = new THREE84.Vector2();
var tempScreenPoints = [];
var tempPoiScreenPosition = new THREE84.Vector2();
var tmpTextBufferCreationParams = {};
var tmpAdditionParams = {};
var tmpBufferAdditionParams = {};
var cache2 = {
    vector2: [
        new THREE84.Vector2()
    ]
};
var TileTextElements = function TileTextElements(tile, group) {
    _classCallCheck(this, TileTextElements);
    this.tile = tile;
    this.group = group;
};
var TextElementLists = /*#__PURE__*/ function() {
    function TextElementLists(lists) {
        _classCallCheck(this, TextElementLists);
        this.lists = lists;
    }
    _createClass(TextElementLists, [
        {
            key: "priority",
            get: function get() {
                assert(this.lists.length > 0);
                return this.lists[0].group.priority;
            }
        },
        {
            key: "count",
            value: function count() {
                var n = 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.lists[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var list = _step.value;
                        n += list.group.elements.length;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return n;
            }
        }
    ]);
    return TextElementLists;
}();
function checkIfTextElementsChanged(dataSourceTileList) {
    var textElementsChanged = false;
    dataSourceTileList.forEach(function(param) {
        var renderedTiles = param.renderedTiles;
        renderedTiles.forEach(function(tile) {
            if (tile.textElementsChanged) {
                tile.textElementsChanged = false;
                textElementsChanged = true;
            }
        });
    });
    return textElementsChanged;
}
function hasTextElements(dataSourceTileList) {
    for(var i = 0; i < dataSourceTileList.length; i++){
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = dataSourceTileList[i].renderedTiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _value = _slicedToArray(_step.value, 2), _key = _value[0], value2 = _value[1];
                if (value2.hasTextElements()) {
                    return true;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return false;
}
function addTextToCanvas(textElement, canvas, screenPosition, path, pathOverflow) {
    tmpAdditionParams.path = path;
    tmpAdditionParams.pathOverflow = pathOverflow;
    tmpAdditionParams.layer = textElement.renderOrder;
    tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;
    tmpAdditionParams.pickingData = textElement.userData ? textElement : void 0;
    canvas.addText(textElement.glyphs, screenPosition, tmpAdditionParams);
}
function addTextBufferToCanvas(textElementState, canvas, screenPosition, fadeFactor, scaleFactor) {
    var textElement = textElementState.element;
    var textRenderState = textElementState.textRenderState;
    var opacity = textRenderState.opacity * fadeFactor * textElement.renderStyle.opacity;
    if (opacity === 0) {
        return false;
    }
    tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;
    if (textElement.textBufferObject === void 0) {
        textElement.textBufferObject = canvas.createTextBufferObject(textElement.glyphs, tmpTextBufferCreationParams);
    }
    var backgroundIsVisible = textElement.renderStyle.backgroundOpacity > 0 && canvas.textRenderStyle.fontSize.backgroundSize > 0;
    tmpBufferAdditionParams.layer = textElement.renderOrder;
    tmpBufferAdditionParams.position = screenPosition;
    tmpBufferAdditionParams.scale = scaleFactor;
    tmpBufferAdditionParams.opacity = opacity;
    tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible ? tmpBufferAdditionParams.opacity * textElement.renderStyle.backgroundOpacity : 0;
    tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : void 0;
    canvas.addTextBufferObject(textElement.textBufferObject, tmpBufferAdditionParams);
    return true;
}
function shouldRenderPointText(labelState, viewState, options) {
    var textRenderState = labelState.textRenderState;
    var label = labelState.element;
    var poiInfo = label.poiInfo;
    assert(label.type !== 1 /* PathLabel */ );
    var hasText = textRenderState !== void 0 && label.text !== "";
    if (!hasText) {
        return false;
    }
    var visibleInZoomLevel = poiInfo === void 0 || MathUtils.isClamped(viewState.zoomLevel, poiInfo.textMinZoomLevel, poiInfo.textMaxZoomLevel);
    if (!visibleInZoomLevel) {
        return false;
    }
    var poiTextMaxDistance = getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels);
    var visibleAtDistance = label.ignoreDistance === true || labelState.viewDistance === void 0 || labelState.viewDistance < poiTextMaxDistance && labelState.viewDistance > 0;
    if (!visibleAtDistance) {
        return false;
    }
    return !poiInfo || poiInfo.isValid === true || poiInfo.iconIsOptional === true;
}
function shouldRenderPoiText(labelState, viewState) {
    var poiInfo = labelState.element.poiInfo;
    return !viewState.cameraIsMoving || poiInfo === void 0 || poiInfo.renderTextDuringMovements === true;
}
function isPlacementTimeExceeded(startTime) {
    if (startTime === void 0 || OVERLOAD_PLACE_TIME_LIMIT <= 0) {
        return false;
    }
    var endTime = PerformanceTimer.now();
    var elapsedTime = endTime - startTime;
    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {
        logger19.debug("Placement time limit exceeded.");
        return true;
    }
    return false;
}
function createDefaultFontCatalogConfig(defaultFontCatalogUrl) {
    return {
        name: DEFAULT_FONT_CATALOG_NAME,
        url: defaultFontCatalogUrl
    };
}
var TextElementsRenderer = /*#__PURE__*/ function() {
    function TextElementsRenderer(m_viewState, m_screenProjector, m_poiManager, m_renderer, m_imageCaches, options, textCanvasFactory, poiRenderer, screenCollisions) {
        _classCallCheck(this, TextElementsRenderer);
        this.m_viewState = m_viewState;
        this.m_screenProjector = m_screenProjector;
        this.m_poiManager = m_poiManager;
        this.m_renderer = m_renderer;
        this.m_imageCaches = m_imageCaches;
        __publicField(this, "m_loadPromisesCount", 0);
        __publicField(this, "m_loadPromise");
        __publicField(this, "m_options");
        __publicField(this, "m_textCanvases", /* @__PURE__ */ new Map());
        __publicField(this, "m_overlayTextElements");
        __publicField(this, "m_debugGlyphTextureCacheMesh");
        __publicField(this, "m_debugGlyphTextureCacheWireMesh");
        __publicField(this, "m_tmpVector", new THREE84.Vector2());
        __publicField(this, "m_tmpVector3", new THREE84.Vector3());
        __publicField(this, "m_cameraLookAt", new THREE84.Vector3());
        __publicField(this, "m_overloaded", false);
        __publicField(this, "m_cacheInvalidated", false);
        __publicField(this, "m_addNewLabels", true);
        __publicField(this, "m_forceNewLabelsPass", false);
        __publicField(this, "m_textElementStateCache", new TextElementStateCache());
        __publicField(this, "m_camera", new THREE84.OrthographicCamera(-1, 1, 1, -1));
        __publicField(this, "m_defaultFontCatalogConfig");
        __publicField(this, "m_poiRenderer");
        __publicField(this, "m_textStyleCache", new TextStyleCache());
        __publicField(this, "m_screenCollisions", new ScreenCollisions());
        __publicField(this, "m_textCanvasFactory");
        __publicField(this, "m_isUpdatePending", false);
        this.m_options = _objectSpread({}, options);
        initializeDefaultOptions(this.m_options);
        if (screenCollisions) {
            this.m_screenCollisions = screenCollisions;
        } else if (this.m_options.collisionDebugCanvas !== void 0 && this.m_options.collisionDebugCanvas !== null) {
            this.m_screenCollisions = new ScreenCollisionsDebug(this.m_options.collisionDebugCanvas);
        }
        this.m_textCanvasFactory = textCanvasFactory !== null && textCanvasFactory !== void 0 ? textCanvasFactory : new TextCanvasFactory(this.m_renderer);
        this.m_textCanvasFactory.setGlyphCountLimits(this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs);
        this.m_poiRenderer = poiRenderer !== null && poiRenderer !== void 0 ? poiRenderer : new PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);
        this.initializeCamera();
        this.initializeDefaultFontCatalog();
        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
    }
    _createClass(TextElementsRenderer, [
        {
            key: "disableFading",
            get: function get() {
                return this.m_options.disableFading === true;
            },
            set: function set(disable) {
                this.m_options.disableFading = disable;
            }
        },
        {
            key: "styleCache",
            get: function get() {
                return this.m_textStyleCache;
            }
        },
        {
            key: "delayLabelsUntilMovementFinished",
            get: function get() {
                return this.m_options.delayLabelsUntilMovementFinished === true;
            },
            set: function set(delay) {
                this.m_options.delayLabelsUntilMovementFinished = delay;
            }
        },
        {
            key: "showReplacementGlyphs",
            get: function get() {
                return this.m_options.showReplacementGlyphs === true;
            },
            set: function set(value2) {
                this.m_options.showReplacementGlyphs = value2;
                this.m_textCanvases.forEach(function(textCanvas) {
                    if (textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.fontCatalog) {
                        textCanvas.fontCatalog.showReplacementGlyphs = value2;
                    }
                });
            }
        },
        {
            key: "restoreRenderers",
            value: function restoreRenderers(renderer) {
                this.m_renderer = renderer;
                this.m_poiRenderer = new PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);
            }
        },
        {
            key: "updateFontCatalogs",
            value: function updateFontCatalogs(fontCatalogs) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, fontCatalog;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                if (_this.m_defaultFontCatalogConfig) {
                                    if (!fontCatalogs || fontCatalogs.findIndex(function(config) {
                                        return config.name === DEFAULT_FONT_CATALOG_NAME;
                                    }) === -1) {
                                        if (!fontCatalogs) {
                                            fontCatalogs = [];
                                        }
                                        fontCatalogs.unshift(_this.m_defaultFontCatalogConfig);
                                    } else {
                                        if (_this.m_textCanvases.has(DEFAULT_FONT_CATALOG_NAME)) {
                                            _this.m_textCanvases.delete(DEFAULT_FONT_CATALOG_NAME);
                                        }
                                    }
                                }
                                if (!(fontCatalogs && fontCatalogs.length > 0)) {
                                    _ctx.next = 46;
                                    break;
                                }
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 3;
                                _loop = function(_iterator, _step) {
                                    var _value = _slicedToArray(_step.value, 1), name2 = _value[0];
                                    if (fontCatalogs.findIndex(function(catalog) {
                                        return catalog.name === name2;
                                    }) < 0) {
                                        _this.m_textCanvases.delete(name2);
                                    }
                                };
                                for(_iterator = _this.m_textCanvases[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
                                _ctx.next = 12;
                                break;
                            case 8:
                                _ctx.prev = 8;
                                _ctx.t0 = _ctx["catch"](3);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t0;
                            case 12:
                                _ctx.prev = 12;
                                _ctx.prev = 13;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 15:
                                _ctx.prev = 15;
                                if (!_didIteratorError) {
                                    _ctx.next = 18;
                                    break;
                                }
                                throw _iteratorError;
                            case 18:
                                return _ctx.finish(15);
                            case 19:
                                return _ctx.finish(12);
                            case 20:
                                _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                _ctx.prev = 21;
                                _iterator1 = fontCatalogs[Symbol.iterator]();
                            case 23:
                                if (_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done) {
                                    _ctx.next = 30;
                                    break;
                                }
                                fontCatalog = _step1.value;
                                _ctx.next = 27;
                                return _this.addTextCanvas(fontCatalog);
                            case 27:
                                _iteratorNormalCompletion1 = true;
                                _ctx.next = 23;
                                break;
                            case 30:
                                _ctx.next = 36;
                                break;
                            case 32:
                                _ctx.prev = 32;
                                _ctx.t1 = _ctx["catch"](21);
                                _didIteratorError1 = true;
                                _iteratorError1 = _ctx.t1;
                            case 36:
                                _ctx.prev = 36;
                                _ctx.prev = 37;
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            case 39:
                                _ctx.prev = 39;
                                if (!_didIteratorError1) {
                                    _ctx.next = 42;
                                    break;
                                }
                                throw _iteratorError1;
                            case 42:
                                return _ctx.finish(39);
                            case 43:
                                return _ctx.finish(36);
                            case 44:
                                _ctx.next = 47;
                                break;
                            case 46:
                                {
                                    _this.m_textCanvases.clear();
                                }
                            case 47:
                                _this.m_textStyleCache.updateTextCanvases(_this.m_textCanvases);
                            case 48:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            3,
                            8,
                            12,
                            20
                        ],
                        [
                            13,
                            ,
                            15,
                            19
                        ],
                        [
                            21,
                            32,
                            36,
                            44
                        ],
                        [
                            37,
                            ,
                            39,
                            43
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "updateTextStyles",
            value: function updateTextStyles(textStyles, defaultTextStyle) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _this.m_textStyleCache.updateTextStyles(textStyles, defaultTextStyle);
                                _ctx.next = 3;
                                return _this.waitLoaded();
                            case 3:
                                _this.m_textStyleCache.updateTextCanvases(_this.m_textCanvases);
                                _this.invalidateCache();
                            case 5:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "renderText",
            value: function renderText(farPlane) {
                this.m_camera.far = farPlane;
                this.updateGlyphDebugMesh();
                var previousLayer;
                this.m_poiRenderer.update();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_poiRenderer.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var poiLayer = _step.value;
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = this.m_textCanvases[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var _value = _slicedToArray(_step1.value, 2), textCanvas = _value[1];
                                textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.render(this.m_camera, previousLayer === null || previousLayer === void 0 ? void 0 : previousLayer.id, poiLayer.id, void 0, false);
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                        this.m_poiRenderer.render(this.m_camera, poiLayer);
                        previousLayer = poiLayer;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                try {
                    for(var _iterator2 = this.m_textCanvases[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                        var _value1 = _slicedToArray(_step2.value, 2), textCanvas1 = _value1[1];
                        textCanvas1 === null || textCanvas1 === void 0 ? void 0 : textCanvas1.render(this.m_camera, previousLayer === null || previousLayer === void 0 ? void 0 : previousLayer.id, void 0, void 0, false);
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                            _iterator2.return();
                        }
                    } finally{
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        },
        {
            key: "invalidateCache",
            value: function invalidateCache() {
                this.m_cacheInvalidated = true;
            }
        },
        {
            key: "movementStarted",
            value: function movementStarted() {
                if (this.delayLabelsUntilMovementFinished) {
                    this.m_addNewLabels = false;
                }
            }
        },
        {
            key: "movementFinished",
            value: function movementFinished() {
                this.invalidateCache();
                if (this.delayLabelsUntilMovementFinished) {
                    this.m_addNewLabels = true;
                }
            }
        },
        {
            key: "overloaded",
            get: function get() {
                return this.m_overloaded;
            }
        },
        {
            key: "placeText",
            value: function placeText(dataSourceTileList, time) {
                var tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);
                var textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged || hasTextElements(dataSourceTileList);
                this.m_isUpdatePending = false;
                if (!textElementsAvailable && !this.m_cacheInvalidated && !this.m_viewState.renderedTilesChanged) {
                    return;
                }
                var updateTextElements = this.m_cacheInvalidated || tileTextElementsChanged || this.m_viewState.renderedTilesChanged;
                var findReplacements = updateTextElements && this.m_addNewLabels;
                if (findReplacements) {
                    this.m_textElementStateCache.clearVisited();
                    this.updateTextElements(dataSourceTileList);
                }
                var anyTextGroupEvicted = this.m_textElementStateCache.update(time, this.m_options.disableFading, findReplacements, this.m_viewState.zoomLevel);
                this.reset();
                if (this.m_addNewLabels) {
                    this.prepopulateScreenWithBlockingElements(dataSourceTileList);
                }
                var placeNewTextElements = (updateTextElements || anyTextGroupEvicted) && this.m_addNewLabels;
                this.placeTextElements(time, placeNewTextElements);
                this.placeOverlayTextElements();
            }
        },
        {
            key: "addOverlayText",
            value: function addOverlayText(textElements) {
                if (textElements.length === 0) {
                    return;
                }
                this.m_overlayTextElements = this.m_overlayTextElements === void 0 ? textElements.slice() : this.m_overlayTextElements.concat(textElements);
            }
        },
        {
            key: "clearOverlayText",
            value: function clearOverlayText() {
                this.m_overlayTextElements = [];
            }
        },
        {
            key: "hasOverlayText",
            value: function hasOverlayText() {
                return this.m_overlayTextElements !== void 0 && this.m_overlayTextElements.length > 0;
            }
        },
        {
            key: "overlayText",
            get: function get() {
                return this.m_overlayTextElements;
            }
        },
        {
            key: "pickTextElements",
            value: function pickTextElements(screenPosition, pickListener) {
                var pickHandler = function(pickData, pickObjectType) {
                    if (pickData === void 0) {
                        return;
                    }
                    var textElement = pickData;
                    var pickResult = {
                        type: pickObjectType,
                        point: screenPosition,
                        distance: 0,
                        renderOrder: textElement.renderOrder,
                        featureId: textElement.featureId,
                        userData: textElement.userData,
                        dataSourceName: textElement.dataSourceName,
                        dataSourceOrder: textElement.dataSourceOrder,
                        text: textElement.text
                    };
                    pickListener.addResult(pickResult);
                };
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_textCanvases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), textCanvas = _value[1];
                        textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.pickText(screenPosition, function(pickData) {
                            pickHandler(pickData, 4 /* Text */ );
                        });
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                this.m_poiRenderer.pickTextElements(screenPosition, function(pickData) {
                    pickHandler(pickData, 5 /* Icon */ );
                });
            }
        },
        {
            key: "loading",
            get: function get() {
                return this.m_loadPromisesCount > 0;
            }
        },
        {
            key: "isUpdatePending",
            get: function get() {
                return this.m_isUpdatePending;
            }
        },
        {
            key: "waitLoaded",
            value: function waitLoaded() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                if (!(_this.m_loadPromise !== void 0)) {
                                    _ctx.next = 4;
                                    break;
                                }
                                _ctx.next = 3;
                                return _this.m_loadPromise;
                            case 3:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 4:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "clearRenderStates",
            value: function clearRenderStates() {
                this.m_textElementStateCache.clear();
            }
        },
        {
            key: "getMemoryUsage",
            value: function getMemoryUsage() {
                var memoryUsage = {
                    heapSize: 0,
                    gpuSize: 0
                };
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_textCanvases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), textCanvas = _value[1];
                        textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.getMemoryUsage(memoryUsage);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                this.m_poiRenderer.getMemoryUsage(memoryUsage);
                return memoryUsage;
            }
        },
        {
            key: "addDefaultTextCanvas",
            value: function addDefaultTextCanvas() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                if (!(_this.m_textCanvases.has(DEFAULT_FONT_CATALOG_NAME) || !_this.m_defaultFontCatalogConfig)) {
                                    _ctx.next = 2;
                                    break;
                                }
                                return _ctx.abrupt("return");
                            case 2:
                                _ctx.next = 4;
                                return _this.addTextCanvas(_this.m_defaultFontCatalogConfig);
                            case 4:
                                _this.m_textStyleCache.updateTextCanvases(_this.m_textCanvases);
                            case 5:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "reset",
            value: function reset() {
                this.m_cameraLookAt.copy(this.m_viewState.lookAtVector);
                this.m_screenCollisions.reset();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_textCanvases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _slicedToArray(_step.value, 2), textCanvas = _value[1];
                        textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.clear();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                this.m_poiRenderer.reset();
            }
        },
        {
            key: "prepopulateScreenWithBlockingElements",
            value: function prepopulateScreenWithBlockingElements(dataSourceTileList) {
                var _this = this;
                var boxes = [];
                dataSourceTileList.forEach(function(renderListEntry) {
                    var startLinePointProj = new THREE84.Vector3();
                    var endLinePointProj = new THREE84.Vector3();
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = renderListEntry.renderedTiles.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var tile = _step.value;
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = tile.blockingElements[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var pathBlockingElement = _step1.value;
                                    if (pathBlockingElement.points.length < 2) {
                                        continue;
                                    }
                                    _this.m_screenProjector.project3(pathBlockingElement.points[0], startLinePointProj);
                                    for(var i = 1; i < pathBlockingElement.points.length; i++){
                                        _this.m_screenProjector.project3(pathBlockingElement.points[i], endLinePointProj);
                                        var line = pathBlockingElement.screenSpaceLines[i - 1];
                                        line.start.copy(startLinePointProj);
                                        line.end.copy(endLinePointProj);
                                        var lineWithBound = {
                                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),
                                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),
                                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),
                                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),
                                            line: line
                                        };
                                        boxes.push(lineWithBound);
                                        startLinePointProj.copy(endLinePointProj);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                });
                this.m_screenCollisions.allocateIBoxes(boxes);
            }
        },
        {
            key: "placeTextElementGroup",
            value: function placeTextElementGroup(groupState, renderParams, maxNumPlacedLabels, pass) {
                assert(groupState.visited);
                var shieldGroups = [];
                var hiddenKinds = this.m_viewState.hiddenGeometryKinds;
                var projection = this.m_viewState.projection;
                var elevationProvider = this.m_viewState.elevationProvider;
                var elevationMap = elevationProvider === null || elevationProvider === void 0 ? void 0 : elevationProvider.getDisplacementMap(groupState.tileKey);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = groupState.textElementStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var textElementState = _step.value;
                        if (pass === 0 /* PersistentLabels */ ) {
                            if (placementStats) {
                                ++placementStats.total;
                            }
                        } else if (maxNumPlacedLabels !== void 0 && renderParams.numRenderedTextElements >= maxNumPlacedLabels) {
                            logger19.debug("Placement label limit exceeded.");
                            return false;
                        }
                        if (!textElementState.initialized) {
                            if (placementStats) {
                                ++placementStats.uninitialized;
                            }
                            continue;
                        }
                        if (textElementState.viewDistance === void 0 || textElementState.viewDistance < 0) {
                            if (placementStats) {
                                ++placementStats.tooFar;
                            }
                            continue;
                        }
                        var elementVisible = textElementState.visible;
                        if (pass === 0 /* PersistentLabels */  && !elementVisible || pass === 1 /* NewLabels */  && elementVisible) {
                            continue;
                        }
                        var textElement = textElementState.element;
                        var textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
                        var textCanvas = textElementStyle.textCanvas;
                        if (hiddenKinds !== void 0 && textElement.kind !== void 0 && hiddenKinds.hasOrIntersects(textElement.kind)) {
                            continue;
                        }
                        if (elevationProvider !== void 0 && !textElement.elevated) {
                            if (!elevationMap) {
                                this.m_isUpdatePending = true;
                                this.m_forceNewLabelsPass = true;
                                continue;
                            }
                            overlayTextElement(textElement, elevationProvider, elevationMap, projection);
                        }
                        var elementType = textElement.type;
                        var isPathLabel = elementType === 1 /* PathLabel */ ;
                        if (isPathLabel) {
                            if (isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {
                                if (placementStats) {
                                    placementStats.numNotVisible++;
                                }
                                if (textElement.dbgPathTooSmall === true) {
                                    if (placementStats) {
                                        placementStats.numPathTooSmall++;
                                    }
                                }
                                textElementState.reset();
                                continue;
                            }
                        }
                        var forceNewPassOnLoaded = true;
                        if (textCanvas) {
                            if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {
                                continue;
                            }
                            var _renderOrder;
                            var layer = textCanvas.getLayer((_renderOrder = textElement.renderOrder) !== null && _renderOrder !== void 0 ? _renderOrder : DEFAULT_TEXT_CANVAS_LAYER);
                            if (layer !== void 0) {
                                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                                    if (placementStats) {
                                        ++placementStats.numCannotAdd;
                                    }
                                    logger19.warn("layer glyph storage capacity exceeded.");
                                    continue;
                                }
                            }
                            textCanvas.textRenderStyle = textElement.renderStyle;
                            textCanvas.textLayoutStyle = textElement.layoutStyle;
                        }
                        switch(elementType){
                            case 0 /* PoiLabel */ :
                                this.addPoiLabel(textElementState, textCanvas, renderParams);
                                break;
                            case 2 /* LineMarker */ :
                                this.addLineMarkerLabel(textElementState, shieldGroups, textCanvas, renderParams);
                                break;
                            case 1 /* PathLabel */ :
                                if (textCanvas) {
                                    this.addPathLabel(textElementState, tempScreenPoints, textCanvas, renderParams);
                                }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return true;
            }
        },
        {
            key: "initializeGlyphs",
            value: function initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded) {
                var _this = this;
                if (textElement.loadingState === 2 /* Initialized */ ) {
                    return textElement.glyphs !== void 0;
                }
                assert(textElementStyle.textCanvas !== void 0);
                var textCanvas = textElementStyle.textCanvas;
                if (textElement.loadingState === void 0) {
                    textElement.loadingState = 0 /* Requested */ ;
                    if (textElement.renderStyle === void 0) {
                        textElement.renderStyle = new TextRenderStyle(_objectSpread({}, textElementStyle.renderParams, textElement.renderParams));
                    }
                    if (textElement.layoutStyle === void 0) {
                        textElement.layoutStyle = new TextLayoutStyle(_objectSpread({}, textElementStyle.layoutParams, textElement.layoutParams));
                    }
                    if (textElement.text === "") {
                        textElement.loadingState = 1 /* Loaded */ ;
                    } else {
                        var newLoadPromise = textCanvas.fontCatalog.loadCharset(textElement.text, textElement.renderStyle).then(function() {
                            --_this.m_loadPromisesCount;
                            textElement.loadingState = 1 /* Loaded */ ;
                            _this.m_isUpdatePending = true;
                            _this.m_forceNewLabelsPass = _this.m_forceNewLabelsPass || forceNewPassOnLoaded;
                        });
                        if (this.m_loadPromisesCount === 0) {
                            this.m_loadPromise = void 0;
                        }
                        ++this.m_loadPromisesCount;
                        this.m_loadPromise = this.m_loadPromise === void 0 ? newLoadPromise : Promise.all([
                            this.m_loadPromise,
                            newLoadPromise
                        ]);
                    }
                }
                if (textElement.loadingState === 1 /* Loaded */ ) {
                    textCanvas.textRenderStyle = textElement.renderStyle;
                    textCanvas.textLayoutStyle = textElement.layoutStyle;
                    textElement.glyphCaseArray = [];
                    textElement.bounds = void 0;
                    textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
                    textElement.loadingState = 2 /* Initialized */ ;
                }
                return textElement.glyphs !== void 0;
            }
        },
        {
            key: "initializeCamera",
            value: function initializeCamera() {
                this.m_camera.position.z = 1;
                this.m_camera.near = 0;
            }
        },
        {
            key: "updateCamera",
            value: function updateCamera() {
                var ref = this.m_renderer.getSize(cache2.vector2[0]), width = ref.width, height = ref.height;
                this.m_camera.left = width / -2;
                this.m_camera.right = width / 2;
                this.m_camera.bottom = height / -2;
                this.m_camera.top = height / 2;
                this.m_camera.updateProjectionMatrix();
                this.m_camera.updateMatrixWorld(false);
                this.m_screenCollisions.update(width, height);
            }
        },
        {
            key: "initializeDefaultFontCatalog",
            value: function initializeDefaultFontCatalog() {
                if (this.m_options.fontCatalog) {
                    this.m_defaultFontCatalogConfig = createDefaultFontCatalogConfig(this.m_options.fontCatalog);
                    this.addDefaultTextCanvas();
                }
            }
        },
        {
            key: "addTextCanvas",
            value: function addTextCanvas(fontCatalogConfig) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var catalogCallback, errorCallback, newLoadPromise;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                catalogCallback = function(name2, catalog) {
                                    if (_this.m_textCanvases.has(name2)) {
                                        var loadedTextCanvas = _this.m_textCanvasFactory.createTextCanvas(catalog, name2);
                                        catalog.showReplacementGlyphs = _this.showReplacementGlyphs;
                                        _this.m_textCanvases.set(name2, loadedTextCanvas);
                                    }
                                };
                                errorCallback = function() {
                                    _this.m_textCanvases.delete(fontCatalogConfig.name);
                                };
                                if (!_this.m_textCanvases.has(fontCatalogConfig.name)) {
                                    _ctx.next = 6;
                                    break;
                                }
                                return _ctx.abrupt("return", Promise.resolve());
                            case 6:
                                _this.m_textCanvases.set(fontCatalogConfig.name, void 0);
                                newLoadPromise = loadFontCatalog(fontCatalogConfig, catalogCallback, errorCallback).then(function() {
                                    --_this.m_loadPromisesCount;
                                }).catch(function(error) {
                                    logger19.info("rendering without font catalog, only icons possible", error);
                                    --_this.m_loadPromisesCount;
                                });
                                if (_this.m_loadPromisesCount === 0) {
                                    _this.m_loadPromise = void 0;
                                }
                                ++_this.m_loadPromisesCount;
                                _this.m_loadPromise = _this.m_loadPromise === void 0 ? newLoadPromise : Promise.all([
                                    _this.m_loadPromise,
                                    newLoadPromise
                                ]);
                                return _ctx.abrupt("return", newLoadPromise);
                            case 12:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "updateGlyphDebugMesh",
            value: function updateGlyphDebugMesh() {
                var debugGlyphs = debugContext.getValue("DEBUG_GLYPHS");
                if (debugGlyphs === void 0) {
                    return;
                }
                if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === void 0) {
                    this.initializeGlyphDebugMesh();
                }
                assert(this.m_debugGlyphTextureCacheMesh !== void 0);
                assert(this.m_debugGlyphTextureCacheWireMesh !== void 0);
                this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;
                this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;
            }
        },
        {
            key: "initializeGlyphDebugMesh",
            value: function initializeGlyphDebugMesh() {
                if (this.m_textCanvases.size === 0) {
                    return;
                }
                var defaultTextCanvas = this.m_textCanvases.values().next().value;
                var defaultFontCatalog = defaultTextCanvas.fontCatalog;
                var planeGeometry = new THREE84.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);
                var material = new THREE84.MeshBasicMaterial({
                    transparent: true,
                    depthWrite: false,
                    depthTest: false,
                    map: defaultFontCatalog.texture
                });
                this.m_debugGlyphTextureCacheMesh = new THREE84.Mesh(planeGeometry, material);
                this.m_debugGlyphTextureCacheMesh.renderOrder = 1e4;
                this.m_debugGlyphTextureCacheMesh.visible = false;
                this.m_debugGlyphTextureCacheMesh.name = "glyphDebug";
                var wireframe = new THREE84.WireframeGeometry(planeGeometry);
                var wireframeMaterial = new THREE84.LineBasicMaterial({
                    transparent: true,
                    color: 10066329,
                    depthWrite: false,
                    depthTest: false
                });
                this.m_debugGlyphTextureCacheWireMesh = new THREE84.LineSegments(wireframe, wireframeMaterial);
                this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;
                this.m_debugGlyphTextureCacheWireMesh.visible = false;
                this.m_debugGlyphTextureCacheWireMesh.name = "glyphDebug";
                defaultTextCanvas.getLayer(DEFAULT_TEXT_CANVAS_LAYER).storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);
            }
        },
        {
            key: "updateTextElements",
            value: function updateTextElements(dataSourceTileList) {
                var _this = this;
                if (updateStats) {
                    updateStats.clear();
                }
                this.m_textElementStateCache.clearTextCache();
                this.m_cacheInvalidated = false;
                this.checkIfOverloaded(dataSourceTileList);
                var updateStartTime = this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : void 0;
                dataSourceTileList.forEach(function(tileList) {
                    _this.updateTextElementsFromSource(tileList.dataSource, tileList.storageLevel, Array.from(tileList.renderedTiles.values()), updateStartTime);
                });
                if (updateStats) {
                    updateStats.log();
                }
            }
        },
        {
            key: "updateTextElementsFromSource",
            value: function updateTextElementsFromSource(tileDataSource, storageLevel, visibleTiles, updateStartTime) {
                if (updateStats) {
                    updateStats.tiles += visibleTiles.length;
                }
                var sortedTiles = visibleTiles;
                sortedTiles.sort(function(a, b) {
                    return a.tileKey.mortonCode() - b.tileKey.mortonCode();
                });
                var sortedGroups = [];
                this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);
                var numTextElementsUpdated = 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = sortedGroups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var textElementLists = _step.value;
                        this.selectTextElementsToUpdateByDistance(textElementLists);
                        if (updateStartTime !== void 0) {
                            if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {
                                var endTime = PerformanceTimer.now();
                                var elapsedTime = endTime - updateStartTime;
                                if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {
                                    logger19.debug("Update time limit exceeded.");
                                    break;
                                }
                            }
                            numTextElementsUpdated += textElementLists.count();
                            if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {
                                logger19.debug("Update label limit exceeded.");
                                break;
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "prepareTextElementGroup",
            value: function prepareTextElementGroup(textElementGroup, tileKey, maxViewDistance) {
                var _this = this;
                if (textElementGroup.elements.length === 0) {
                    return;
                }
                var textElementSelection = function(textElementState) {
                    var ref = checkReadyForPlacement(textElementState.element, textElementState.element.type === 2 /* LineMarker */  ? textElementState.lineMarkerIndex : void 0, _this.m_viewState, _this.m_poiManager, maxViewDistance), result = ref.result, viewDistance = ref.viewDistance;
                    if (result === 0 /* Ok */  && !_this.m_textElementStateCache.deduplicateElement(_this.m_viewState.zoomLevel, textElementState)) {
                        result = 4 /* Duplicate */ ;
                        viewDistance = void 0;
                    }
                    if (updateStats) {
                        updateStats.totalLabels++;
                        updateStats.results[result]++;
                    }
                    return viewDistance;
                };
                var ref = _slicedToArray(this.m_textElementStateCache.getOrSet(textElementGroup, tileKey, textElementSelection), 2), found = ref[1];
                if (updateStats) {
                    ++updateStats.totalGroups;
                    if (!found) {
                        ++updateStats.newGroups;
                    }
                }
            }
        },
        {
            key: "createSortedGroupsForSorting",
            value: function createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {
                if (sortedTiles.length === 0) {
                    return;
                }
                var tilesToRender = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = sortedTiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var tile = _step.value;
                        if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {
                            tilesToRender.push(tile);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var groupedPriorityLists = /* @__PURE__ */ new Map();
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = tilesToRender[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var tile1 = _step1.value;
                        var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                        try {
                            for(var _iterator2 = tile1.textElementGroups.groups.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                                var group = _step2.value;
                                if (group.elements.length === 0) {
                                    continue;
                                }
                                var foundGroup = groupedPriorityLists.get(group.priority);
                                if (foundGroup === void 0) {
                                    groupedPriorityLists.set(group.priority, new TextElementLists([
                                        new TileTextElements(tile1, group)
                                    ]));
                                } else {
                                    foundGroup.lists.push(new TileTextElements(tile1, group));
                                }
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                    _iterator2.return();
                                }
                            } finally{
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                if (groupedPriorityLists.size === 0) {
                    return;
                }
                var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
                try {
                    for(var _iterator3 = groupedPriorityLists[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                        var g = _step3.value;
                        var lists = g[1];
                        sortedGroups.push(lists);
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                            _iterator3.return();
                        }
                    } finally{
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
                sortedGroups.sort(function(a, b) {
                    return b.priority - a.priority;
                });
                var printTextInfo = false;
                if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {
                    var outString = "";
                    var _iteratorNormalCompletion4 = true, _didIteratorError4 = false, _iteratorError4 = undefined;
                    try {
                        for(var _iterator4 = sortedGroups[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true){
                            var textElementLists = _step4.value;
                            var size = 0;
                            var _iteratorNormalCompletion5 = true, _didIteratorError5 = false, _iteratorError5 = undefined;
                            try {
                                for(var _iterator5 = textElementLists.lists[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true){
                                    var tileTextElements = _step5.value;
                                    size += tileTextElements.group.elements.length;
                                }
                            } catch (err) {
                                _didIteratorError5 = true;
                                _iteratorError5 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                                        _iterator5.return();
                                    }
                                } finally{
                                    if (_didIteratorError5) {
                                        throw _iteratorError5;
                                    }
                                }
                            }
                            outString += "priority ".concat(textElementLists.priority, " size: ").concat(size, "\n");
                        }
                    } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                                _iterator4.return();
                            }
                        } finally{
                            if (_didIteratorError4) {
                                throw _iteratorError4;
                            }
                        }
                    }
                    logger19.log(outString);
                }
            }
        },
        {
            key: "selectTextElementsToUpdateByDistance",
            value: function selectTextElementsToUpdateByDistance(textElementLists) {
                var farDistanceLimitRatio = Math.max(this.m_options.maxDistanceRatioForTextLabels, this.m_options.maxDistanceRatioForPoiLabels);
                var maxViewDistance = getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = textElementLists.lists[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var tileTextElements = _step.value;
                        this.prepareTextElementGroup(tileTextElements.group, tileTextElements.tile.tileKey, maxViewDistance);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "placeTextElements",
            value: function placeTextElements(time, placeNewTextElements) {
                var renderParams = {
                    numRenderedTextElements: 0,
                    fadeAnimationRunning: false,
                    time: time
                };
                var placeStartTime = this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : void 0;
                if (placementStats) {
                    placementStats.clear();
                }
                if (this.m_textElementStateCache.size === 0) {
                    logger19.debug("Text element cache empty.");
                    return;
                }
                var placeNew = this.m_forceNewLabelsPass || placeNewTextElements;
                if (this.m_forceNewLabelsPass) {
                    this.m_forceNewLabelsPass = false;
                }
                var maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels;
                var groupStates = this.m_textElementStateCache.sortedGroupStates;
                var currentPriority = groupStates[0].priority;
                var currentPriorityBegin = 0;
                for(var i = 0; i < groupStates.length; ++i){
                    var textElementGroupState = groupStates[i];
                    if (placementStats) {
                        ++placementStats.totalGroups;
                    }
                    var newPriority = textElementGroupState.priority;
                    if (placeNew && currentPriority !== newPriority) {
                        this.placeNewTextElements(currentPriorityBegin, i, renderParams);
                        if (isPlacementTimeExceeded(placeStartTime)) {
                            break;
                        }
                        currentPriority = newPriority;
                        currentPriorityBegin = i;
                    }
                    if (!this.placeTextElementGroup(textElementGroupState, renderParams, maxNumPlacedTextElements, 0 /* PersistentLabels */ )) {
                        break;
                    }
                    if (isPlacementTimeExceeded(placeStartTime)) {
                        break;
                    }
                }
                if (placeNew) {
                    this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);
                }
                if (placementStats) {
                    placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;
                    placementStats.log();
                }
                if (renderParams.fadeAnimationRunning) {
                    this.m_isUpdatePending = true;
                }
            }
        },
        {
            key: "placeNewTextElements",
            value: function placeNewTextElements(beginGroupIndex, endGroupIndex, renderParams) {
                var groupStates = this.m_textElementStateCache.sortedGroupStates;
                for(var i = beginGroupIndex; i < endGroupIndex; ++i){
                    if (!this.placeTextElementGroup(groupStates[i], renderParams, this.m_options.maxNumVisibleLabels, 1 /* NewLabels */ )) {
                        break;
                    }
                }
            }
        },
        {
            key: "placeOverlayTextElements",
            value: function placeOverlayTextElements() {
                if (this.m_overlayTextElements === void 0 || this.m_overlayTextElements.length === 0) {
                    return;
                }
                var screenSize = this.m_tmpVector.set(this.m_screenProjector.width, this.m_screenProjector.height);
                var screenXOrigin = -screenSize.width / 2;
                var screenYOrigin = screenSize.height / 2;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_overlayTextElements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var textElement = _step.value;
                        var textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
                        var textCanvas = textElementStyle.textCanvas;
                        if (textCanvas === void 0) {
                            continue;
                        }
                        var forceNewPassOnLoaded = false;
                        this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);
                        if (textElement.loadingState !== 2 /* Initialized */ ) {
                            continue;
                        }
                        var _renderOrder;
                        var layer = textCanvas.getLayer((_renderOrder = textElement.renderOrder) !== null && _renderOrder !== void 0 ? _renderOrder : DEFAULT_TEXT_CANVAS_LAYER);
                        if (layer !== void 0) {
                            if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                                continue;
                            }
                        }
                        textCanvas.textRenderStyle = textElement.renderStyle;
                        textCanvas.textLayoutStyle = textElement.layoutStyle;
                        var textPath = void 0;
                        if (!(textElement.type === 1 /* PathLabel */ )) {
                            tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;
                            tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;
                            if (textElement.xOffset !== void 0) {
                                tempScreenPosition.x += textElement.xOffset;
                            }
                            if (textElement.yOffset !== void 0) {
                                tempScreenPosition.y -= textElement.yOffset;
                            }
                            tempPosition.x = tempScreenPosition.x;
                            tempPosition.y = tempScreenPosition.y;
                            tempPosition.z = 0;
                            addTextToCanvas(textElement, textCanvas, tempPosition);
                        } else {
                            tempScreenPosition.x = screenXOrigin;
                            tempScreenPosition.y = screenYOrigin;
                            if (textElement.xOffset !== void 0) {
                                tempScreenPosition.x += textElement.xOffset;
                            }
                            if (textElement.yOffset !== void 0) {
                                tempScreenPosition.y -= textElement.yOffset;
                            }
                            var screenPoints = [];
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = textElement.path[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var pt = _step1.value;
                                    var pX = tempScreenPosition.x + pt.x * screenSize.width;
                                    var pY = tempScreenPosition.y - pt.y * screenSize.height;
                                    screenPoints.push(new THREE84.Vector2(pX, pY));
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                            textPath = new SimplePath();
                            for(var i = 0; i < screenPoints.length - 1; ++i){
                                textPath.add(new THREE84.LineCurve(screenPoints[i], screenPoints[i + 1]));
                            }
                            addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "getDistanceScalingFactor",
            value: function getDistanceScalingFactor(label, distance, lookAtDistance) {
                var factor = lookAtDistance / distance;
                factor = 1 + (factor - 1) * label.distanceScale;
                factor = Math.max(factor, this.m_options.labelDistanceScaleMin);
                factor = Math.min(factor, this.m_options.labelDistanceScaleMax);
                return factor;
            }
        },
        {
            key: "getDistanceFadingFactor",
            value: function getDistanceFadingFactor(label, state, maxVisibilityDist) {
                var distanceFadeValue = 1;
                var textDistance = state.viewDistance;
                if (textDistance !== void 0 && label.fadeFar !== void 0 && label.fadeFar > 0) {
                    var fadeNear = label.fadeNear === void 0 ? 0 : label.fadeNear;
                    var fadeFar = label.fadeFar;
                    if (fadeFar > fadeNear) {
                        distanceFadeValue = 1 - THREE84.MathUtils.clamp((textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear), 0, 1);
                    }
                }
                return distanceFadeValue;
            }
        },
        {
            key: "addPointLabel",
            value: function addPointLabel(labelState, position, screenPosition, textCanvas, renderParams) {
                var pointLabel = labelState.element;
                var textRenderState = labelState.textRenderState;
                var isLineMarker = pointLabel.type === 2 /* LineMarker */ ;
                var iconRenderState = labelState.iconRenderState;
                assert(iconRenderState !== void 0);
                tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;
                tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;
                var textDistance = pointToPlaneDistance(position, this.m_viewState.worldCenter, this.m_cameraLookAt);
                if (pointLabel.fadeFar !== void 0 && (pointLabel.fadeFar <= 0 || pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)) {
                    if (placementStats) {
                        ++placementStats.tooFar;
                    }
                    return false;
                }
                labelState.setViewDistance(textDistance);
                var poiInfo = pointLabel.poiInfo;
                var iconRejected = false;
                var renderIcon = poiInfo !== void 0 && MathUtils.isClamped(this.m_viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel) && poiInfo.isValid !== false;
                var distanceScaleFactor = this.getDistanceScalingFactor(pointLabel, textDistance, this.m_viewState.lookAtDistance);
                var iconReady = renderIcon && this.m_poiRenderer.prepareRender(pointLabel, this.m_viewState.env);
                var iconInvisible = false;
                if (iconReady) {
                    var result = placeIcon(iconRenderState, poiInfo, tempPoiScreenPosition, distanceScaleFactor, this.m_viewState.env, this.m_screenCollisions);
                    iconInvisible = result === 2 /* Invisible */ ;
                    iconRejected = result === 1 /* Rejected */ ;
                    if (iconInvisible) {
                        iconRenderState.reset();
                    }
                } else if (renderIcon && (poiInfo === null || poiInfo === void 0 ? void 0 : poiInfo.imageItem) !== null) {
                    this.m_forceNewLabelsPass = true;
                    this.m_isUpdatePending = true;
                }
                var distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, labelState, this.m_viewState.maxVisibilityDist);
                if (textCanvas && shouldRenderPointText(labelState, this.m_viewState, this.m_options)) {
                    var newLabel = !labelState.visible;
                    var placeResult = iconRejected && newLabel ? 1 /* Rejected */  : placePointLabel(labelState, tempScreenPosition, distanceScaleFactor, textCanvas, this.m_viewState.env, this.m_screenCollisions, tempPosition, !isLineMarker);
                    var textInvisible = placeResult === 2 /* Invisible */ ;
                    if (textInvisible) {
                        if (placementStats) {
                            placementStats.numPoiTextsInvisible++;
                        }
                        if (!renderIcon || iconInvisible) {
                            labelState.reset();
                            return false;
                        }
                        textRenderState.reset();
                    }
                    var iconIsOptional = (poiInfo === null || poiInfo === void 0 ? void 0 : poiInfo.iconIsOptional) === true;
                    var requiredIconRejected = iconRejected && iconReady && !iconIsOptional;
                    var textRejected = requiredIconRejected || placeResult === 1 /* Rejected */ ;
                    if (!iconRejected && !iconInvisible) {
                        var ref;
                        var textIsOptional = ((ref = pointLabel.poiInfo) === null || ref === void 0 ? void 0 : ref.textIsOptional) === true;
                        iconRejected = textRejected && !textIsOptional;
                    }
                    if (textRejected) {
                        textRenderState.startFadeOut(renderParams.time);
                    }
                    var textNeedsDraw = !textInvisible && (!textRejected && shouldRenderPoiText(labelState, this.m_viewState) || textRenderState.isFading());
                    if (textNeedsDraw) {
                        if (!textRejected) {
                            textRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
                        }
                        renderParams.fadeAnimationRunning = renderParams.fadeAnimationRunning || textRenderState.isFading();
                        if (addTextBufferToCanvas(labelState, textCanvas, tempPosition, distanceFadeFactor, distanceScaleFactor) && placementStats) {
                            placementStats.numRenderedPoiTexts++;
                        }
                    }
                }
                if (iconReady && !iconInvisible) {
                    if (iconRejected) {
                        iconRenderState.startFadeOut(renderParams.time);
                    } else {
                        iconRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
                    }
                    renderParams.fadeAnimationRunning = renderParams.fadeAnimationRunning || iconRenderState.isFading();
                    var opacity = iconRenderState.opacity * distanceFadeFactor;
                    if (opacity > 0) {
                        var allocateSpace = poiInfo.reserveSpace !== false && !iconRejected;
                        this.m_poiRenderer.addPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, labelState.renderDistance, distanceScaleFactor, allocateSpace, opacity, this.m_viewState.env);
                        if (placementStats) {
                            placementStats.numRenderedPoiIcons++;
                        }
                    }
                }
                renderParams.numRenderedTextElements++;
                return true;
            }
        },
        {
            key: "addPoiLabel",
            value: function addPoiLabel(labelState, textCanvas, renderParams) {
                var worldPosition = getWorldPosition(labelState.element, this.m_viewState.projection, this.m_viewState.env, this.m_tmpVector3);
                if (!this.labelPotentiallyVisible(worldPosition, tempScreenPosition)) {
                    return false;
                }
                return this.addPointLabel(labelState, worldPosition, tempScreenPosition, textCanvas, renderParams);
            }
        },
        {
            key: "addLineMarkerLabel",
            value: function addLineMarkerLabel(labelState, shieldGroups, textCanvas, renderParams) {
                var ref;
                var lineMarkerLabel = labelState.element;
                var poiInfo = lineMarkerLabel.poiInfo;
                if (!((ref = this.m_poiRenderer) === null || ref === void 0 ? void 0 : ref.prepareRender(lineMarkerLabel, this.m_viewState.env))) {
                    return;
                }
                var shieldGroup;
                if (poiInfo.shieldGroupIndex !== void 0) {
                    shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];
                    if (shieldGroup === void 0) {
                        shieldGroup = [];
                        shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;
                    }
                }
                var lineTechnique = poiInfo.technique;
                var minDistanceSqr = lineTechnique.minDistance !== void 0 ? lineTechnique.minDistance * lineTechnique.minDistance : 0;
                if (minDistanceSqr > 0 && shieldGroup !== void 0) {
                    var numShieldsVisible = 0;
                    var point = labelState.position;
                    if (this.labelPotentiallyVisible(point, tempScreenPosition)) {
                        var tooClose = false;
                        for(var j = 0; j < shieldGroup.length; j += 2){
                            var distanceSqr = Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);
                            tooClose = distanceSqr < minDistanceSqr;
                            if (tooClose) {
                                break;
                            }
                        }
                        if (!tooClose) {
                            if (this.addPointLabel(labelState, point, tempScreenPosition, textCanvas, renderParams)) {
                                shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);
                                numShieldsVisible++;
                            }
                        }
                    }
                    if (numShieldsVisible === 0) {
                        labelState.reset();
                    }
                } else {
                    var point1 = labelState.position;
                    if (this.labelPotentiallyVisible(point1, tempScreenPosition)) {
                        this.addPointLabel(labelState, point1, tempScreenPosition, textCanvas, renderParams);
                    }
                }
            }
        },
        {
            key: "addPathLabel",
            value: function addPathLabel(labelState, screenPoints, textCanvas, renderParams) {
                var textMaxDistance = getMaxViewDistance(this.m_viewState, this.m_options.maxDistanceRatioForTextLabels);
                var pathLabel = labelState.element;
                if (!(pathLabel.ignoreDistance === true || labelState.viewDistance === void 0 || labelState.viewDistance < textMaxDistance)) {
                    if (placementStats) {
                        ++placementStats.tooFar;
                    }
                    labelState.textRenderState.reset();
                    return false;
                }
                if (pathLabel.fadeFar !== void 0 && (pathLabel.fadeFar <= 0 || pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)) {
                    if (placementStats) {
                        ++placementStats.tooFar;
                    }
                    labelState.textRenderState.reset();
                    return false;
                }
                var textPath = new THREE84.Path();
                tempScreenPosition.copy(screenPoints[0]);
                for(var i = 0; i < screenPoints.length - 1; ++i){
                    textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));
                }
                if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {
                    tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);
                    textPath = new THREE84.Path();
                    for(var i1 = screenPoints.length - 1; i1 > 0; --i1){
                        textPath.add(new SimpleLineCurve(screenPoints[i1], screenPoints[i1 - 1]));
                    }
                }
                labelState.setViewDistance(computeViewDistance(pathLabel, void 0, this.m_viewState.worldCenter, this.m_cameraLookAt));
                var textRenderDistance = -labelState.renderDistance;
                var distanceScaleFactor = this.getDistanceScalingFactor(pathLabel, textRenderDistance, this.m_viewState.lookAtDistance);
                var prevSize = textCanvas.textRenderStyle.fontSize.size;
                textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;
                if (placePathLabel(labelState, textPath, tempScreenPosition, textCanvas, this.m_screenCollisions) !== 0 /* Ok */ ) {
                    textCanvas.textRenderStyle.fontSize.size = prevSize;
                    if (placementStats) {
                        ++placementStats.numNotVisible;
                    }
                    labelState.textRenderState.reset();
                    return false;
                }
                labelState.textRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
                var opacity = pathLabel.renderStyle.opacity;
                if (labelState.textRenderState.isFading()) {
                    opacity *= labelState.textRenderState.opacity;
                    renderParams.fadeAnimationRunning = true;
                }
                if (labelState.textRenderState.opacity === 0) {
                    textCanvas.textRenderStyle.fontSize.size = prevSize;
                    return false;
                }
                var prevOpacity = textCanvas.textRenderStyle.opacity;
                var prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;
                var distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, labelState, this.m_viewState.maxVisibilityDist);
                textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;
                textCanvas.textRenderStyle.backgroundOpacity = textCanvas.textRenderStyle.opacity * pathLabel.renderStyle.backgroundOpacity;
                tempPosition.z = labelState.renderDistance;
                addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);
                renderParams.numRenderedTextElements++;
                textCanvas.textRenderStyle.fontSize.size = prevSize;
                textCanvas.textRenderStyle.opacity = prevOpacity;
                textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;
                return true;
            }
        },
        {
            key: "checkIfOverloaded",
            value: function checkIfOverloaded(dataSourceTileList) {
                var numTextElementsInScene = 0;
                dataSourceTileList.forEach(function(renderListEntry) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = renderListEntry.renderedTiles.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var tile = _step.value;
                            numTextElementsInScene += tile.textElementGroups.count();
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                });
                var newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;
                if (newOverloaded && !this.m_overloaded) {
                    logger19.debug("Overloaded Mode enabled.");
                }
                this.m_overloaded = newOverloaded;
                return this.m_overloaded;
            }
        },
        {
            key: "labelPotentiallyVisible",
            value: function labelPotentiallyVisible(point, outPoint) {
                var _maxPoiDistanceToBorder;
                var maxDistance = THREE84.MathUtils.clamp((_maxPoiDistanceToBorder = this.m_options.maxPoiDistanceToBorder) !== null && _maxPoiDistanceToBorder !== void 0 ? _maxPoiDistanceToBorder : 0, 0, 1);
                var projectionResult = this.m_screenProjector.projectAreaToScreen(point, maxDistance, maxDistance, outPoint);
                return projectionResult !== void 0;
            }
        }
    ]);
    return TextElementsRenderer;
}();
// src/mapview/text/TextElementBuilder.ts
var logger20 = LoggerManager.instance.create("TextElementBuilder");
var _TextElementBuilder = /*#__PURE__*/ function() {
    function _TextElementBuilder(m_env, m_styleCache, m_baseRenderOrder) {
        _classCallCheck(this, _TextElementBuilder);
        this.m_env = m_env;
        this.m_styleCache = m_styleCache;
        this.m_baseRenderOrder = m_baseRenderOrder;
        __publicField(this, "m_priority");
        __publicField(this, "m_fadeNear");
        __publicField(this, "m_fadeFar");
        __publicField(this, "m_minZoomLevel");
        __publicField(this, "m_maxZoomLevel");
        __publicField(this, "m_distanceScale", DEFAULT_TEXT_DISTANCE_SCALE);
        __publicField(this, "m_mayOverlap");
        __publicField(this, "m_reserveSpace");
        __publicField(this, "m_renderStyle");
        __publicField(this, "m_layoutStype");
        __publicField(this, "m_technique");
        __publicField(this, "m_renderOrder");
        __publicField(this, "m_xOffset");
        __publicField(this, "m_yOffset");
        __publicField(this, "m_poiBuilder");
        __publicField(this, "m_alwaysOnTop");
        __publicField(this, "renderOrderUpBound");
        this.m_renderOrder = m_baseRenderOrder;
        if (Number.isInteger(m_baseRenderOrder)) {
            this.renderOrderUpBound = _TextElementBuilder.RENDER_ORDER_UP_BOUND;
        } else {
            var absBaseRenderOrder = Math.abs(m_baseRenderOrder);
            this.renderOrderUpBound = (absBaseRenderOrder - Math.floor(absBaseRenderOrder)) * _TextElementBuilder.RENDER_ORDER_UP_BOUND;
        }
        if (!this.isValidRenderOrder(m_baseRenderOrder)) {
            logger20.warn("Large base render order (".concat(m_baseRenderOrder, ") might cause precision issues."));
        }
    }
    _createClass(_TextElementBuilder, [
        {
            key: "withTechnique",
            value: function withTechnique(technique) {
                this.m_technique = technique;
                var ref;
                this.m_priority = (ref = getPropertyValue(technique.priority, this.m_env)) !== null && ref !== void 0 ? ref : 0;
                var ref1;
                this.m_fadeNear = (ref1 = getPropertyValue(technique.fadeNear, this.m_env)) !== null && ref1 !== void 0 ? ref1 : void 0;
                var ref2;
                this.m_fadeFar = (ref2 = getPropertyValue(technique.fadeFar, this.m_env)) !== null && ref2 !== void 0 ? ref2 : void 0;
                var ref3;
                this.m_minZoomLevel = (ref3 = getPropertyValue(technique.minZoomLevel, this.m_env)) !== null && ref3 !== void 0 ? ref3 : void 0;
                var ref4;
                this.m_maxZoomLevel = (ref4 = getPropertyValue(technique.maxZoomLevel, this.m_env)) !== null && ref4 !== void 0 ? ref4 : void 0;
                var _distanceScale;
                this.m_distanceScale = (_distanceScale = technique.distanceScale) !== null && _distanceScale !== void 0 ? _distanceScale : DEFAULT_TEXT_DISTANCE_SCALE;
                this.m_renderStyle = this.m_styleCache.getRenderStyle(technique);
                this.m_layoutStype = this.m_styleCache.getLayoutStyle(technique);
                this.m_xOffset = getPropertyValue(technique.xOffset, this.m_env);
                this.m_yOffset = getPropertyValue(technique.yOffset, this.m_env);
                var ref5;
                var techniqueRenderOrder = (ref5 = getPropertyValue(technique.renderOrder, this.m_env)) !== null && ref5 !== void 0 ? ref5 : 0;
                if (!this.isValidRenderOrder(techniqueRenderOrder)) {
                    var msg = "Unsupported large render order (".concat(techniqueRenderOrder, ")");
                    logger20.error(msg);
                    assert(false, msg);
                }
                this.m_renderOrder = _TextElementBuilder.composeRenderOrder(this.m_baseRenderOrder, techniqueRenderOrder);
                if (isTextTechnique(technique)) {
                    this.withTextTechnique(technique);
                } else {
                    this.withPoiTechnique(technique);
                }
                return this;
            }
        },
        {
            key: "withIcon",
            value: function withIcon(imageTextureName, shieldGroupIndex) {
                assert(this.m_poiBuilder !== void 0);
                this.m_poiBuilder.withIcon(imageTextureName, shieldGroupIndex);
                return this;
            }
        },
        {
            key: "build",
            value: function build(text, points, tileOffset, dataSourceName, dataSourceOrder, attributes, pathLengthSqr, offsetDirection) {
                var ref;
                var featureId = getFeatureId(attributes);
                assert(this.m_technique !== void 0);
                assert(this.m_renderStyle !== void 0);
                assert(this.m_layoutStype !== void 0);
                var technique = this.m_technique;
                var renderStyle = this.m_renderStyle;
                var layoutStyle = this.m_layoutStype;
                var textElement = new TextElement(ContextualArabicConverter.instance.convert(text), points, renderStyle, layoutStyle, this.m_priority, this.m_xOffset, this.m_yOffset, featureId, technique.style, this.m_fadeNear, this.m_fadeFar, tileOffset, offsetDirection, dataSourceName, dataSourceOrder);
                textElement.minZoomLevel = this.m_minZoomLevel;
                textElement.maxZoomLevel = this.m_maxZoomLevel;
                textElement.distanceScale = this.m_distanceScale;
                textElement.mayOverlap = this.m_mayOverlap;
                textElement.reserveSpace = this.m_reserveSpace;
                textElement.kind = technique.kind;
                textElement.userData = attributes;
                textElement.textFadeTime = technique.textFadeTime !== void 0 ? technique.textFadeTime * 1e3 : void 0;
                textElement.pathLengthSqr = pathLengthSqr;
                textElement.alwaysOnTop = this.m_alwaysOnTop;
                textElement.renderOrder = this.m_renderOrder;
                textElement.poiInfo = (ref = this.m_poiBuilder) === null || ref === void 0 ? void 0 : ref.build(textElement);
                _TextElementBuilder.alignZoomLevelRanges(textElement);
                return textElement;
            }
        },
        {
            key: "withTextTechnique",
            value: function withTextTechnique(technique) {
                this.m_mayOverlap = technique.mayOverlap === true;
                this.m_reserveSpace = technique.reserveSpace !== false;
                this.m_poiBuilder = void 0;
            }
        },
        {
            key: "withPoiTechnique",
            value: function withPoiTechnique(technique) {
                this.m_mayOverlap = technique.textMayOverlap === true;
                this.m_reserveSpace = technique.textReserveSpace !== false;
                this.m_alwaysOnTop = technique.alwaysOnTop === true;
                if (!this.m_poiBuilder) {
                    this.m_poiBuilder = new PoiBuilder(this.m_env);
                }
                this.m_poiBuilder.withTechnique(technique);
            }
        },
        {
            key: "isValidRenderOrder",
            value: function isValidRenderOrder(renderOrder) {
                return Math.abs(renderOrder) < this.renderOrderUpBound;
            }
        }
    ], [
        {
            key: "alignZoomLevelRanges",
            value: function alignZoomLevelRanges(textElement) {
                if (!textElement.poiInfo) {
                    return;
                }
                var poiInfo = textElement.poiInfo;
                var _minZoomLevel;
                textElement.minZoomLevel = (_minZoomLevel = textElement.minZoomLevel) !== null && _minZoomLevel !== void 0 ? _minZoomLevel : MathUtils.min2(poiInfo.iconMinZoomLevel, poiInfo.textMinZoomLevel);
                var _maxZoomLevel;
                textElement.maxZoomLevel = (_maxZoomLevel = textElement.maxZoomLevel) !== null && _maxZoomLevel !== void 0 ? _maxZoomLevel : MathUtils.max2(poiInfo.iconMaxZoomLevel, poiInfo.textMaxZoomLevel);
            }
        },
        {
            key: "composeRenderOrder",
            value: function composeRenderOrder(baseRenderOrder, offset) {
                return baseRenderOrder * _TextElementBuilder.RENDER_ORDER_UP_BOUND + offset;
            }
        }
    ]);
    return _TextElementBuilder;
}();
var TextElementBuilder = _TextElementBuilder;
__publicField(TextElementBuilder, "RENDER_ORDER_UP_BOUND", 1e7);
// src/mapview/poi/PoiManager.ts
var logger21 = LoggerManager.instance.create("PoiManager");
function getImageTexture2(poiGeometry) {
    var index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (poiGeometry.imageTextures) {
        var textureNameIndex = poiGeometry.imageTextures[index];
        if (textureNameIndex >= 0) {
            assert(poiGeometry.imageTextures.length > index);
            return poiGeometry.stringCatalog[textureNameIndex];
        }
    }
    return void 0;
}
function getAttributes(poiGeometry) {
    var index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return poiGeometry.objInfos ? poiGeometry.objInfos[index] : void 0;
}
function getPosition(positionAttribute, worldOffsetX) {
    var index = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var position = new THREE85.Vector3().fromBufferAttribute(positionAttribute, index);
    position.x += worldOffsetX;
    return position;
}
function getText(poiGeometry) {
    var index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    assert(poiGeometry.texts.length > index);
    var stringIndex = poiGeometry.texts[index];
    assert(poiGeometry.stringCatalog.length > stringIndex);
    var _stringIndex;
    return (_stringIndex = poiGeometry.stringCatalog[stringIndex]) !== null && _stringIndex !== void 0 ? _stringIndex : "";
}
var _PoiManager = /*#__PURE__*/ function() {
    function _PoiManager(mapView) {
        _classCallCheck(this, _PoiManager);
        this.mapView = mapView;
        __publicField(this, "m_imageTextures", /* @__PURE__ */ new Map());
        __publicField(this, "m_poiShieldGroups", /* @__PURE__ */ new Map());
    }
    _createClass(_PoiManager, [
        {
            key: "addPois",
            value: function addPois(tile, decodedTile) {
                var poiGeometries = assertExists(decodedTile.poiGeometries);
                var worldOffsetX = tile.computeWorldOffsetX();
                var mapView = tile.mapView;
                var discreteZoomLevel = Math.floor(mapView.zoomLevel);
                var intZoomEnv = new MapEnv({
                    $zoom: discreteZoomLevel
                }, mapView.env);
                var poiBuilder = new TextElementBuilder(intZoomEnv, tile.textStyleCache, tile.dataSource.dataSourceOrder);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = poiGeometries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var poiGeometry = _step.value;
                        assert(poiGeometry.technique !== void 0);
                        var techniqueIndex = assertExists(poiGeometry.technique);
                        var technique = decodedTile.techniques[techniqueIndex];
                        if (technique._kindState === false || !isLineMarkerTechnique(technique) && !isPoiTechnique(technique)) {
                            continue;
                        }
                        if (technique.showOnMap === false) {
                            continue;
                        }
                        var positions = new THREE85.BufferAttribute(new Float64Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);
                        poiBuilder.withTechnique(technique);
                        if (isLineMarkerTechnique(technique) && positions.count > 0) {
                            this.addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX);
                        } else if (isPoiTechnique(technique)) {
                            this.addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "addTextureAtlas",
            value: function addTextureAtlas(imageName, atlas, abortSignal) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var response, jsonAtlas, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, textureName, imageTextureDef, imageTexture;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return fetch(atlas, {
                                    signal: abortSignal
                                });
                            case 2:
                                response = _ctx.sent;
                                if (response.ok) {
                                    _ctx.next = 5;
                                    break;
                                }
                                throw new Error("addTextureAtlas: Cannot load textureAtlas: ".concat(response.statusText));
                            case 5:
                                _ctx.prev = 5;
                                _ctx.next = 8;
                                return response.json();
                            case 8:
                                jsonAtlas = _ctx.sent;
                                if (!(jsonAtlas === void 0)) {
                                    _ctx.next = 12;
                                    break;
                                }
                                logger21.info("addTextureAtlas: TextureAtlas empty: ".concat(atlas));
                                return _ctx.abrupt("return");
                            case 12:
                                logger21.debug("addTextureAtlas: Loading textureAtlas '".concat(atlas, "' for image '").concat(imageName, "'"));
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 14;
                                for(_iterator = Object.getOwnPropertyNames(jsonAtlas)[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    textureName = _step.value;
                                    imageTextureDef = jsonAtlas[textureName];
                                    imageTexture = {
                                        name: textureName,
                                        image: imageName,
                                        xOffset: imageTextureDef.x,
                                        yOffset: imageTextureDef.y,
                                        width: imageTextureDef.width,
                                        height: imageTextureDef.height
                                    };
                                    _this.addImageTexture(imageTexture);
                                }
                                _ctx.next = 22;
                                break;
                            case 18:
                                _ctx.prev = 18;
                                _ctx.t0 = _ctx["catch"](14);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t0;
                            case 22:
                                _ctx.prev = 22;
                                _ctx.prev = 23;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 25:
                                _ctx.prev = 25;
                                if (!_didIteratorError) {
                                    _ctx.next = 28;
                                    break;
                                }
                                throw _iteratorError;
                            case 28:
                                return _ctx.finish(25);
                            case 29:
                                return _ctx.finish(22);
                            case 30:
                                _this.mapView.update();
                                _ctx.next = 36;
                                break;
                            case 33:
                                _ctx.prev = 33;
                                _ctx.t1 = _ctx["catch"](5);
                                logger21.error("addTextureAtlas: Failed to load textureAtlas '".concat(atlas, "' : ").concat(_ctx.t1));
                            case 36:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            5,
                            33
                        ],
                        [
                            14,
                            18,
                            22,
                            30
                        ],
                        [
                            23,
                            ,
                            25,
                            29
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "addImageTexture",
            value: function addImageTexture(imageTexture) {
                if (imageTexture.name === void 0) {
                    logger21.error("addImageTexture: Name required", imageTexture);
                    return;
                }
                if (this.m_imageTextures.get(imageTexture.name) !== void 0) {
                    logger21.warn("addImageTexture: Name already used: ".concat(imageTexture.name, " (overriding it)"));
                }
                this.m_imageTextures.set(imageTexture.name, imageTexture);
            }
        },
        {
            key: "getImageTexture",
            value: function getImageTexture(name2) {
                return this.m_imageTextures.get(name2);
            }
        },
        {
            key: "updatePoiFromPoiTable",
            value: function updatePoiFromPoiTable(pointLabel) {
                var poiInfo = pointLabel.poiInfo;
                if (!poiInfo || poiInfo.poiTableName === void 0 || poiInfo.poiName === void 0) {
                    return true;
                }
                var poiTableName = poiInfo.poiTableName;
                var poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);
                if (poiTable && poiTable.isLoading) {
                    return false;
                }
                poiInfo.poiTableName = void 0;
                if (!poiTable || !poiTable.loadedOk) {
                    _PoiManager.notifyMissingPoiTable(poiTableName, poiTable);
                    return true;
                }
                var poiName = poiInfo.poiName;
                var poiTableEntry = poiTable.getEntry(poiName);
                if (!poiTableEntry) {
                    _PoiManager.notifyMissingPoi(poiName, poiTableName);
                    return true;
                }
                if (poiTableEntry.iconName !== void 0 && poiTableEntry.iconName.length > 0) {
                    poiInfo.imageTextureName = composeTechniqueTextureName(poiTableEntry.iconName, poiInfo.technique);
                }
                var _visible;
                pointLabel.visible = (_visible = poiTableEntry.visible) !== null && _visible !== void 0 ? _visible : pointLabel.visible;
                var _priority;
                pointLabel.priority = (_priority = poiTableEntry.priority) !== null && _priority !== void 0 ? _priority : pointLabel.priority;
                var _iconMinLevel;
                poiInfo.iconMinZoomLevel = (_iconMinLevel = poiTableEntry.iconMinLevel) !== null && _iconMinLevel !== void 0 ? _iconMinLevel : poiInfo.iconMinZoomLevel;
                var _iconMaxLevel;
                poiInfo.iconMaxZoomLevel = (_iconMaxLevel = poiTableEntry.iconMaxLevel) !== null && _iconMaxLevel !== void 0 ? _iconMaxLevel : poiInfo.iconMaxZoomLevel;
                var _textMinLevel;
                poiInfo.textMinZoomLevel = (_textMinLevel = poiTableEntry.textMinLevel) !== null && _textMinLevel !== void 0 ? _textMinLevel : poiInfo.textMinZoomLevel;
                var _textMaxLevel;
                poiInfo.textMaxZoomLevel = (_textMaxLevel = poiTableEntry.textMaxLevel) !== null && _textMaxLevel !== void 0 ? _textMaxLevel : poiInfo.textMaxZoomLevel;
                TextElementBuilder.alignZoomLevelRanges(pointLabel);
                return true;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.m_imageTextures.clear();
                this.m_poiShieldGroups.clear();
            }
        },
        {
            key: "addLineMarker",
            value: function addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX) {
                var text = getText(poiGeometry);
                var imageTextureName = getImageTexture2(poiGeometry);
                var groupKey = imageTextureName + "-" + text;
                var shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);
                if (shieldGroupIndex === void 0) {
                    shieldGroupIndex = this.m_poiShieldGroups.size;
                    this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);
                }
                var positionArray = [];
                for(var i = 0; i < positions.count; i += 3){
                    positionArray.push(getPosition(positions, worldOffsetX, i));
                }
                var textElement = poiBuilder.withIcon(imageTextureName, shieldGroupIndex).build(text, positionArray, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, getAttributes(poiGeometry));
                tile.addTextElement(textElement);
            }
        },
        {
            key: "addPoi",
            value: function addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX) {
                for(var i = 0; i < positions.count; ++i){
                    var ref;
                    var ref1;
                    var offsetDirection = (ref1 = (ref = poiGeometry.offsetDirections) === null || ref === void 0 ? void 0 : ref[i]) !== null && ref1 !== void 0 ? ref1 : 0;
                    var textElement = poiBuilder.withIcon(getImageTexture2(poiGeometry, i)).build(getText(poiGeometry, i), getPosition(positions, worldOffsetX, i), tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, getAttributes(poiGeometry, i), void 0, offsetDirection);
                    tile.addTextElement(textElement);
                }
            }
        }
    ], [
        {
            key: "notifyMissingPoiTable",
            value: function notifyMissingPoiTable(poiTableName, poiTable) {
                if (poiTableName === void 0) {
                    poiTableName = "undefined";
                }
                if (_PoiManager.m_missingPoiTableName.get(poiTableName) === void 0) {
                    _PoiManager.m_missingPoiTableName.set(poiTableName, true);
                    if (poiTable !== void 0 && !poiTable.loadedOk) {
                        logger21.error("updatePoiFromPoiTable: Could not load POI table '".concat(poiTableName, "'!"));
                    } else {
                        logger21.error("updatePoiFromPoiTable: No POI table with name '".concat(poiTableName, "' found!"));
                    }
                }
            }
        },
        {
            key: "notifyMissingPoi",
            value: function notifyMissingPoi(poiName, poiTableName) {
                if (poiName === void 0) {
                    poiName = "undefined";
                }
                var key = "".concat(poiTableName, "[").concat(poiName, "]");
                if (_PoiManager.m_missingPoiName.get(key) === void 0) {
                    _PoiManager.m_missingPoiName.set(key, true);
                    logger21.warn("updatePoiFromPoiTable: Cannot find POI info for '".concat(poiName, "' in table '").concat(poiTableName, "'."));
                }
            }
        }
    ]);
    return _PoiManager;
}();
var PoiManager = _PoiManager;
__publicField(PoiManager, "m_missingPoiTableName", /* @__PURE__ */ new Map());
__publicField(PoiManager, "m_missingPoiName", /* @__PURE__ */ new Map());
// src/mapview/poi/PoiTableManager.ts
var logger22 = LoggerManager.instance.create("PoiTable");
var PoiTableEntry = /*#__PURE__*/ function() {
    function PoiTableEntry() {
        _classCallCheck(this, PoiTableEntry);
        __publicField(this, "name");
        __publicField(this, "altNames");
        __publicField(this, "visible");
        __publicField(this, "iconName");
        __publicField(this, "stackMode");
        __publicField(this, "priority");
        __publicField(this, "iconMinLevel");
        __publicField(this, "iconMaxLevel");
        __publicField(this, "textMinLevel");
        __publicField(this, "textMaxLevel");
    }
    _createClass(PoiTableEntry, [
        {
            key: "setup",
            value: function setup(jsonEntry) {
                this.name = jsonEntry.name;
                this.altNames = jsonEntry.altNames;
                this.iconName = jsonEntry.iconName;
                this.visible = jsonEntry.visible;
                this.priority = jsonEntry.priority;
                this.iconMinLevel = jsonEntry.iconMinLevel;
                this.iconMaxLevel = jsonEntry.iconMaxLevel;
                this.textMinLevel = jsonEntry.textMinLevel;
                this.textMaxLevel = jsonEntry.textMaxLevel;
                switch(jsonEntry.stackMode){
                    case "yes":
                        this.stackMode = "show-in-stack" /* Show */ ;
                        break;
                    case "no":
                        this.stackMode = "hide-in-stack" /* Hide */ ;
                        break;
                    case "parent":
                        this.stackMode = "show-parent" /* ShowParent */ ;
                        break;
                    default:
                }
            }
        }
    ], [
        {
            key: "verifyJSON",
            value: function verifyJSON(jsonEntry) {
                var isOK = typeof jsonEntry.name === "string" && jsonEntry.name.length > 0 && (jsonEntry.altNames === void 0 || Array.isArray(jsonEntry.altNames)) && (jsonEntry.stackMode === void 0 || jsonEntry.stackMode === "yes" || jsonEntry.stackMode === "no" || jsonEntry.stackMode === "parent") && (jsonEntry.visible === void 0 || typeof jsonEntry.visible === "boolean") && (jsonEntry.priority === void 0 || typeof jsonEntry.priority === "number") && (jsonEntry.iconMinLevel === void 0 || typeof jsonEntry.iconMinLevel === "number") && (jsonEntry.iconMaxLevel === void 0 || typeof jsonEntry.iconMaxLevel === "number") && (jsonEntry.textMinLevel === void 0 || typeof jsonEntry.textMinLevel === "number") && (jsonEntry.textMaxLevel === void 0 || typeof jsonEntry.textMaxLevel === "number");
                if (isOK && jsonEntry.altNames !== void 0) {
                    var altNames = jsonEntry.altNames;
                    for(var str in altNames){
                        if (typeof str !== "string") {
                            isOK = false;
                            break;
                        }
                    }
                }
                return isOK;
            }
        }
    ]);
    return PoiTableEntry;
}();
var PoiTable = /*#__PURE__*/ function() {
    function PoiTable(name2, useAltNamesForKey) {
        _classCallCheck(this, PoiTable);
        this.name = name2;
        this.useAltNamesForKey = useAltNamesForKey;
        __publicField(this, "poiList", new Array());
        __publicField(this, "poiDict", /* @__PURE__ */ new Map());
        __publicField(this, "m_isLoading", false);
        __publicField(this, "m_loadedOk");
    }
    _createClass(PoiTable, [
        {
            key: "isLoading",
            get: function get() {
                return this.m_isLoading;
            }
        },
        {
            key: "loadedOk",
            get: function get() {
                return this.m_loadedOk === true;
            }
        },
        {
            key: "getEntry",
            value: function getEntry(poiName) {
                var entryIdx = this.poiDict.get(poiName);
                if (entryIdx !== void 0) {
                    if (entryIdx < this.poiList.length) {
                        return this.poiList[entryIdx];
                    } else {
                        throw new Error("Poi table entry index out of stored list!");
                    }
                }
                return void 0;
            }
        },
        {
            key: "load",
            value: function load(poiTableUrl, abortSignal) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var response, jsonPoiTable, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, tableEntry, newPoiEntry, entryIdx, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, altName;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                if (!(_this.m_loadedOk !== void 0)) {
                                    _ctx.next = 2;
                                    break;
                                }
                                return _ctx.abrupt("return", true);
                            case 2:
                                _this.m_loadedOk = false;
                                _ctx.next = 5;
                                return fetch(poiTableUrl, {
                                    signal: abortSignal
                                });
                            case 5:
                                response = _ctx.sent;
                                if (response.ok) {
                                    _ctx.next = 8;
                                    break;
                                }
                                throw new Error("load: Cannot load POI table at ".concat(poiTableUrl, ": ").concat(response.statusText));
                            case 8:
                                _ctx.next = 10;
                                return response.json();
                            case 10:
                                jsonPoiTable = _ctx.sent;
                                if (!(jsonPoiTable === void 0)) {
                                    _ctx.next = 14;
                                    break;
                                }
                                logger22.info("load: TextureAtlas empty: ".concat(poiTableUrl));
                                return _ctx.abrupt("return", true);
                            case 14:
                                _this.startLoading();
                                _ctx.prev = 15;
                                logger22.debug("load: Loading POI table '".concat(poiTableUrl, "' for table '").concat(_this.name, "'"));
                                if (!(jsonPoiTable.poiList !== void 0 && Array.isArray(jsonPoiTable.poiList))) {
                                    _ctx.next = 72;
                                    break;
                                }
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 19;
                                _iterator = jsonPoiTable.poiList[Symbol.iterator]();
                            case 21:
                                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                    _ctx.next = 58;
                                    break;
                                }
                                tableEntry = _step.value;
                                if (!PoiTableEntry.verifyJSON(tableEntry)) {
                                    _ctx.next = 54;
                                    break;
                                }
                                newPoiEntry = new PoiTableEntry();
                                newPoiEntry.setup(tableEntry);
                                entryIdx = _this.poiList.push(newPoiEntry) - 1;
                                if (_this.useAltNamesForKey) {
                                    _ctx.next = 31;
                                    break;
                                }
                                {
                                    if (newPoiEntry.name === void 0) {
                                        logger22.warn("load: Invalid entry in POI table '".concat(poiTableUrl, "' : . No name set in entry: ").concat(tableEntry, "."));
                                    } else {
                                        _this.poiDict.set(newPoiEntry.name, entryIdx);
                                    }
                                }
                                _ctx.next = 52;
                                break;
                            case 31:
                                if (!(newPoiEntry.altNames !== void 0 && newPoiEntry.altNames.length > 0)) {
                                    _ctx.next = 51;
                                    break;
                                }
                                _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                _ctx.prev = 33;
                                for(_iterator1 = newPoiEntry.altNames[Symbol.iterator](); !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    altName = _step1.value;
                                    _this.poiDict.set(altName, entryIdx);
                                }
                                _ctx.next = 41;
                                break;
                            case 37:
                                _ctx.prev = 37;
                                _ctx.t0 = _ctx["catch"](33);
                                _didIteratorError1 = true;
                                _iteratorError1 = _ctx.t0;
                            case 41:
                                _ctx.prev = 41;
                                _ctx.prev = 42;
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            case 44:
                                _ctx.prev = 44;
                                if (!_didIteratorError1) {
                                    _ctx.next = 47;
                                    break;
                                }
                                throw _iteratorError1;
                            case 47:
                                return _ctx.finish(44);
                            case 48:
                                return _ctx.finish(41);
                            case 49:
                                _ctx.next = 52;
                                break;
                            case 51:
                                {
                                    logger22.debug("load: Invalid entry in POI table '".concat(poiTableUrl, "' : No alternative names set in entry: ").concat(JSON.stringify(tableEntry), "."));
                                }
                            case 52:
                                _ctx.next = 55;
                                break;
                            case 54:
                                {
                                    logger22.warn("load: Invalid entry in POI table '".concat(poiTableUrl, "' : ").concat(JSON.stringify(tableEntry)));
                                }
                            case 55:
                                _iteratorNormalCompletion = true;
                                _ctx.next = 21;
                                break;
                            case 58:
                                _ctx.next = 64;
                                break;
                            case 60:
                                _ctx.prev = 60;
                                _ctx.t1 = _ctx["catch"](19);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t1;
                            case 64:
                                _ctx.prev = 64;
                                _ctx.prev = 65;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 67:
                                _ctx.prev = 67;
                                if (!_didIteratorError) {
                                    _ctx.next = 70;
                                    break;
                                }
                                throw _iteratorError;
                            case 70:
                                return _ctx.finish(67);
                            case 71:
                                return _ctx.finish(64);
                            case 72:
                                _this.m_loadedOk = true;
                                _this.finishedLoading();
                                _ctx.next = 82;
                                break;
                            case 76:
                                _ctx.prev = 76;
                                _ctx.t2 = _ctx["catch"](15);
                                logger22.error("load: Failed to load POI table '".concat(poiTableUrl, "' : ").concat(_ctx.t2));
                                _this.m_loadedOk = false;
                                _this.finishedLoading();
                                return _ctx.abrupt("return", false);
                            case 82:
                                return _ctx.abrupt("return", true);
                            case 83:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            15,
                            76
                        ],
                        [
                            19,
                            60,
                            64,
                            72
                        ],
                        [
                            33,
                            37,
                            41,
                            49
                        ],
                        [
                            42,
                            ,
                            44,
                            48
                        ],
                        [
                            65,
                            ,
                            67,
                            71
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "startLoading",
            value: function startLoading() {
                this.m_isLoading = true;
            }
        },
        {
            key: "finishedLoading",
            value: function finishedLoading() {
                this.m_isLoading = false;
            }
        }
    ]);
    return PoiTable;
}();
var PoiTableManager = /*#__PURE__*/ function() {
    function PoiTableManager(mapView) {
        _classCallCheck(this, PoiTableManager);
        this.mapView = mapView;
        __publicField(this, "m_isLoading", false);
        __publicField(this, "m_poiTables", /* @__PURE__ */ new Map());
        __publicField(this, "m_abortControllers", /* @__PURE__ */ new Map());
    }
    _createClass(PoiTableManager, [
        {
            key: "loadPoiTables",
            value: function loadPoiTables(poiTables) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var finished;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                finished = new Promise(function(resolve) {
                                    _this.clear();
                                    if (poiTables !== void 0) {
                                        _this.startLoading();
                                        var loadPromises = new Array();
                                        poiTables.forEach(function(poiTableRef) {
                                            if (poiTableRef !== void 0 && poiTableRef.name !== void 0 && typeof poiTableRef.name === "string") {
                                                var poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);
                                                if (poiTableRef.url !== void 0 && typeof poiTableRef.url === "string") {
                                                    var ref;
                                                    _this.addTable(poiTable);
                                                    _this.m_abortControllers.set(poiTableRef.name, new AbortController());
                                                    loadPromises.push(poiTable.load(poiTableRef.url, (ref = _this.m_abortControllers.get(poiTableRef.name)) === null || ref === void 0 ? void 0 : ref.signal));
                                                } else {
                                                    logger22.error("POI table definition has no valid url: ".concat(poiTableRef));
                                                }
                                            } else {
                                                logger22.error("POI table definition has no valid name: ".concat(poiTableRef));
                                            }
                                        });
                                        if (loadPromises.length > 0) {
                                            Promise.all(loadPromises).finally(function() {
                                                _this.finishLoading();
                                                resolve();
                                            });
                                        } else {
                                            _this.finishLoading();
                                            resolve();
                                        }
                                    } else {
                                        _this.finishLoading();
                                        resolve();
                                    }
                                });
                                return _ctx.abrupt("return", finished);
                            case 2:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "clear",
            value: function clear() {
                var _this = this;
                this.m_poiTables = /* @__PURE__ */ new Map();
                this.m_abortControllers.forEach(function(abortController, name2) {
                    abortController.abort();
                    _this.m_abortControllers.delete(name2);
                });
            }
        },
        {
            key: "poiTables",
            get: function get() {
                return this.m_poiTables;
            }
        },
        {
            key: "addTable",
            value: function addTable(poiTable) {
                this.m_poiTables.set(poiTable.name, poiTable);
            }
        },
        {
            key: "getPoiTable",
            value: function getPoiTable(poiTableName) {
                return poiTableName === void 0 ? void 0 : this.m_poiTables.get(poiTableName);
            }
        },
        {
            key: "finishedLoading",
            get: function get() {
                return !this.m_isLoading;
            }
        },
        {
            key: "startLoading",
            value: function startLoading() {
                this.m_isLoading = true;
            }
        },
        {
            key: "finishLoading",
            value: function finishLoading() {
                this.m_isLoading = false;
            }
        }
    ]);
    return PoiTableManager;
}();
// src/mapview/PolarTileDataSource.ts
var THREE87 = __toESM(require("three"));
// src/datasource-protocol/StyleSetEvaluator.ts
var logger23 = LoggerManager.instance.create("StyleSetEvaluator");
var DEFAULT_TECHNIQUE_ATTR_SCOPE = 1 /* TechniqueGeometry */ ;
function getStyleAttributeScope(style, attrName) {
    var ref;
    if (style.technique === "extruded-polygon") {
        if (attrName === "color" && style.vertexColors !== false) {
            return DEFAULT_TECHNIQUE_ATTR_SCOPE;
        }
    }
    var ref1;
    return (ref1 = (ref = getTechniqueAttributeDescriptor(style.technique, attrName)) === null || ref === void 0 ? void 0 : ref.scope) !== null && ref1 !== void 0 ? ref1 : DEFAULT_TECHNIQUE_ATTR_SCOPE;
}
var StyleConditionClassifier = /*#__PURE__*/ function() {
    function StyleConditionClassifier() {
        _classCallCheck(this, StyleConditionClassifier);
        __publicField(this, "_style");
    }
    _createClass(StyleConditionClassifier, [
        {
            key: "classify",
            value: function classify(style) {
                if (style._whenExpr) {
                    var savedStyle = this.switchStyle(style);
                    style._whenExpr = style._whenExpr.accept(this, void 0);
                    this._style = savedStyle;
                }
            }
        },
        {
            key: "visitNullLiteralExpr",
            value: function visitNullLiteralExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitBooleanLiteralExpr",
            value: function visitBooleanLiteralExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitNumberLiteralExpr",
            value: function visitNumberLiteralExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitStringLiteralExpr",
            value: function visitStringLiteralExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitObjectLiteralExpr",
            value: function visitObjectLiteralExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitVarExpr",
            value: function visitVarExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitHasAttributeExpr",
            value: function visitHasAttributeExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitMatchExpr",
            value: function visitMatchExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitCaseExpr",
            value: function visitCaseExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitCallExpr",
            value: function visitCallExpr(call, enclosingExpr) {
                var _this = this;
                if (call.op === "all") {
                    var children = call.args.map(function(childExpr) {
                        return childExpr.accept(_this, call);
                    }).filter(function(childExpr) {
                        return childExpr !== void 0;
                    });
                    return new CallExpr7(call.op, children);
                } else if (enclosingExpr) {
                    var matched = this.matchVarStringComparison(call);
                    if (matched) {
                        if (this._style.layer === void 0 && matched.name === "$layer") {
                            this._style.layer = matched.value;
                            return void 0;
                        } else if (this._style._geometryType === void 0 && matched.name === "$geometryType") {
                            this._style._geometryType = matched.value;
                            return void 0;
                        }
                    }
                }
                return call;
            }
        },
        {
            key: "visitLookupExpr",
            value: function visitLookupExpr(lookup, enclosingExpr) {
                return this.visitCallExpr(lookup, enclosingExpr);
            }
        },
        {
            key: "visitStepExpr",
            value: function visitStepExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "visitInterpolateExpr",
            value: function visitInterpolateExpr(expr, enclosingExpr) {
                return expr;
            }
        },
        {
            key: "matchVarStringComparison",
            value: function matchVarStringComparison(call) {
                if (call.op === "==") {
                    var left = call.args[0];
                    var right = call.args[1];
                    if (_instanceof(left, VarExpr3) && _instanceof(right, StringLiteralExpr)) {
                        return {
                            name: left.name,
                            value: right.value
                        };
                    }
                    if (_instanceof(right, VarExpr3) && _instanceof(left, StringLiteralExpr)) {
                        return {
                            name: right.name,
                            value: left.value
                        };
                    }
                }
                return void 0;
            }
        },
        {
            key: "switchStyle",
            value: function switchStyle(style) {
                var saved = this._style;
                this._style = style;
                return saved;
            }
        }
    ]);
    return StyleConditionClassifier;
}();
var OptimizedSubSetKey = /*#__PURE__*/ function() {
    function OptimizedSubSetKey(layer, geometryType) {
        _classCallCheck(this, OptimizedSubSetKey);
        __publicField(this, "key");
        __publicField(this, "layer");
        __publicField(this, "geometryType");
        __publicField(this, "cachedStyleSet");
        this.key = "";
        this.set(layer, geometryType);
    }
    _createClass(OptimizedSubSetKey, [
        {
            key: "set",
            value: function set(layer, geometryType, env) {
                var keyUpdateNeeded = false;
                if (layer === void 0) {
                    var envLayer = env !== void 0 ? env.lookup("$layer") : void 0;
                    layer = typeof envLayer === "string" ? envLayer : void 0;
                }
                if (this.layer !== layer) {
                    this.layer = layer;
                    keyUpdateNeeded = true;
                }
                if (geometryType === void 0) {
                    var envGeometryType = env !== void 0 ? env.lookup("$geometryType") : void 0;
                    geometryType = typeof envGeometryType === "string" ? envGeometryType : void 0;
                }
                if (this.geometryType !== geometryType) {
                    this.geometryType = geometryType;
                    keyUpdateNeeded = true;
                }
                if (keyUpdateNeeded) {
                    this.updateKey();
                }
                return this;
            }
        },
        {
            key: "updateKey",
            value: function updateKey() {
                if (this.layer !== void 0) {
                    if (this.geometryType !== void 0) {
                        this.key = "".concat(this.layer, ":").concat(this.geometryType);
                    } else {
                        this.key = "".concat(this.layer, ":");
                    }
                } else {
                    if (this.geometryType !== void 0) {
                        this.key = ":".concat(this.geometryType);
                    } else {
                        this.key = "all";
                    }
                }
                this.cachedStyleSet = void 0;
            }
        }
    ]);
    return OptimizedSubSetKey;
}();
var StyleSetEvaluator = /*#__PURE__*/ function() {
    function StyleSetEvaluator(m_options) {
        _classCallCheck(this, StyleSetEvaluator);
        this.m_options = m_options;
        __publicField(this, "styleSet");
        __publicField(this, "m_techniques", []);
        __publicField(this, "m_exprPool", new ExprPool());
        __publicField(this, "m_cachedResults", /* @__PURE__ */ new Map());
        __publicField(this, "m_styleConditionClassifier", new StyleConditionClassifier());
        __publicField(this, "m_subStyleSetCache", /* @__PURE__ */ new Map());
        __publicField(this, "m_definitions");
        __publicField(this, "m_definitionExprCache", /* @__PURE__ */ new Map());
        __publicField(this, "m_tmpOptimizedSubSetKey", new OptimizedSubSetKey());
        __publicField(this, "m_emptyEnv", new Env());
        __publicField(this, "m_featureDependencies", []);
        __publicField(this, "m_layer");
        __publicField(this, "m_geometryType");
        __publicField(this, "m_zoomLevel");
        __publicField(this, "m_previousResult");
        __publicField(this, "m_previousEnv");
        __publicField(this, "m_nextArrayBufferId", 0);
        this.m_definitions = this.m_options.definitions;
        this.styleSet = resolveReferences(this.m_options.styleSet, this.m_definitions);
        computeDefaultRenderOrder(this.styleSet);
        this.compileStyleSet();
    }
    _createClass(StyleSetEvaluator, [
        {
            key: "getMatchingTechniques",
            value: function getMatchingTechniques(env, layer, geometryType) {
                var _this = this;
                if (this.m_previousResult && this.m_previousEnv && this.m_featureDependencies.every(function(p) {
                    var ref;
                    return ((ref = _this.m_previousEnv) === null || ref === void 0 ? void 0 : ref.lookup(p)) === env.lookup(p);
                })) {
                    return this.m_previousResult;
                }
                var result = [];
                this.m_cachedResults.clear();
                var optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;
                optimizedSubSetKey.set(layer, geometryType, env);
                this.m_layer = optimizedSubSetKey.layer;
                this.m_geometryType = optimizedSubSetKey.geometryType;
                this.m_zoomLevel = env.lookup("$zoom");
                var searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = searchedStyleSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var currStyle = _step.value;
                        if (this.processStyle(env, currStyle, result)) {
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                this.m_previousResult = result;
                this.m_previousEnv = env;
                return result;
            }
        },
        {
            key: "wantsLayer",
            value: function wantsLayer(layer) {
                return this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, void 0)).length > 0;
            }
        },
        {
            key: "wantsFeature",
            value: function wantsFeature(layer, geometryType) {
                return this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType)).length > 0;
            }
        },
        {
            key: "resetTechniques",
            value: function resetTechniques() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_techniques[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var techinque = _step.value;
                        techinque._index = void 0;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                this.m_techniques.length = 0;
                this.m_previousResult = void 0;
                this.m_previousEnv = void 0;
            }
        },
        {
            key: "techniques",
            get: function get() {
                return this.m_techniques;
            }
        },
        {
            key: "decodedTechniques",
            get: function get() {
                return this.m_techniques.map(makeDecodedTechnique);
            }
        },
        {
            key: "getOptimizedStyleSet",
            value: function getOptimizedStyleSet(subSetKey) {
                if (subSetKey.cachedStyleSet !== void 0) {
                    return subSetKey.cachedStyleSet;
                }
                var optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);
                if (optimizedStyleSet !== void 0) {
                    subSetKey.cachedStyleSet = optimizedStyleSet;
                    return optimizedStyleSet;
                }
                optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);
                this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);
                subSetKey.cachedStyleSet = optimizedStyleSet;
                return optimizedStyleSet;
            }
        },
        {
            key: "createPreFilteredStyleSet",
            value: function createPreFilteredStyleSet(subSetKey) {
                var layer = subSetKey.layer, geometryType = subSetKey.geometryType;
                return this.styleSet.filter(function(style) {
                    if (layer !== void 0 && style.layer !== void 0 && style.layer !== layer) {
                        return false;
                    }
                    if (geometryType !== void 0 && style._geometryType !== void 0 && style._geometryType !== geometryType) {
                        return false;
                    }
                    return true;
                });
            }
        },
        {
            key: "compileStyleSet",
            value: function compileStyleSet() {
                var _this = this;
                this.m_featureDependencies = [
                    "$layer",
                    "$geometryType",
                    "$zoom"
                ];
                this.styleSet.forEach(function(style) {
                    return _this.compileStyle(style);
                });
                this.styleSet.forEach(function(style) {
                    _this.getOptimizedStyleSet(_this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));
                });
            }
        },
        {
            key: "compileStyle",
            value: function compileStyle(style) {
                var _this = this;
                this.checkStyleDynamicAttributes(style);
                if (style.when !== void 0) {
                    try {
                        style._whenExpr = Array.isArray(style.when) ? Expr3.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache) : Expr3.parse(style.when);
                        this.m_styleConditionClassifier.classify(style);
                        if (style._whenExpr !== void 0) {
                            style._whenExpr = style._whenExpr.intern(this.m_exprPool);
                        }
                        var deps = style._whenExpr.dependencies();
                        deps === null || deps === void 0 ? void 0 : deps.properties.forEach(function(prop) {
                            if (!_this.m_featureDependencies.includes(prop)) {
                                _this.m_featureDependencies.push(prop);
                            }
                        });
                        if (isJsonExpr(style.minZoomLevel)) {
                            style._minZoomLevelExpr = Expr3.fromJSON(style.minZoomLevel, this.m_definitions).intern(this.m_exprPool);
                        }
                        if (isJsonExpr(style.maxZoomLevel)) {
                            style._maxZoomLevelExpr = Expr3.fromJSON(style.maxZoomLevel, this.m_definitions).intern(this.m_exprPool);
                        }
                    } catch (err) {
                        logger23.log("failed to evaluate expression", JSON.stringify(style.when), "error", String(err));
                    }
                }
            }
        },
        {
            key: "processStyle",
            value: function processStyle(env, style, result) {
                if (!this.checkZoomLevel(env, style)) {
                    return false;
                }
                if (this.m_layer !== void 0 && style.layer !== void 0 && style.layer !== this.m_layer) {
                    return false;
                }
                if (this.m_geometryType !== void 0 && style._geometryType !== void 0 && style._geometryType !== this.m_geometryType) {
                    return false;
                }
                if (style._whenExpr) {
                    try {
                        if (!style._whenExpr.evaluate(env, 1 /* Condition */ , this.m_cachedResults)) {
                            return false;
                        }
                    } catch (error) {
                        logger23.error("failed to evaluate expression '".concat(JSON.stringify(style.when), "': ").concat(error));
                        return false;
                    }
                }
                if (style.technique === void 0) {
                    return false;
                }
                if (style.technique !== "none") {
                    result.push(this.getTechniqueForStyleMatch(env, style));
                }
                return style.final === true;
            }
        },
        {
            key: "checkZoomLevel",
            value: function checkZoomLevel(env, style) {
                if (style.minZoomLevel === void 0 && style.maxZoomLevel === void 0) {
                    return true;
                }
                var zoomLevel = this.m_zoomLevel;
                if (zoomLevel === void 0) {
                    return true;
                }
                if (style.minZoomLevel !== void 0) {
                    var ref;
                    var minZoomLevel = style.minZoomLevel;
                    if (((ref = style._minZoomLevelExpr) === null || ref === void 0 ? void 0 : ref.isDynamic()) === false) {
                        try {
                            minZoomLevel = style._minZoomLevelExpr.evaluate(env, 1 /* Condition */ , this.m_cachedResults);
                        } catch (error) {
                            logger23.error("failed to evaluate expression '".concat(JSON.stringify(style._minZoomLevelExpr), "': ").concat(error));
                        }
                    }
                    if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
                        return false;
                    }
                }
                if (style.maxZoomLevel !== void 0) {
                    var ref1;
                    var maxZoomLevel = style.maxZoomLevel;
                    if (((ref1 = style._maxZoomLevelExpr) === null || ref1 === void 0 ? void 0 : ref1.isDynamic()) === false) {
                        try {
                            maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, 1 /* Condition */ , this.m_cachedResults);
                        } catch (error1) {
                            logger23.error("failed to evaluate expression '".concat(JSON.stringify(style._maxZoomLevelExpr), "': ").concat(error1));
                        }
                    }
                    if (typeof maxZoomLevel === "number" && zoomLevel >= maxZoomLevel) {
                        return false;
                    }
                }
                return true;
            }
        },
        {
            key: "getTechniqueForStyleMatch",
            value: function getTechniqueForStyleMatch(env, style) {
                var technique;
                if (style._dynamicTechniques !== void 0) {
                    var dynamicAttributes = this.evaluateTechniqueProperties(style, env);
                    var key = this.getDynamicTechniqueKey(style, dynamicAttributes);
                    technique = style._dynamicTechniques.get(key);
                    if (technique === void 0) {
                        technique = this.createTechnique(style, key, dynamicAttributes);
                        style._dynamicTechniques.set(key, technique);
                    }
                } else {
                    technique = style._staticTechnique;
                    if (technique === void 0) {
                        style._staticTechnique = technique = this.createTechnique(style, "".concat(style._styleSetIndex), []);
                    }
                }
                if (technique._index === void 0) {
                    technique._index = this.m_techniques.length;
                    this.m_techniques.push(technique);
                }
                return technique;
            }
        },
        {
            key: "getDynamicTechniqueKey",
            value: function getDynamicTechniqueKey(style, dynamicAttributes) {
                var _this = this;
                var dynamicAttrKey = dynamicAttributes.map(function(param) {
                    var _param = _slicedToArray(param, 2), _attrName = _param[0], attrValue = _param[1];
                    if (attrValue === void 0) {
                        return "U";
                    } else if (typeof attrValue === "object") {
                        return JSON.stringify(attrValue, function(_, value2) {
                            if (_instanceof(value2, ArrayBuffer)) {
                                var arrayBufferId = value2.id;
                                if (arrayBufferId === void 0) {
                                    arrayBufferId = value2.id = _this.m_nextArrayBufferId++;
                                }
                                return arrayBufferId;
                            }
                            return value2;
                        });
                    } else {
                        return JSON.stringify(attrValue);
                    }
                }).join(":");
                return "".concat(style._styleSetIndex, ":").concat(dynamicAttrKey);
            }
        },
        {
            key: "checkStyleDynamicAttributes",
            value: function checkStyleDynamicAttributes(style) {
                var _this = this;
                if (style._dynamicTechniqueAttributes !== void 0 || style.technique === "none") {
                    return;
                }
                style._dynamicTechniqueAttributes = [];
                style._dynamicFeatureAttributes = [];
                style._dynamicForwardedAttributes = [];
                style._staticAttributes = [];
                var dynamicFeatureAttributes = style._dynamicFeatureAttributes;
                var dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;
                var dynamicForwardedAttributes = style._dynamicForwardedAttributes;
                var targetStaticAttributes = style._staticAttributes;
                var processAttribute = function(attrName, attrValue) {
                    if (attrValue === void 0) {
                        return;
                    }
                    if (isJsonExpr(attrValue)) {
                        attrValue = Expr3.fromJSON(attrValue, _this.m_definitions, _this.m_definitionExprCache).intern(_this.m_exprPool);
                    } else if (isInterpolatedPropertyDefinition(attrValue)) {
                        attrValue = Expr3.fromJSON(interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(_this.m_exprPool);
                    }
                    if (Expr3.isExpr(attrValue)) {
                        var deps = attrValue.dependencies();
                        if (deps.featureState) {
                            if (attrName !== "enabled") {
                                logger23.log("feature-state is not supported in this context");
                            } else {
                                style._usesFeatureState = true;
                            }
                        }
                        if (deps.properties.size === 0 && !attrValue.isDynamic()) {
                            attrValue = attrValue.evaluate(_this.m_emptyEnv);
                        }
                    }
                    if (Expr3.isExpr(attrValue)) {
                        var attrScope = getStyleAttributeScope(style, attrName);
                        var deps1 = attrValue.dependencies();
                        deps1.properties.forEach(function(prop) {
                            if (!_this.m_featureDependencies.includes(prop)) {
                                _this.m_featureDependencies.push(prop);
                            }
                        });
                        switch(attrScope){
                            case 0 /* FeatureGeometry */ :
                                dynamicFeatureAttributes.push([
                                    attrName,
                                    attrValue
                                ]);
                                break;
                            case 1 /* TechniqueGeometry */ :
                                dynamicTechniqueAttributes.push([
                                    attrName,
                                    attrValue
                                ]);
                                break;
                            case 2 /* TechniqueRendering */ :
                                if (deps1.properties.size === 0) {
                                    dynamicForwardedAttributes.push([
                                        attrName,
                                        attrValue
                                    ]);
                                } else {
                                    dynamicTechniqueAttributes.push([
                                        attrName,
                                        attrValue
                                    ]);
                                }
                                break;
                        }
                    } else if (attrValue !== void 0 && attrValue !== null) {
                        targetStaticAttributes.push([
                            attrName,
                            attrValue
                        ]);
                    }
                };
                var replacement = /* @__PURE__ */ new Map([
                    [
                        "category",
                        "_category"
                    ],
                    [
                        "secondaryCategory",
                        "_secondaryCategory"
                    ]
                ]);
                for(var p in style){
                    if (!style.hasOwnProperty(p)) {
                        continue;
                    }
                    if (p.startsWith("_")) {
                        continue;
                    }
                    if ([
                        "when",
                        "technique",
                        "layer",
                        "attr",
                        "description"
                    ].includes(p)) {
                        continue;
                    }
                    var ref;
                    var pp = (ref = replacement.get(p)) !== null && ref !== void 0 ? ref : p;
                    processAttribute(pp, style[p]);
                }
                if (style.attr !== void 0) {
                    for(var attrName in style.attr){
                        if (!style.attr.hasOwnProperty(attrName)) {
                            continue;
                        }
                        processAttribute(attrName, style.attr[attrName]);
                    }
                }
                if (dynamicTechniqueAttributes.length > 0) {
                    style._dynamicTechniques = /* @__PURE__ */ new Map();
                }
            }
        },
        {
            key: "evaluateTechniqueProperties",
            value: function evaluateTechniqueProperties(style, env) {
                var _this = this;
                if (style._dynamicTechniqueAttributes === void 0) {
                    return [];
                }
                return style._dynamicTechniqueAttributes.map(function(param) {
                    var _param = _slicedToArray(param, 2), attrName = _param[0], attrExpr = _param[1];
                    try {
                        var evaluatedValue = attrExpr.evaluate(env, 0 /* Value */ , _this.m_cachedResults);
                        return [
                            attrName,
                            evaluatedValue
                        ];
                    } catch (error) {
                        logger23.error("failed to evaluate expression '".concat(attrExpr.toJSON(), "': ").concat(error));
                        return [
                            attrName,
                            null
                        ];
                    }
                });
            }
        },
        {
            key: "createTechnique",
            value: function createTechnique(style, key, dynamicAttrs) {
                var technique = {};
                technique.name = style.technique;
                if (style._staticAttributes !== void 0) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = style._staticAttributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _value = _slicedToArray(_step.value, 2), attrName = _value[0], attrValue = _value[1];
                            if (attrValue !== null) {
                                technique[attrName] = attrValue;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = dynamicAttrs[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var _value1 = _slicedToArray(_step1.value, 2), attrName1 = _value1[0], attrValue1 = _value1[1];
                        if (attrValue1 !== null) {
                            technique[attrName1] = attrValue1;
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                if (style._dynamicFeatureAttributes !== void 0) {
                    var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                    try {
                        for(var _iterator2 = style._dynamicFeatureAttributes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                            var _value2 = _slicedToArray(_step2.value, 2), attrName2 = _value2[0], attrValue2 = _value2[1];
                            technique[attrName2] = attrValue2;
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                _iterator2.return();
                            }
                        } finally{
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }
                if (style._dynamicForwardedAttributes !== void 0) {
                    var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
                    try {
                        for(var _iterator3 = style._dynamicForwardedAttributes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
                            var _value3 = _slicedToArray(_step3.value, 2), attrName3 = _value3[0], attrValue3 = _value3[1];
                            technique[attrName3] = attrValue3;
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                                _iterator3.return();
                            }
                        } finally{
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                }
                technique._index = this.m_techniques.length;
                technique._styleSetIndex = style._styleSetIndex;
                if (style.styleSet !== void 0) {
                    technique._styleSet = style.styleSet;
                }
                if (style._usesFeatureState !== void 0) {
                    technique._usesFeatureState = style._usesFeatureState;
                }
                var _priorities, _labelPriorities;
                setTechniqueRenderOrderOrPriority(technique, (_priorities = this.m_options.priorities) !== null && _priorities !== void 0 ? _priorities : [], (_labelPriorities = this.m_options.labelPriorities) !== null && _labelPriorities !== void 0 ? _labelPriorities : []);
                this.m_techniques.push(technique);
                return technique;
            }
        }
    ]);
    return StyleSetEvaluator;
}();
function computeDefaultRenderOrder(styleSet) {
    var techniqueRenderOrder = 0;
    var styleSetIndex = 0;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = styleSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var style = _step.value;
            style._styleSetIndex = styleSetIndex++;
            if (style.technique !== void 0 && style.renderOrder === void 0) {
                style.renderOrder = techniqueRenderOrder++;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function resolveReferences(styleSet, definitions) {
    return styleSet.map(function(style) {
        return resolveStyleReferences(style, definitions);
    });
}
function resolveStyleReferences(style, definitions) {
    return _objectSpread({}, style);
}
function makeDecodedTechnique(technique) {
    var result = {};
    for(var attrName in technique){
        if (!technique.hasOwnProperty(attrName)) {
            continue;
        }
        var attrValue = technique[attrName];
        if (typeof attrValue === "object" && (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)) {
            attrValue = LiteralExpr.fromValue(attrValue);
        }
        if (Expr3.isExpr(attrValue)) {
            attrValue = attrValue.toJSON();
        }
        ;
        result[attrName] = attrValue;
    }
    return result;
}
// src/datasource-protocol/Outliner.ts
var THREE86 = __toESM(require("three"));
var currEdgeStart = new THREE86.Vector2();
var currEdgeGoal = new THREE86.Vector2();
var prevEdgeStart = new THREE86.Vector2();
var prevEdgeGoal = new THREE86.Vector2();
// src/datasource-protocol/ThreeBufferUtils.ts
var ThreeBufferUtils;
(function(ThreeBufferUtils2) {
    var getBufferElementType = function getBufferElementType(buffer) {
        if (_instanceof(buffer, Int8Array)) {
            return "int8";
        } else if (_instanceof(buffer, Uint8Array)) {
            return "uint8";
        } else if (_instanceof(buffer, Int16Array)) {
            return "int16";
        } else if (_instanceof(buffer, Uint16Array)) {
            return "uint16";
        } else if (_instanceof(buffer, Int32Array)) {
            return "int32";
        } else if (_instanceof(buffer, Uint32Array)) {
            return "uint32";
        } else if (_instanceof(buffer, Float32Array)) {
            return "float";
        }
        throw new Error("Unsupported buffer type ".concat(name));
    };
    var fromThreeBufferAttribute = function fromThreeBufferAttribute(bufferAttribute) {
        var buffer = bufferAttribute.array;
        return {
            name: bufferAttribute.name,
            buffer: buffer.buffer,
            type: getBufferElementType(buffer),
            itemCount: bufferAttribute.itemSize,
            normalized: bufferAttribute.normalized
        };
    };
    var fromThreeInterleavedBufferAttribute = function fromThreeInterleavedBufferAttribute(bufferAttribute) {
        throw new Error("Not implemented yet");
    };
    var fromThreeBufferGeometry = function fromThreeBufferGeometry(bufferGeometry, techniqueIndex) {
        var vertexAttributes = [];
        var attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = attributeNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var name2 = _step.value;
                var attribute = bufferGeometry.attributes[name2];
                var vertexAttribute = fromThreeBufferAttribute(attribute);
                vertexAttribute.name = name2;
                vertexAttributes.push(vertexAttribute);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var index = bufferGeometry.index !== null ? fromThreeBufferAttribute(bufferGeometry.index) : void 0;
        var count = 0;
        if (index !== void 0) {
            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;
        } else {
            var posAttr = bufferGeometry.attributes.position;
            if (posAttr === void 0) {
                throw new Error("Missing position attibute to deduce item count");
            }
            count = posAttr.count;
        }
        return {
            type: 0 /* Unspecified */ ,
            vertexAttributes: vertexAttributes,
            index: index,
            groups: [
                {
                    start: 0,
                    count: count,
                    technique: techniqueIndex
                }
            ]
        };
    };
    ThreeBufferUtils2.getBufferElementType = getBufferElementType;
    ThreeBufferUtils2.fromThreeBufferAttribute = fromThreeBufferAttribute;
    ThreeBufferUtils2.fromThreeInterleavedBufferAttribute = fromThreeInterleavedBufferAttribute;
    ThreeBufferUtils2.fromThreeBufferGeometry = fromThreeBufferGeometry;
})(ThreeBufferUtils || (ThreeBufferUtils = {}));
// src/mapview/PolarTileDataSource.ts
var PolarTileDataSource = /*#__PURE__*/ function(DataSource) {
    _inherits(PolarTileDataSource, DataSource);
    var _super = _createSuper(PolarTileDataSource);
    function PolarTileDataSource(param) {
        var tmp = param.name, name2 = tmp === void 0 ? "polar" : tmp, _styleSetName = param.styleSetName, styleSetName = _styleSetName === void 0 ? "polar" : _styleSetName, minDataLevel = param.minDataLevel, maxDataLevel = param.maxDataLevel, minDisplayLevel = param.minDisplayLevel, maxDisplayLevel = param.maxDisplayLevel, _storageLevelOffset = param.storageLevelOffset, storageLevelOffset = _storageLevelOffset === void 0 ? -2 : _storageLevelOffset, _geometryLevelOffset = param.geometryLevelOffset, geometryLevelOffset = _geometryLevelOffset === void 0 ? 1 : _geometryLevelOffset, _debugTiles = param.debugTiles, debugTiles = _debugTiles === void 0 ? false : _debugTiles;
        _classCallCheck(this, PolarTileDataSource);
        var _this;
        _this = _super.call(this, {
            name: name2,
            styleSetName: styleSetName,
            minDataLevel: minDataLevel,
            maxDataLevel: maxDataLevel,
            minDisplayLevel: minDisplayLevel,
            maxDisplayLevel: maxDisplayLevel,
            storageLevelOffset: storageLevelOffset
        });
        __publicField(_assertThisInitialized(_this), "m_tilingScheme", polarTilingScheme);
        __publicField(_assertThisInitialized(_this), "m_maxLatitude", THREE87.MathUtils.radToDeg(MercatorConstants.MAXIMUM_LATITUDE));
        __publicField(_assertThisInitialized(_this), "m_geometryLevelOffset");
        __publicField(_assertThisInitialized(_this), "m_debugTiles");
        __publicField(_assertThisInitialized(_this), "m_styleSetEvaluator");
        __publicField(_assertThisInitialized(_this), "m_northPoleEntry");
        __publicField(_assertThisInitialized(_this), "m_southPoleEntry");
        _this.m_geometryLevelOffset = geometryLevelOffset;
        _this.m_debugTiles = debugTiles;
        _this.cacheable = false;
        _this.enablePicking = false;
        return _this;
    }
    _createClass(PolarTileDataSource, [
        {
            key: "dispose",
            value: function dispose() {
                if (this.m_northPoleEntry) {
                    this.m_northPoleEntry.material.dispose();
                    delete this.m_northPoleEntry;
                }
                if (this.m_southPoleEntry) {
                    this.m_southPoleEntry.material.dispose();
                    delete this.m_southPoleEntry;
                }
                if (this.m_styleSetEvaluator) {
                    delete this.m_styleSetEvaluator;
                }
            }
        },
        {
            key: "createTechiqueEntry",
            value: function createTechiqueEntry(kind) {
                if (!this.m_styleSetEvaluator) {
                    return void 0;
                }
                var env = new MapEnv({
                    $geometryType: "polygon",
                    $layer: "earth",
                    kind: kind
                });
                var techniques = this.m_styleSetEvaluator.getMatchingTechniques(env);
                if (techniques.length === 0) {
                    return void 0;
                }
                var technique = techniques[0];
                var material = createMaterial(this.mapView.renderer.capabilities, {
                    technique: technique,
                    env: this.mapView.env
                });
                if (!material) {
                    return void 0;
                }
                return {
                    material: material,
                    technique: technique
                };
            }
        },
        {
            key: "setTheme",
            value: function setTheme(theme) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var styleSet;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return ThemeLoader.load(theme);
                            case 2:
                                theme = _ctx.sent;
                                styleSet = getStyles(theme.styles).filter(function(style) {
                                    return !style.styleSet || style.styleSet === _this.styleSetName;
                                });
                                if (styleSet.length > 0) {
                                    _this.m_styleSetEvaluator = new StyleSetEvaluator({
                                        styleSet: styleSet,
                                        definitions: theme.definitions,
                                        priorities: theme.priorities,
                                        labelPriorities: theme.labelPriorities
                                    });
                                }
                                _this.m_northPoleEntry = _this.createTechiqueEntry("north_pole");
                                _this.m_southPoleEntry = _this.createTechiqueEntry("south_pole");
                                _this.mapView.markTilesDirty(_this);
                            case 8:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "canGetTile",
            value: function canGetTile(zoomLevel, tileKey) {
                if (zoomLevel !== tileKey.level || tileKey.level < 1) {
                    return false;
                }
                var ref = this.m_tilingScheme.getGeoBox(tileKey), north = ref.north, south = ref.south;
                return north > this.m_maxLatitude || south < -this.m_maxLatitude;
            }
        },
        {
            key: "shouldSubdivide",
            value: function shouldSubdivide(zoomLevel, tileKey) {
                if (zoomLevel <= tileKey.level) {
                    return false;
                }
                var ref = this.m_tilingScheme.getGeoBox(tileKey), north = ref.north, south = ref.south;
                return north > this.m_maxLatitude || south < -this.m_maxLatitude;
            }
        },
        {
            key: "getTilingScheme",
            value: function getTilingScheme() {
                return this.m_tilingScheme;
            }
        },
        {
            key: "getTile",
            value: function getTile(tileKey) {
                var tile = new Tile(this, tileKey);
                this.createTileGeometry(tile);
                return tile;
            }
        },
        {
            key: "geometryLevelOffset",
            get: function get() {
                return this.m_geometryLevelOffset;
            },
            set: function set(geometryLevelOffset) {
                this.m_geometryLevelOffset = geometryLevelOffset;
            }
        },
        {
            key: "intersectEdge",
            value: function intersectEdge(latitude, a, b) {
                var latA = a.latitude;
                var latB = b.latitude;
                var lonA = a.longitude;
                var lonB = b.longitude;
                if (Math.abs(latA) === 90) {
                    lonA = lonB;
                }
                if (Math.abs(latB) === 90) {
                    lonB = lonA;
                }
                var deltaLat = latB - latA;
                var deltaLon = lonB - lonA;
                var scale = (latitude - latA) / deltaLat;
                return new GeoCoordinates(latitude, lonA + deltaLon * scale, 0);
            }
        },
        {
            key: "createTileGeometry",
            value: function createTileGeometry(tile) {
                var _geoBox = tile.geoBox, north = _geoBox.north, south = _geoBox.south;
                var isNorthPole = north > 0 && south >= 0;
                var techniqueEntry = isNorthPole ? this.m_northPoleEntry : this.m_southPoleEntry;
                if (techniqueEntry === void 0) {
                    tile.forceHasGeometry(true);
                    return;
                }
                var srcProjection = this.m_tilingScheme.projection;
                var dstProjection = this.projection;
                var maxLat = this.m_maxLatitude;
                var poleLat = isNorthPole ? maxLat : -maxLat;
                var box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);
                var pBL = srcProjection.unprojectPoint(new THREE87.Vector3(box.min.x, box.min.y, 0));
                var pBR = srcProjection.unprojectPoint(new THREE87.Vector3(box.max.x, box.min.y, 0));
                var pTR = srcProjection.unprojectPoint(new THREE87.Vector3(box.max.x, box.max.y, 0));
                var pTL = srcProjection.unprojectPoint(new THREE87.Vector3(box.min.x, box.max.y, 0));
                var points;
                var needsGeometryCut = false;
                if (tile.tileKey.level === 1) {
                    var isLeftHalf = box.min.x === 0;
                    var poleX = isLeftHalf ? box.max.x : box.min.x;
                    var poleY = (box.max.y + box.min.y) / 2;
                    var pPole = srcProjection.unprojectPoint(new THREE87.Vector3(poleX, poleY, 0));
                    var pXX = isLeftHalf ? pBL : pBR;
                    points = isNorthPole ? isLeftHalf ? [
                        pPole,
                        pTR,
                        pXX,
                        pBR
                    ] : [
                        pPole,
                        pBL,
                        pXX,
                        pTL
                    ] : isLeftHalf ? [
                        pPole,
                        pBR,
                        pXX,
                        pTR
                    ] : [
                        pPole,
                        pTL,
                        pXX,
                        pBL
                    ];
                    needsGeometryCut = true;
                } else {
                    var _Math, _Math1;
                    points = isNorthPole ? [
                        pBL,
                        pBR,
                        pTR,
                        pTL
                    ] : [
                        pBL,
                        pTL,
                        pTR,
                        pBR
                    ];
                    var lats = points.map(function(p) {
                        return p.latitude;
                    });
                    var lmax = (_Math = Math).max.apply(_Math, _toConsumableArray(lats));
                    var lmin = (_Math1 = Math).min.apply(_Math1, _toConsumableArray(lats));
                    var isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;
                    if (isAllPointsOut) {
                        return;
                    }
                    var isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;
                    needsGeometryCut = isSomePointsOut;
                    if (needsGeometryCut) {
                        var nearest = lats.indexOf(isNorthPole ? lmax : lmin);
                        if (nearest !== 0) {
                            for(var i = 0; i < nearest; i++){
                                points.push(points.shift());
                            }
                        }
                    }
                }
                if (needsGeometryCut) {
                    var centerX = (box.min.x + box.max.x) / 2;
                    var centerY = (box.min.y + box.max.y) / 2;
                    var center = srcProjection.unprojectPoint(new THREE87.Vector3(centerX, centerY, 0));
                    TransverseMercatorUtils.alignLongitude(points, center);
                    var a = points[0];
                    var b = points[1];
                    var c = points[2];
                    var d = points[3];
                    var inPointB = Math.abs(b.latitude) >= maxLat;
                    var inPointD = Math.abs(d.latitude) >= maxLat;
                    var cutStart = inPointB ? this.intersectEdge(poleLat, b, c) : this.intersectEdge(poleLat, a, b);
                    var cutEnd = inPointD ? this.intersectEdge(poleLat, d, c) : this.intersectEdge(poleLat, a, d);
                    points.splice(inPointB ? 2 : 1, 4, cutStart);
                    var level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;
                    var subdivisions = 1 << Math.max(0, level);
                    var step = 360 / subdivisions;
                    var cutIndexStart = Math.floor((cutStart.longitude + 180) / step);
                    var cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);
                    for(var i1 = cutIndexStart + 1; i1 < cutIndexEnd; i1++){
                        points.push(new GeoCoordinates(poleLat, i1 * step - 180, 0));
                    }
                    points.push(cutEnd);
                    if (inPointD) {
                        points.push(d);
                    }
                }
                var geometry = new THREE87.BufferGeometry();
                var vertices = points.map(function(point) {
                    var projected = dstProjection.projectPoint(point, new THREE87.Vector3());
                    projected.sub(tile.center);
                    return projected;
                });
                geometry.setFromPoints(vertices);
                var indices = [];
                for(var i2 = 1; i2 < vertices.length - 1; i2++){
                    isNorthPole ? indices.push(0, i2, i2 + 1) : indices.push(0, i2 + 1, i2);
                }
                geometry.setIndex(indices);
                var mesh = new THREE87.Mesh(geometry, techniqueEntry.material);
                mesh.userData = {
                    dataSource: this.name,
                    tileKey: tile.tileKey
                };
                if (this.m_debugTiles) {
                    var color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 16777215);
                    mesh.material = new THREE87.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.5
                    });
                    tile.objects.push(new THREE87.Mesh(geometry, new THREE87.MeshBasicMaterial({
                        color: color,
                        wireframe: true
                    })));
                }
                MapObjectAdapter.create(mesh, {
                    dataSource: this,
                    technique: techniqueEntry.technique,
                    kind: [
                        isNorthPole ? "water" /* Water */  : "background" /* Background */ 
                    ]
                });
                tile.objects.push(mesh);
            }
        }
    ]);
    return PolarTileDataSource;
}(DataSource);
// src/mapview/ScreenProjector.ts
var THREE88 = __toESM(require("three"));
function isOnScreen(ndc) {
    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;
}
function isInRange(ndc) {
    return ndc.z > -1 && ndc.z < 1;
}
var _ScreenProjector = /*#__PURE__*/ function() {
    function _ScreenProjector(m_camera) {
        _classCallCheck(this, _ScreenProjector);
        this.m_camera = m_camera;
        __publicField(this, "m_width", 0);
        __publicField(this, "m_height", 0);
    }
    _createClass(_ScreenProjector, [
        {
            key: "width",
            get: function get() {
                return this.m_width;
            }
        },
        {
            key: "height",
            get: function get() {
                return this.m_height;
            }
        },
        {
            key: "project",
            value: function project(source) {
                var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new THREE88.Vector2();
                var p = this.projectVector(source, _ScreenProjector.tempV3);
                return this.ndcToScreen(p, target);
            }
        },
        {
            key: "projectToScreen",
            value: function projectToScreen(source) {
                var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new THREE88.Vector2();
                var p = this.projectVector(source, _ScreenProjector.tempV3);
                if (isInRange(p)) {
                    return this.ndcToScreen(p, target);
                }
                return void 0;
            }
        },
        {
            key: "projectAreaToScreen",
            value: function projectAreaToScreen(source, halfWidth, halfHeight) {
                var target = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new THREE88.Vector2();
                halfWidth *= 2;
                halfHeight *= 2;
                var p = this.projectVector(source, _ScreenProjector.tempV3);
                if (isInRange(p) && p.x + halfWidth >= -1 && p.x - halfWidth <= 1 && p.y + halfHeight >= -1 && p.y - halfHeight <= 1) {
                    return this.ndcToScreen(p, target);
                }
                return void 0;
            }
        },
        {
            key: "project3",
            value: function project3(source) {
                var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new THREE88.Vector3();
                var p = this.projectVector(source, _ScreenProjector.tempV3);
                if (p.z > -1 && p.z < 1) {
                    target.set(p.x * this.m_width / 2, p.y * this.m_height / 2, p.z);
                    return target;
                }
                return void 0;
            }
        },
        {
            key: "projectVector",
            value: function projectVector(source, target) {
                target.set(source.x, source.y, source.z).project(this.m_camera);
                return target;
            }
        },
        {
            key: "onScreen",
            value: function onScreen(source) {
                var p = this.projectVector(source, _ScreenProjector.tempV3);
                return isOnScreen(p);
            }
        },
        {
            key: "update",
            value: function update(camera, width, height) {
                this.m_camera = camera;
                this.m_width = width;
                this.m_height = height;
            }
        },
        {
            key: "ndcToScreen",
            value: function ndcToScreen(ndc, screenCoords) {
                return screenCoords.set(ndc.x * this.m_width / 2, ndc.y * this.m_height / 2);
            }
        }
    ]);
    return _ScreenProjector;
}();
var ScreenProjector = _ScreenProjector;
__publicField(ScreenProjector, "tempV2", new THREE88.Vector2());
__publicField(ScreenProjector, "tempV3", new THREE88.Vector3());
// src/mapview/text/MapViewState.ts
var THREE89 = __toESM(require("three"));
var MapViewState = /*#__PURE__*/ function() {
    function MapViewState(m_mapView, m_renderedTilesChangeCheck) {
        _classCallCheck(this, MapViewState);
        this.m_mapView = m_mapView;
        this.m_renderedTilesChangeCheck = m_renderedTilesChangeCheck;
        __publicField(this, "m_lookAtVector", new THREE89.Vector3());
    }
    _createClass(MapViewState, [
        {
            key: "worldCenter",
            get: function get() {
                return this.m_mapView.worldCenter;
            }
        },
        {
            key: "cameraIsMoving",
            get: function get() {
                return this.m_mapView.cameraIsMoving;
            }
        },
        {
            key: "maxVisibilityDist",
            get: function get() {
                return this.m_mapView.viewRanges.maximum;
            }
        },
        {
            key: "zoomLevel",
            get: function get() {
                return this.m_mapView.zoomLevel;
            }
        },
        {
            key: "env",
            get: function get() {
                return this.m_mapView.env;
            }
        },
        {
            key: "frameNumber",
            get: function get() {
                return this.m_mapView.frameNumber;
            }
        },
        {
            key: "lookAtVector",
            get: function get() {
                return this.m_mapView.camera.getWorldDirection(this.m_lookAtVector);
            }
        },
        {
            key: "lookAtDistance",
            get: function get() {
                return this.m_mapView.targetDistance;
            }
        },
        {
            key: "isDynamic",
            get: function get() {
                return this.m_mapView.isDynamicFrame;
            }
        },
        {
            key: "hiddenGeometryKinds",
            get: function get() {
                return this.m_mapView.tileGeometryManager === void 0 ? void 0 : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;
            }
        },
        {
            key: "renderedTilesChanged",
            get: function get() {
                return this.m_renderedTilesChangeCheck();
            }
        },
        {
            key: "projection",
            get: function get() {
                return this.m_mapView.projection;
            }
        },
        {
            key: "elevationProvider",
            get: function get() {
                return this.m_mapView.elevationProvider;
            }
        }
    ]);
    return MapViewState;
}();
// src/mapview/TileObjectsRenderer.ts
var DEFAULT_STENCIL_VALUE = 1;
var TileObjectRenderer = /*#__PURE__*/ function() {
    function TileObjectRenderer(m_env, m_renderer) {
        _classCallCheck(this, TileObjectRenderer);
        this.m_env = m_env;
        this.m_renderer = m_renderer;
        __publicField(this, "m_renderOrderStencilValues", /* @__PURE__ */ new Map());
        __publicField(this, "m_stencilValue", DEFAULT_STENCIL_VALUE);
    }
    _createClass(TileObjectRenderer, [
        {
            key: "render",
            value: function render(tile, storageLevel, zoomLevel, cameraPosition, rootNode) {
                var worldOffsetX = tile.computeWorldOffsetX();
                if (tile.willRender(storageLevel)) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = tile.objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var object = _step.value;
                            var mapObjectAdapter = MapObjectAdapter.get(object);
                            if (!this.processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter)) {
                                continue;
                            }
                            this.updateStencilRef(object);
                            object.position.copy(tile.center);
                            if (object.displacement !== void 0) {
                                object.position.add(object.displacement);
                            }
                            object.position.x += worldOffsetX;
                            object.position.sub(cameraPosition);
                            if (tile.localTangentSpace) {
                                object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());
                            }
                            object.frustumCulled = false;
                            rootNode.add(object);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    tile.didRender();
                }
            }
        },
        {
            key: "prepareRender",
            value: function prepareRender() {
                this.m_stencilValue = DEFAULT_STENCIL_VALUE;
                this.m_renderOrderStencilValues.clear();
            }
        },
        {
            key: "setupRenderer",
            value: function setupRenderer() {
                var stableSort = function(a, b) {
                    if (a.groupOrder !== b.groupOrder) {
                        return a.groupOrder - b.groupOrder;
                    } else if (a.renderOrder !== b.renderOrder) {
                        return a.renderOrder - b.renderOrder;
                    } else if (a.object.userData.tileKey && b.object.userData.tileKey && a.object.userData.tileKey.mortonCode() !== b.object.userData.tileKey.mortonCode()) {
                        return a.object.userData.tileKey.mortonCode() - b.object.userData.tileKey.mortonCode();
                    } else if (a.program !== b.program) {
                        return a.program.id - b.program.id;
                    } else if (a.material.id !== b.material.id) {
                        return a.material.id - b.material.id;
                    } else if (a.z !== b.z) {
                        return a.z - b.z;
                    } else {
                        return a.id - b.id;
                    }
                };
                var painterSortStable = function(a, b) {
                    var ref, ref1;
                    var mapObjectAdapterA = MapObjectAdapter.get(a.object);
                    var mapObjectAdapterB = MapObjectAdapter.get(b.object);
                    var dataSourceOrder = mapObjectAdapterA === null || mapObjectAdapterA === void 0 ? void 0 : (ref = mapObjectAdapterA.dataSource) === null || ref === void 0 ? void 0 : ref.dataSourceOrder;
                    var otherDataSourceOrder = mapObjectAdapterB === null || mapObjectAdapterB === void 0 ? void 0 : (ref1 = mapObjectAdapterB.dataSource) === null || ref1 === void 0 ? void 0 : ref1.dataSourceOrder;
                    if (dataSourceOrder !== void 0 && otherDataSourceOrder !== void 0 && dataSourceOrder !== otherDataSourceOrder) {
                        return dataSourceOrder - otherDataSourceOrder;
                    }
                    if (a.renderOrder === BackgroundDataSource.GROUND_RENDER_ORDER || b.renderOrder === BackgroundDataSource.GROUND_RENDER_ORDER) {
                        return stableSort(a, b);
                    }
                    if ((mapObjectAdapterA === null || mapObjectAdapterA === void 0 ? void 0 : mapObjectAdapterA.level) !== void 0 && (mapObjectAdapterB === null || mapObjectAdapterB === void 0 ? void 0 : mapObjectAdapterB.level) !== void 0) {
                        var ref2, ref3;
                        var eitherIsBuilding = ((ref2 = mapObjectAdapterA.kind) === null || ref2 === void 0 ? void 0 : ref2.find(function(s) {
                            return s === "building";
                        })) !== void 0 || ((ref3 = mapObjectAdapterB.kind) === null || ref3 === void 0 ? void 0 : ref3.find(function(s) {
                            return s === "building";
                        })) !== void 0;
                        var sameLevel = mapObjectAdapterA.level === mapObjectAdapterB.level;
                        if (sameLevel || eitherIsBuilding) {
                            return stableSort(a, b);
                        }
                        return mapObjectAdapterA.level - mapObjectAdapterB.level;
                    }
                    return stableSort(a, b);
                };
                this.m_renderer.setOpaqueSort(painterSortStable);
            }
        },
        {
            key: "updateStencilRef",
            value: function updateStencilRef(object) {
                var _this = this;
                if (object.renderOrder !== void 0 && _instanceof(object, SolidLineMesh)) {
                    var material = object.material;
                    if (Array.isArray(material)) {
                        material.forEach(function(mat) {
                            return mat.stencilRef = _this.getStencilValue(object.renderOrder);
                        });
                    } else {
                        material.stencilRef = this.getStencilValue(object.renderOrder);
                    }
                }
            }
        },
        {
            key: "allocateStencilValue",
            value: function allocateStencilValue(renderOrder) {
                var stencilValue = this.m_stencilValue++;
                this.m_renderOrderStencilValues.set(renderOrder, stencilValue);
                return stencilValue;
            }
        },
        {
            key: "getStencilValue",
            value: function getStencilValue(renderOrder) {
                var ref;
                return (ref = this.m_renderOrderStencilValues.get(renderOrder)) !== null && ref !== void 0 ? ref : this.allocateStencilValue(renderOrder);
            }
        },
        {
            key: "processTileObject",
            value: function processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter) {
                if (!object.visible) {
                    return false;
                }
                if (!this.processTileObjectFeatures(tile, storageLevel, zoomLevel, object)) {
                    return false;
                }
                if (mapObjectAdapter) {
                    mapObjectAdapter.ensureUpdated(tile.mapView);
                    if (!mapObjectAdapter.isVisible() && !(mapObjectAdapter.pickability === "all" /* all */ )) {
                        return false;
                    }
                }
                return true;
            }
        },
        {
            key: "processTileObjectFeatures",
            value: function processTileObjectFeatures(tile, storageLevel, zoomLevel, object) {
                var _this = this;
                var ref;
                var technique = object.userData.technique;
                var minZoomLevel = getPropertyValue(technique === null || technique === void 0 ? void 0 : technique.minZoomLevel, this.m_env);
                var maxZoomLevel = getPropertyValue(technique === null || technique === void 0 ? void 0 : technique.maxZoomLevel, this.m_env);
                if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
                    return false;
                }
                if (typeof maxZoomLevel === "number" && zoomLevel >= maxZoomLevel) {
                    return false;
                }
                if ((technique === null || technique === void 0 ? void 0 : technique.enabled) === void 0) {
                    return true;
                }
                var feature = object.userData.feature;
                if (!feature || !Expr3.isExpr(technique.enabled)) {
                    return Boolean(getPropertyValue(technique.enabled, this.m_env));
                }
                var starts = feature.starts, objInfos = feature.objInfos;
                if (!Array.isArray(objInfos) || !Array.isArray(starts)) {
                    return true;
                }
                var geometry = object.geometry;
                if (!geometry || !geometry.isBufferGeometry) {
                    return true;
                }
                var ref1;
                var finalIndex = (ref1 = (ref = geometry.getIndex()) === null || ref === void 0 ? void 0 : ref.count) !== null && ref1 !== void 0 ? ref1 : geometry.attributes.position.count;
                geometry.clearGroups();
                var endOfLastGroup;
                objInfos.forEach(function(properties, featureIndex) {
                    var featureId = getFeatureId(properties);
                    var enabled = true;
                    if (Expr3.isExpr(technique.enabled)) {
                        var featureState = tile.dataSource.getFeatureState(featureId);
                        var $state = featureState ? new MapEnv(featureState) : null;
                        var parentEnv = typeof properties === "object" ? new MapEnv(properties, _this.m_env) : _this.m_env;
                        var env = new MapEnv({
                            $state: $state
                        }, parentEnv);
                        enabled = Boolean(getPropertyValue(technique.enabled, env));
                    }
                    if (!enabled) {
                        return;
                    }
                    var _featureIndex;
                    var start = (_featureIndex = starts[featureIndex]) !== null && _featureIndex !== void 0 ? _featureIndex : 0;
                    var ref;
                    var end = (ref = starts[featureIndex + 1]) !== null && ref !== void 0 ? ref : finalIndex;
                    var count = end - start;
                    if (start === endOfLastGroup) {
                        geometry.groups[geometry.groups.length - 1].count += count;
                    } else {
                        geometry.addGroup(start, count);
                    }
                    endOfLastGroup = start + count;
                });
                return geometry.groups.length > 0;
            }
        }
    ]);
    return TileObjectRenderer;
}();
// src/mapview/VisibleTileSet.ts
var THREE90 = __toESM(require("three"));
var ResourceComputationType = /* @__PURE__ */ function(ResourceComputationType2) {
    ResourceComputationType2[ResourceComputationType2["EstimationInMb"] = 0] = "EstimationInMb";
    ResourceComputationType2[ResourceComputationType2["NumberOfTiles"] = 1] = "NumberOfTiles";
    return ResourceComputationType2;
}(ResourceComputationType || {});
var MB_FACTOR = 1 / (1024 * 1024);
var DataSourceCache = /*#__PURE__*/ function() {
    function DataSourceCache(cacheSize) {
        var rct = arguments.length > 1 && arguments[1] !== void 0 /* EstimationInMb */  ? arguments[1] : 0;
        var _this = this;
        _classCallCheck(this, DataSourceCache);
        __publicField(this, "m_tileCache");
        __publicField(this, "m_disposedTiles", []);
        __publicField(this, "m_resourceComputationType");
        this.m_resourceComputationType = rct;
        this.m_tileCache = new LRUCache(cacheSize, function(tile) {
            if (_this.m_resourceComputationType === 0 /* EstimationInMb */ ) {
                return tile.memoryUsage * MB_FACTOR;
            } else {
                return 1;
            }
        });
        this.m_tileCache.evictionCallback = function(_, tile) {
            if (tile.tileLoader !== void 0) {
                tile.tileLoader.cancel();
            }
            _this.m_disposedTiles.push(tile);
        };
        this.m_tileCache.canEvict = function(_, tile) {
            return !tile.isVisible;
        };
    }
    _createClass(DataSourceCache, [
        {
            key: "resourceComputationType",
            get: function get() {
                return this.m_resourceComputationType;
            }
        },
        {
            key: "capacity",
            get: function get() {
                return this.m_tileCache.capacity;
            }
        },
        {
            key: "size",
            get: function get() {
                return this.m_tileCache.size;
            }
        },
        {
            key: "setCapacity",
            value: function setCapacity(size, rct) {
                var _this = this;
                this.m_resourceComputationType = rct;
                this.m_tileCache.setCapacityAndMeasure(size, function(tile) {
                    if (_this.m_resourceComputationType === 0 /* EstimationInMb */ ) {
                        return tile.memoryUsage * MB_FACTOR;
                    } else {
                        return 1;
                    }
                });
            }
        },
        {
            key: "get",
            value: function get(mortonCode, offset, dataSource) {
                return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));
            }
        },
        {
            key: "set",
            value: function set(mortonCode, offset, dataSource, tile) {
                this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);
            }
        },
        {
            key: "delete",
            value: function _delete(tile) {
                var tileKey = DataSourceCache.getKeyForTile(tile);
                this.deleteByKey(tileKey);
            }
        },
        {
            key: "deleteByKey",
            value: function deleteByKey(tileKey) {
                this.m_tileCache.delete(tileKey);
            }
        },
        {
            key: "disposeTiles",
            value: function disposeTiles() {
                this.m_disposedTiles.forEach(function(tile) {
                    tile.dispose();
                });
                this.m_disposedTiles.length = 0;
            }
        },
        {
            key: "shrinkToCapacity",
            value: function shrinkToCapacity() {
                this.m_tileCache.shrinkToCapacity();
            }
        },
        {
            key: "evictAll",
            value: function evictAll() {
                this.m_tileCache.evictAll();
            }
        },
        {
            key: "evictSelected",
            value: function evictSelected(selector) {
                this.m_tileCache.evictSelected(selector);
            }
        },
        {
            key: "forEach",
            value: function forEach(callback, inDataSource) {
                this.m_tileCache.forEach(function(entry, key) {
                    if (inDataSource === void 0 || entry.dataSource === inDataSource) {
                        callback(entry, key);
                    }
                });
            }
        }
    ], [
        {
            key: "getKey",
            value: function getKey(mortonCode, offset, dataSource) {
                return "".concat(dataSource.name, "_").concat(mortonCode, "_").concat(offset);
            }
        },
        {
            key: "getKeyForTile",
            value: function getKeyForTile(tile) {
                return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);
            }
        }
    ]);
    return DataSourceCache;
}();
var compareDistances = function(a, b) {
    var distanceDiff = a.distance - b.distance;
    var minDiff = (a.distance + b.distance) * 1e-6;
    return Math.abs(distanceDiff) < minDiff ? a.tileKey.mortonCode() - b.tileKey.mortonCode() : distanceDiff;
};
var VisibleTileSet = /*#__PURE__*/ function() {
    function VisibleTileSet(m_frustumIntersection, m_tileGeometryManager, options, m_taskQueue) {
        _classCallCheck(this, VisibleTileSet);
        this.m_frustumIntersection = m_frustumIntersection;
        this.m_tileGeometryManager = m_tileGeometryManager;
        this.options = options;
        this.m_taskQueue = m_taskQueue;
        __publicField(this, "dataSourceTileList", []);
        __publicField(this, "allVisibleTilesLoaded", false);
        __publicField(this, "m_cameraOverride", new THREE90.PerspectiveCamera());
        __publicField(this, "m_dataSourceCache");
        __publicField(this, "m_viewRange", {
            near: 0.1,
            far: Infinity,
            minimum: 0.1,
            maximum: Infinity
        });
        __publicField(this, "m_coveringMap", /* @__PURE__ */ new Map());
        __publicField(this, "m_resourceComputationType", 0 /* EstimationInMb */ );
        this.options = options;
        var _maxTilesPerFrame;
        this.options.maxTilesPerFrame = Math.floor((_maxTilesPerFrame = this.options.maxTilesPerFrame) !== null && _maxTilesPerFrame !== void 0 ? _maxTilesPerFrame : 0);
        this.m_resourceComputationType = options.resourceComputationType === void 0 ? 0 /* EstimationInMb */  : options.resourceComputationType;
        this.m_dataSourceCache = new DataSourceCache(this.options.tileCacheSize, this.m_resourceComputationType);
    }
    _createClass(VisibleTileSet, [
        {
            key: "getDataSourceCacheSize",
            value: function getDataSourceCacheSize() {
                return this.options.tileCacheSize;
            }
        },
        {
            key: "setDataSourceCacheSize",
            value: function setDataSourceCacheSize(size) {
                var computationType = arguments.length > 1 && arguments[1] !== void 0 /* EstimationInMb */  ? arguments[1] : 0;
                this.options.tileCacheSize = size;
                this.resourceComputationType = computationType;
            }
        },
        {
            key: "getNumberOfVisibleTiles",
            value: function getNumberOfVisibleTiles() {
                return this.options.maxVisibleDataSourceTiles;
            }
        },
        {
            key: "setNumberOfVisibleTiles",
            value: function setNumberOfVisibleTiles(size) {
                this.options.maxVisibleDataSourceTiles = size;
            }
        },
        {
            key: "maxTilesPerFrame",
            get: function get() {
                return this.options.maxTilesPerFrame;
            },
            set: function set(value2) {
                if (value2 < 0) {
                    throw new Error("Invalid value, this will result in no tiles ever showing");
                }
                this.options.maxTilesPerFrame = Math.floor(value2);
            }
        },
        {
            key: "resourceComputationType",
            get: function get() {
                return this.m_resourceComputationType;
            },
            set: function set(computationType) {
                this.m_resourceComputationType = computationType;
                this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);
            }
        },
        {
            key: "updateClipPlanes",
            value: function updateClipPlanes(maxElevation, minElevation) {
                if (maxElevation !== void 0) {
                    this.options.clipPlanesEvaluator.maxElevation = maxElevation;
                }
                if (minElevation !== void 0) {
                    this.options.clipPlanesEvaluator.minElevation = minElevation;
                }
                var _mapView = this.m_frustumIntersection.mapView, camera = _mapView.camera, projection = _mapView.projection, elevationProvider = _mapView.elevationProvider;
                this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(camera, projection, elevationProvider);
                return this.m_viewRange;
            }
        },
        {
            key: "updateRenderList",
            value: function updateRenderList(storageLevel, zoomLevel, dataSources, frameNumber, elevationRangeSource) {
                var _this = this;
                var allVisibleTilesLoaded = true;
                var newTilesPerFrame = 0;
                var visibleTileKeysResult = this.getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource);
                this.dataSourceTileList = [];
                this.m_coveringMap.clear();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = visibleTileKeysResult.tileKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _value = _step.value, dataSource = _value.dataSource, visibleTileKeys = _value.visibleTileKeys;
                        visibleTileKeys.sort(compareDistances);
                        var dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);
                        var visibleResult = this.processVisibleTiles(visibleTileKeys, dataSource, frameNumber, {
                            newTilesPerFrame: newTilesPerFrame
                        }, true);
                        var dependentResult = this.processVisibleTiles(visibleResult.dependentTiles, dataSource, frameNumber, {
                            newTilesPerFrame: newTilesPerFrame
                        }, false);
                        this.m_tileGeometryManager.updateTiles(visibleResult.visibleTiles);
                        this.m_tileGeometryManager.updateTiles(dependentResult.visibleTiles);
                        this.dataSourceTileList.push({
                            dataSource: dataSource,
                            storageLevel: storageLevel,
                            zoomLevel: dataZoomLevel,
                            allVisibleTileLoaded: visibleResult.allDataSourceTilesLoaded && dependentResult.allDataSourceTilesLoaded,
                            numTilesLoading: visibleResult.numTilesLoading + dependentResult.numTilesLoading,
                            visibleTiles: _toConsumableArray(visibleResult.visibleTiles).concat(_toConsumableArray(dependentResult.visibleTiles)),
                            renderedTiles: /* @__PURE__ */ new Map()
                        });
                        allVisibleTilesLoaded = allVisibleTilesLoaded && visibleResult.allDataSourceTilesLoaded;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                this.allVisibleTilesLoaded = allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;
                this.populateRenderedTiles();
                this.forEachCachedTile(function(tile) {
                    if (!tile.isVisible && !tile.allGeometryLoaded) {
                        _this.disposeTile(tile);
                    }
                });
                this.m_dataSourceCache.shrinkToCapacity();
                var minElevation;
                var maxElevation;
                this.dataSourceTileList.forEach(function(renderListEntry) {
                    var tiles = renderListEntry.renderedTiles;
                    tiles.forEach(function(tile) {
                        tile.update(renderListEntry.zoomLevel);
                        minElevation = MathUtils.min2(minElevation, tile.geoBox.minAltitude);
                        maxElevation = MathUtils.max2(maxElevation, tile.geoBox.maxAltitude);
                    });
                });
                if (minElevation === void 0) {
                    minElevation = 0;
                }
                if (maxElevation === void 0) {
                    maxElevation = 0;
                }
                var viewRangesChanged = false;
                var oldViewRanges = this.m_viewRange;
                var newViewRanges = this.updateClipPlanes(maxElevation, minElevation);
                viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;
                return {
                    viewRanges: newViewRanges,
                    viewRangesChanged: viewRangesChanged
                };
            }
        },
        {
            key: "getTile",
            value: function getTile(dataSource, tileKey, offset, frameNumber) {
                var cacheOnly = false;
                return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);
            }
        },
        {
            key: "getCachedTile",
            value: function getCachedTile(dataSource, tileKey, offset, frameNumber) {
                assert(dataSource.cacheable);
                var cacheOnly = true;
                return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);
            }
        },
        {
            key: "getRenderedTile",
            value: function getRenderedTile(dataSource, tileKey) {
                var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                var dataSourceVisibleTileList = this.dataSourceTileList.find(function(list) {
                    return list.dataSource === dataSource;
                });
                if (dataSourceVisibleTileList === void 0) {
                    return void 0;
                }
                return dataSourceVisibleTileList.renderedTiles.get(TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset));
            }
        },
        {
            key: "getRenderedTileAtLocation",
            value: function getRenderedTileAtLocation(dataSource, geoPoint) {
                var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                var dataSourceVisibleTileList = this.dataSourceTileList.find(function(list) {
                    return list.dataSource === dataSource;
                });
                if (dataSourceVisibleTileList === void 0) {
                    return void 0;
                }
                var tilingScheme = dataSource.getTilingScheme();
                var visibleLevel = dataSourceVisibleTileList.zoomLevel;
                var visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);
                if (!visibleTileKey) {
                    return void 0;
                }
                var tile = dataSourceVisibleTileList.renderedTiles.get(TileKeyUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset));
                if (tile !== void 0) {
                    return tile;
                }
                var ref = this.getSearchDirection(dataSource, visibleLevel), searchLevelsUp = ref.searchLevelsUp, searchLevelsDown = ref.searchLevelsDown;
                var parentTileKey = visibleTileKey;
                for(var levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset){
                    parentTileKey = parentTileKey.parent();
                    tile = dataSourceVisibleTileList.renderedTiles.get(TileKeyUtils.getKeyForTileKeyAndOffset(parentTileKey, offset));
                    if (tile !== void 0) {
                        return tile;
                    }
                }
                var worldPoint = tilingScheme.projection.projectPoint(geoPoint);
                for(var levelOffset1 = 1; levelOffset1 <= searchLevelsDown; ++levelOffset1){
                    var childLevel = visibleLevel + levelOffset1;
                    var childTileKey = TileKeyUtils.worldCoordinatesToTileKey(tilingScheme, worldPoint, childLevel);
                    if (childTileKey) {
                        tile = dataSourceVisibleTileList.renderedTiles.get(TileKeyUtils.getKeyForTileKeyAndOffset(childTileKey, offset));
                        if (tile !== void 0) {
                            return tile;
                        }
                    }
                }
                return void 0;
            }
        },
        {
            key: "removeDataSource",
            value: function removeDataSource(dataSource) {
                this.clearTileCache(dataSource);
                this.dataSourceTileList = this.dataSourceTileList.filter(function(tileList) {
                    return tileList.dataSource !== dataSource;
                });
            }
        },
        {
            key: "clearTileCache",
            value: function clearTileCache(dataSource, filter) {
                if (dataSource !== void 0) {
                    this.m_dataSourceCache.evictSelected(function(tile, _) {
                        return tile.dataSource === dataSource && (filter !== void 0 ? filter(tile) : true);
                    });
                } else if (filter !== void 0) {
                    this.m_dataSourceCache.evictSelected(filter);
                } else {
                    this.m_dataSourceCache.evictAll();
                }
            }
        },
        {
            key: "markTilesDirty",
            value: function markTilesDirty(dataSource, filter) {
                var _this = this;
                if (dataSource === void 0) {
                    this.dataSourceTileList.forEach(function(renderListEntry) {
                        _this.markDataSourceTilesDirty(renderListEntry, filter);
                    });
                } else {
                    var renderListEntry = this.dataSourceTileList.find(function(e) {
                        return e.dataSource === dataSource;
                    });
                    if (renderListEntry === void 0) {
                        return;
                    }
                    this.markDataSourceTilesDirty(renderListEntry, filter);
                }
            }
        },
        {
            key: "disposePendingTiles",
            value: function disposePendingTiles() {
                this.m_dataSourceCache.disposeTiles();
            }
        },
        {
            key: "forEachVisibleTile",
            value: function forEachVisibleTile(fun) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.dataSourceTileList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var listEntry = _step.value;
                        listEntry.renderedTiles.forEach(fun);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "forEachCachedTile",
            value: function forEachCachedTile(fun, dataSource) {
                this.m_dataSourceCache.forEach(function(tile, _) {
                    return fun(tile);
                }, dataSource);
            }
        },
        {
            key: "disposeTile",
            value: function disposeTile(tile) {
                this.m_dataSourceCache.delete(tile);
                tile.dispose();
            }
        },
        {
            key: "processVisibleTiles",
            value: function processVisibleTiles(visibleTileKeys, dataSource, frameNumber, refs, processDependentTiles) {
                var allDataSourceTilesLoaded = true;
                var numTilesLoading = 0;
                var visibleTiles = [];
                var dependentTiles = [];
                for(var i = 0; i < visibleTileKeys.length && visibleTiles.length < this.options.maxVisibleDataSourceTiles; i++){
                    var tileEntry = visibleTileKeys[i];
                    var tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset, frameNumber);
                    if (tile === void 0) {
                        continue;
                    }
                    visibleTiles.push(tile);
                    allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;
                    if (!tile.allGeometryLoaded) {
                        numTilesLoading++;
                    } else {
                        this.skipOverlappedTiles(dataSource, tile);
                        if (this.processDelayTileRendering(tile, refs.newTilesPerFrame, frameNumber)) {
                            refs.newTilesPerFrame++;
                        }
                    }
                    tile.visibleArea = tileEntry.area;
                    var _elevationRange;
                    tile.elevationRange = (_elevationRange = tileEntry.elevationRange) !== null && _elevationRange !== void 0 ? _elevationRange : {
                        minElevation: 0,
                        maxElevation: 0
                    };
                    if (processDependentTiles) {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            var _loop = function(_iterator, _step) {
                                var tileKey = _step.value;
                                if (visibleTileKeys.find(function(tileKeyEntry) {
                                    return tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode();
                                }) === void 0 && dependentTiles.find(function(tileKeyEntry) {
                                    return tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode();
                                }) === void 0) {
                                    dependentTiles.push(new TileKeyEntry(tileKey, 0));
                                }
                            };
                            for(var _iterator = tile.dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                }
                return {
                    allDataSourceTilesLoaded: allDataSourceTilesLoaded,
                    numTilesLoading: numTilesLoading,
                    visibleTiles: visibleTiles,
                    dependentTiles: dependentTiles
                };
            }
        },
        {
            key: "processDelayTileRendering",
            value: function processDelayTileRendering(tile, newTilesPerFrame, frameNumber) {
                var isNewTile = false;
                if (this.options.maxTilesPerFrame !== 0 && newTilesPerFrame > this.options.maxTilesPerFrame && !(tile.frameNumLastVisible === frameNumber - 1)) {
                    tile.delayRendering = true;
                    tile.mapView.update();
                } else {
                    if (tile.frameNumVisible < 0) {
                        tile.frameNumVisible = frameNumber;
                        isNewTile = true;
                    }
                    tile.numFramesVisible++;
                    tile.delayRendering = false;
                }
                return isNewTile;
            }
        },
        {
            key: "skipOverlappedTiles",
            value: function skipOverlappedTiles(dataSource, tile) {
                if (this.options.projection.type === 1 /* Spherical */ ) {
                    return;
                }
                if (dataSource.isFullyCovering()) {
                    var key = tile.uniqueKey;
                    var entry = this.m_coveringMap.get(key);
                    if (entry === void 0) {
                        tile.skipRendering = false;
                        this.m_coveringMap.set(key, tile);
                    } else {
                        if (_instanceof(entry.dataSource, BackgroundDataSource)) {
                            entry.skipRendering = true;
                        } else if (_instanceof(dataSource, BackgroundDataSource)) {
                            tile.skipRendering = true;
                        }
                    }
                }
            }
        },
        {
            key: "getSearchDirection",
            value: function getSearchDirection(dataSource, visibleLevel) {
                var searchLevelsUp = Math.min(this.options.quadTreeSearchDistanceUp, Math.max(0, visibleLevel - dataSource.minDataLevel));
                var searchLevelsDown = Math.min(this.options.quadTreeSearchDistanceDown, Math.max(0, dataSource.maxDataLevel - visibleLevel));
                var searchDirection = searchLevelsDown > 0 && searchLevelsUp > 0 ? 3 /* BOTH */  : searchLevelsDown > 0 ? 2 /* DOWN */  : searchLevelsUp > 0 ? 1 /* UP */  : 0 /* NONE */ ;
                return {
                    searchDirection: searchDirection,
                    searchLevelsUp: searchLevelsUp,
                    searchLevelsDown: searchLevelsDown
                };
            }
        },
        {
            key: "populateRenderedTiles",
            value: function populateRenderedTiles() {
                var _this = this;
                this.dataSourceTileList.forEach(function(renderListEntry) {
                    var renderedTiles = renderListEntry.renderedTiles;
                    var incompleteTiles = [];
                    renderListEntry.visibleTiles.forEach(function(tile) {
                        tile.levelOffset = 0;
                        if (tile.hasGeometry && !tile.delayRendering) {
                            renderedTiles.set(tile.uniqueKey, tile);
                        } else {
                            incompleteTiles.push(tile.uniqueKey);
                        }
                    });
                    var dataSource = renderListEntry.dataSource;
                    if (incompleteTiles.length === 0 || dataSource.allowOverlappingTiles === false) {
                        return;
                    }
                    var dataZoomLevel = renderListEntry.zoomLevel;
                    var searchDirection = _this.getSearchDirection(dataSource, dataZoomLevel).searchDirection;
                    var checkedTiles = /* @__PURE__ */ new Map();
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = incompleteTiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var tileKeyCode = _step.value;
                            if (searchDirection === 3 /* BOTH */  || searchDirection === 1 /* UP */ ) {
                                if (_this.findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource)) {
                                    continue;
                                }
                            }
                            if (searchDirection === 3 /* BOTH */  || searchDirection === 2 /* DOWN */ ) {
                                _this.findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                });
            }
        },
        {
            key: "findDown",
            value: function findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource) {
                var ref = TileKeyUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode), offset = ref.offset, mortonCode = ref.mortonCode;
                var tileKey = TileKey.fromMortonCode(mortonCode);
                var tilingScheme = dataSource.getTilingScheme();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = tilingScheme.getSubTileKeys(tileKey)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var childTileKey = _step.value;
                        var childTileCode = TileKeyUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
                        var childTile = this.m_dataSourceCache.get(childTileKey.mortonCode(), offset, dataSource);
                        var nextLevelDiff = Math.abs(childTileKey.level - dataZoomLevel);
                        if (childTile !== void 0 && childTile.hasGeometry && !childTile.delayRendering) {
                            renderedTiles.set(childTileCode, childTile);
                            childTile.levelOffset = nextLevelDiff;
                            continue;
                        }
                        if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {
                            this.findDown(childTileCode, dataZoomLevel, renderedTiles, dataSource);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "findUp",
            value: function findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource) {
                var parentCode = TileKeyUtils.getParentKeyFromKey(tileKeyCode);
                if (renderedTiles.get(parentCode) !== void 0) {
                    return true;
                }
                var exists = checkedTiles.get(parentCode);
                if (exists !== void 0) {
                    return exists;
                }
                var ref = TileKeyUtils.extractOffsetAndMortonKeyFromKey(parentCode), offset = ref.offset, mortonCode = ref.mortonCode;
                var parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);
                var parentTileKey = parentTile ? parentTile.tileKey : TileKey.fromMortonCode(mortonCode);
                var nextLevelDiff = Math.abs(dataZoomLevel - parentTileKey.level);
                if (parentTile !== void 0 && parentTile.hasGeometry && !parentTile.delayRendering) {
                    checkedTiles.set(parentCode, true);
                    renderedTiles.set(parentCode, parentTile);
                    parentTile.levelOffset = -nextLevelDiff;
                    return true;
                } else {
                    checkedTiles.set(parentCode, false);
                }
                if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {
                    var foundUp = this.findUp(parentCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource);
                    checkedTiles.set(parentCode, foundUp);
                    if (foundUp) {
                        return true;
                    }
                }
                return false;
            }
        },
        {
            key: "getTileImpl",
            value: function getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber) {
                var touchTile = function touchTile(tileToUpdate) {
                    tileToUpdate.frameNumLastRequested = frameNumber;
                };
                if (!dataSource.cacheable && !cacheOnly) {
                    var resultTile = dataSource.getTile(tileKey, true);
                    if (resultTile !== void 0) {
                        this.addToTaskQueue(resultTile);
                        touchTile(resultTile);
                    }
                    return resultTile;
                }
                var tileCache = this.m_dataSourceCache;
                var tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);
                if (tile !== void 0 && tile.offset === offset) {
                    touchTile(tile);
                    return tile;
                }
                if (cacheOnly) {
                    return void 0;
                }
                tile = dataSource.getTile(tileKey, true);
                if (tile !== void 0) {
                    this.addToTaskQueue(tile);
                    tile.offset = offset;
                    touchTile(tile);
                    tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);
                }
                return tile;
            }
        },
        {
            key: "addToTaskQueue",
            value: function addToTaskQueue(tile) {
                this.m_taskQueue.add({
                    execute: tile.load.bind(tile),
                    group: "fetch" /* FETCH_AND_DECODE */ ,
                    getPriority: function() {
                        var ref;
                        var ref1;
                        return (ref1 = tile === null || tile === void 0 ? void 0 : (ref = tile.tileLoader) === null || ref === void 0 ? void 0 : ref.priority) !== null && ref1 !== void 0 ? ref1 : 0;
                    },
                    isExpired: function() {
                        return !(tile === null || tile === void 0 ? void 0 : tile.isVisible);
                    },
                    estimatedProcessTime: function() {
                        return 1;
                    }
                });
            }
        },
        {
            key: "markDataSourceTilesDirty",
            value: function markDataSourceTilesDirty(renderListEntry, filter) {
                var _this = this;
                var dataSourceCache = this.m_dataSourceCache;
                var retainedTiles = /* @__PURE__ */ new Set();
                var markTileDirty = function(tile) {
                    var tileKey = DataSourceCache.getKeyForTile(tile);
                    if (!retainedTiles.has(tileKey)) {
                        var ref;
                        retainedTiles.add(tileKey);
                        (ref = tile.tileLoader) === null || ref === void 0 ? void 0 : ref.cancel();
                        _this.addToTaskQueue(tile);
                    }
                };
                renderListEntry.visibleTiles.forEach(function(tile) {
                    if (filter === void 0 || filter(tile)) {
                        markTileDirty(tile);
                    }
                });
                renderListEntry.renderedTiles.forEach(function(tile) {
                    if (filter === void 0 || filter(tile)) {
                        markTileDirty(tile);
                    }
                });
                dataSourceCache.forEach(function(tile, key) {
                    if ((filter === void 0 || filter(tile)) && !retainedTiles.has(key)) {
                        dataSourceCache.deleteByKey(key);
                        tile.dispose();
                    }
                }, renderListEntry.dataSource);
            }
        },
        {
            key: "getVisibleTileKeysForDataSources",
            value: function getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource) {
                var tileKeys = Array();
                var allBoundingBoxesFinal = true;
                if (dataSources.length === 0) {
                    return {
                        tileKeys: tileKeys,
                        allBoundingBoxesFinal: allBoundingBoxesFinal
                    };
                }
                var dataSourceBuckets = /* @__PURE__ */ new Map();
                dataSources.forEach(function(dataSource) {
                    var tilingScheme = dataSource.getTilingScheme();
                    var bucket = dataSourceBuckets.get(tilingScheme);
                    if (bucket === void 0) {
                        dataSourceBuckets.set(tilingScheme, [
                            dataSource
                        ]);
                    } else {
                        bucket.push(dataSource);
                    }
                });
                if (elevationRangeSource !== void 0) {
                    this.m_cameraOverride.copy(this.m_frustumIntersection.camera);
                    this.m_cameraOverride.near = Math.min(this.m_cameraOverride.near, this.m_viewRange.minimum);
                    this.m_cameraOverride.far = Math.max(this.m_cameraOverride.far, this.m_viewRange.maximum);
                    this.m_cameraOverride.updateProjectionMatrix();
                    this.m_frustumIntersection.updateFrustum(this.m_cameraOverride.projectionMatrix);
                } else {
                    this.m_frustumIntersection.updateFrustum();
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    var _this = this, _loop = function(_iterator, _step) {
                        var _value = _slicedToArray(_step.value, 2), tilingScheme = _value[0], bucket = _value[1];
                        var zoomLevels = bucket.map(function(dataSource) {
                            return dataSource.getDataZoomLevel(zoomLevel);
                        });
                        var result = _this.m_frustumIntersection.compute(tilingScheme, elevationRangeSource, zoomLevels, bucket);
                        allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator1 = bucket[Symbol.iterator](), _step1; !(_iteratorNormalCompletion = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion = true){
                                var dataSource = _step1.value;
                                var visibleTileKeys = [];
                                var dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);
                                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                try {
                                    for(var _iterator2 = result.tileKeyEntries.get(dataZoomLevel).values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion1 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion1 = true){
                                        var tileKeyEntry = _step2.value;
                                        if (dataSource.canGetTile(dataZoomLevel, tileKeyEntry.tileKey)) {
                                            visibleTileKeys.push(tileKeyEntry);
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError1 = true;
                                    _iteratorError1 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion1 && _iterator2.return != null) {
                                            _iterator2.return();
                                        }
                                    } finally{
                                        if (_didIteratorError1) {
                                            throw _iteratorError1;
                                        }
                                    }
                                }
                                tileKeys.push({
                                    dataSource: dataSource,
                                    visibleTileKeys: visibleTileKeys
                                });
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    };
                    for(var _iterator = dataSourceBuckets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return {
                    tileKeys: tileKeys,
                    allBoundingBoxesFinal: allBoundingBoxesFinal
                };
            }
        }
    ]);
    return VisibleTileSet;
}();
function viewRangesEqual(a, b) {
    return a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near;
}
// src/mapview/MapView.ts
var isProduction2 = process.env.NODE_ENV === "production";
var TileTaskGroups = /* @__PURE__ */ function(TileTaskGroups2) {
    TileTaskGroups2["FETCH_AND_DECODE"] = "fetch";
    TileTaskGroups2["CREATE"] = "create";
    return TileTaskGroups2;
}(TileTaskGroups || {});
var logger24 = LoggerManager.instance.create("MapView");
var DEFAULT_CAM_NEAR_PLANE = 0.1;
var DEFAULT_CAM_FAR_PLANE = 4e6;
var DEFAULT_MIN_ZOOM_LEVEL2 = 1;
var DEFAULT_MAX_ZOOM_LEVEL = 20;
var DEFAULT_MIN_CAMERA_HEIGHT = 20;
var DEFAULT_POLAR_STYLE_SET_NAME = "polar";
var MapViewDefaults = {
    projection: mercatorProjection,
    addBackgroundDatasource: true,
    maxVisibleDataSourceTiles: 100,
    extendedFrustumCulling: true,
    tileCacheSize: 200,
    resourceComputationType: 0 /* EstimationInMb */ ,
    quadTreeSearchDistanceUp: 3,
    quadTreeSearchDistanceDown: 2,
    pixelRatio: typeof window !== "undefined" && window.devicePixelRatio !== void 0 ? window.devicePixelRatio : 1,
    target: new GeoCoordinates(25, 0),
    zoomLevel: 5,
    tilt: 0,
    heading: 0,
    theme: {},
    maxTilesPerFrame: 0
};
var MapView3 = /*#__PURE__*/ function(EventDispatcher) {
    _inherits(MapView3, EventDispatcher);
    var _super = _createSuper(MapView3);
    function MapView3(options) {
        _classCallCheck(this, MapView3);
        var _this;
        _this = _super.call(this);
        __publicField(_assertThisInitialized(_this), "handleRequestAnimationFrame");
        __publicField(_assertThisInitialized(_this), "m_animatedExtrusionHandler");
        __publicField(_assertThisInitialized(_this), "m_animationCount", 0);
        __publicField(_assertThisInitialized(_this), "m_animationFrameHandle");
        __publicField(_assertThisInitialized(_this), "m_camera");
        __publicField(_assertThisInitialized(_this), "m_canvas");
        __publicField(_assertThisInitialized(_this), "m_collisionDebugCanvas");
        __publicField(_assertThisInitialized(_this), "m_connectedDataSources", /* @__PURE__ */ new Set());
        __publicField(_assertThisInitialized(_this), "m_context");
        __publicField(_assertThisInitialized(_this), "m_copyrightInfo", []);
        __publicField(_assertThisInitialized(_this), "m_disposed", false);
        __publicField(_assertThisInitialized(_this), "m_drawing", false);
        __publicField(_assertThisInitialized(_this), "m_elevationProvider");
        __publicField(_assertThisInitialized(_this), "m_elevationRangeSource");
        __publicField(_assertThisInitialized(_this), "m_elevationSource");
        __publicField(_assertThisInitialized(_this), "m_enableMixedLod");
        __publicField(_assertThisInitialized(_this), "m_enablePolarDataSource", true);
        __publicField(_assertThisInitialized(_this), "m_env", new MapEnv({}));
        __publicField(_assertThisInitialized(_this), "m_failedDataSources", /* @__PURE__ */ new Set());
        __publicField(_assertThisInitialized(_this), "m_firstFrameComplete", false);
        __publicField(_assertThisInitialized(_this), "m_firstFrameRendered", false);
        __publicField(_assertThisInitialized(_this), "m_forceCameraAspect");
        __publicField(_assertThisInitialized(_this), "m_frameNumber", 0);
        __publicField(_assertThisInitialized(_this), "m_geoMaxBounds");
        __publicField(_assertThisInitialized(_this), "m_languages");
        __publicField(_assertThisInitialized(_this), "m_lastTileIds", "");
        __publicField(_assertThisInitialized(_this), "m_lodMinTilePixelSize");
        __publicField(_assertThisInitialized(_this), "m_mapAnchors", new MapAnchors());
        __publicField(_assertThisInitialized(_this), "mapRenderingManager");
        __publicField(_assertThisInitialized(_this), "m_maxZoomLevel", DEFAULT_MAX_ZOOM_LEVEL);
        __publicField(_assertThisInitialized(_this), "m_minCameraHeight", DEFAULT_MIN_CAMERA_HEIGHT);
        __publicField(_assertThisInitialized(_this), "m_minZoomLevel", DEFAULT_MIN_ZOOM_LEVEL2);
        __publicField(_assertThisInitialized(_this), "m_movementDetector");
        __publicField(_assertThisInitialized(_this), "m_movementFinishedUpdateTimerId");
        __publicField(_assertThisInitialized(_this), "m_options");
        __publicField(_assertThisInitialized(_this), "m_overlayScene", new THREE91.Scene());
        __publicField(_assertThisInitialized(_this), "m_overlaySceneRoot", new THREE91.Object3D());
        __publicField(_assertThisInitialized(_this), "m_pickHandler");
        __publicField(_assertThisInitialized(_this), "m_pitch", 0);
        __publicField(_assertThisInitialized(_this), "m_pixelRatio");
        __publicField(_assertThisInitialized(_this), "m_pixelToWorld");
        __publicField(_assertThisInitialized(_this), "m_plane", new THREE91.Plane(new THREE91.Vector3(0, 0, 1)));
        __publicField(_assertThisInitialized(_this), "m_poiManager", new PoiManager(_assertThisInitialized(_this)));
        __publicField(_assertThisInitialized(_this), "m_pointOfView");
        __publicField(_assertThisInitialized(_this), "m_poiTableManager", new PoiTableManager(_assertThisInitialized(_this)));
        __publicField(_assertThisInitialized(_this), "m_polarDataSource");
        __publicField(_assertThisInitialized(_this), "m_politicalView");
        __publicField(_assertThisInitialized(_this), "m_postEffects");
        __publicField(_assertThisInitialized(_this), "m_previousFrameTimeStamp");
        __publicField(_assertThisInitialized(_this), "m_raycaster", new THREE91.Raycaster());
        __publicField(_assertThisInitialized(_this), "m_renderer");
        __publicField(_assertThisInitialized(_this), "m_renderLabels", true);
        __publicField(_assertThisInitialized(_this), "m_roll", 0);
        __publicField(_assertThisInitialized(_this), "m_rteCamera", new THREE91.PerspectiveCamera());
        __publicField(_assertThisInitialized(_this), "m_scene", new THREE91.Scene());
        __publicField(_assertThisInitialized(_this), "m_sceneEntity");
        __publicField(_assertThisInitialized(_this), "m_sceneEnvironment");
        __publicField(_assertThisInitialized(_this), "m_sceneRoot", new THREE91.Object3D());
        __publicField(_assertThisInitialized(_this), "m_screenProjector");
        __publicField(_assertThisInitialized(_this), "m_sphere", new THREE91.Sphere(void 0, EarthConstants.EQUATORIAL_RADIUS));
        __publicField(_assertThisInitialized(_this), "m_targetGeoPos", GeoCoordinates.fromObject(MapViewDefaults.target));
        __publicField(_assertThisInitialized(_this), "m_targetDistance", 0);
        __publicField(_assertThisInitialized(_this), "m_targetWorldPos", new THREE91.Vector3());
        __publicField(_assertThisInitialized(_this), "m_taskScheduler");
        __publicField(_assertThisInitialized(_this), "m_taskSchedulerTimeout");
        __publicField(_assertThisInitialized(_this), "m_textElementsRenderer");
        __publicField(_assertThisInitialized(_this), "m_themeManager");
        __publicField(_assertThisInitialized(_this), "m_thisFrameTilesChanged");
        __publicField(_assertThisInitialized(_this), "m_tileDataSources", []);
        __publicField(_assertThisInitialized(_this), "m_tileGeometryManager");
        __publicField(_assertThisInitialized(_this), "m_tileObjectRenderer");
        __publicField(_assertThisInitialized(_this), "m_tileWrappingEnabled", true);
        __publicField(_assertThisInitialized(_this), "m_updatePending", false);
        __publicField(_assertThisInitialized(_this), "m_uriResolver");
        __publicField(_assertThisInitialized(_this), "m_userImageCache", new MapViewImageCache());
        __publicField(_assertThisInitialized(_this), "m_viewRanges", {
            near: DEFAULT_CAM_NEAR_PLANE,
            far: DEFAULT_CAM_FAR_PLANE,
            minimum: DEFAULT_CAM_NEAR_PLANE,
            maximum: DEFAULT_CAM_FAR_PLANE
        });
        __publicField(_assertThisInitialized(_this), "m_visibleTiles");
        __publicField(_assertThisInitialized(_this), "m_visibleTileSetLock", false);
        __publicField(_assertThisInitialized(_this), "m_visibleTileSetOptions");
        __publicField(_assertThisInitialized(_this), "m_world");
        __publicField(_assertThisInitialized(_this), "m_worldMaxBounds");
        __publicField(_assertThisInitialized(_this), "m_yaw", 0);
        __publicField(_assertThisInitialized(_this), "m_zoomLevel", DEFAULT_MIN_ZOOM_LEVEL2);
        __publicField(_assertThisInitialized(_this), "UPDATE_EVENT", {
            type: MapViewEventNames.Update
        });
        __publicField(_assertThisInitialized(_this), "RENDER_EVENT", {
            type: MapViewEventNames.Render
        });
        __publicField(_assertThisInitialized(_this), "DID_RENDER_EVENT", {
            type: MapViewEventNames.AfterRender
        });
        __publicField(_assertThisInitialized(_this), "FIRST_FRAME_EVENT", {
            type: MapViewEventNames.FirstFrame
        });
        __publicField(_assertThisInitialized(_this), "FRAME_COMPLETE_EVENT", {
            type: MapViewEventNames.FrameComplete
        });
        __publicField(_assertThisInitialized(_this), "THEME_LOADED_EVENT", {
            type: MapViewEventNames.ThemeLoaded
        });
        __publicField(_assertThisInitialized(_this), "ANIMATION_STARTED_EVENT", {
            type: MapViewEventNames.AnimationStarted
        });
        __publicField(_assertThisInitialized(_this), "ANIMATION_FINISHED_EVENT", {
            type: MapViewEventNames.AnimationFinished
        });
        __publicField(_assertThisInitialized(_this), "MOVEMENT_STARTED_EVENT", {
            type: MapViewEventNames.MovementStarted
        });
        __publicField(_assertThisInitialized(_this), "MOVEMENT_FINISHED_EVENT", {
            type: MapViewEventNames.MovementFinished
        });
        __publicField(_assertThisInitialized(_this), "CONTEXT_LOST_EVENT", {
            type: MapViewEventNames.ContextLost
        });
        __publicField(_assertThisInitialized(_this), "CONTEXT_RESTORED_EVENT", {
            type: MapViewEventNames.ContextRestored
        });
        __publicField(_assertThisInitialized(_this), "COPYRIGHT_CHANGED_EVENT", {
            type: MapViewEventNames.CopyrightChanged
        });
        __publicField(_assertThisInitialized(_this), "DISPOSE_EVENT", {
            type: MapViewEventNames.Dispose
        });
        __publicField(_assertThisInitialized(_this), "onWebGLContextLost", function(event) {
            _this.dispatchEvent(_this.CONTEXT_LOST_EVENT);
            logger24.warn("WebGL context lost", event);
        });
        __publicField(_assertThisInitialized(_this), "onWebGLContextRestored", function(event) {
            _this.dispatchEvent(_this.CONTEXT_RESTORED_EVENT);
            if (_this.m_renderer !== void 0) {
                _this.textElementsRenderer.restoreRenderers(_this.m_renderer);
                _this.getTheme().then(function(theme) {
                    _this.m_sceneEnvironment.updateClearColor(theme.clearColor, theme.clearAlpha);
                    _this.update();
                });
            }
            logger24.warn("WebGL context restored", event);
        });
        _this.m_options = _objectSpread({}, options);
        _this.m_uriResolver = _this.m_options.uriResolver;
        if (_this.m_options.minZoomLevel !== void 0) {
            _this.m_minZoomLevel = _this.m_options.minZoomLevel;
        }
        if (_this.m_options.maxZoomLevel !== void 0) {
            _this.m_maxZoomLevel = _this.m_options.maxZoomLevel;
        }
        if (_this.m_options.minCameraHeight !== void 0) {
            _this.m_minCameraHeight = _this.m_options.minCameraHeight;
        }
        if (_this.m_options.maxBounds !== void 0) {
            _this.m_geoMaxBounds = _this.m_options.maxBounds;
        }
        if (_this.m_options.decoderUrl !== void 0) {
            ConcurrentDecoderFacade.defaultScriptUrl = _this.m_uriResolver ? _this.m_uriResolver.resolveUri(_this.m_options.decoderUrl) : _this.m_options.decoderUrl;
        }
        if (_this.m_options.decoderCount !== void 0) {
            ConcurrentDecoderFacade.defaultWorkerCount = _this.m_options.decoderCount;
        }
        _this.m_visibleTileSetOptions = _objectSpreadProps(_objectSpread({}, MapViewDefaults), {
            clipPlanesEvaluator: options.clipPlanesEvaluator !== void 0 ? options.clipPlanesEvaluator : createDefaultClipPlanesEvaluator()
        });
        if (options.projection !== void 0) {
            _this.m_visibleTileSetOptions.projection = options.projection;
        }
        if (options.extendedFrustumCulling !== void 0) {
            _this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;
        }
        if (options.maxVisibleDataSourceTiles !== void 0) {
            _this.m_visibleTileSetOptions.maxVisibleDataSourceTiles = options.maxVisibleDataSourceTiles;
        }
        if (options.tileCacheSize !== void 0) {
            _this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;
        }
        if (options.resourceComputationType !== void 0) {
            _this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;
        }
        if (options.quadTreeSearchDistanceUp !== void 0) {
            _this.m_visibleTileSetOptions.quadTreeSearchDistanceUp = options.quadTreeSearchDistanceUp;
        }
        if (options.quadTreeSearchDistanceDown !== void 0) {
            _this.m_visibleTileSetOptions.quadTreeSearchDistanceDown = options.quadTreeSearchDistanceDown;
        }
        if (options.enablePolarDataSource !== void 0) {
            _this.m_enablePolarDataSource = options.enablePolarDataSource;
        }
        _this.m_pixelRatio = options.pixelRatio;
        var _maxFps;
        _this.m_options.maxFps = (_maxFps = _this.m_options.maxFps) !== null && _maxFps !== void 0 ? _maxFps : 0;
        _this.m_options.enableStatistics = _this.m_options.enableStatistics === true;
        _this.m_languages = _this.m_options.languages;
        _this.m_politicalView = _this.m_options.politicalView;
        _this.handleRequestAnimationFrame = _this.renderLoop.bind(_assertThisInitialized(_this));
        if (_this.m_options.tileWrappingEnabled !== void 0) {
            _this.m_tileWrappingEnabled = _this.m_options.tileWrappingEnabled;
        }
        _this.setupStats(_this.m_options.enableStatistics);
        if (_this.m_options.renderer !== void 0) {
            _this.m_renderer = _this.m_options.renderer;
            _this.m_canvas = _this.m_options.renderer.domElement;
            console.log("Renderer set to passed-in renderer:", _this.m_renderer);
        } else {
            _this.m_canvas = _this.m_options.canvas;
            var _WebGL1Renderer;
            _this.m_renderer = new ((_WebGL1Renderer = THREE91.WebGL1Renderer) !== null && _WebGL1Renderer !== void 0 ? _WebGL1Renderer : THREE91.WebGLRenderer)({
                canvas: _this.m_canvas
            });
        }
        _this.m_renderer.autoClear = false;
        _this.m_renderer.debug.checkShaderErrors = !isProduction2;
        _this.m_context = _this.m_renderer.getContext();
        _this.m_canvas.addEventListener("webglcontextlost", _this.onWebGLContextLost);
        _this.m_canvas.addEventListener("webglcontextrestored", _this.onWebGLContextRestored);
        _this.m_renderer.info.autoReset = false;
        _this.m_tileObjectRenderer = new TileObjectRenderer(_this.m_env, _this.m_renderer);
        _this.setupRenderer(_this.m_tileObjectRenderer);
        _this.m_options.fovCalculation = _this.m_options.fovCalculation === void 0 ? DEFAULT_FOV_CALCULATION : _this.m_options.fovCalculation;
        _this.m_options.fovCalculation.fov = THREE91.MathUtils.clamp(_this.m_options.fovCalculation.fov, MIN_FOV_DEG, MAX_FOV_DEG);
        var ref = _this.getCanvasClientSize(), width = ref.width, height = ref.height;
        var aspect = width / height;
        if (_this.m_options.camera !== void 0) {
            _this.m_camera = _this.m_options.camera;
            console.log("Camera set to passed-in camera:", _this.m_camera);
        } else {
            _this.m_camera = new THREE91.PerspectiveCamera(_this.m_options.fovCalculation.fov, aspect, DEFAULT_CAM_NEAR_PLANE, DEFAULT_CAM_FAR_PLANE);
        }
        _this.m_camera.up.set(0, 0, 1);
        _this.setFovOnCamera(_this.m_options.fovCalculation, height);
        _this.projection.projectPoint(_this.m_targetGeoPos, _this.m_targetWorldPos);
        _this.m_scene.add(_this.m_camera);
        _this.m_screenProjector = new ScreenProjector(_this.m_camera);
        _this.m_taskScheduler = new MapViewTaskScheduler(_this.maxFps);
        _this.m_tileGeometryManager = new TileGeometryManager(_assertThisInitialized(_this));
        if (options.enableMixedLod !== void 0) {
            _this.m_enableMixedLod = options.enableMixedLod;
        }
        if (options.lodMinTilePixelSize !== void 0) {
            _this.m_lodMinTilePixelSize = options.lodMinTilePixelSize;
        }
        _this.m_visibleTiles = _this.createVisibleTileSet();
        _this.m_sceneEnvironment = new MapViewEnvironment(_assertThisInitialized(_this), options);
        _this.setupCamera();
        _this.m_pickHandler = new PickHandler(_assertThisInitialized(_this), _this.m_rteCamera, _this.m_options.enablePickTechnique === true);
        _this.m_movementDetector = new CameraMovementDetector(_this.m_options.movementThrottleTimeout, function() {
            return _this.movementStarted();
        }, function() {
            return _this.movementFinished();
        });
        var mapPassAntialiasSettings = _this.m_options.customAntialiasSettings;
        _this.mapRenderingManager = new MapRenderingManager(width, height, _this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);
        _this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler(_assertThisInitialized(_this));
        if (_this.m_enablePolarDataSource) {
            var styleSetName = options.polarStyleSetName !== void 0 ? options.polarStyleSetName : DEFAULT_POLAR_STYLE_SET_NAME;
            _this.m_polarDataSource = new PolarTileDataSource({
                styleSetName: styleSetName,
                geometryLevelOffset: options.polarGeometryLevelOffset
            });
            _this.updatePolarDataSource();
        }
        _this.m_taskScheduler.addEventListener(MapViewEventNames.Update, function() {
            _this.update();
        });
        if (options.throttlingEnabled !== void 0) {
            _this.m_taskScheduler.throttlingEnabled = options.throttlingEnabled;
        }
        _this.m_themeManager = new MapViewThemeManager(_assertThisInitialized(_this), _this.m_uriResolver);
        _this.m_textElementsRenderer = _this.createTextRenderer();
        _this.setTheme(getOptionValue(_this.m_options.theme, MapViewDefaults.theme));
        _this.update();
        return _this;
    }
    _createClass(MapView3, [
        {
            key: "addDataSource",
            value: function addDataSource(dataSource) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var ref, twinDataSource, conflictingDataSource, alreadyRemoved, theme, _message;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                ;
                                twinDataSource = _this.getDataSourceByName(dataSource.name);
                                if (!(twinDataSource !== void 0)) {
                                    _ctx.next = 4;
                                    break;
                                }
                                throw new Error('A DataSource with the name "'.concat(dataSource.name, '" already exists in this MapView.'));
                            case 4:
                                dataSource.attach(_this);
                                dataSource.setEnableElevationOverlay(_this.m_elevationProvider !== void 0);
                                conflictingDataSource = _this.m_tileDataSources.find(function(ds) {
                                    return ds.addGroundPlane === true && !_instanceof(ds, BackgroundDataSource);
                                });
                                if (dataSource.addGroundPlane === true && conflictingDataSource !== void 0) {
                                    console.warn("The DataSources ".concat(dataSource.name, " and ").concat(conflictingDataSource.name, " both have a ground plane added, this will cause problems with the fallback logic, see HARP-14728 & HARP-15488."));
                                }
                                _this.m_tileDataSources.push(dataSource);
                                (ref = _this.m_sceneEnvironment) === null || ref === void 0 ? void 0 : ref.updateBackgroundDataSource();
                                _ctx.prev = 10;
                                _ctx.next = 13;
                                return dataSource.connect();
                            case 13:
                                alreadyRemoved = !_this.m_tileDataSources.includes(dataSource);
                                if (!alreadyRemoved) {
                                    _ctx.next = 16;
                                    break;
                                }
                                return _ctx.abrupt("return");
                            case 16:
                                dataSource.addEventListener(MapViewEventNames.Update, function() {
                                    _this.update();
                                });
                                _ctx.next = 19;
                                return _this.getTheme();
                            case 19:
                                theme = _ctx.sent;
                                dataSource.setLanguages(_this.m_languages);
                                if (!(theme !== void 0 && theme.styles !== void 0)) {
                                    _ctx.next = 24;
                                    break;
                                }
                                _ctx.next = 24;
                                return dataSource.setTheme(theme);
                            case 24:
                                _this.m_connectedDataSources.add(dataSource.name);
                                _this.dispatchEvent({
                                    type: MapViewEventNames.DataSourceConnect,
                                    dataSourceName: dataSource.name
                                });
                                _this.update();
                                _ctx.next = 35;
                                break;
                            case 29:
                                _ctx.prev = 29;
                                _ctx.t0 = _ctx["catch"](10);
                                ;
                                logger24.error("Failed to connect to datasource ".concat(dataSource.name, ": ").concat((_message = _ctx.t0.message) !== null && _message !== void 0 ? _message : _ctx.t0));
                                _this.m_failedDataSources.add(dataSource.name);
                                _this.dispatchEvent({
                                    type: MapViewEventNames.DataSourceConnect,
                                    dataSourceName: dataSource.name,
                                    error: _ctx.t0
                                });
                            case 35:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            10,
                            29
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "animatedExtrusionHandler",
            get: function get() {
                return this.m_animatedExtrusionHandler;
            }
        },
        {
            key: "animating",
            get: function get() {
                return this.m_animationCount > 0;
            }
        },
        {
            key: "beginAnimation",
            value: function beginAnimation() {
                if ((this.m_animationCount++) === 0) {
                    this.update();
                    this.ANIMATION_STARTED_EVENT.time = Date.now();
                    this.dispatchEvent(this.ANIMATION_STARTED_EVENT);
                }
            }
        },
        {
            key: "camera",
            get: function get() {
                return this.m_camera;
            }
        },
        {
            key: "cameraIsMoving",
            get: function get() {
                0;
                return this.m_movementDetector.cameraIsMoving;
            }
        },
        {
            key: "cameraMovementDetector",
            get: function get() {
                return this.m_movementDetector;
            }
        },
        {
            key: "canvas",
            get: function get() {
                return this.m_canvas;
            }
        },
        {
            key: "checkCopyrightUpdates",
            value: function checkCopyrightUpdates() {
                if (!this.checkIfTilesChanged()) {
                    return;
                }
                var newCopyrightInfo = this.getRenderedTilesCopyrightInfo();
                if (newCopyrightInfo === this.m_copyrightInfo) {
                    return;
                }
                if (newCopyrightInfo.length === this.m_copyrightInfo.length) {
                    var allEqual = true;
                    for(var i = 0; i < newCopyrightInfo.length; i++){
                        var a = newCopyrightInfo[i];
                        var b = this.m_copyrightInfo[i];
                        if (a.label !== b.label) {
                            allEqual = false;
                            break;
                        }
                    }
                    if (allEqual) {
                        return;
                    }
                }
                this.m_copyrightInfo = newCopyrightInfo;
                this.dispatchEvent(this.COPYRIGHT_CHANGED_EVENT);
            }
        },
        {
            key: "checkIfTilesChanged",
            value: function checkIfTilesChanged() {
                if (this.m_thisFrameTilesChanged !== void 0) {
                    return this.m_thisFrameTilesChanged;
                }
                var renderList = this.m_visibleTiles.dataSourceTileList;
                var tileIdList = [];
                tileIdList.length = 0;
                renderList.forEach(function(param) {
                    var dataSource = param.dataSource, renderedTiles = param.renderedTiles;
                    renderedTiles.forEach(function(tile) {
                        tileIdList.push(dataSource.name + "-" + tile.tileKey.mortonCode());
                    });
                });
                tileIdList.sort();
                var newTileIds = tileIdList.join("#");
                if (newTileIds !== this.m_lastTileIds) {
                    this.m_lastTileIds = newTileIds;
                    this.m_thisFrameTilesChanged = true;
                } else {
                    this.m_thisFrameTilesChanged = false;
                }
                return this.m_thisFrameTilesChanged;
            }
        },
        {
            key: "clearColor",
            get: function get() {
                var rendererClearColor = this.m_renderer.getClearColor(cache3.color);
                return rendererClearColor !== void 0 ? rendererClearColor.getHex() : 0;
            }
        },
        {
            key: "clearTileCache",
            value: function clearTileCache(dataSourceName, filter) {
                if (this.m_visibleTiles === void 0) {
                    return;
                }
                if (dataSourceName !== void 0) {
                    var dataSource = this.getDataSourceByName(dataSourceName);
                    if (dataSource) {
                        this.m_visibleTiles.clearTileCache(dataSource, filter);
                        dataSource.clearCache();
                    }
                } else {
                    this.m_visibleTiles.clearTileCache(void 0, filter);
                    this.m_tileDataSources.forEach(function(dataSource) {
                        return dataSource.clearCache();
                    });
                }
                if (this.m_elevationProvider !== void 0) {
                    this.m_elevationProvider.clearCache();
                }
            }
        },
        {
            key: "collisionDebugCanvas",
            get: function get() {
                return this.m_collisionDebugCanvas;
            }
        },
        {
            key: "copyrightInfo",
            get: function get() {
                return this.m_copyrightInfo;
            }
        },
        {
            key: "createBox",
            value: function createBox(x, y) {
                var geometry = new THREE91.BoxGeometry(100, 100, 100);
                var material = new THREE91.MeshStandardMaterial({
                    color: 16711934
                });
                var cube = new THREE91.Mesh(geometry, material);
                cube.renderOrder = 1e5;
                var geoPosition = this.getGeoCoordinatesAt(x, y);
                cube.anchor = geoPosition !== null && geoPosition !== void 0 ? geoPosition : void 0;
                this.world.createEntity().addComponent(Rotating, {
                    speed: 5
                }).addObject3DComponent(cube, this.sceneEntity);
                this.mapAnchors.add(cube);
                this.update();
            }
        },
        {
            key: "createTextRenderer",
            value: function createTextRenderer() {
                return new TextElementsRenderer(new MapViewState(this, this.checkIfTilesChanged.bind(this)), this.m_screenProjector, this.m_poiManager, this.m_renderer, [
                    this.imageCache,
                    this.userImageCache
                ], {});
            }
        },
        {
            key: "createVisibleTileSet",
            value: function createVisibleTileSet() {
                assert(this.m_tileGeometryManager !== void 0);
                if (this.m_visibleTiles) {
                    this.m_visibleTiles.clearTileCache();
                    this.m_visibleTiles.disposePendingTiles();
                }
                var enableMixedLod = this.m_enableMixedLod === void 0 ? this.projection.type === 1 /* Spherical */  : this.m_enableMixedLod;
                this.m_visibleTiles = new VisibleTileSet(new FrustumIntersection(this.m_camera, this, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled, enableMixedLod, this.m_lodMinTilePixelSize), this.m_tileGeometryManager, this.m_visibleTileSetOptions, this.taskQueue);
                return this.m_visibleTiles;
            }
        },
        {
            key: "dataSources",
            get: function get() {
                return this.m_tileDataSources;
            }
        },
        {
            key: "disposed",
            get: function get() {
                return this.m_disposed;
            }
        },
        {
            key: "elevationProvider",
            get: function get() {
                return this.m_elevationProvider;
            }
        },
        {
            key: "enableMixedLod",
            get: function get() {
                return this.m_enableMixedLod;
            }
        },
        {
            key: "endAnimation",
            value: function endAnimation() {
                if (this.m_animationCount > 0) {
                    --this.m_animationCount;
                }
                if (this.m_animationCount === 0) {
                    this.ANIMATION_FINISHED_EVENT.time = Date.now();
                    this.dispatchEvent(this.ANIMATION_FINISHED_EVENT);
                }
            }
        },
        {
            key: "env",
            get: function get() {
                return this.m_env;
            }
        },
        {
            key: "extractAttitude",
            value: function extractAttitude() {
                var camera = this.m_camera;
                var projection = this.projection;
                var cameraPos = cache3.vector3[1];
                var transform = cache3.transform[0];
                var tangentSpaceMatrix = cache3.matrix4[1];
                cameraPos.setFromMatrixPosition(camera.matrixWorld);
                projection.localTangentSpace(this.m_targetGeoPos, transform);
                tangentSpaceMatrix.makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
                cache3.matrix4[0].copy(tangentSpaceMatrix).invert().multiply(camera.matrixWorld);
                transform.xAxis.setFromMatrixColumn(cache3.matrix4[0], 0);
                transform.yAxis.setFromMatrixColumn(cache3.matrix4[0], 1);
                transform.zAxis.setFromMatrixColumn(cache3.matrix4[0], 2);
                var yaw = 0;
                var pitch = 0;
                var roll = 0;
                var epsilon3 = 1e-10;
                var d = transform.zAxis.dot(cameraPos.set(0, 0, 1));
                if (d < 1 - epsilon3) {
                    if (d > -1 + epsilon3) {
                        yaw = Math.atan2(transform.zAxis.x, -transform.zAxis.y);
                        pitch = Math.acos(transform.zAxis.z);
                        roll = Math.atan2(transform.xAxis.x, transform.yAxis.z);
                    } else {
                        yaw = -Math.atan2(-transform.yAxis.x, transform.xAxis.x);
                        pitch = 180;
                        roll = 0;
                    }
                } else {
                    yaw = Math.atan2(-transform.yAxis.x, transform.xAxis.x);
                    pitch = 0;
                    roll = 0;
                }
                return {
                    yaw: yaw,
                    pitch: pitch,
                    roll: roll
                };
            }
        },
        {
            key: "flyTo",
            value: function flyTo(coords) {
                var distance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 800, tilt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                var cameraAnimation;
                var animOptions = {
                    globe: true,
                    orbit: false,
                    flyTo: "Dubai",
                    flyOver: false
                };
                var animationOptions = {
                    interpolation: THREE91.InterpolateSmooth,
                    loop: THREE91.LoopOnce,
                    repetitions: 1,
                    rotateOnlyClockWise: true
                };
                if (cameraAnimation) {
                    cameraAnimation.stop();
                    cameraAnimation = void 0;
                    animOptions.flyOver = false;
                    animOptions.orbit = false;
                }
                if (coords) {
                    var target = new ControlPoint({
                        target: coords,
                        distance: distance,
                        tilt: tilt,
                        timestamp: 1
                    });
                    var flyToOpts = CameraAnimationBuilder.createBowFlyToOptions(this, new ControlPoint(_objectSpreadProps(_objectSpread({}, CameraAnimationBuilder.getLookAtFromView(this)), {
                        timestamp: 0
                    })), target, 50);
                    Object.assign(flyToOpts, animationOptions);
                    cameraAnimation = new CameraKeyTrackAnimation(this, flyToOpts);
                    cameraAnimation.start();
                }
            }
        },
        {
            key: "focalLength",
            get: function get() {
                var ref;
                var focalLength = (ref = CameraUtils.getFocalLength(this.m_camera)) !== null && ref !== void 0 ? ref : 0;
                return focalLength;
            }
        },
        {
            key: "frameNumber",
            get: function get() {
                return this.m_frameNumber;
            }
        },
        {
            key: "geoCenter",
            get: function get() {
                return this.projection.unprojectPoint(this.m_camera.position).normalized();
            },
            set: function set(geoCenter) {
                if (geoCenter.altitude !== void 0) {
                    this.projection.projectPoint(geoCenter, this.m_camera.position);
                } else {
                    var altitude = this.geoCenter.altitude;
                    this.projection.projectPoint(new GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);
                }
                this.update();
            }
        },
        {
            key: "geoMaxBounds",
            get: function get() {
                return this.m_geoMaxBounds;
            },
            set: function set(bounds) {
                this.m_geoMaxBounds = bounds;
                this.m_worldMaxBounds = this.m_geoMaxBounds ? this.projection.projectBox(this.m_geoMaxBounds, this.projection.type === 0 /* Planar */  ? new THREE91.Box3() : new OrientedBox3()) : void 0;
            }
        },
        {
            key: "getCanvasClientSize",
            value: function getCanvasClientSize() {
                var _canvas = this.canvas, clientWidth = _canvas.clientWidth, clientHeight = _canvas.clientHeight;
                if (clientWidth === 0 || clientHeight === 0 || typeof clientWidth !== "number" || typeof clientHeight !== "number") {
                    var pixelRatio = this.m_renderer.getPixelRatio();
                    return {
                        width: Math.round(this.canvas.width / pixelRatio),
                        height: Math.round(this.canvas.height / pixelRatio)
                    };
                } else {
                    return {
                        width: clientWidth,
                        height: clientHeight
                    };
                }
            }
        },
        {
            key: "getDataSourceByName",
            value: function getDataSourceByName(dataSourceName) {
                return this.m_tileDataSources.find(function(ds) {
                    return ds.name === dataSourceName;
                });
            }
        },
        {
            key: "getEnabledTileDataSources",
            value: function getEnabledTileDataSources() {
                var enabledDataSources = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_tileDataSources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var dataSource = _step.value;
                        if (this.isDataSourceEnabled(dataSource)) {
                            enabledDataSources.push(dataSource);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return enabledDataSources;
            }
        },
        {
            key: "getGeoCoordinatesAt",
            value: function getGeoCoordinatesAt(x, y, fallback) {
                var worldPosition = this.getWorldPositionAt(x, y, fallback);
                if (!worldPosition) {
                    return null;
                }
                var geoPos = this.projection.unprojectPoint(worldPosition);
                if (!this.tileWrappingEnabled && this.projection.type === 0 /* Planar */ ) {
                    geoPos.longitude = THREE91.MathUtils.clamp(geoPos.longitude, -180, 180);
                }
                return geoPos;
            }
        },
        {
            key: "getNormalizedScreenCoordinates",
            value: function getNormalizedScreenCoordinates(x, y) {
                var ref = this.getCanvasClientSize(), width = ref.width, height = ref.height;
                return new THREE91.Vector3(x / width * 2 - 1, -(y / height * 2) + 1, 0);
            }
        },
        {
            key: "getRenderedTilesCopyrightInfo",
            value: function getRenderedTilesCopyrightInfo() {
                var result = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_visibleTiles.dataSourceTileList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var tileList = _step.value;
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = tileList.renderedTiles.values()[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var tile = _step1.value;
                                var tileCopyrightInfo = tile.copyrightInfo;
                                if (tileCopyrightInfo === void 0 || tileCopyrightInfo.length === 0) {
                                    continue;
                                }
                                result = CopyrightInfo.mergeArrays(result, tileCopyrightInfo);
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return result;
            }
        },
        {
            key: "getTheme",
            value: function getTheme() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return _this.m_themeManager.getTheme();
                            case 2:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 3:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "getWorldPositionAt",
            value: function getWorldPositionAt(x, y, fallback) {
                this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);
                var worldPos = this.projection.type === 1 /* Spherical */  ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache3.vector3[0]) : this.m_raycaster.ray.intersectPlane(this.m_plane, cache3.vector3[0]);
                if (worldPos === null && fallback === true) {
                    var cosAlpha = this.m_camera.getWorldDirection(cache3.vector3[0]).dot(this.m_raycaster.ray.direction);
                    return cache3.vector3[0].copy(this.m_raycaster.ray.direction).multiplyScalar(this.m_camera.far / cosAlpha).add(this.m_camera.position);
                }
                return worldPos;
            }
        },
        {
            key: "heading",
            get: function get() {
                return -THREE91.MathUtils.radToDeg(this.m_yaw);
            },
            set: function set(heading) {
                this.lookAtImpl({
                    heading: heading
                });
            }
        },
        {
            key: "isDynamicFrame",
            get: function get() {
                return !this.m_visibleTiles.allVisibleTilesLoaded || this.m_themeManager.isUpdating() || this.cameraIsMoving || this.animating || this.m_updatePending || this.m_animatedExtrusionHandler.isAnimating || this.m_textElementsRenderer.isUpdatePending || this.m_textElementsRenderer.loading;
            }
        },
        {
            key: "imageCache",
            get: function get() {
                return this.m_themeManager.imageCache;
            }
        },
        {
            key: "isDataSourceEnabled",
            value: function isDataSourceEnabled(dataSource) {
                return dataSource.enabled && dataSource.ready() && this.m_connectedDataSources.has(dataSource.name) && dataSource.isVisible(this.zoomLevel);
            }
        },
        {
            key: "lockVisibleTileSet",
            get: function get() {
                return this.m_visibleTileSetLock;
            },
            set: function set(value2) {
                this.m_visibleTileSetLock = value2;
            }
        },
        {
            key: "lookAt",
            value: function lookAt(targetOrParams, distance, tiltDeg, headingDeg) {
                if (isGeoCoordinatesLike(targetOrParams)) {
                    var zoomLevel = distance !== void 0 ? MapViewUtils.calculateZoomLevelFromDistance(this, distance) : void 0;
                    var params = {
                        target: targetOrParams,
                        zoomLevel: zoomLevel,
                        tilt: tiltDeg,
                        heading: headingDeg
                    };
                    this.lookAtImpl(params);
                } else if (typeof targetOrParams === "object") {
                    this.lookAtImpl(targetOrParams);
                }
            }
        },
        {
            key: "lookAtImpl",
            value: function lookAtImpl(params) {
                var _this = this;
                var tilt = Math.min(getOptionValue(params.tilt, this.tilt), MapViewUtils.MAX_TILT_DEG);
                var heading = getOptionValue(params.heading, this.heading);
                var distance = params.zoomLevel !== void 0 ? MapViewUtils.calculateDistanceFromZoomLevel(this, THREE91.MathUtils.clamp(params.zoomLevel, this.m_minZoomLevel, this.m_maxZoomLevel)) : params.distance !== void 0 ? params.distance : this.m_targetDistance;
                var target;
                if (params.bounds !== void 0) {
                    var geoPoints;
                    if (_instanceof(params.bounds, GeoBox)) {
                        target = params.target ? GeoCoordinates.fromObject(params.target) : params.bounds.center;
                        geoPoints = MapViewUtils.geoBoxToGeoPoints(params.bounds);
                    } else if (_instanceof(params.bounds, GeoPolygon)) {
                        target = params.bounds.getCentroid();
                        geoPoints = params.bounds.coordinates;
                    } else if (isGeoBoxExtentLike(params.bounds)) {
                        target = params.target ? GeoCoordinates.fromObject(params.target) : this.target;
                        var box = GeoBox.fromCenterAndExtents(target, params.bounds);
                        geoPoints = MapViewUtils.geoBoxToGeoPoints(box);
                    } else if (Array.isArray(params.bounds)) {
                        geoPoints = params.bounds;
                        if (params.target !== void 0) {
                            target = GeoCoordinates.fromObject(params.target);
                        }
                    } else {
                        throw Error("#lookAt: Invalid 'bounds' value");
                    }
                    if (!(_instanceof(params.bounds, GeoBox) || _instanceof(params.bounds, GeoPolygon)) && this.m_tileWrappingEnabled && this.projection.type === 0 /* Planar */ ) {
                        geoPoints = MapViewUtils.wrapGeoPointsToScreen(geoPoints, target);
                    }
                    var worldPoints = geoPoints.map(function(point) {
                        return _this.projection.projectPoint(GeoCoordinates.fromObject(point), new THREE91.Vector3());
                    });
                    var worldTarget = new THREE91.Vector3();
                    if (target === void 0) {
                        var box1 = new THREE91.Box3().setFromPoints(worldPoints);
                        box1.getCenter(worldTarget);
                        this.projection.scalePointToSurface(worldTarget);
                        target = this.projection.unprojectPoint(worldTarget);
                    } else {
                        this.projection.projectPoint(target, worldTarget);
                    }
                    if (params.zoomLevel !== void 0 || params.distance !== void 0) {
                        return this.lookAtImpl({
                            tilt: tilt,
                            heading: heading,
                            distance: distance,
                            target: target
                        });
                    }
                    return this.lookAtImpl(MapViewUtils.getFitBoundsLookAtParams(target, worldTarget, worldPoints, {
                        tilt: tilt,
                        heading: heading,
                        minDistance: MapViewUtils.calculateDistanceFromZoomLevel(this, this.maxZoomLevel),
                        projection: this.projection,
                        camera: this.camera
                    }));
                }
                target = params.target !== void 0 ? GeoCoordinates.fromObject(params.target) : this.target;
                MapViewUtils.getCameraRotationAtTarget(this.projection, target, -heading, tilt, this.camera.quaternion);
                MapViewUtils.getCameraPositionFromTargetCoordinates(target, distance, -heading, tilt, this.projection, this.camera.position);
                this.camera.updateMatrixWorld(true);
                this.updateLookAtSettings();
                this.update();
            }
        },
        {
            key: "mapAnchors",
            get: function get() {
                return this.m_mapAnchors;
            }
        },
        {
            key: "markTilesDirty",
            value: function markTilesDirty(dataSource, filter) {
                this.m_visibleTiles.markTilesDirty(dataSource, filter);
                this.update();
            }
        },
        {
            key: "maxFps",
            get: function get() {
                return this.m_options.maxFps;
            }
        },
        {
            key: "maxZoomLevel",
            get: function get() {
                return this.m_maxZoomLevel;
            }
        },
        {
            key: "minCameraHeight",
            get: function get() {
                return this.m_minCameraHeight;
            }
        },
        {
            key: "minZoomLevel",
            get: function get() {
                return this.m_minZoomLevel;
            }
        },
        {
            key: "movementStarted",
            value: function movementStarted() {
                this.m_textElementsRenderer.movementStarted();
                this.MOVEMENT_STARTED_EVENT.time = Date.now();
                this.dispatchEvent(this.MOVEMENT_STARTED_EVENT);
            }
        },
        {
            key: "movementFinished",
            value: function movementFinished() {
                var _this = this;
                this.m_textElementsRenderer.movementFinished();
                this.MOVEMENT_FINISHED_EVENT.time = Date.now();
                this.dispatchEvent(this.MOVEMENT_FINISHED_EVENT);
                if (!this.animating) {
                    if (this.m_movementFinishedUpdateTimerId !== void 0) {
                        clearTimeout(this.m_movementFinishedUpdateTimerId);
                    }
                    this.m_movementFinishedUpdateTimerId = setTimeout(function() {
                        _this.m_movementFinishedUpdateTimerId = void 0;
                        _this.update();
                    }, 0);
                }
            }
        },
        {
            key: "ndcToView",
            value: function ndcToView(vector, result) {
                result.set(vector.x, vector.y, vector.z).applyMatrix4(this.camera.projectionMatrixInverse).applyMatrix4(this.m_rteCamera.matrixWorld);
                return result;
            }
        },
        {
            key: "overlayScene",
            get: function get() {
                return this.m_overlayScene;
            }
        },
        {
            key: "pixelRatio",
            get: function get() {
                if (this.m_pixelRatio !== void 0) {
                    return this.m_pixelRatio;
                }
                return typeof window !== "undefined" && window.devicePixelRatio !== void 0 ? window.devicePixelRatio : 1;
            }
        },
        {
            key: "pixelToWorld",
            get: function get() {
                if (this.m_pixelToWorld === void 0) {
                    assert(this.m_options.fovCalculation !== void 0);
                    var lookAtDistance = this.m_targetDistance;
                    var focalLength = CameraUtils.getFocalLength(this.m_camera);
                    assert(focalLength !== void 0);
                    this.m_pixelToWorld = CameraUtils.convertScreenToWorldSize(focalLength, lookAtDistance, 1);
                }
                return this.m_pixelToWorld;
            }
        },
        {
            key: "poiManager",
            get: function get() {
                return this.m_poiManager;
            }
        },
        {
            key: "poiTableManager",
            get: function get() {
                return this.m_poiTableManager;
            }
        },
        {
            key: "loadPostEffects",
            value: function loadPostEffects(postEffectsFile) {
                var _this = this;
                fetch(postEffectsFile).then(function(response) {
                    return response.json();
                }).then(function(postEffects) {
                    _this.m_postEffects = postEffects;
                    _this.setPostEffects();
                });
            }
        },
        {
            key: "postEffects",
            get: function get() {
                return this.m_postEffects;
            },
            set: function set(postEffects) {
                this.m_postEffects = postEffects;
                this.setPostEffects();
            }
        },
        {
            key: "projection",
            get: function get() {
                return this.m_visibleTileSetOptions.projection;
            },
            set: function set(projection) {
                var tilt = this.tilt;
                var heading = this.heading;
                this.m_visibleTileSetOptions.projection = projection;
                this.updatePolarDataSource();
                this.clearTileCache();
                this.textElementsRenderer.clearRenderStates();
                this.m_visibleTiles = this.createVisibleTileSet();
                this.geoMaxBounds = this.geoMaxBounds;
                this.lookAtImpl({
                    tilt: tilt,
                    heading: heading
                });
            }
        },
        {
            key: "removeDataSource",
            value: function removeDataSource(dataSource) {
                var dsIndex = this.m_tileDataSources.indexOf(dataSource);
                if (dsIndex === -1) {
                    return;
                }
                dataSource.detach(this);
                this.m_visibleTiles.removeDataSource(dataSource);
                this.m_tileDataSources.splice(dsIndex, 1);
                this.m_connectedDataSources.delete(dataSource.name);
                this.m_failedDataSources.delete(dataSource.name);
                this.m_sceneEnvironment.updateBackgroundDataSource();
                this.update();
            }
        },
        {
            key: "render",
            value: function render(frameStartTime) {
                var _this = this;
                if (this.m_drawing) {
                    return;
                }
                if (this.disposed) {
                    logger24.warn("render(): MapView has been disposed of.");
                    return;
                }
                this.RENDER_EVENT.time = frameStartTime;
                this.dispatchEvent(this.RENDER_EVENT);
                this.m_tileObjectRenderer.prepareRender();
                ++this.m_frameNumber;
                var currentFrameEvent;
                var stats = PerformanceStatistics.instance;
                var gatherStatistics = stats.enabled;
                if (gatherStatistics) {
                    currentFrameEvent = stats.currentFrame;
                    if (this.m_previousFrameTimeStamp !== void 0) {
                        var timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;
                        currentFrameEvent.setValue("render.fps", 1e3 / timeSincePreviousFrame);
                    }
                    stats.storeAndClearFrameInfo();
                    currentFrameEvent = currentFrameEvent;
                    currentFrameEvent.setValue("renderCount.frameNumber", this.m_frameNumber);
                }
                this.m_previousFrameTimeStamp = frameStartTime;
                var setupTime;
                var cullTime;
                var textPlacementTime;
                var drawTime;
                var textDrawTime;
                var endTime;
                this.m_renderer.info.reset();
                this.m_updatePending = false;
                this.m_thisFrameTilesChanged = void 0;
                this.m_drawing = true;
                if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
                    this.m_renderer.setPixelRatio(this.pixelRatio);
                }
                this.updateCameras();
                this.updateEnv();
                this.m_renderer.clear();
                this.m_sceneRoot.children.length = 0;
                this.m_overlaySceneRoot.children.length = 0;
                if (gatherStatistics) {
                    setupTime = PerformanceTimer.now();
                }
                if (!this.lockVisibleTileSet) {
                    var viewRangesStatus = this.m_visibleTiles.updateRenderList(this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_frameNumber, this.m_elevationRangeSource);
                    if (viewRangesStatus.viewRangesChanged) {
                        this.updateCameras(viewRangesStatus.viewRanges);
                    }
                }
                if (gatherStatistics) {
                    cullTime = PerformanceTimer.now();
                }
                var renderList = this.m_visibleTiles.dataSourceTileList;
                renderList.forEach(function(param) {
                    var zoomLevel = param.zoomLevel, renderedTiles = param.renderedTiles;
                    renderedTiles.forEach(function(tile) {
                        _this.m_tileObjectRenderer.render(tile, zoomLevel, _this.zoomLevel, _this.m_camera.position, _this.m_sceneRoot);
                        tile.frameNumLastVisible = _this.m_frameNumber;
                    });
                });
                this.m_mapAnchors.update(this.projection, this.camera.position, this.m_sceneRoot, this.m_overlaySceneRoot);
                this.m_animatedExtrusionHandler.update(this.zoomLevel);
                if (currentFrameEvent !== void 0) {
                    currentFrameEvent.addValue("renderCount.numTilesRendered", 0);
                    currentFrameEvent.addValue("renderCount.numTilesVisible", 0);
                    currentFrameEvent.addValue("renderCount.numTilesLoading", 0);
                    renderList.forEach(function(param) {
                        var zoomLevel = param.zoomLevel, renderedTiles = param.renderedTiles, visibleTiles = param.visibleTiles, numTilesLoading = param.numTilesLoading;
                        currentFrameEvent.addValue("renderCount.numTilesRendered", renderedTiles.size);
                        currentFrameEvent.addValue("renderCount.numTilesVisible", visibleTiles.length);
                        currentFrameEvent.addValue("renderCount.numTilesLoading", numTilesLoading);
                    });
                }
                if (this.m_movementDetector.checkCameraMoved(this, frameStartTime)) {
                    var _geoCenter = this.geoCenter, latitude = _geoCenter.latitude, longitude = _geoCenter.longitude, altitude = _geoCenter.altitude;
                    this.dispatchEvent({
                        type: MapViewEventNames.CameraPositionChanged,
                        latitude: latitude,
                        longitude: longitude,
                        altitude: altitude,
                        yaw: this.m_yaw,
                        pitch: this.m_pitch,
                        roll: this.m_roll,
                        tilt: this.tilt,
                        heading: this.heading,
                        zoom: this.zoomLevel
                    });
                }
                var camera = this.m_pointOfView !== void 0 ? this.m_pointOfView : this.m_rteCamera;
                if (this.renderLabels && !this.m_pointOfView) {
                    this.m_textElementsRenderer.placeText(renderList, frameStartTime);
                }
                if (gatherStatistics) {
                    textPlacementTime = PerformanceTimer.now();
                }
                this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !this.isDynamicFrame);
                if (gatherStatistics) {
                    drawTime = PerformanceTimer.now();
                }
                if (this.renderLabels && !this.m_pointOfView) {
                    this.m_textElementsRenderer.renderText(this.m_viewRanges.maximum);
                }
                if (this.m_overlaySceneRoot.children.length > 0) {
                    this.m_renderer.render(this.m_overlayScene, camera);
                }
                if (gatherStatistics) {
                    textDrawTime = PerformanceTimer.now();
                }
                if (!this.m_firstFrameRendered) {
                    this.m_firstFrameRendered = true;
                    if (gatherStatistics) {
                        stats.appResults.set("firstFrame", frameStartTime);
                    }
                    this.FIRST_FRAME_EVENT.time = frameStartTime;
                    this.dispatchEvent(this.FIRST_FRAME_EVENT);
                }
                this.m_visibleTiles.disposePendingTiles();
                this.m_drawing = false;
                this.checkCopyrightUpdates();
                if (this.m_taskSchedulerTimeout !== void 0) {
                    clearTimeout(this.m_taskSchedulerTimeout);
                }
                this.m_taskSchedulerTimeout = setTimeout(function() {
                    _this.m_taskSchedulerTimeout = void 0;
                    _this.m_taskScheduler.processPending(frameStartTime);
                }, 0);
                if (currentFrameEvent !== void 0) {
                    endTime = PerformanceTimer.now();
                    var frameRenderTime = endTime - frameStartTime;
                    currentFrameEvent.setValue("render.setupTime", setupTime - frameStartTime);
                    currentFrameEvent.setValue("render.cullTime", cullTime - setupTime);
                    currentFrameEvent.setValue("render.textPlacementTime", textPlacementTime - cullTime);
                    currentFrameEvent.setValue("render.drawTime", drawTime - textPlacementTime);
                    currentFrameEvent.setValue("render.textDrawTime", textDrawTime - drawTime);
                    currentFrameEvent.setValue("render.cleanupTime", endTime - textDrawTime);
                    currentFrameEvent.setValue("render.frameRenderTime", frameRenderTime);
                    currentFrameEvent.setValue("render.fullFrameTime", frameRenderTime);
                    currentFrameEvent.setValue("render.geometryCreationTime", 0);
                    stats.addWebGLInfo(this.m_renderer.info);
                    stats.addMemoryInfo();
                }
                this.DID_RENDER_EVENT.time = frameStartTime;
                this.dispatchEvent(this.DID_RENDER_EVENT);
                if (!this.isDynamicFrame) {
                    if (this.m_firstFrameComplete === false) {
                        this.m_firstFrameComplete = true;
                        if (gatherStatistics) {
                            stats.appResults.set("firstFrameComplete", frameStartTime);
                        }
                    }
                    this.FRAME_COMPLETE_EVENT.time = frameStartTime;
                    this.dispatchEvent(this.FRAME_COMPLETE_EVENT);
                }
            }
        },
        {
            key: "renderer",
            get: function get() {
                return this.m_renderer;
            }
        },
        {
            key: "renderLabels",
            get: function get() {
                return this.m_renderLabels;
            },
            set: function set(value2) {
                this.m_renderLabels = value2;
            }
        },
        {
            key: "renderLoop",
            value: function renderLoop(frameStartTime) {
                if (this.m_options.synchronousRendering === true || this.disposed) {
                    return;
                }
                if (this.maxFps === 0) {
                    this.render(frameStartTime);
                } else {
                    var fudgeTimeInMs = 3;
                    var frameInterval = 1e3 / this.maxFps;
                    var previousFrameTime = this.m_previousFrameTimeStamp === void 0 ? 0 : this.m_previousFrameTimeStamp;
                    var targetTime = previousFrameTime + frameInterval - fudgeTimeInMs;
                    if (frameStartTime >= targetTime) {
                        this.render(frameStartTime);
                    }
                }
                requestAnimationFrame(this.handleRequestAnimationFrame);
            }
        },
        {
            key: "renderSync",
            value: function renderSync(frameStartTime) {
                if (frameStartTime === void 0) {
                    frameStartTime = PerformanceTimer.now();
                }
                this.render(frameStartTime);
            }
        },
        {
            key: "resetTextRenderer",
            value: function resetTextRenderer(fontCatalogs, textStyles, defaultTextStyle) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return _this.m_textElementsRenderer.updateFontCatalogs(fontCatalogs);
                            case 2:
                                _ctx.next = 4;
                                return _this.m_textElementsRenderer.updateTextStyles(textStyles, defaultTextStyle);
                            case 4:
                                _this.update();
                            case 5:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "resize",
            value: function resize(width, height) {
                this.m_renderer.setSize(width, height, false);
                if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
                    this.m_renderer.setPixelRatio(this.pixelRatio);
                }
                if (this.mapRenderingManager !== void 0) {
                    this.mapRenderingManager.setSize(width, height);
                }
                if (this.collisionDebugCanvas !== void 0) {
                    this.collisionDebugCanvas.width = width;
                    this.collisionDebugCanvas.height = height;
                }
                this.updateCameras();
                this.update();
                this.dispatchEvent({
                    type: MapViewEventNames.Resize,
                    size: {
                        width: width,
                        height: height
                    }
                });
            }
        },
        {
            key: "scene",
            get: function get() {
                return this.m_scene;
            }
        },
        {
            key: "sceneEntity",
            get: function get() {
                return this.m_sceneEntity;
            },
            set: function set(sceneEntity) {
                this.m_sceneEntity = sceneEntity;
            }
        },
        {
            key: "sceneEnvironment",
            get: function get() {
                return this.m_sceneEnvironment;
            }
        },
        {
            key: "setFovOnCamera",
            value: function setFovOnCamera(fovCalculation, height) {
                var fovRad = THREE91.MathUtils.degToRad(fovCalculation.fov);
                if (fovCalculation.type === "fixed") {
                    CameraUtils.setVerticalFov(this.m_camera, fovRad, height);
                    return;
                }
                var focalLength = CameraUtils.getFocalLength(this.m_camera);
                if (focalLength === void 0) {
                    CameraUtils.setVerticalFov(this.m_camera, fovRad, height);
                    focalLength = CameraUtils.getFocalLength(this.m_camera);
                }
                CameraUtils.setFocalLength(this.m_camera, focalLength, height);
            }
        },
        {
            key: "setPostEffects",
            value: function setPostEffects() {
                this.mapRenderingManager.bloom.enabled = false;
                this.mapRenderingManager.outline.enabled = false;
                this.mapRenderingManager.vignette.enabled = false;
                this.mapRenderingManager.sepia.enabled = false;
                if (this.m_postEffects !== void 0) {
                    if (this.m_postEffects.bloom !== void 0) {
                        this.mapRenderingManager.bloom = this.m_postEffects.bloom;
                    }
                    if (this.m_postEffects.outline !== void 0) {
                        this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;
                        this.mapRenderingManager.updateOutline(this.m_postEffects.outline);
                    }
                    if (this.m_postEffects.vignette !== void 0) {
                        this.mapRenderingManager.vignette = this.m_postEffects.vignette;
                    }
                    if (this.m_postEffects.sepia !== void 0) {
                        this.mapRenderingManager.sepia = this.m_postEffects.sepia;
                    }
                }
            }
        },
        {
            key: "setTheme",
            value: function setTheme(theme) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var newTheme;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return _this.m_themeManager.setTheme(theme);
                            case 2:
                                newTheme = _ctx.sent;
                                _this.THEME_LOADED_EVENT.time = Date.now();
                                _this.dispatchEvent(_this.THEME_LOADED_EVENT);
                                _this.update();
                                return _ctx.abrupt("return", newTheme);
                            case 7:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "setupCamera",
            value: function setupCamera() {
                assert(this.m_visibleTiles !== void 0);
                this.m_options.target = GeoCoordinates.fromObject(getOptionValue(this.m_options.target, MapViewDefaults.target));
                this.m_options.target.altitude = 0;
                this.m_options.tilt = getOptionValue(this.m_options.tilt, MapViewDefaults.tilt);
                this.m_options.heading = getOptionValue(this.m_options.heading, MapViewDefaults.heading);
                this.m_options.zoomLevel = getOptionValue(this.m_options.zoomLevel, MapViewDefaults.zoomLevel);
                this.lookAtImpl(this.m_options);
                var ref = this.getCanvasClientSize(), width = ref.width, height = ref.height;
                this.resize(width, height);
            }
        },
        {
            key: "setupStats",
            value: function setupStats(enable) {
                new PerformanceStatistics(enable, 1e3);
            }
        },
        {
            key: "setupRenderer",
            value: function setupRenderer(tileObjectRenderer) {
                this.m_scene.add(this.m_sceneRoot);
                this.m_overlayScene.add(this.m_overlaySceneRoot);
                var _enableShadows;
                this.shadowsEnabled = (_enableShadows = this.m_options.enableShadows) !== null && _enableShadows !== void 0 ? _enableShadows : false;
                tileObjectRenderer.setupRenderer();
            }
        },
        {
            key: "shadowsEnabled",
            get: function get() {
                return this.m_options.enableShadows === true;
            },
            set: function set(enabled) {
                if (this.m_renderer.shadowMap === void 0 || enabled === this.m_renderer.shadowMap.enabled) {
                    return;
                }
                this.m_options.enableShadows = enabled;
                this.m_renderer.shadowMap.enabled = enabled;
                this.m_renderer.shadowMap.type = THREE91.PCFSoftShadowMap;
                this.clearTileCache();
            }
        },
        {
            key: "startRenderLoop",
            value: function startRenderLoop() {
                if (this.m_animationFrameHandle !== void 0 || this.m_options.synchronousRendering) {
                    return;
                }
                this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
            }
        },
        {
            key: "storageLevel",
            get: function get() {
                return THREE91.MathUtils.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);
            }
        },
        {
            key: "target",
            get: function get() {
                return this.m_targetGeoPos;
            }
        },
        {
            key: "targetDistance",
            get: function get() {
                return this.m_targetDistance;
            }
        },
        {
            key: "taskQueue",
            get: function get() {
                return this.m_taskScheduler.taskQueue;
            }
        },
        {
            key: "textElementsRenderer",
            get: function get() {
                return this.m_textElementsRenderer;
            }
        },
        {
            key: "tilt",
            get: function get() {
                return THREE91.MathUtils.radToDeg(this.m_pitch);
            }
        },
        {
            key: "tileGeometryManager",
            get: function get() {
                return this.m_tileGeometryManager;
            }
        },
        {
            key: "tileWrappingEnabled",
            get: function get() {
                return this.m_tileWrappingEnabled;
            }
        },
        {
            key: "update",
            value: function update() {
                if (this.disposed) {
                    logger24.warn("update(): MapView has been disposed of.");
                    return;
                }
                this.dispatchEvent(this.UPDATE_EVENT);
                if (this.m_updatePending) {
                    return;
                }
                this.m_updatePending = true;
                this.startRenderLoop();
            }
        },
        {
            key: "updateCameras",
            value: function updateCameras(viewRanges) {
                var ref;
                this.m_camera.updateMatrixWorld(false);
                this.updateLookAtSettings();
                var ref1 = this.m_renderer.getSize(cache3.vector2[0]), width = ref1.width, height = ref1.height;
                this.m_camera.aspect = this.m_forceCameraAspect !== void 0 ? this.m_forceCameraAspect : width / height;
                this.setFovOnCamera(this.m_options.fovCalculation, height);
                var projectionScale = this.projection.getScaleFactor(this.camera.position);
                var maxGeometryHeightScaled = projectionScale * this.m_tileDataSources.reduce(function(r, ds) {
                    return Math.max(r, ds.maxGeometryHeight);
                }, 0);
                var minGeometryHeightScaled = projectionScale * this.m_tileDataSources.reduce(function(r, ds) {
                    return Math.min(r, ds.minGeometryHeight);
                }, 0);
                Object.assign(this.m_viewRanges, viewRanges === void 0 ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled, minGeometryHeightScaled) : viewRanges);
                this.m_camera.near = this.m_viewRanges.near;
                this.m_camera.far = this.m_viewRanges.far;
                this.m_camera.updateProjectionMatrix();
                this.m_rteCamera.copy(this.m_camera);
                this.m_rteCamera.position.setScalar(0);
                this.m_rteCamera.updateMatrixWorld(true);
                (ref = this.m_textElementsRenderer) === null || ref === void 0 ? void 0 : ref.updateCamera();
                this.m_screenProjector.update(this.camera, width, height);
                this.m_pixelToWorld = void 0;
                this.m_sceneEnvironment.update();
            }
        },
        {
            key: "updateEnv",
            value: function updateEnv() {
                this.m_env.entries.$zoom = this.m_zoomLevel;
                this.m_env.entries.$pixelToMeters = this.pixelToWorld;
                this.m_env.entries.$frameNumber = this.m_frameNumber;
            }
        },
        {
            key: "updateLookAtSettings",
            value: function updateLookAtSettings() {
                var ref = MapViewUtils.getTargetAndDistance(this.projection, this.camera, this.elevationProvider), target = ref.target, distance = ref.distance, final = ref.final;
                if (!final) {
                    this.update();
                }
                if (this.geoMaxBounds) {
                    ;
                    var ref1;
                    ref1 = MapViewUtils.constrainTargetAndDistanceToViewBounds(target, distance, this), target = ref1.target, distance = ref1.distance, ref1;
                }
                this.m_targetWorldPos.copy(target);
                this.m_targetGeoPos = this.projection.unprojectPoint(this.m_targetWorldPos);
                this.m_targetDistance = distance;
                this.m_zoomLevel = MapViewUtils.calculateZoomLevelFromDistance(this, this.m_targetDistance);
                var ref2 = this.extractAttitude(), yaw = ref2.yaw, pitch = ref2.pitch, roll = ref2.roll;
                this.m_yaw = yaw;
                this.m_pitch = pitch;
                this.m_roll = roll;
            }
        },
        {
            key: "updatePolarDataSource",
            value: function updatePolarDataSource() {
                var dataSource = this.m_polarDataSource;
                if (this.m_enablePolarDataSource === true && dataSource !== void 0) {
                    var twinDataSource = this.getDataSourceByName(dataSource.name);
                    if (this.projection.type === 1 /* Spherical */ ) {
                        if (twinDataSource === void 0) {
                            this.addDataSource(dataSource);
                        }
                    } else {
                        if (twinDataSource !== void 0) {
                            this.removeDataSource(dataSource);
                        }
                    }
                }
            }
        },
        {
            key: "userImageCache",
            get: function get() {
                return this.m_userImageCache;
            }
        },
        {
            key: "viewportHeight",
            get: function get() {
                return this.canvas.height;
            }
        },
        {
            key: "viewRanges",
            get: function get() {
                return this.m_viewRanges;
            }
        },
        {
            key: "visibleTileSet",
            get: function get() {
                return this.m_visibleTiles;
            }
        },
        {
            key: "world",
            get: function get() {
                return this.m_world;
            },
            set: function set(world) {
                this.m_world = world;
            }
        },
        {
            key: "worldCenter",
            get: function get() {
                return this.m_camera.position;
            }
        },
        {
            key: "worldMaxBounds",
            get: function get() {
                return this.m_worldMaxBounds;
            }
        },
        {
            key: "worldTarget",
            get: function get() {
                return this.m_targetWorldPos;
            }
        },
        {
            key: "zoomLevel",
            get: function get() {
                return this.m_zoomLevel;
            }
        }
    ]);
    return MapView3;
}(EventDispatcher);
var MapViewEventNames = /* @__PURE__ */ function(MapViewEventNames2) {
    MapViewEventNames2["Update"] = "update";
    MapViewEventNames2["Resize"] = "resize";
    MapViewEventNames2["Render"] = "render";
    MapViewEventNames2["AfterRender"] = "didrender";
    MapViewEventNames2["FirstFrame"] = "first-render";
    MapViewEventNames2["FrameComplete"] = "frame-complete";
    MapViewEventNames2["ThemeLoaded"] = "theme-loaded";
    MapViewEventNames2["AnimationStarted"] = "animation-started";
    MapViewEventNames2["AnimationFinished"] = "animation-finished";
    MapViewEventNames2["MovementStarted"] = "movement-started";
    MapViewEventNames2["MovementFinished"] = "movement-finished";
    MapViewEventNames2["DataSourceConnect"] = "datasource-connect";
    MapViewEventNames2["CopyrightChanged"] = "copyright-changed";
    MapViewEventNames2["ContextLost"] = "webglcontext-lost";
    MapViewEventNames2["ContextRestored"] = "webglcontext-restored";
    MapViewEventNames2["CameraPositionChanged"] = "camera-changed";
    MapViewEventNames2["Dispose"] = "dispose";
    return MapViewEventNames2;
}(MapViewEventNames || {});
var cache3 = {
    vector2: [
        new THREE91.Vector2()
    ],
    vector3: [
        new THREE91.Vector3(),
        new THREE91.Vector3(),
        new THREE91.Vector3()
    ],
    rayCaster: new THREE91.Raycaster(),
    groundPlane: new THREE91.Plane(),
    groundSphere: new THREE91.Sphere(void 0, EarthConstants.EQUATORIAL_RADIUS),
    matrix4: [
        new THREE91.Matrix4(),
        new THREE91.Matrix4()
    ],
    transform: [
        {
            position: new THREE91.Vector3(),
            xAxis: new THREE91.Vector3(),
            yAxis: new THREE91.Vector3(),
            zAxis: new THREE91.Vector3()
        }
    ],
    color: new THREE91.Color()
};
// src/mapview/geometry/TileGeometryCreator.ts
var THREE94 = __toESM(require("three"));
// src/mapview/DepthPrePass.ts
var THREE92 = __toESM(require("three"));
var DEPTH_PRE_PASS_STENCIL_MASK = 1;
var DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;
function isRenderDepthPrePassEnabled(technique, env) {
    if (technique.enableDepthPrePass === false) {
        return false;
    }
    var transparent = technique.opacity !== void 0 && technique.opacity > 0 && technique.opacity < 1;
    if (!transparent) {
        var color = evaluateBaseColorProperty(technique, env);
        if (color !== void 0) {
            var alpha = ColorUtils.getAlphaFromHex(color);
            transparent = alpha > 0 && alpha < 1;
        }
    }
    return transparent;
}
function createDepthPrePassMaterial(baseMaterial) {
    baseMaterial.depthWrite = false;
    baseMaterial.depthFunc = THREE92.EqualDepth;
    baseMaterial.colorWrite = true;
    enforceBlending(baseMaterial);
    var depthPassMaterial = baseMaterial.clone();
    depthPassMaterial.isDepthPrepassMaterial = true;
    depthPassMaterial.depthWrite = true;
    depthPassMaterial.depthTest = true;
    depthPassMaterial.depthFunc = THREE92.LessDepth;
    depthPassMaterial.colorWrite = false;
    depthPassMaterial.opacity = 1;
    depthPassMaterial.blending = THREE92.NoBlending;
    return depthPassMaterial;
}
function isDepthPrePassMesh(object) {
    if (object.isMesh !== true) {
        return false;
    }
    var mesh = object;
    return _instanceof(mesh.material, Array) ? mesh.material.every(function(material) {
        return material.isDepthPrepassMaterial === true;
    }) : mesh.material.isDepthPrepassMaterial === true;
}
function createDepthPrePassMesh(mesh) {
    var originalGeometry = mesh.geometry;
    if (!_instanceof(originalGeometry, THREE92.BufferGeometry)) {
        throw new Error("#createDepthPassMesh only BufferGeometry is supported");
    }
    var positionAttribute = originalGeometry.getAttribute("position");
    if (!positionAttribute) {
        throw new Error("#createDepthPassMesh position attribute not found");
    }
    var depthPassGeometry = new THREE92.BufferGeometry();
    depthPassGeometry.setAttribute("position", positionAttribute);
    var uvAttribute = originalGeometry.getAttribute("uv");
    if (uvAttribute) {
        depthPassGeometry.setAttribute("uv", uvAttribute);
    }
    var normalAttribute = originalGeometry.getAttribute("normal");
    if (normalAttribute) {
        depthPassGeometry.setAttribute("normal", normalAttribute);
    }
    var extrusionAxisAttribute = originalGeometry.getAttribute("extrusionAxis");
    if (extrusionAxisAttribute) {
        depthPassGeometry.setAttribute("extrusionAxis", extrusionAxisAttribute);
    }
    if (originalGeometry.index) {
        depthPassGeometry.setIndex(originalGeometry.index);
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = originalGeometry.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var group = _step.value;
            var start = group.start, count = group.count, materialIndex = group.materialIndex;
            depthPassGeometry.addGroup(start, count, materialIndex);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    var depthPassMaterial = _instanceof(mesh.material, Array) ? mesh.material.map(createDepthPrePassMaterial) : createDepthPrePassMaterial(mesh.material);
    var depthPassMesh = new THREE92.Mesh(depthPassGeometry, depthPassMaterial);
    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;
    return depthPassMesh;
}
function setDepthPrePassStencil(depthMesh, colorMesh) {
    var setupDepthMaterialStencil = function setupDepthMaterialStencil(depthMeshMaterial) {
        var depthMaterial = depthMeshMaterial;
        depthMaterial.stencilWrite = true;
        depthMaterial.stencilFail = THREE92.KeepStencilOp;
        depthMaterial.stencilZFail = THREE92.KeepStencilOp;
        depthMaterial.stencilZPass = THREE92.ReplaceStencilOp;
        depthMaterial.stencilFunc = THREE92.AlwaysStencilFunc;
        depthMaterial.stencilRef = 255;
        depthMaterial.stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;
    };
    var setupColorMaterialStencil = function setupColorMaterialStencil(colorMeshMaterial) {
        var colorMaterial = colorMeshMaterial;
        colorMaterial.stencilWrite = true;
        colorMaterial.stencilFail = THREE92.KeepStencilOp;
        colorMaterial.stencilZFail = THREE92.KeepStencilOp;
        colorMaterial.stencilZPass = THREE92.ZeroStencilOp;
        colorMaterial.stencilFunc = THREE92.EqualStencilFunc;
        colorMaterial.stencilRef = 255;
        colorMaterial.stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;
    };
    if (_instanceof(depthMesh.material, Array)) {
        depthMesh.material.map(setupDepthMaterialStencil);
    } else {
        setupDepthMaterialStencil(depthMesh.material);
    }
    if (_instanceof(colorMesh.material, Array)) {
        colorMesh.material.map(setupColorMaterialStencil);
    } else {
        setupColorMaterialStencil(colorMesh.material);
    }
}
// src/mapview/PathBlockingElement.ts
var THREE93 = __toESM(require("three"));
var PathBlockingElement = function PathBlockingElement(points) {
    _classCallCheck(this, PathBlockingElement);
    this.points = points;
    __publicField(this, "screenSpaceLines");
    this.screenSpaceLines = new Array(points.length >= 2 ? points.length - 1 : 0);
    for(var i = 0; i < this.screenSpaceLines.length; i++){
        this.screenSpaceLines[i] = new THREE93.Line3(new THREE93.Vector3(), new THREE93.Vector3());
    }
};
// src/mapview/geometry/TileGeometryCreator.ts
var logger25 = LoggerManager.instance.create("TileGeometryCreator");
var tmpVector3 = new THREE94.Vector3();
var tmpVector2 = new THREE94.Vector2();
var AttachmentCache = function AttachmentCache() {
    _classCallCheck(this, AttachmentCache);
    __publicField(this, "bufferAttributes", /* @__PURE__ */ new Map());
    __publicField(this, "interleavedAttributes", /* @__PURE__ */ new Map());
};
var MemoCallExpr = /*#__PURE__*/ function(CallExpr7) {
    _inherits(MemoCallExpr, CallExpr7);
    var _super = _createSuper(MemoCallExpr);
    function MemoCallExpr(expr) {
        _classCallCheck(this, MemoCallExpr);
        var _this;
        _this = _super.call(this, "memo", [
            expr
        ]);
        __publicField(_assertThisInitialized(_this), "m_deps");
        __publicField(_assertThisInitialized(_this), "m_cachedProperties", []);
        __publicField(_assertThisInitialized(_this), "m_cachedValue");
        _this.m_deps = Array.from(expr.dependencies().properties);
        _this.descriptor = _assertThisInitialized(_this);
        return _this;
    }
    _createClass(MemoCallExpr, [
        {
            key: "call",
            value: function call(context) {
                var _this = this;
                var changed = false;
                this.m_deps.forEach(function(d, i) {
                    var newValue = context.env.lookup(d);
                    if (!changed && newValue !== _this.m_cachedProperties[i]) {
                        changed = true;
                    }
                    if (changed) {
                        _this.m_cachedProperties[i] = newValue;
                    }
                });
                if (changed || this.m_cachedValue === void 0) {
                    this.m_cachedValue = context.evaluate(this.args[0]);
                }
                return this.m_cachedValue;
            }
        }
    ]);
    return MemoCallExpr;
}(CallExpr7);
var AttachmentInfo = /*#__PURE__*/ function() {
    function AttachmentInfo(geometry, info, cache6) {
        _classCallCheck(this, AttachmentInfo);
        this.geometry = geometry;
        this.info = info;
        this.cache = cache6;
    }
    _createClass(AttachmentInfo, [
        {
            key: "getBufferAttribute",
            value: function getBufferAttribute1(description) {
                if (this.cache.bufferAttributes.has(description)) {
                    return this.cache.bufferAttributes.get(description);
                }
                var attribute = getBufferAttribute(description);
                this.cache.bufferAttributes.set(description, attribute);
                return attribute;
            }
        },
        {
            key: "getInterleavedBufferAttributes",
            value: function getInterleavedBufferAttributes(description) {
                var interleavedAttributes = this.cache.interleavedAttributes.get(description);
                if (interleavedAttributes) {
                    return interleavedAttributes;
                }
                var ArrayCtor = getArrayConstructor(description.type);
                var buffer = new ArrayCtor(description.buffer);
                var interleavedBuffer = new THREE94.InterleavedBuffer(buffer, description.stride);
                var attrs = description.attributes.map(function(interleavedAttr) {
                    var attribute = new THREE94.InterleavedBufferAttribute(interleavedBuffer, interleavedAttr.itemSize, interleavedAttr.offset, false);
                    var name2 = interleavedAttr.name;
                    return {
                        name: name2,
                        attribute: attribute
                    };
                });
                this.cache.interleavedAttributes.set(description, attrs);
                return attrs;
            }
        }
    ]);
    return AttachmentInfo;
}();
function addToExtrudedMaterials(material, extrudedMaterials) {
    if (Array.isArray(material)) {
        var _extrudedMaterials;
        var materials = material;
        (_extrudedMaterials = extrudedMaterials).push.apply(_extrudedMaterials, _toConsumableArray(materials));
    } else {
        extrudedMaterials.push(material);
    }
}
var _TileGeometryCreator = /*#__PURE__*/ function() {
    function _TileGeometryCreator() {
        _classCallCheck(this, _TileGeometryCreator);
    }
    _createClass(_TileGeometryCreator, [
        {
            key: "initDecodedTile",
            value: function initDecodedTile(decodedTile, enabledKinds, disabledKinds) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = decodedTile.techniques[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var technique = _step.value;
                        var kind = technique.kind;
                        if (kind === void 0 || _instanceof(kind, Set) && kind.size === 0) {
                            technique._kindState = true;
                            continue;
                        }
                        technique._kindState = !(disabledKinds !== void 0 && disabledKinds.hasOrIntersects(kind)) || enabledKinds !== void 0 && enabledKinds.hasOrIntersects(kind);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = decodedTile.geometries[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var srcGeometry = _step1.value;
                        var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                        try {
                            for(var _iterator2 = srcGeometry.groups[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                                var group = _step2.value;
                                group.createdOffsets = [];
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                    _iterator2.return();
                                }
                            } finally{
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
            }
        },
        {
            key: "createAllGeometries",
            value: function createAllGeometries(tile, decodedTile) {
                var filter = function(technique) {
                    return technique._kindState !== false;
                };
                var texturesReady = Promise.resolve();
                var onNewTexture = function(texturePromise) {
                    texturesReady = Promise.all([
                        texturesReady,
                        texturePromise.then(function(texture) {
                            tile.addOwnedTexture(texture);
                            if (!texture.image) {
                                return Promise.resolve();
                            }
                            return new Promise(function(resolve) {
                                texture.onUpdate = function() {
                                    ;
                                    texture.onUpdate = null;
                                    resolve();
                                };
                                tile.mapView.renderer.initTexture(texture);
                            });
                        }).catch(function() {})
                    ]);
                };
                this.createObjects(tile, decodedTile, onNewTexture, filter);
                this.preparePois(tile, decodedTile);
                var textFilter = function(technique) {
                    if (!isPoiTechnique(technique) && !isLineMarkerTechnique(technique) && !isTextTechnique(technique)) {
                        return false;
                    }
                    return filter(technique);
                };
                this.createTextElements(tile, decodedTile, textFilter);
                this.createLabelRejectionElements(tile, decodedTile);
                if (tile.dataSource.addGroundPlane && tile.projection.type === 0 /* Planar */ ) {
                    addGroundPlane(tile, -1);
                }
                return texturesReady;
            }
        },
        {
            key: "createLabelRejectionElements",
            value: function createLabelRejectionElements(tile, decodedTile) {
                if (decodedTile.pathGeometries === void 0) {
                    return;
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = decodedTile.pathGeometries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var path = _step.value;
                        tile.addBlockingElement(new PathBlockingElement(path.path));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "processTechniques",
            value: function processTechniques(tile, enabledKinds, disabledKinds) {
                var decodedTile = tile.decodedTile;
                if (decodedTile === void 0) {
                    return;
                }
                this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
                var exprPool = tile.dataSource.exprPool;
                decodedTile.techniques.forEach(function(technique) {
                    for(var propertyName in technique){
                        if (!technique.hasOwnProperty(propertyName)) {
                            continue;
                        }
                        var value2 = technique[propertyName];
                        if (isJsonExpr(value2) && propertyName !== "kind") {
                            try {
                                var expr = Expr3.fromJSON(value2);
                                if (expr.dependencies().volatile !== true) {
                                    expr = new MemoCallExpr(Expr3.fromJSON(value2));
                                }
                                technique[propertyName] = expr.intern(exprPool);
                            } catch (error) {
                                logger25.error("Failed to compile expression:", error);
                            }
                        }
                    }
                });
            }
        },
        {
            key: "prepareTextPaths",
            value: function prepareTextPaths(textPathGeometries, decodedTile, textFilter) {
                var processedPaths = new Array();
                var newPaths = textPathGeometries.slice();
                while(newPaths.length > 0){
                    var textPath = newPaths.pop();
                    if (textPath === void 0) {
                        break;
                    }
                    var technique = decodedTile.techniques[textPath.technique];
                    if (!isTextTechnique(technique) || textFilter !== void 0 && !textFilter(technique)) {
                        continue;
                    }
                    processedPaths.push(textPath);
                }
                return processedPaths;
            }
        },
        {
            key: "createTextElements",
            value: function createTextElements(tile, decodedTile, textFilter) {
                var mapView = tile.mapView;
                var worldOffsetX = tile.computeWorldOffsetX();
                var discreteZoomLevel = Math.floor(mapView.zoomLevel);
                var discreteZoomEnv = new MapEnv({
                    $zoom: discreteZoomLevel
                }, mapView.env);
                var textElementBuilder = new TextElementBuilder(discreteZoomEnv, tile.textStyleCache, tile.dataSource.dataSourceOrder);
                if (decodedTile.textPathGeometries !== void 0) {
                    var textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = textPathGeometries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var textPath = _step.value;
                            var technique = decodedTile.techniques[textPath.technique];
                            if (technique._kindState === false || !isTextTechnique(technique) || textFilter !== void 0 && !textFilter(technique)) {
                                continue;
                            }
                            var path = [];
                            for(var i = 0; i < textPath.path.length; i += 3){
                                path.push(new THREE94.Vector3(textPath.path[i] + worldOffsetX, textPath.path[i + 1], textPath.path[i + 2]));
                            }
                            var textElement = textElementBuilder.withTechnique(technique).build(textPath.text, path, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, textPath.objInfos, textPath.pathLengthSqr);
                            tile.addTextElement(textElement);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                if (decodedTile.textGeometries !== void 0) {
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = decodedTile.textGeometries[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var text = _step1.value;
                            if (text.technique === void 0 || text.stringCatalog === void 0) {
                                continue;
                            }
                            var technique1 = decodedTile.techniques[text.technique];
                            if (technique1._kindState === false || !isTextTechnique(technique1) || textFilter !== void 0 && !textFilter(technique1)) {
                                continue;
                            }
                            var positions = new THREE94.BufferAttribute(new Float64Array(text.positions.buffer), text.positions.itemCount);
                            var numPositions = positions.count;
                            if (numPositions < 1) {
                                continue;
                            }
                            textElementBuilder.withTechnique(technique1);
                            for(var i1 = 0; i1 < numPositions; ++i1){
                                var ref;
                                var x = positions.getX(i1) + worldOffsetX;
                                var y = positions.getY(i1);
                                var z = positions.getZ(i1);
                                var label = text.stringCatalog[text.texts[i1]];
                                if (label === void 0) {
                                    continue;
                                }
                                var attributes = (ref = text.objInfos) === null || ref === void 0 ? void 0 : ref[i1];
                                var point = new THREE94.Vector3(x, y, z);
                                var textElement1 = textElementBuilder.build(label, point, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, attributes);
                                tile.addTextElement(textElement1);
                            }
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                }
            }
        },
        {
            key: "createObjects",
            value: function createObjects(tile, decodedTile, onTextureCreated, techniqueFilter) {
                var mapView = tile.mapView;
                var materials = [];
                var extrudedMaterials = [];
                var animatedExtrusionHandler = mapView.animatedExtrusionHandler;
                var discreteZoomLevel = Math.floor(mapView.zoomLevel);
                var discreteZoomEnv = new MapEnv({
                    $zoom: discreteZoomLevel
                }, mapView.env);
                var objects = tile.objects;
                var viewRanges = mapView.viewRanges;
                var elevationEnabled = mapView.elevationProvider !== void 0;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.getAttachments(decodedTile)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _this = this, _loop = function(_iterator, _step) {
                            var ref, ref1;
                            var group = groups[groupIndex++];
                            var start = group.start;
                            var techniqueIndex = group.technique;
                            var technique = decodedTile.techniques[techniqueIndex];
                            if (group.createdOffsets === void 0) {
                                group.createdOffsets = [];
                            }
                            if (group.createdOffsets.includes(tile.offset) || technique._kindState === false || techniqueFilter !== void 0 && !techniqueFilter(technique)) {
                                return "continue";
                            }
                            var count = group.count;
                            group.createdOffsets.push(tile.offset);
                            for(; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex){
                                if (start + count !== groups[groupIndex].start) {
                                    break;
                                }
                                count += groups[groupIndex].count;
                                groups[groupIndex].createdOffsets.push(tile.offset);
                            }
                            if (!usesObject3D(technique)) {
                                return "continue";
                            }
                            var ref2;
                            var extrusionAnimationEnabled = (ref2 = animatedExtrusionHandler === null || animatedExtrusionHandler === void 0 ? void 0 : animatedExtrusionHandler.setAnimationProperties(technique, discreteZoomEnv)) !== null && ref2 !== void 0 ? ref2 : false;
                            var material = materials[techniqueIndex];
                            if (material === void 0) {
                                material = createMaterial(mapView.renderer.capabilities, {
                                    technique: technique,
                                    env: mapView.env,
                                    fog: mapView.scene.fog !== null,
                                    shadowsEnabled: mapView.shadowsEnabled
                                }, onTextureCreated);
                                if (material === void 0) {
                                    return "continue";
                                }
                                if (extrusionAnimationEnabled && hasExtrusionFeature(material)) {
                                    addToExtrudedMaterials(material, extrudedMaterials);
                                }
                                materials[techniqueIndex] = material;
                            }
                            var techniqueKind = technique.kind;
                            if (isTerrainTechnique(technique)) {
                                _this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);
                            }
                            var bufferGeometry = new THREE94.BufferGeometry();
                            (ref = srcGeometry.vertexAttributes) === null || ref === void 0 ? void 0 : ref.forEach(function(vertexAttribute) {
                                var buffer = attachment.getBufferAttribute(vertexAttribute);
                                bufferGeometry.setAttribute(vertexAttribute.name, buffer);
                            });
                            (ref1 = srcGeometry.interleavedVertexAttributes) === null || ref1 === void 0 ? void 0 : ref1.forEach(function(attr) {
                                attachment.getInterleavedBufferAttributes(attr).forEach(function(param) {
                                    var name2 = param.name, attribute = param.attribute;
                                    return bufferGeometry.setAttribute(name2, attribute);
                                });
                            });
                            var _index;
                            var index = (_index = attachment.info.index) !== null && _index !== void 0 ? _index : srcGeometry.index;
                            if (index) {
                                bufferGeometry.setIndex(attachment.getBufferAttribute(index));
                            }
                            if (!bufferGeometry.getAttribute("normal") && needsVertexNormals(technique)) {
                                bufferGeometry.computeVertexNormals();
                            }
                            bufferGeometry.addGroup(start, count);
                            if (isSolidLineTechnique(technique)) {
                                assert(!isHighPrecisionLineMaterial(material));
                                var lineMaterial = material;
                                if (technique.clipping === true && tile.projection.type === 0 /* Planar */ ) {
                                    tile.boundingBox.getSize(tmpVector3);
                                    tmpVector2.set(tmpVector3.x, tmpVector3.y);
                                    lineMaterial.clipTileSize = tmpVector2;
                                }
                                if (bufferGeometry.getAttribute("color")) {
                                    setShaderMaterialDefine(lineMaterial, "USE_COLOR", true);
                                }
                            }
                            var hasSolidLinesOutlines = isSolidLineTechnique(technique) && technique.secondaryWidth !== void 0;
                            var hasFeatureGroups = Expr3.isExpr(technique.enabled) && srcGeometry.featureStarts && srcGeometry.featureStarts.length > 0;
                            var object = buildObject(technique, bufferGeometry, hasFeatureGroups ? [
                                material
                            ] : material, tile, elevationEnabled);
                            object.renderOrder = getPropertyValue(technique.renderOrder, mapView.env);
                            if (attachment.info.uuid !== void 0) {
                                object.uuid = attachment.info.uuid;
                                object.userData.geometryId = attachment.info.uuid;
                            }
                            if ((isCirclesTechnique(technique) || isSquaresTechnique(technique)) && technique.enablePicking !== void 0) {
                                ;
                                object.enableRayTesting = technique.enablePicking;
                            }
                            if (isLineTechnique(technique) || isSegmentsTechnique(technique)) {
                                var fadingParams = _this.getFadingParams(discreteZoomEnv, technique);
                                FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                            }
                            if (isSolidLineTechnique(technique)) {
                                var fadingParams1 = _this.getFadingParams(discreteZoomEnv, technique);
                                FadingFeature.addRenderHelper(object, viewRanges, fadingParams1.fadeNear, fadingParams1.fadeFar, false);
                            }
                            if (isExtrudedLineTechnique(technique)) {
                                if (technique.fadeFar !== void 0) {
                                    var fadingParams2 = _this.getFadingParams(mapView.env, technique);
                                    FadingFeature.addRenderHelper(object, viewRanges, fadingParams2.fadeNear, fadingParams2.fadeFar, true);
                                }
                            }
                            _this.addUserData(tile, srcGeometry, technique, object);
                            if (isExtrudedPolygonTechnique(technique)) {
                                object.castShadow = mapView.shadowsEnabled;
                                object.receiveShadow = mapView.shadowsEnabled;
                            } else if (isStandardTechnique(technique) || isFillTechnique(technique)) {
                                object.receiveShadow = mapView.shadowsEnabled;
                            }
                            if (isExtrudedPolygonTechnique(technique) || isStandardTechnique(technique) || isFillTechnique(technique)) {
                                if (technique.fadeFar !== void 0) {
                                    var fadingParams3 = _this.getFadingParams(discreteZoomEnv, technique);
                                    FadingFeature.addRenderHelper(object, viewRanges, fadingParams3.fadeNear, fadingParams3.fadeFar, true);
                                }
                            }
                            var renderDepthPrePass = isExtrudedPolygonTechnique(technique) && isRenderDepthPrePassEnabled(technique, discreteZoomEnv);
                            if (renderDepthPrePass) {
                                var depthPassMesh = createDepthPrePassMesh(object);
                                _this.addUserData(tile, srcGeometry, technique, depthPassMesh);
                                registerTileObject(tile, depthPassMesh, techniqueKind, {
                                    technique: technique,
                                    pickability: "transient" /* transient */ 
                                });
                                objects.push(depthPassMesh);
                                if (extrusionAnimationEnabled) {
                                    addToExtrudedMaterials(depthPassMesh.material, extrudedMaterials);
                                }
                                setDepthPrePassStencil(depthPassMesh, object);
                            }
                            var techniquePickability = transientToPickability(getPropertyValue(technique.transient, mapView.env));
                            registerTileObject(tile, object, techniqueKind, {
                                technique: technique,
                                pickability: hasSolidLinesOutlines ? "transient" /* transient */  : techniquePickability
                            });
                            objects.push(object);
                            if (isExtrudedPolygonTechnique(technique) && attachment.info.edgeIndex !== void 0) {
                                var hasEdgeFeatureGroups = Expr3.isExpr(technique.enabled) && srcGeometry.edgeFeatureStarts && srcGeometry.edgeFeatureStarts.length > 0;
                                var buildingTechnique = technique;
                                var edgeGeometry = new THREE94.BufferGeometry();
                                edgeGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                                var colorAttribute = bufferGeometry.getAttribute("color");
                                if (colorAttribute !== void 0) {
                                    edgeGeometry.setAttribute("color", colorAttribute);
                                }
                                var extrusionAttribute = bufferGeometry.getAttribute("extrusionAxis");
                                if (extrusionAttribute !== void 0) {
                                    edgeGeometry.setAttribute("extrusionAxis", extrusionAttribute);
                                }
                                var normalAttribute = bufferGeometry.getAttribute("normal");
                                if (normalAttribute !== void 0) {
                                    edgeGeometry.setAttribute("normal", normalAttribute);
                                }
                                var uvAttribute = bufferGeometry.getAttribute("uv");
                                if (uvAttribute !== void 0) {
                                    edgeGeometry.setAttribute("uv", uvAttribute);
                                }
                                edgeGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
                                var extrudedPolygonTechnique = technique;
                                var fadingParams4 = _this.getPolygonFadingParams(discreteZoomEnv, extrudedPolygonTechnique);
                                var materialParams = {
                                    color: fadingParams4.color,
                                    colorMix: fadingParams4.colorMix,
                                    fadeNear: fadingParams4.lineFadeNear,
                                    fadeFar: fadingParams4.lineFadeFar,
                                    extrusionRatio: extrusionAnimationEnabled ? 0 : void 0,
                                    vertexColors: bufferGeometry.getAttribute("color") ? true : false,
                                    rendererCapabilities: mapView.renderer.capabilities
                                };
                                var edgeMaterial = new EdgeMaterial(materialParams);
                                var edgeObj = new THREE94.LineSegments(edgeGeometry, hasEdgeFeatureGroups ? [
                                    edgeMaterial
                                ] : edgeMaterial);
                                _this.addUserData(tile, srcGeometry, technique, edgeObj);
                                edgeObj.renderOrder = object.renderOrder + 0.1;
                                FadingFeature.addRenderHelper(edgeObj, viewRanges, fadingParams4.lineFadeNear, fadingParams4.lineFadeFar, false);
                                if (extrusionAnimationEnabled) {
                                    addToExtrudedMaterials(edgeObj.material, extrudedMaterials);
                                }
                                registerTileObject(tile, edgeObj, techniqueKind, {
                                    technique: technique,
                                    pickability: "transient" /* transient */ 
                                });
                                MapMaterialAdapter.create(edgeMaterial, {
                                    color: buildingTechnique.lineColor,
                                    objectColor: buildingTechnique.color,
                                    opacity: buildingTechnique.opacity,
                                    lineWidth: function(frameMapView) {
                                        var value2 = getPropertyValue(buildingTechnique.lineWidth, frameMapView.env);
                                        if (typeof value2 === "number") {
                                            return THREE94.MathUtils.clamp(value2, 0, 1);
                                        } else {
                                            return 0;
                                        }
                                    }
                                });
                                objects.push(edgeObj);
                            }
                            if (isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {
                                object.customDepthMaterial = new MapMeshDepthMaterial({
                                    depthPacking: THREE94.RGBADepthPacking
                                });
                                addToExtrudedMaterials(object.customDepthMaterial, extrudedMaterials);
                            }
                            if (isFillTechnique(technique) && attachment.info.edgeIndex) {
                                var hasEdgeFeatureGroups1 = Expr3.isExpr(technique.enabled) && srcGeometry.edgeFeatureStarts && srcGeometry.edgeFeatureStarts.length > 0;
                                var outlineGeometry = new THREE94.BufferGeometry();
                                outlineGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                                outlineGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
                                var fillTechnique = technique;
                                var fadingParams5 = _this.getPolygonFadingParams(mapView.env, fillTechnique);
                                var materialParams1 = {
                                    color: fadingParams5.color,
                                    colorMix: fadingParams5.colorMix,
                                    fadeNear: fadingParams5.lineFadeNear,
                                    fadeFar: fadingParams5.lineFadeFar,
                                    vertexColors: bufferGeometry.getAttribute("color") ? true : false,
                                    rendererCapabilities: mapView.renderer.capabilities
                                };
                                var outlineMaterial = new EdgeMaterial(materialParams1);
                                var outlineObj = new THREE94.LineSegments(outlineGeometry, hasEdgeFeatureGroups1 ? [
                                    outlineMaterial
                                ] : outlineMaterial);
                                outlineObj.renderOrder = object.renderOrder + 0.1;
                                FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams5.lineFadeNear, fadingParams5.lineFadeFar, false);
                                _this.addUserData(tile, srcGeometry, technique, outlineObj);
                                registerTileObject(tile, outlineObj, techniqueKind, {
                                    technique: technique,
                                    pickability: techniquePickability
                                });
                                MapMaterialAdapter.create(outlineMaterial, {
                                    color: fillTechnique.lineColor,
                                    objectColor: fillTechnique.color,
                                    opacity: fillTechnique.opacity
                                });
                                objects.push(outlineObj);
                            }
                            if (hasSolidLinesOutlines) {
                                var outlineTechnique = technique;
                                var outlineMaterial1 = material.clone();
                                var _secondaryColor;
                                applyBaseColorToMaterial(outlineMaterial1, outlineMaterial1.color, outlineTechnique, (_secondaryColor = outlineTechnique.secondaryColor) !== null && _secondaryColor !== void 0 ? _secondaryColor : 0, discreteZoomEnv);
                                if (outlineTechnique.secondaryCaps !== void 0) {
                                    outlineMaterial1.caps = getPropertyValue(outlineTechnique.secondaryCaps, mapView.env);
                                }
                                var outlineObj1 = buildObject(technique, bufferGeometry, outlineMaterial1, tile, elevationEnabled);
                                var ref3;
                                outlineObj1.renderOrder = ((ref3 = getPropertyValue(outlineTechnique.secondaryRenderOrder, mapView.env)) !== null && ref3 !== void 0 ? ref3 : 0) - 1e-7;
                                _this.addUserData(tile, srcGeometry, technique, outlineObj1);
                                var fadingParams6 = _this.getFadingParams(discreteZoomEnv, technique);
                                FadingFeature.addRenderHelper(outlineObj1, viewRanges, fadingParams6.fadeNear, fadingParams6.fadeFar, false);
                                var secondaryWidth = buildMetricValueEvaluator(outlineTechnique.secondaryWidth, outlineTechnique.metricUnit);
                                registerTileObject(tile, outlineObj1, techniqueKind, {
                                    technique: technique
                                });
                                var mainMaterialAdapter = MapMaterialAdapter.get(material);
                                var outlineMaterialAdapter = MapMaterialAdapter.create(outlineMaterial1, {
                                    color: outlineTechnique.secondaryColor,
                                    opacity: outlineTechnique.opacity,
                                    caps: outlineTechnique.secondaryCaps,
                                    lineWidth: function(frameMapView) {
                                        if (!mainMaterialAdapter) {
                                            return;
                                        }
                                        mainMaterialAdapter.ensureUpdated(frameMapView);
                                        var mainLineWidth = mainMaterialAdapter.currentStyledProperties.lineWidth;
                                        var secondaryLineWidth = getPropertyValue(secondaryWidth, mapView.env);
                                        var opacity = outlineMaterialAdapter.currentStyledProperties.opacity;
                                        if (typeof mainLineWidth === "number" && typeof secondaryLineWidth === "number") {
                                            if (secondaryLineWidth <= mainLineWidth && (opacity === null || opacity === void 0 || opacity === 1)) {
                                                return 0;
                                            } else {
                                                return secondaryLineWidth;
                                            }
                                        } else {
                                            return 0;
                                        }
                                    }
                                });
                                objects.push(outlineObj1);
                            }
                        };
                        var attachment = _step.value;
                        var srcGeometry = attachment.geometry;
                        var groups = attachment.info.groups;
                        var groupCount = groups.length;
                        for(var groupIndex = 0; groupIndex < groupCount;)_loop(_iterator, _step);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (extrudedMaterials.length > 0) {
                    mapView.animatedExtrusionHandler.add(tile, extrudedMaterials);
                }
            }
        },
        {
            key: "preparePois",
            value: function preparePois(tile, decodedTile) {
                if (decodedTile.poiGeometries !== void 0) {
                    tile.mapView.poiManager.addPois(tile, decodedTile);
                }
            }
        },
        {
            key: "getAttachments",
            value: regeneratorRuntime.mark(function getAttachments(decodedTile) {
                var cache6, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, geometry, mainAttachment, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, info;
                return regeneratorRuntime.wrap(function getAttachments$(_ctx) {
                    while(1)switch(_ctx.prev = _ctx.next){
                        case 0:
                            cache6 = new AttachmentCache();
                            _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            _ctx.prev = 2;
                            _iterator = decodedTile.geometries[Symbol.iterator]();
                        case 4:
                            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                _ctx.next = 37;
                                break;
                            }
                            geometry = _step.value;
                            mainAttachment = {
                                index: geometry.index,
                                edgeIndex: geometry.edgeIndex,
                                uuid: geometry.uuid,
                                groups: geometry.groups
                            };
                            _ctx.next = 9;
                            return new AttachmentInfo(geometry, mainAttachment, cache6);
                        case 9:
                            if (!geometry.attachments) {
                                _ctx.next = 34;
                                break;
                            }
                            _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            _ctx.prev = 11;
                            _iterator1 = geometry.attachments[Symbol.iterator]();
                        case 13:
                            if (_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done) {
                                _ctx.next = 20;
                                break;
                            }
                            info = _step1.value;
                            _ctx.next = 17;
                            return new AttachmentInfo(geometry, info, cache6);
                        case 17:
                            _iteratorNormalCompletion1 = true;
                            _ctx.next = 13;
                            break;
                        case 20:
                            _ctx.next = 26;
                            break;
                        case 22:
                            _ctx.prev = 22;
                            _ctx.t0 = _ctx["catch"](11);
                            _didIteratorError1 = true;
                            _iteratorError1 = _ctx.t0;
                        case 26:
                            _ctx.prev = 26;
                            _ctx.prev = 27;
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        case 29:
                            _ctx.prev = 29;
                            if (!_didIteratorError1) {
                                _ctx.next = 32;
                                break;
                            }
                            throw _iteratorError1;
                        case 32:
                            return _ctx.finish(29);
                        case 33:
                            return _ctx.finish(26);
                        case 34:
                            _iteratorNormalCompletion = true;
                            _ctx.next = 4;
                            break;
                        case 37:
                            _ctx.next = 43;
                            break;
                        case 39:
                            _ctx.prev = 39;
                            _ctx.t1 = _ctx["catch"](2);
                            _didIteratorError = true;
                            _iteratorError = _ctx.t1;
                        case 43:
                            _ctx.prev = 43;
                            _ctx.prev = 44;
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        case 46:
                            _ctx.prev = 46;
                            if (!_didIteratorError) {
                                _ctx.next = 49;
                                break;
                            }
                            throw _iteratorError;
                        case 49:
                            return _ctx.finish(46);
                        case 50:
                            return _ctx.finish(43);
                        case 51:
                        case "end":
                            return _ctx.stop();
                    }
                }, getAttachments, null, [
                    [
                        2,
                        39,
                        43,
                        51
                    ],
                    [
                        11,
                        22,
                        26,
                        34
                    ],
                    [
                        27,
                        ,
                        29,
                        33
                    ],
                    [
                        44,
                        ,
                        46,
                        50
                    ]
                ]);
            })
        },
        {
            key: "setupTerrainMaterial",
            value: function setupTerrainMaterial(technique, material, terrainColor) {
                if (!technique.map || !technique.displacementMap) {
                    var stdMaterial = material;
                    stdMaterial.color.set(terrainColor);
                    setDisplacementMapToMaterial(null, stdMaterial);
                    return;
                }
                ;
                material.onBeforeCompile = function(shader) {
                    shader.fragmentShader = shader.fragmentShader.replace("#include <map_pars_fragment>", "#include <map_pars_fragment>\n    uniform sampler2D displacementMap;\n    uniform float displacementScale;\n    uniform float displacementBias;");
                    shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", "#ifdef USE_MAP\n    float minElevation = ".concat(EarthConstants.MIN_ELEVATION.toFixed(1), ";\n    float maxElevation = ").concat(EarthConstants.MAX_ELEVATION.toFixed(1), ";\n    float elevationRange = maxElevation - minElevation;\n\n    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;\n    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );\n    texelColor = mapTexelToLinear( texelColor );\n    diffuseColor *= texelColor;\n#endif"));
                    shader.vertexShader = shader.vertexShader.replace("#include <displacementmap_vertex>", "");
                };
                material.displacementMap.needsUpdate = true;
            }
        },
        {
            key: "addUserData",
            value: function addUserData(tile, srcGeometry, technique, object) {
                if (isTerrainTechnique(technique)) {
                    assert(Object.keys(object.userData).length === 0, "Unexpected user data in terrain object");
                    assert(typeof srcGeometry.objInfos[0] === "object", "Wrong attribute map type for terrain geometry");
                    var displacementMap = srcGeometry.objInfos[0];
                    var tileDisplacementMap = {
                        tileKey: tile.tileKey,
                        texture: new THREE94.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE94.LuminanceFormat, THREE94.FloatType),
                        displacementMap: displacementMap,
                        geoBox: tile.geoBox
                    };
                    object.userData = tileDisplacementMap;
                } else {
                    var isOutline = object.type === "LineSegments" && (isExtrudedPolygonTechnique(technique) || isFillTechnique(technique));
                    var featureData = {
                        geometryType: srcGeometry.type,
                        starts: isOutline ? srcGeometry.edgeFeatureStarts : srcGeometry.featureStarts,
                        objInfos: srcGeometry.objInfos
                    };
                    object.userData.feature = featureData;
                    object.userData.technique = technique;
                }
            }
        },
        {
            key: "getFadingParams",
            value: function getFadingParams(env, technique) {
                var fadeNear = technique.fadeNear !== void 0 ? getPropertyValue(technique.fadeNear, env) : FadingFeature.DEFAULT_FADE_NEAR;
                var fadeFar = technique.fadeFar !== void 0 ? getPropertyValue(technique.fadeFar, env) : FadingFeature.DEFAULT_FADE_FAR;
                return {
                    fadeNear: fadeNear,
                    fadeFar: fadeFar
                };
            }
        },
        {
            key: "getPolygonFadingParams",
            value: function getPolygonFadingParams(env, technique) {
                var color;
                var colorMix = EdgeMaterial.DEFAULT_COLOR_MIX;
                if (technique.lineColor !== void 0) {
                    color = getPropertyValue(technique.lineColor, env);
                    if (isExtrudedPolygonTechnique(technique)) {
                        var extrudedPolygonTechnique = technique;
                        colorMix = extrudedPolygonTechnique.lineColorMix !== void 0 ? extrudedPolygonTechnique.lineColorMix : EdgeMaterial.DEFAULT_COLOR_MIX;
                    }
                }
                var fadeNear = technique.fadeNear !== void 0 ? getPropertyValue(technique.fadeNear, env) : FadingFeature.DEFAULT_FADE_NEAR;
                var fadeFar = technique.fadeFar !== void 0 ? getPropertyValue(technique.fadeFar, env) : FadingFeature.DEFAULT_FADE_FAR;
                var lineFadeNear = technique.lineFadeNear !== void 0 ? getPropertyValue(technique.lineFadeNear, env) : fadeNear;
                var lineFadeFar = technique.lineFadeFar !== void 0 ? getPropertyValue(technique.lineFadeFar, env) : fadeFar;
                if (color === void 0) {
                    color = EdgeMaterial.DEFAULT_COLOR;
                }
                return {
                    color: color,
                    colorMix: colorMix,
                    fadeNear: fadeNear,
                    fadeFar: fadeFar,
                    lineFadeNear: lineFadeNear,
                    lineFadeFar: lineFadeFar
                };
            }
        }
    ], [
        {
            key: "instance",
            get: function get() {
                return this.m_instance || (this.m_instance = new _TileGeometryCreator());
            }
        }
    ]);
    return _TileGeometryCreator;
}();
var TileGeometryCreator = _TileGeometryCreator;
__publicField(TileGeometryCreator, "m_instance");
// src/mapview/geometry/TileGeometryLoader.ts
function addDiscardedTileToStats(tile) {
    var stats = PerformanceStatistics.instance;
    if (stats.enabled) {
        var name2 = tile.dataSource.name;
        var level = tile.tileKey.level;
        var col = tile.tileKey.column;
        var row = tile.tileKey.row;
        var reason = tile.disposed ? "disposed" : "invisible";
        stats.currentFrame.addMessage("Decoded tile: ".concat(name2, " # lvl=").concat(level, " col=").concat(col, " row=").concat(row, " DISCARDED - ").concat(reason));
    }
}
var TileGeometryLoader = /*#__PURE__*/ function() {
    function TileGeometryLoader(m_tile, m_taskQueue) {
        var _this = this;
        _classCallCheck(this, TileGeometryLoader);
        this.m_tile = m_tile;
        this.m_taskQueue = m_taskQueue;
        __publicField(this, "m_decodedTile");
        __publicField(this, "m_availableGeometryKinds");
        __publicField(this, "m_enabledKinds");
        __publicField(this, "m_disabledKinds");
        __publicField(this, "m_priority", 0);
        __publicField(this, "m_state", 0 /* Initialized */ );
        __publicField(this, "m_finishedPromise");
        __publicField(this, "m_resolveFinishedPromise");
        __publicField(this, "m_rejectFinishedPromise");
        this.m_finishedPromise = new Promise(function(resolve, reject) {
            _this.m_resolveFinishedPromise = resolve;
            _this.m_rejectFinishedPromise = reject;
        });
    }
    _createClass(TileGeometryLoader, [
        {
            key: "priority",
            set: function set(value2) {
                this.m_priority = value2;
            }
        },
        {
            key: "getPriority",
            value: function getPriority() {
                return this.m_priority;
            }
        },
        {
            key: "tile",
            get: function get() {
                return this.m_tile;
            }
        },
        {
            key: "hasDecodedTile",
            get: function get() {
                return this.m_decodedTile !== void 0;
            }
        },
        {
            key: "isFinished",
            get: function get() {
                return this.m_state === 3 /* Finished */ ;
            }
        },
        {
            key: "isSettled",
            get: function get() {
                return this.isFinished || this.isCanceled || this.isDisposed;
            }
        },
        {
            key: "waitFinished",
            value: function waitFinished() {
                return this.m_finishedPromise;
            }
        },
        {
            key: "setDecodedTile",
            value: function setDecodedTile(decodedTile) {
                this.m_decodedTile = decodedTile;
                if (this.hasDecodedTile) {
                    this.m_availableGeometryKinds = TileGeometryLoader.prepareAvailableGeometryKinds(this.m_decodedTile);
                }
                return this.m_decodedTile;
            }
        },
        {
            key: "availableGeometryKinds",
            get: function get() {
                return this.m_availableGeometryKinds;
            }
        },
        {
            key: "update",
            value: function update(enabledKinds, disabledKinds) {
                var tile = this.tile;
                if (this.tile.hasGeometry && !this.compareGeometryKinds(enabledKinds, disabledKinds)) {
                    this.reset();
                }
                if ((this.m_state === 0 /* Initialized */  || this.m_state === 4 /* Canceled */ ) && tile.decodedTile !== void 0) {
                    if (this.m_state === 0 /* Initialized */ ) {
                        TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);
                        this.setGeometryKinds(enabledKinds, disabledKinds);
                        this.setDecodedTile(tile.decodedTile);
                    }
                    this.queueGeometryCreation(enabledKinds, disabledKinds);
                }
            }
        },
        {
            key: "cancel",
            value: function cancel() {
                var _obj, ref;
                addDiscardedTileToStats(this.tile);
                this.m_state = 4 /* Canceled */ ;
                (ref = (_obj = this).m_rejectFinishedPromise) === null || ref === void 0 ? void 0 : ref.call(_obj);
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                var _obj, ref;
                addDiscardedTileToStats(this.tile);
                this.clear();
                this.m_state = 5 /* Disposed */ ;
                (ref = (_obj = this).m_rejectFinishedPromise) === null || ref === void 0 ? void 0 : ref.call(_obj);
            }
        },
        {
            key: "reset",
            value: function reset() {
                var _this = this;
                this.clear();
                if (this.isSettled) {
                    this.m_finishedPromise = new Promise(function(resolve, reject) {
                        _this.m_resolveFinishedPromise = resolve;
                        _this.m_rejectFinishedPromise = reject;
                    });
                }
                this.m_state = 0 /* Initialized */ ;
            }
        },
        {
            key: "finish",
            value: function finish() {
                var _obj, ref;
                this.m_decodedTile = void 0;
                this.m_state = 3 /* Finished */ ;
                (ref = (_obj = this).m_resolveFinishedPromise) === null || ref === void 0 ? void 0 : ref.call(_obj);
            }
        },
        {
            key: "clear",
            value: function clear() {
                var ref, ref1, ref2;
                (ref = this.m_availableGeometryKinds) === null || ref === void 0 ? void 0 : ref.clear();
                (ref1 = this.m_enabledKinds) === null || ref1 === void 0 ? void 0 : ref1.clear();
                (ref2 = this.m_disabledKinds) === null || ref2 === void 0 ? void 0 : ref2.clear();
                this.m_decodedTile = void 0;
            }
        },
        {
            key: "queueGeometryCreation",
            value: function queueGeometryCreation(enabledKinds, disabledKinds) {
                var _this = this;
                if (this.m_state === 1 /* CreationQueued */ ) {
                    return;
                }
                this.m_taskQueue.add({
                    execute: this.createGeometry.bind(this, enabledKinds, disabledKinds),
                    group: "create" /* CREATE */ ,
                    getPriority: this.getPriority.bind(this),
                    isExpired: function() {
                        return _this.m_state !== 1 /* CreationQueued */ ;
                    },
                    estimatedProcessTime: function() {
                        var ref;
                        var ref1;
                        return ((ref1 = (ref = _this.tile.decodedTile) === null || ref === void 0 ? void 0 : ref.decodeTime) !== null && ref1 !== void 0 ? ref1 : 30) / 6;
                    }
                });
                this.m_state = 1 /* CreationQueued */ ;
            }
        },
        {
            key: "createGeometry",
            value: function createGeometry(enabledKinds, disabledKinds) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var tile, decodedTile, stats, now2, geometryCreator;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                if (!(_this.m_state === 2 /* CreatingGeometry */ )) {
                                    _ctx.next = 2;
                                    break;
                                }
                                return _ctx.abrupt("return");
                            case 2:
                                _this.m_state = 2 /* CreatingGeometry */ ;
                                tile = _this.tile;
                                decodedTile = _this.m_decodedTile;
                                if (!(decodedTile === void 0)) {
                                    _ctx.next = 8;
                                    break;
                                }
                                _this.finish();
                                return _ctx.abrupt("return");
                            case 8:
                                stats = PerformanceStatistics.instance;
                                now2 = 0;
                                if (stats.enabled) {
                                    now2 = PerformanceTimer.now();
                                }
                                geometryCreator = TileGeometryCreator.instance;
                                tile.clear();
                                geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
                                _ctx.next = 16;
                                return geometryCreator.createAllGeometries(tile, decodedTile);
                            case 16:
                                if (stats.enabled) {
                                    _this.addStats(stats, now2);
                                }
                                _this.finish();
                                tile.dataSource.requestUpdate();
                            case 19:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "addStats",
            value: function addStats(stats, now2) {
                var tile = this.tile;
                var decodedTile = this.m_decodedTile;
                if (decodedTile === void 0) {
                    return;
                }
                var geometryCreationTime = PerformanceTimer.now() - now2;
                var currentFrame = stats.currentFrame;
                currentFrame.addValue("render.fullFrameTime", geometryCreationTime);
                currentFrame.addValue("render.geometryCreationTime", geometryCreationTime);
                currentFrame.addValue("geometry.geometryCreationTime", geometryCreationTime);
                currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
                currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
                currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== void 0 ? decodedTile.poiGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== void 0 ? decodedTile.textGeometries.length : 0);
                currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== void 0 ? decodedTile.textPathGeometries.length : 0);
                currentFrame.addValue("geometryCount.numPathGeometries", decodedTile.pathGeometries !== void 0 ? decodedTile.pathGeometries.length : 0);
                currentFrame.addMessage("Decoded tile: ".concat(tile.dataSource.name, " # lvl=").concat(tile.tileKey.level, " col=").concat(tile.tileKey.column, " row=").concat(tile.tileKey.row));
            }
        },
        {
            key: "setGeometryKinds",
            value: function setGeometryKinds(enabledKinds, disabledKinds) {
                if (enabledKinds !== void 0) {
                    var _m_enabledKinds;
                    this.m_enabledKinds = Object.assign((_m_enabledKinds = this.m_enabledKinds) !== null && _m_enabledKinds !== void 0 ? _m_enabledKinds : new GeometryKindSet(), enabledKinds);
                }
                if (disabledKinds !== void 0) {
                    var _m_disabledKinds;
                    this.m_disabledKinds = Object.assign((_m_disabledKinds = this.m_disabledKinds) !== null && _m_disabledKinds !== void 0 ? _m_disabledKinds : new GeometryKindSet(), disabledKinds);
                }
            }
        },
        {
            key: "compareGeometryKinds",
            value: function compareGeometryKinds(enabledKinds, disabledKinds) {
                var enabledSame = this.m_enabledKinds === enabledKinds;
                var disabledSame = this.m_disabledKinds === disabledKinds;
                if (enabledSame && disabledSame) {
                    return true;
                }
                var enabledEmpty = (this.m_enabledKinds === void 0 || this.m_enabledKinds.size === 0) && (enabledKinds === void 0 || enabledKinds.size === 0);
                var disabledEmpty = (this.m_disabledKinds === void 0 || this.m_disabledKinds.size === 0) && (disabledKinds === void 0 || disabledKinds.size === 0);
                if (enabledEmpty && disabledEmpty || enabledSame && disabledEmpty || disabledSame && enabledEmpty) {
                    return true;
                }
                if (!enabledEmpty) {
                    if (enabledKinds === void 0 || this.m_enabledKinds === void 0) {
                        return false;
                    } else if (!enabledKinds.has(this.m_enabledKinds)) {
                        return false;
                    }
                }
                if (!disabledEmpty) {
                    if (disabledKinds === void 0 || this.m_disabledKinds === void 0) {
                        return false;
                    } else if (!disabledKinds.has(this.m_disabledKinds)) {
                        return false;
                    }
                }
                return true;
            }
        },
        {
            key: "isCanceled",
            get: function get() {
                return this.m_state === 4 /* Canceled */ ;
            }
        },
        {
            key: "isDisposed",
            get: function get() {
                return this.m_state === 5 /* Disposed */ ;
            }
        }
    ], [
        {
            key: "prepareAvailableGeometryKinds",
            value: function prepareAvailableGeometryKinds(decodedTile) {
                var foundSet = new GeometryKindSet();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = decodedTile.techniques[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var technique = _step.value;
                        var geometryKind = TileGeometryLoader.compileGeometryKind(technique);
                        if (_instanceof(geometryKind, Set)) {
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = geometryKind[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var kind = _step1.value;
                                    foundSet.add(kind);
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        } else {
                            foundSet.add(geometryKind);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return foundSet;
            }
        },
        {
            key: "compileGeometryKind",
            value: function compileGeometryKind(technique) {
                var geometryKind = technique.kind;
                if (geometryKind === void 0) {
                    if (isFillTechnique(technique)) {
                        geometryKind = GeometryKind.Area;
                    } else if (isLineTechnique(technique) || isSolidLineTechnique(technique) || isSegmentsTechnique(technique) || isExtrudedLineTechnique(technique)) {
                        geometryKind = GeometryKind.Line;
                    } else if (isExtrudedPolygonTechnique(technique)) {
                        geometryKind = GeometryKind.Building;
                    } else if (isPoiTechnique(technique) || isLineMarkerTechnique(technique) || isTextTechnique(technique)) {
                        geometryKind = GeometryKind.Label;
                    } else {
                        geometryKind = GeometryKind.All;
                    }
                    technique.kind = geometryKind;
                } else if (Array.isArray(geometryKind)) {
                    geometryKind = technique.kind = new GeometryKindSet(geometryKind);
                }
                return geometryKind;
            }
        }
    ]);
    return TileGeometryLoader;
}();
// src/mapview/text/TextElementGroup.ts
var TextElementGroup = /*#__PURE__*/ function(PriorityListGroup) {
    _inherits(TextElementGroup, PriorityListGroup);
    var _super = _createSuper(TextElementGroup);
    function TextElementGroup() {
        _classCallCheck(this, TextElementGroup);
        return _super.apply(this, arguments);
    }
    return TextElementGroup;
}(PriorityListGroup);
// src/mapview/text/TextElementGroupPriorityList.ts
var TextElementGroupPriorityList = /*#__PURE__*/ function(GroupedPriorityList) {
    _inherits(TextElementGroupPriorityList, GroupedPriorityList);
    var _super = _createSuper(TextElementGroupPriorityList);
    function TextElementGroupPriorityList() {
        _classCallCheck(this, TextElementGroupPriorityList);
        return _super.apply(this, arguments);
    }
    return TextElementGroupPriorityList;
}(GroupedPriorityList);
// src/mapview/text/TileTextStyleCache.ts
var TileTextStyleCache = /*#__PURE__*/ function() {
    function TileTextStyleCache(tile) {
        _classCallCheck(this, TileTextStyleCache);
        __publicField(this, "textRenderStyles", []);
        __publicField(this, "textLayoutStyles", []);
        __publicField(this, "tile");
        this.tile = tile;
    }
    _createClass(TileTextStyleCache, [
        {
            key: "clear",
            value: function clear() {
                this.textRenderStyles.length = 0;
                this.textLayoutStyles.length = 0;
            }
        },
        {
            key: "getRenderStyle",
            value: function getRenderStyle(technique) {
                var style = this.textRenderStyles[technique._index];
                if (style === void 0) {
                    style = this.textRenderStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createRenderStyle(this.tile, technique);
                }
                return style;
            }
        },
        {
            key: "getLayoutStyle",
            value: function getLayoutStyle(technique) {
                var style = this.textLayoutStyles[technique._index];
                if (style === void 0) {
                    style = this.textLayoutStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createLayoutStyle(this.tile, technique);
                }
                return style;
            }
        }
    ]);
    return TileTextStyleCache;
}();
// src/mapview/Tile.ts
var logger26 = LoggerManager.instance.create("Tile");
var MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;
var MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
function getFeatureDataSize(featureData) {
    var numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    if (featureData.starts !== void 0) {
        numBytes += featureData.starts.length * 8;
    }
    if (featureData.objInfos !== void 0) {
        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
var Tile = /*#__PURE__*/ function() {
    function Tile(dataSource, tileKey) {
        var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, localTangentSpace = arguments.length > 3 ? arguments[3] : void 0;
        _classCallCheck(this, Tile);
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        __publicField(this, "objects", []);
        __publicField(this, "dependencies", []);
        __publicField(this, "geoBox");
        __publicField(this, "copyrightInfo");
        __publicField(this, "frameNumLastRequested", -1);
        __publicField(this, "frameNumVisible", -1);
        __publicField(this, "frameNumLastVisible", -1);
        __publicField(this, "numFramesVisible", 0);
        __publicField(this, "visibilityCounter", -1);
        __publicField(this, "levelOffset", 0);
        __publicField(this, "skipRendering", false);
        __publicField(this, "delayRendering", false);
        __publicField(this, "preparedTextPaths");
        __publicField(this, "m_tileGeometryLoader");
        __publicField(this, "m_boundingBox", new OrientedBox3());
        __publicField(this, "m_disposed", false);
        __publicField(this, "m_disposeCallback");
        __publicField(this, "m_localTangentSpace");
        __publicField(this, "m_forceHasGeometry");
        __publicField(this, "m_tileLoader");
        __publicField(this, "m_decodedTile");
        __publicField(this, "m_textElementGroups", new TextElementGroupPriorityList());
        __publicField(this, "m_pathBlockingElements", []);
        __publicField(this, "m_textElementsChanged");
        __publicField(this, "m_worldCenter", new THREE95.Vector3());
        __publicField(this, "m_visibleArea", 0);
        __publicField(this, "m_elevationRange", {
            minElevation: 0,
            maxElevation: 0
        });
        __publicField(this, "m_maxGeometryHeight");
        __publicField(this, "m_minGeometryHeight");
        __publicField(this, "m_resourceInfo");
        __publicField(this, "m_ownedTextures", /* @__PURE__ */ new WeakSet());
        __publicField(this, "m_textStyleCache");
        __publicField(this, "m_uniqueKey");
        __publicField(this, "m_offset");
        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);
        this.updateBoundingBox();
        this.m_worldCenter.copy(this.boundingBox.position);
        this.m_localTangentSpace = localTangentSpace !== null && localTangentSpace !== void 0 ? localTangentSpace : false;
        this.m_textStyleCache = new TileTextStyleCache(this);
        this.m_offset = offset;
        this.m_uniqueKey = TileKeyUtils.getKeyForTileKeyAndOffset(this.tileKey, this.offset);
        if (dataSource.useGeometryLoader) {
            this.m_tileGeometryLoader = new TileGeometryLoader(this, this.mapView.taskQueue);
            this.attachGeometryLoadedCallback();
        }
    }
    _createClass(Tile, [
        {
            key: "isVisible",
            get: function get() {
                try {
                    return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;
                } catch (error) {
                    logger26.debug(error);
                    return false;
                }
            },
            set: function set(visible) {
                this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;
                if (!visible && this.m_tileGeometryLoader && !this.m_tileGeometryLoader.isSettled) {
                    this.m_tileGeometryLoader.cancel();
                }
            }
        },
        {
            key: "projection",
            get: function get() {
                return this.dataSource.projection;
            }
        },
        {
            key: "mapView",
            get: function get() {
                return this.dataSource.mapView;
            }
        },
        {
            key: "localTangentSpace",
            get: function get() {
                return this.m_localTangentSpace;
            }
        },
        {
            key: "memoryUsage",
            get: function get() {
                if (this.m_resourceInfo === void 0) {
                    this.computeResourceInfo();
                }
                return this.m_resourceInfo.heapSize;
            }
        },
        {
            key: "center",
            get: function get() {
                return this.m_worldCenter;
            }
        },
        {
            key: "uniqueKey",
            get: function get() {
                return this.m_uniqueKey;
            }
        },
        {
            key: "offset",
            get: function get() {
                return this.m_offset;
            },
            set: function set(offset) {
                if (this.m_offset !== offset) {
                    this.m_uniqueKey = TileKeyUtils.getKeyForTileKeyAndOffset(this.tileKey, offset);
                }
                this.m_offset = offset;
            }
        },
        {
            key: "getResourceInfo",
            value: function getResourceInfo() {
                if (this.m_resourceInfo === void 0) {
                    this.computeResourceInfo();
                }
                return this.m_resourceInfo;
            }
        },
        {
            key: "invalidateResourceInfo",
            value: function invalidateResourceInfo() {
                this.m_resourceInfo = void 0;
            }
        },
        {
            key: "addOwnedTexture",
            value: function addOwnedTexture(texture) {
                this.m_ownedTextures.add(texture);
            }
        },
        {
            key: "userTextElements",
            get: function get() {
                var group = this.m_textElementGroups.groups.get(TextElement.HIGHEST_PRIORITY);
                if (group === void 0) {
                    group = new TextElementGroup(TextElement.HIGHEST_PRIORITY);
                    this.m_textElementGroups.groups.set(group.priority, group);
                }
                return group;
            }
        },
        {
            key: "addUserTextElement",
            value: function addUserTextElement(textElement) {
                textElement.priority = TextElement.HIGHEST_PRIORITY;
                this.addTextElement(textElement);
            }
        },
        {
            key: "removeUserTextElement",
            value: function removeUserTextElement(textElement) {
                textElement.priority = TextElement.HIGHEST_PRIORITY;
                return this.removeTextElement(textElement);
            }
        },
        {
            key: "addTextElement",
            value: function addTextElement(textElement) {
                this.textElementGroups.add(textElement);
                if (this.m_textElementsChanged === false) {
                    this.m_textElementGroups = this.textElementGroups.clone();
                }
                this.textElementsChanged = true;
            }
        },
        {
            key: "addBlockingElement",
            value: function addBlockingElement(blockingElement) {
                this.m_pathBlockingElements.push(blockingElement);
            }
        },
        {
            key: "removeTextElement",
            value: function removeTextElement(textElement) {
                var groups = this.textElementGroups;
                if (!groups.remove(textElement)) {
                    return false;
                }
                if (this.m_textElementsChanged === false) {
                    this.m_textElementGroups = groups.clone();
                }
                this.textElementsChanged = true;
                return true;
            }
        },
        {
            key: "textElementGroups",
            get: function get() {
                return this.m_textElementGroups;
            }
        },
        {
            key: "textElementsChanged",
            get: function get() {
                var _m_textElementsChanged;
                return (_m_textElementsChanged = this.m_textElementsChanged) !== null && _m_textElementsChanged !== void 0 ? _m_textElementsChanged : false;
            },
            set: function set(changed) {
                this.m_textElementsChanged = changed;
            }
        },
        {
            key: "hasTextElements",
            value: function hasTextElements() {
                return this.m_textElementGroups.count() > 0;
            }
        },
        {
            key: "blockingElements",
            get: function get() {
                return this.m_pathBlockingElements;
            }
        },
        {
            key: "willRender",
            value: function willRender(_zoomLevel) {
                return !this.skipRendering && !this.delayRendering;
            }
        },
        {
            key: "didRender",
            value: function didRender() {}
        },
        {
            key: "visibleArea",
            get: function get() {
                return this.m_visibleArea;
            },
            set: function set(area) {
                this.m_visibleArea = area;
                if (this.tileLoader !== void 0) {
                    this.tileLoader.priority = area;
                }
            }
        },
        {
            key: "elevationRange",
            get: function get() {
                return this.m_elevationRange;
            },
            set: function set(elevationRange) {
                if (elevationRange.minElevation === this.m_elevationRange.minElevation && elevationRange.maxElevation === this.m_elevationRange.maxElevation && elevationRange.calculationStatus === this.m_elevationRange.calculationStatus) {
                    return;
                }
                this.m_elevationRange.minElevation = elevationRange.minElevation;
                this.m_elevationRange.maxElevation = elevationRange.maxElevation;
                this.m_elevationRange.calculationStatus = elevationRange.calculationStatus;
                this.elevateGeoBox();
                if (this.m_maxGeometryHeight !== void 0 || this.m_minGeometryHeight !== void 0) {
                    var ref;
                    assert(((ref = this.decodedTile) === null || ref === void 0 ? void 0 : ref.boundingBox) === void 0);
                    this.updateBoundingBox();
                }
            }
        },
        {
            key: "decodedTile",
            get: function get() {
                return this.m_decodedTile;
            },
            set: function set(decodedTile) {
                this.m_decodedTile = decodedTile;
                this.invalidateResourceInfo();
                if (decodedTile === void 0) {
                    return;
                }
                if (decodedTile.geometries.length === 0) {
                    this.forceHasGeometry(true);
                }
                var _maxGeometryHeight;
                this.m_maxGeometryHeight = decodedTile.boundingBox ? void 0 : (_maxGeometryHeight = decodedTile.maxGeometryHeight) !== null && _maxGeometryHeight !== void 0 ? _maxGeometryHeight : 0;
                var _minGeometryHeight;
                this.m_minGeometryHeight = decodedTile.boundingBox ? void 0 : (_minGeometryHeight = decodedTile.minGeometryHeight) !== null && _minGeometryHeight !== void 0 ? _minGeometryHeight : 0;
                this.elevateGeoBox();
                this.updateBoundingBox(decodedTile.boundingBox);
                var stats = PerformanceStatistics.instance;
                if (stats.enabled && decodedTile.decodeTime !== void 0) {
                    stats.currentFrame.addValue("decode.decodingTime", decodedTile.decodeTime);
                    stats.currentFrame.addValue("decode.decodedTiles", 1);
                }
                if (decodedTile.copyrightHolderIds !== void 0) {
                    this.copyrightInfo = decodedTile.copyrightHolderIds.map(function(id) {
                        return {
                            id: id
                        };
                    });
                }
                this.dataSource.requestUpdate();
            }
        },
        {
            key: "shouldDisposeObjectGeometry",
            value: function shouldDisposeObjectGeometry(object) {
                return true;
            }
        },
        {
            key: "shouldDisposeObjectMaterial",
            value: function shouldDisposeObjectMaterial(object) {
                return true;
            }
        },
        {
            key: "shouldDisposeTexture",
            value: function shouldDisposeTexture(texture) {
                return this.m_ownedTextures.has(texture);
            }
        },
        {
            key: "disposed",
            get: function get() {
                return this.m_disposed;
            }
        },
        {
            key: "allGeometryLoaded",
            get: function get() {
                var ref;
                var ref1;
                return (ref1 = (ref = this.m_tileGeometryLoader) === null || ref === void 0 ? void 0 : ref.isFinished) !== null && ref1 !== void 0 ? ref1 : this.hasGeometry;
            }
        },
        {
            key: "hasGeometry",
            get: function get() {
                if (this.m_forceHasGeometry === void 0) {
                    return this.objects.length !== 0;
                } else {
                    return this.m_forceHasGeometry;
                }
            }
        },
        {
            key: "forceHasGeometry",
            value: function forceHasGeometry(value2) {
                this.m_forceHasGeometry = value2;
            }
        },
        {
            key: "resetVisibilityCounter",
            value: function resetVisibilityCounter() {
                this.visibilityCounter = -1;
            }
        },
        {
            key: "tileLoader",
            get: function get() {
                return this.m_tileLoader;
            },
            set: function set(tileLoader) {
                this.m_tileLoader = tileLoader;
            }
        },
        {
            key: "load",
            value: function load() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var tileLoader, wasSettled;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                tileLoader = _this.tileLoader;
                                if (!(tileLoader === void 0)) {
                                    _ctx.next = 5;
                                    break;
                                }
                                _ctx.next = 4;
                                return Promise.resolve();
                            case 4:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 5:
                                if (_this.m_tileGeometryLoader) {
                                    wasSettled = _this.m_tileGeometryLoader.isSettled;
                                    _this.m_tileGeometryLoader.reset();
                                    if (wasSettled) {
                                        _this.attachGeometryLoadedCallback();
                                    }
                                }
                                _ctx.next = 8;
                                return tileLoader.loadAndDecode().then(function(tileLoaderState) {
                                    var ref;
                                    assert(tileLoaderState === 4 /* Ready */ );
                                    var decodedTile = tileLoader.decodedTile;
                                    _this.decodedTile = decodedTile;
                                    decodedTile === null || decodedTile === void 0 ? void 0 : (ref = decodedTile.dependencies) === null || ref === void 0 ? void 0 : ref.forEach(function(mortonCode) {
                                        _this.dependencies.push(TileKey.fromMortonCode(mortonCode));
                                    });
                                }).catch(function(tileLoaderState) {
                                    if (tileLoaderState === 6 /* Failed */ ) {
                                        _this.dispose();
                                    } else if (tileLoaderState !== 5 /* Canceled */ ) {
                                        logger26.error("Unknown error" + tileLoaderState);
                                    }
                                });
                            case 8:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 9:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "textStyleCache",
            get: function get() {
                return this.m_textStyleCache;
            }
        },
        {
            key: "clear",
            value: function clear() {
                var _this = this;
                var disposeMaterial = function(material) {
                    Object.getOwnPropertyNames(material).forEach(function(property) {
                        var materialProperty = material[property];
                        if (materialProperty !== void 0 && _instanceof(materialProperty, THREE95.Texture)) {
                            var texture = materialProperty;
                            if (_this.shouldDisposeTexture(texture)) {
                                texture.dispose();
                            }
                        }
                    });
                    material.dispose();
                };
                var disposeObject = function(object) {
                    if (_this.shouldDisposeObjectGeometry(object)) {
                        if (object.geometry !== void 0) {
                            object.geometry.dispose();
                        }
                        if (object.geometries !== void 0) {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = object.geometries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var geometry = _step.value;
                                    geometry.dispose();
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }
                    if (object.material !== void 0 && _this.shouldDisposeObjectMaterial(object)) {
                        if (_instanceof(object.material, Array)) {
                            object.material.forEach(function(material) {
                                if (material !== void 0) {
                                    disposeMaterial(material);
                                }
                            });
                        } else {
                            disposeMaterial(object.material);
                        }
                    }
                };
                this.objects.forEach(function(rootObject) {
                    rootObject.traverse(function(object) {
                        disposeObject(object);
                    });
                    disposeObject(rootObject);
                });
                this.objects.length = 0;
                if (this.preparedTextPaths) {
                    this.preparedTextPaths = [];
                }
                this.m_textStyleCache.clear();
                this.clearTextElements();
                this.invalidateResourceInfo();
            }
        },
        {
            key: "clearTextElements",
            value: function clearTextElements() {
                if (!this.hasTextElements()) {
                    return;
                }
                this.textElementsChanged = true;
                this.m_pathBlockingElements.splice(0);
                this.textElementGroups.forEach(function(element) {
                    element.dispose();
                });
                this.textElementGroups.clear();
            }
        },
        {
            key: "addDisposeCallback",
            value: function addDisposeCallback(callback) {
                this.m_disposeCallback = chainCallbacks(this.m_disposeCallback, callback);
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                var ref;
                if (this.m_disposed) {
                    return;
                }
                if (this.m_tileLoader) {
                    this.m_tileLoader.cancel();
                    this.m_tileLoader = void 0;
                }
                this.clear();
                this.frameNumLastRequested = 0;
                this.m_disposed = true;
                (ref = this.m_tileGeometryLoader) === null || ref === void 0 ? void 0 : ref.dispose();
                if (this.m_disposeCallback) {
                    this.m_disposeCallback(this);
                }
            }
        },
        {
            key: "computeWorldOffsetX",
            value: function computeWorldOffsetX() {
                return this.projection.worldExtent(0, 0).max.x * this.offset;
            }
        },
        {
            key: "update",
            value: function update(zoomLevel) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var object = _step.value;
                        if (_instanceof(object, LodMesh)) {
                            object.setLevelOfDetail(zoomLevel - this.tileKey.level);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "boundingBox",
            get: function get() {
                return this.m_boundingBox;
            }
        },
        {
            key: "updateGeometry",
            value: function updateGeometry(priority, enabledKinds, disabledKinds) {
                if (!this.m_tileGeometryLoader) {
                    return false;
                }
                if (this.m_tileGeometryLoader.isSettled) {
                    return true;
                }
                if (this.dataSource.isDetached()) {
                    this.m_tileGeometryLoader.cancel();
                    return true;
                }
                if (this.tileLoader) {
                    if (!this.tileLoader.isFinished) {
                        return true;
                    } else if (!this.decodedTile) {
                        this.m_tileGeometryLoader.finish();
                        return true;
                    }
                }
                if (priority !== void 0) {
                    this.m_tileGeometryLoader.priority = priority;
                }
                this.m_tileGeometryLoader.update(enabledKinds, disabledKinds);
                return true;
            }
        },
        {
            key: "loadedGeometryKinds",
            get: function get() {
                var ref;
                return (ref = this.m_tileGeometryLoader) === null || ref === void 0 ? void 0 : ref.availableGeometryKinds;
            }
        },
        {
            key: "loadingFinished",
            value: function loadingFinished() {}
        },
        {
            key: "attachGeometryLoadedCallback",
            value: function attachGeometryLoadedCallback() {
                var _this = this;
                assert(this.m_tileGeometryLoader !== void 0);
                this.m_tileGeometryLoader.waitFinished().then(function() {
                    _this.loadingFinished();
                    _this.removeDecodedTile();
                }).catch(function() {
                    if (_this.disposed) {
                        return;
                    }
                    if (!_this.dataSource.isDetached()) {
                        _this.mapView.visibleTileSet.disposeTile(_this);
                    }
                });
            }
        },
        {
            key: "removeDecodedTile",
            value: function removeDecodedTile() {
                this.m_decodedTile = void 0;
                this.invalidateResourceInfo();
            }
        },
        {
            key: "updateBoundingBox",
            value: function updateBoundingBox(newBoundingBox) {
                if (newBoundingBox) {
                    this.m_boundingBox.copy(newBoundingBox);
                    this.m_worldCenter.copy(this.boundingBox.position);
                } else {
                    this.projection.projectBox(this.geoBox, this.boundingBox);
                }
            }
        },
        {
            key: "elevateGeoBox",
            value: function elevateGeoBox() {
                var _m_minGeometryHeight;
                this.geoBox.southWest.altitude = this.m_elevationRange.minElevation + ((_m_minGeometryHeight = this.m_minGeometryHeight) !== null && _m_minGeometryHeight !== void 0 ? _m_minGeometryHeight : 0);
                var _m_maxGeometryHeight;
                this.geoBox.northEast.altitude = this.m_elevationRange.maxElevation + ((_m_maxGeometryHeight = this.m_maxGeometryHeight) !== null && _m_maxGeometryHeight !== void 0 ? _m_maxGeometryHeight : 0);
            }
        },
        {
            key: "computeResourceInfo",
            value: function computeResourceInfo() {
                var heapSize = 0;
                var num3dObjects = 0;
                var numTextElements = 0;
                var aggregatedObjSize = {
                    heapSize: 0,
                    gpuSize: 0
                };
                var visitedObjects = /* @__PURE__ */ new Map();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var object = _step.value;
                        if (object.visible) {
                            num3dObjects++;
                        }
                        Object3DUtils.estimateSize(object, aggregatedObjSize, visitedObjects);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = this.textElementGroups.groups[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var group = _step1.value;
                        numTextElements += group[1].elements.length;
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
                heapSize += numTextElements * 312;
                if (this.m_decodedTile !== void 0 && this.m_decodedTile.tileInfo !== void 0) {
                    aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;
                }
                this.m_resourceInfo = {
                    heapSize: aggregatedObjSize.heapSize + heapSize,
                    gpuSize: aggregatedObjSize.gpuSize,
                    num3dObjects: num3dObjects,
                    numTextElements: numTextElements,
                    numUserTextElements: 0
                };
            }
        }
    ]);
    return Tile;
}();
// src/mapview/geometry/Object3DUtils.ts
var MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1e3;
var MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;
var logger27 = LoggerManager.instance.create("Object3DUtils");
var Object3DUtils;
(function(Object3DUtils2) {
    var estimateTextureSize = function estimateTextureSize(texture, objectSize, visitedObjects) {
        if (texture === null || texture === void 0 || texture.image === void 0 || texture.image === null) {
            return;
        }
        if (texture.uuid !== void 0 && visitedObjects.get(texture.uuid) === true) {
            return;
        }
        visitedObjects.set(texture.uuid, true);
        var image = texture.image;
        var imageBytes = 4 * image.width * image.height;
        objectSize.heapSize += imageBytes;
        objectSize.gpuSize += imageBytes;
    };
    var estimateMaterialSize = function estimateMaterialSize(material, objectSize, visitedObjects) {
        if (material.uuid !== void 0 && visitedObjects.get(material.uuid) === true) {
            return;
        }
        visitedObjects.set(material.uuid, true);
        if (_instanceof(material, THREE96.RawShaderMaterial) || _instanceof(material, THREE96.ShaderMaterial)) {
            var rawMaterial = material;
            for(var name2 in rawMaterial.uniforms){
                if (rawMaterial.uniforms[name2] !== void 0) {
                    var uniform = rawMaterial.uniforms[name2];
                    if (_instanceof(uniform, THREE96.Texture)) {
                        estimateTextureSize(uniform, objectSize, visitedObjects);
                    }
                }
            }
        } else if (_instanceof(material, THREE96.MeshBasicMaterial) || _instanceof(material, MapMeshBasicMaterial)) {
            var meshMaterial = material;
            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);
        } else if (_instanceof(material, MapMeshStandardMaterial)) {
            var standardMaterial = material;
            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);
        } else if (_instanceof(material, THREE96.LineBasicMaterial) || _instanceof(material, THREE96.LineDashedMaterial) || _instanceof(material, THREE96.PointsMaterial)) {} else {
            logger27.warn("estimateMeshSize: unidentified material: ", material);
        }
    };
    var estimateAttributeSize = function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {
        if (attribute.uuid === void 0) {
            attribute.uuid = THREE96.MathUtils.generateUUID();
        }
        if (visitedObjects.get(attribute.uuid) === true) {
            return;
        }
        visitedObjects.set(attribute.uuid, true);
        var attrBytes = 0;
        var bytesPerElement = 4;
        if (attribute.array.BYTES_PER_ELEMENT !== void 0) {
            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;
        }
        if (_instanceof(attribute, THREE96.InterleavedBufferAttribute) || _instanceof(attribute, THREE96.BufferAttribute)) {
            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;
        } else {
            logger27.warn("estimateMeshSize: unidentified attribute: ", attrName);
        }
        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;
        objectSize.gpuSize += attrBytes;
    };
    var estimateGeometrySize = function estimateGeometrySize(geometry, objectSize, visitedObjects) {
        var isNewObject = geometry.uuid === void 0 || visitedObjects.get(geometry.uuid) !== true;
        if (!isNewObject) {
            return;
        }
        visitedObjects.set(geometry.uuid, true);
        if (geometry === void 0) {
            return;
        }
        var attributes = geometry.attributes;
        if (attributes === void 0) {
            logger27.warn("estimateGeometrySize: unidentified geometry: ", geometry);
            return;
        }
        for(var property in attributes){
            if (attributes[property] !== void 0) {
                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);
            }
        }
        if (geometry.index !== null) {
            estimateAttributeSize(geometry.index, "index", objectSize, visitedObjects);
        }
    };
    var estimateMeshSize = function estimateMeshSize(object, objectSize, visitedObjects) {
        if (!object.isObject3D || _instanceof(object, THREE96.Scene)) {
            return;
        }
        if (object.uuid !== void 0 && visitedObjects.get(object.uuid) === true) {
            return;
        }
        visitedObjects.set(object.uuid, true);
        if (object.isMesh || object.isLine || object.isPoints) {
            var heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;
            var gpuSize = 0;
            var mesh = object;
            if (mesh.material !== void 0) {
                if (Array.isArray(mesh.material)) {
                    var materials = mesh.material;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = materials[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var material = _step.value;
                            estimateMaterialSize(material, objectSize, visitedObjects);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else {
                    var material1 = mesh.material;
                    estimateMaterialSize(material1, objectSize, visitedObjects);
                }
            }
            if (mesh.geometries !== void 0) {
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = mesh.geometries[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var geometry = _step1.value;
                        estimateGeometrySize(geometry, objectSize, visitedObjects);
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
            } else if (mesh.geometry !== void 0) {
                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);
            }
            var featureData = object.userData !== void 0 ? object.userData.feature : void 0;
            if (featureData !== void 0) {
                heapSize += getFeatureDataSize(featureData);
            }
            objectSize.heapSize += heapSize;
            objectSize.gpuSize += gpuSize;
        } else {
            logger27.warn("estimateMeshSize: unidentified object", object);
        }
    };
    function estimateSize(object, parentSize, visitedObjects) {
        var size = parentSize !== void 0 ? parentSize : {
            heapSize: 0,
            gpuSize: 0
        };
        if (visitedObjects === void 0) {
            visitedObjects = /* @__PURE__ */ new Map();
        }
        estimateMeshSize(object, size, visitedObjects);
        if (object.children.length > 0) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                for(var _iterator = object.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                    var child = _step.value;
                    estimateSize(child, size, visitedObjects);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
        return size;
    }
    Object3DUtils2.estimateSize = estimateSize;
})(Object3DUtils || (Object3DUtils = {}));
// src/mapview/Utils.ts
var logger28 = LoggerManager.instance.create("MapViewUtils");
var TERRAIN_ZOOM_LEVEL = 4;
var groundNormalPlanarProj = new THREE97.Vector3(0, 0, 1);
var groundPlane = new THREE97.Plane(groundNormalPlanarProj.clone());
var groundSphere = new THREE97.Sphere(void 0, EarthConstants.EQUATORIAL_RADIUS);
var rayCaster = new THREE97.Raycaster();
var epsilon2 = 1e-5;
var space = {
    x: new THREE97.Vector3(),
    y: new THREE97.Vector3(),
    z: new THREE97.Vector3()
};
var tangentSpace = {
    x: new THREE97.Vector3(),
    y: new THREE97.Vector3(),
    z: new THREE97.Vector3()
};
var cache4 = {
    box3: [
        new THREE97.Box3()
    ],
    obox3: [
        new OrientedBox3()
    ],
    quaternions: [
        new THREE97.Quaternion(),
        new THREE97.Quaternion()
    ],
    vector2: [
        new THREE97.Vector2(),
        new THREE97.Vector2()
    ],
    vector3: [
        new THREE97.Vector3(),
        new THREE97.Vector3(),
        new THREE97.Vector3(),
        new THREE97.Vector3()
    ],
    matrix4: [
        new THREE97.Matrix4(),
        new THREE97.Matrix4()
    ],
    transforms: [
        {
            xAxis: new THREE97.Vector3(),
            yAxis: new THREE97.Vector3(),
            zAxis: new THREE97.Vector3(),
            position: new THREE97.Vector3()
        }
    ]
};
var tmpCamera = new THREE97.PerspectiveCamera();
function snapToCeilingZoomLevel(zoomLevel) {
    var eps = 1e-6;
    var ceiling = Math.ceil(zoomLevel);
    return ceiling - zoomLevel < eps ? ceiling : zoomLevel;
}
var MapViewUtils;
(function(MapViewUtils2) {
    var zoomOnTargetPosition = function zoomOnTargetPosition(mapView, targetNDCx, targetNDCy, zoomLevel) {
        var maxTiltAngle = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : MapViewUtils2.MAX_TILT_RAD;
        var elevationProvider = mapView.elevationProvider, camera = mapView.camera, projection = mapView.projection;
        var elevation = elevationProvider ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL) : void 0;
        var zoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);
        var cameraTarget = MapViewUtils2.getTargetAndDistance(projection, camera, elevationProvider).target;
        var newCameraDistance = calculateDistanceFromZoomLevel(mapView, zoomLevel);
        if (mapView.geoMaxBounds) {
            var constrained = constrainTargetAndDistanceToViewBounds(cameraTarget, newCameraDistance, mapView);
            if (constrained.distance !== newCameraDistance) {
                return zoomLevel >= mapView.zoomLevel;
            }
        }
        camera.getWorldDirection(camera.position).multiplyScalar(-newCameraDistance).add(cameraTarget);
        if (projection.type === 1 /* Spherical */ ) {
            var tilt = extractCameraTilt(camera, projection);
            var deltaTilt = tilt - maxTiltAngle;
            if (deltaTilt > 0) {
                orbitAroundScreenPoint(mapView, {
                    deltaTilt: deltaTilt,
                    maxTiltAngle: maxTiltAngle
                });
            }
        }
        var newZoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);
        if (!zoomTarget || !newZoomTarget) {
            return true;
        }
        if (projection.type === 0 /* Planar */ ) {
            zoomTarget.sub(newZoomTarget);
            panCameraAboveFlatMap(mapView, zoomTarget.x, zoomTarget.y);
        } else if (projection.type === 1 /* Spherical */ ) {
            panCameraAroundGlobe(mapView, zoomTarget, newZoomTarget);
        }
        return true;
    };
    var orbitAroundScreenPoint = function orbitAroundScreenPoint(mapView, offsetXOrOrbitParams, offsetY, deltaAzimuth, deltaTilt, maxTiltAngle) {
        var ppalPoint = CameraUtils.getPrincipalPoint(mapView.camera, cache4.vector2[0]);
        var mapTargetWorld = MapViewUtils2.rayCastWorldCoordinates(mapView, ppalPoint.x, ppalPoint.y);
        if (mapTargetWorld === null) {
            return;
        }
        var orbitCenter;
        if (typeof offsetXOrOrbitParams === "number") {
            orbitCenter = cache4.vector2[1].set(offsetXOrOrbitParams, offsetY);
        } else {
            var params = offsetXOrOrbitParams;
            var _center;
            orbitCenter = (_center = params.center) !== null && _center !== void 0 ? _center : ppalPoint;
            var _deltaAzimuth;
            deltaAzimuth = (_deltaAzimuth = params.deltaAzimuth) !== null && _deltaAzimuth !== void 0 ? _deltaAzimuth : 0;
            var _deltaTilt;
            deltaTilt = (_deltaTilt = params.deltaTilt) !== null && _deltaTilt !== void 0 ? _deltaTilt : 0;
            maxTiltAngle = params.maxTiltAngle;
        }
        var orbitAroundPpalPoint = orbitCenter.x === ppalPoint.x && orbitCenter.y === ppalPoint.y;
        var rotationTargetWorld = orbitAroundPpalPoint ? mapTargetWorld : MapViewUtils2.rayCastWorldCoordinates(mapView, orbitCenter.x, orbitCenter.y);
        if (rotationTargetWorld === null) {
            return;
        }
        applyAzimuthAroundTarget(mapView, rotationTargetWorld, -deltaAzimuth);
        var tiltAxis = new THREE97.Vector3(1, 0, 0).applyQuaternion(mapView.camera.quaternion);
        var clampedDeltaTilt = computeClampedDeltaTilt(mapView, orbitCenter.y - ppalPoint.y, deltaTilt, maxTiltAngle, mapTargetWorld, rotationTargetWorld, tiltAxis);
        applyTiltAroundTarget(mapView, rotationTargetWorld, clampedDeltaTilt, tiltAxis);
    };
    var applyAzimuthAroundTarget = function applyAzimuthAroundTarget(mapView, rotationTargetWorld, deltaAzimuth) {
        var camera = mapView.camera;
        var projection = mapView.projection;
        var headingAxis = projection.surfaceNormal(rotationTargetWorld, cache4.vector3[0]);
        var headingQuat = cache4.quaternions[0].setFromAxisAngle(headingAxis, deltaAzimuth);
        camera.quaternion.premultiply(headingQuat);
        camera.position.sub(rotationTargetWorld);
        camera.position.applyQuaternion(headingQuat);
        camera.position.add(rotationTargetWorld);
    };
    var computeClampedDeltaTilt = function computeClampedDeltaTilt(mapView, offsetY, deltaTilt, maxTiltAngle, mapTargetWorld, rotationTargetWorld, tiltAxis) {
        var camera = mapView.camera;
        var projection = mapView.projection;
        var tilt = extractTiltAngleFromLocation(projection, camera, mapTargetWorld, tiltAxis);
        if (tilt + deltaTilt < 0) {
            return -tilt;
        } else if (deltaTilt <= 0) {
            return deltaTilt;
        } else if (mapTargetWorld.equals(rotationTargetWorld) || offsetY < 0) {
            return MathUtils6.clamp(deltaTilt + tilt, 0, maxTiltAngle) - tilt;
        }
        var rotationCenterTilt = extractTiltAngleFromLocation(projection, camera, rotationTargetWorld, tiltAxis);
        var maxRotationTiltAngle = THREE97.MathUtils.degToRad(89);
        if (rotationCenterTilt > maxRotationTiltAngle) {
            return 0;
        }
        var angleBetweenNormals = 0;
        if (projection === sphereProjection) {
            var projectedRotationTargetNormal = projection.surfaceNormal(rotationTargetWorld, cache4.vector3[0]).projectOnPlane(tiltAxis).normalize();
            var mapTargetNormal = projection.surfaceNormal(mapTargetWorld, cache4.vector3[1]);
            angleBetweenNormals = projectedRotationTargetNormal.angleTo(mapTargetNormal);
        }
        var ninetyRad = THREE97.MathUtils.degToRad(90);
        var MRpC = ninetyRad + angleBetweenNormals - rotationCenterTilt;
        var CMRp = ninetyRad + tilt;
        var RpCM = ninetyRad * 2 - (MRpC + CMRp);
        var CMRpMaxTilt = ninetyRad * 2 - RpCM - ninetyRad - maxTiltAngle;
        var maxTilt = ninetyRad + angleBetweenNormals - CMRpMaxTilt;
        var clampedDeltaTilt = MathUtils6.clamp(deltaTilt + rotationCenterTilt, 0, Math.min(maxTilt, maxRotationTiltAngle)) - rotationCenterTilt;
        return clampedDeltaTilt;
    };
    var applyTiltAroundTarget = function applyTiltAroundTarget(mapView, rotationTargetWorld, deltaTilt, tiltAxis) {
        var camera = mapView.camera;
        var posBackup = camera.position.clone();
        var quatBackup = camera.quaternion.clone();
        var tiltQuat = cache4.quaternions[0].setFromAxisAngle(tiltAxis, deltaTilt);
        camera.quaternion.premultiply(tiltQuat);
        camera.position.sub(rotationTargetWorld);
        camera.position.applyQuaternion(tiltQuat);
        camera.position.add(rotationTargetWorld);
        if (MapViewUtils2.rayCastWorldCoordinates(mapView, 0, 0) === null) {
            logger28.warn("Target got invalidated during rotation.");
            camera.position.copy(posBackup);
            camera.quaternion.copy(quatBackup);
        }
    };
    var getGeoTargetFromCamera = function getGeoTargetFromCamera(camera, projection, elevation) {
        var targetWorldPos = getWorldTargetFromCamera(camera, projection, elevation);
        if (targetWorldPos !== null) {
            return projection.unprojectPoint(targetWorldPos);
        }
        return null;
    };
    var getWorldTargetFromCamera = function getWorldTargetFromCamera(camera, projection, elevation) {
        var cameraPos = cache4.vector3[0].copy(camera.position);
        var cameraLookAt = camera.getWorldDirection(cache4.vector3[1]);
        rayCaster.set(cameraPos, cameraLookAt);
        if (elevation !== void 0) {
            groundPlane.constant -= elevation;
            groundSphere.radius += elevation;
        }
        var targetWorldPos = new THREE97.Vector3();
        var result = projection.type === 0 /* Planar */  ? rayCaster.ray.intersectPlane(groundPlane, targetWorldPos) : rayCaster.ray.intersectSphere(groundSphere, targetWorldPos);
        if (elevation !== void 0) {
            groundPlane.constant = 0;
            groundSphere.radius = EarthConstants.EQUATORIAL_RADIUS;
        }
        return result;
    };
    var constrainTargetAndDistanceToViewBounds = function constrainTargetAndDistanceToViewBounds(target, distance, mapView) {
        var unconstrained = {
            target: target,
            distance: distance
        };
        var worldMaxBounds = mapView.worldMaxBounds;
        var camera = mapView.camera;
        var projection = mapView.projection;
        if (!worldMaxBounds) {
            return unconstrained;
        }
        var boundsSize = worldMaxBounds.getSize(cache4.vector3[1]);
        var screenSize = mapView.renderer.getSize(cache4.vector2[0]);
        var viewHeight = CameraUtils.convertScreenToWorldSize(mapView.focalLength, unconstrained.distance, screenSize.height);
        var viewWidth = viewHeight * camera.aspect;
        var scale = Math.max(viewWidth / boundsSize.x, viewHeight / boundsSize.y);
        var viewHalfSize = new THREE97.Vector3(viewWidth / 2, viewHeight / 2, 0);
        var constrained = {
            target: unconstrained.target.clone(),
            distance: unconstrained.distance
        };
        if (projection.type === 0 /* Planar */ ) {
            if (scale > 1) {
                constrained.distance /= scale;
                camera.getWorldDirection(camera.position).multiplyScalar(-constrained.distance).add(worldMaxBounds.getCenter(constrained.target));
            } else {
                var targetBounds = cache4.box3[0].copy(worldMaxBounds).expandByVector(viewHalfSize.multiplyScalar(-1));
                targetBounds.clampPoint(unconstrained.target, constrained.target).setZ(unconstrained.target.z);
                if (constrained.target.equals(unconstrained.target)) {
                    return unconstrained;
                }
                camera.position.x += constrained.target.x - unconstrained.target.x;
                camera.position.y += constrained.target.y - unconstrained.target.y;
            }
            return constrained;
        }
        if (scale > 1) {
            worldMaxBounds.getCenter(constrained.target);
            constrained.target.setLength(unconstrained.target.length());
            constrained.distance /= scale;
        } else {
            var targetMaxBounds = cache4.obox3[0];
            targetMaxBounds.copy(worldMaxBounds);
            targetMaxBounds.position.setLength(unconstrained.target.length());
            targetMaxBounds.extents.sub(viewHalfSize);
            var rotMatrix = targetMaxBounds.getRotationMatrix(cache4.matrix4[0]);
            var localTarget = cache4.vector3[1].copy(constrained.target).sub(targetMaxBounds.position).applyMatrix4(cache4.matrix4[1].copy(rotMatrix).transpose()).setZ(0);
            var constrainedLocalTarget = cache4.vector3[2].copy(localTarget).clamp(cache4.vector3[3].copy(targetMaxBounds.extents).multiplyScalar(-1), targetMaxBounds.extents);
            if (constrainedLocalTarget.equals(localTarget)) {
                return unconstrained;
            }
            constrained.target.copy(constrainedLocalTarget).applyMatrix4(rotMatrix).add(targetMaxBounds.position);
            var targetHeightSq = targetMaxBounds.position.lengthSq();
            var constTargetDistSq = constrained.target.distanceToSquared(targetMaxBounds.position);
            var constTargetDistToGround = Math.sqrt(targetHeightSq) - Math.sqrt(targetHeightSq - constTargetDistSq);
            constrained.target.addScaledVector(targetMaxBounds.zAxis, -constTargetDistToGround);
            constrained.target.setLength(unconstrained.target.length());
        }
        MapViewUtils2.panCameraAroundGlobe(mapView, cache4.vector3[1].copy(constrained.target), cache4.vector3[2].copy(unconstrained.target));
        camera.getWorldDirection(camera.position).multiplyScalar(-constrained.distance).add(constrained.target);
        return constrained;
    };
    var getTargetAndDistance = function getTargetAndDistance(projection, camera, elevationProvider) {
        var cameraPitch = extractAttitude({
            projection: projection
        }, camera).pitch;
        var elevation = elevationProvider ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL) : void 0;
        var final = !elevationProvider || elevation !== void 0;
        var target = cameraPitch < MapViewUtils2.MAX_TILT_RAD ? getWorldTargetFromCamera(camera, projection, elevation) : null;
        if (target !== null) {
            var distance = camera.position.distanceTo(target);
            return {
                target: target,
                distance: distance,
                final: final
            };
        } else {
            var groundDistance = projection.groundDistance(camera.position);
            var heightAboveTerrain = Math.max(groundDistance - (elevation !== null && elevation !== void 0 ? elevation : 0), 0);
            var distance1 = projection.type === 0 /* Planar */  ? heightAboveTerrain / Math.cos(Math.min(cameraPitch, MapViewUtils2.MAX_TILT_RAD)) : Math.sqrt(Math.pow(heightAboveTerrain + EarthConstants.EQUATORIAL_RADIUS, 2) - Math.pow(EarthConstants.EQUATORIAL_RADIUS, 2));
            var cameraDir2 = camera.getWorldDirection(cache4.vector3[0]);
            cameraDir2.multiplyScalar(distance1);
            var fallbackTarget = cache4.vector3[1];
            fallbackTarget.copy(camera.position).add(cameraDir2);
            return {
                target: fallbackTarget,
                distance: distance1,
                final: final
            };
        }
    };
    var getCameraPositionFromTargetCoordinates = function getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, projection) {
        var result = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : new THREE97.Vector3();
        var pitchRad = THREE97.MathUtils.degToRad(pitchDeg);
        var altitude = Math.cos(pitchRad) * distance;
        var yawRad = THREE97.MathUtils.degToRad(yawDeg);
        projection.projectPoint(targetCoordinates, result);
        var groundDistance = distance * Math.sin(pitchRad);
        if (projection.type === 0 /* Planar */ ) {
            result.x = result.x + Math.sin(yawRad) * groundDistance;
            result.y = result.y - Math.cos(yawRad) * groundDistance;
            result.z = result.z + altitude;
        } else if (projection.type === 1 /* Spherical */ ) {
            tangentSpace.z.copy(result).normalize();
            tangentSpace.y.set(0, 0, 1).projectOnPlane(tangentSpace.z).normalize();
            cache4.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);
            tangentSpace.y.applyQuaternion(cache4.quaternions[0]);
            tangentSpace.y.setLength(groundDistance);
            var height = distance * Math.cos(pitchRad);
            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));
            var a = EarthConstants.EQUATORIAL_RADIUS + altitude;
            var b = Math.sin(pitchRad) * distance;
            var cameraHeight = Math.sqrt(a * a + b * b);
            result.setLength(cameraHeight);
        }
        return result;
    };
    var wrapGeoPointsToScreen = function wrapGeoPointsToScreen(points, startPosition) {
        var startIndex = 0;
        if (startPosition === void 0) {
            startPosition = GeoCoordinates.fromObject(points[0]);
            startIndex = 1;
        }
        var north = startPosition.latitude;
        var south = startPosition.latitude;
        var lonCenter = MathUtils6.normalizeLongitudeDeg(startPosition.longitude);
        var lonSpan = 0;
        var east = startPosition.longitude;
        var west = startPosition.longitude;
        var result = [];
        result.push(new GeoCoordinates(north, lonCenter));
        for(var i = startIndex; i < points.length; i++){
            var p = GeoCoordinates.fromObject(points[i]);
            if (p.latitude > north) {
                north = p.latitude;
            } else if (p.latitude < south) {
                south = p.latitude;
            }
            var longitude = MathUtils6.normalizeLongitudeDeg(p.longitude);
            var relToCenter = MathUtils6.angleDistanceDeg(lonCenter, longitude);
            longitude = lonCenter - relToCenter;
            if (relToCenter < 0 && -relToCenter > lonSpan / 2) {
                east = Math.max(east, lonCenter - relToCenter);
                lonSpan = east - west;
                lonCenter = (east + west) / 2;
            } else if (relToCenter > 0 && relToCenter > lonSpan / 2) {
                west = Math.min(west, longitude);
                lonSpan = east - west;
                lonCenter = (east + west) / 2;
            }
            result.push(new GeoCoordinates(p.latitude, longitude));
        }
        return result;
    };
    var wrapWorldPointsToView = function wrapWorldPointsToView(points, cameraPos) {
        var cameraPosNormalized = cameraPos.clone().normalize();
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var point = _step.value;
                if (point.angleTo(cameraPos) > Math.PI / 2) {
                    var pointLen = point.length();
                    point.projectOnPlane(cameraPosNormalized).setLength(pointLen);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };
    var geoBoxToGeoPoints = function geoBoxToGeoPoints(box) {
        var center = box.center;
        return [
            new GeoCoordinates(box.north, box.west),
            new GeoCoordinates(box.north, box.east),
            new GeoCoordinates(center.latitude, box.west),
            new GeoCoordinates(center.latitude, box.east),
            new GeoCoordinates(box.south, box.west),
            new GeoCoordinates(box.south, box.east),
            new GeoCoordinates(box.north, center.longitude),
            new GeoCoordinates(box.south, center.longitude)
        ];
    };
    var getFitBoundsDistance = function getFitBoundsDistance(points, worldTarget, camera) {
        var targetDist = cache4.vector3[0].copy(worldTarget).sub(camera.position).length();
        var ppalPoint = CameraUtils.getPrincipalPoint(camera);
        var newDistance = targetDist;
        var getDistanceFactor = function(pointNDC, ppNDC) {
            var maxNDC = 0.99;
            return Math.abs(pointNDC) > 1 ? Math.abs((pointNDC - ppNDC) / (maxNDC * Math.sign(pointNDC) - ppNDC)) : 1;
        };
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var point = _step.value;
                var pEyeZ = -cache4.vector3[0].copy(point).applyMatrix4(camera.matrixWorldInverse).z;
                var pointNDC = cache4.vector3[0].applyMatrix4(camera.projectionMatrix);
                var maxFactor = Math.max(getDistanceFactor(pointNDC.x, ppalPoint.x), getDistanceFactor(pointNDC.y, ppalPoint.y));
                if (maxFactor > 1) {
                    var constDist = targetDist - pEyeZ;
                    var newPEyeZ = Math.abs(pEyeZ) * maxFactor + constDist;
                    newDistance = Math.max(newDistance, newPEyeZ);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return newDistance;
    };
    var getFitBoundsLookAtParams = function getFitBoundsLookAtParams(geoTarget, worldTarget, worldPoints, params) {
        var tilt = params.tilt, heading = params.heading, projection = params.projection;
        var startDistance = params.minDistance;
        var tmpCamera2 = params.camera.clone();
        getCameraRotationAtTarget(projection, geoTarget, -heading, tilt, tmpCamera2.quaternion);
        getCameraPositionFromTargetCoordinates(geoTarget, startDistance, -heading, tilt, projection, tmpCamera2.position);
        tmpCamera2.updateMatrixWorld(true);
        if (projection.type === 1 /* Spherical */ ) {
            wrapWorldPointsToView(worldPoints, tmpCamera2.position);
        }
        var distance = getFitBoundsDistance(worldPoints, worldTarget, tmpCamera2);
        return {
            target: geoTarget,
            distance: distance,
            heading: heading,
            tilt: tilt
        };
    };
    var getCameraCoordinatesFromTargetCoordinates = function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {
        return mapView.projection.unprojectPoint(getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView.projection, cache4.vector3[1]));
    };
    var rayCastWorldCoordinates = function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {
        var pointInNDCPosition = cache4.vector3[0].set(pointOnScreenXinNDC, pointOnScreenYinNDC, 0);
        mapView.camera.updateMatrixWorld();
        var cameraPos = cache4.vector3[1].copy(mapView.camera.position);
        cache4.matrix4[0].extractRotation(mapView.camera.matrixWorld);
        cache4.matrix4[1].multiplyMatrices(cache4.matrix4[0], cache4.matrix4[1].copy(mapView.camera.projectionMatrix).invert());
        var pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache4.matrix4[1]);
        rayCaster.set(cameraPos, pointInCameraSpace.normalize());
        if (elevation !== void 0) {
            groundPlane.constant -= elevation;
            groundSphere.radius += elevation;
        }
        var worldPosition = new THREE97.Vector3();
        var result = mapView.projection.type === 0 /* Planar */  ? rayCaster.ray.intersectPlane(groundPlane, worldPosition) : rayCaster.ray.intersectSphere(groundSphere, worldPosition);
        if (elevation !== void 0) {
            groundPlane.constant = 0;
            groundSphere.radius = EarthConstants.EQUATORIAL_RADIUS;
        }
        return result;
    };
    var panCameraAboveFlatMap = function panCameraAboveFlatMap(mapView, offsetX, offsetY) {
        mapView.camera.position.x += offsetX;
        mapView.camera.position.y += offsetY;
    };
    var panCameraAroundGlobe = function panCameraAroundGlobe(mapView, fromWorld, toWorld) {
        cache4.quaternions[0].setFromUnitVectors(fromWorld.normalize(), toWorld.normalize()).invert();
        cache4.matrix4[0].makeRotationFromQuaternion(cache4.quaternions[0]);
        mapView.camera.applyMatrix4(cache4.matrix4[0]);
        mapView.camera.updateMatrixWorld();
    };
    var rotate = function rotate(mapView, deltaYawDeg) {
        var deltaPitchDeg = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, maxTiltAngleRad = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Math.PI / 4;
        mapView.camera.rotateOnWorldAxis(mapView.projection.type === 1 /* Spherical */  ? cache4.vector3[0].copy(mapView.camera.position).normalize() : cache4.vector3[0].set(0, 0, 1), THREE97.MathUtils.degToRad(-deltaYawDeg));
        mapView.camera.updateMatrixWorld();
        if (deltaPitchDeg === 0) {
            return;
        }
        var pitch = MapViewUtils2.extractAttitude(mapView, mapView.camera).pitch;
        var newPitch = THREE97.MathUtils.clamp(pitch + THREE97.MathUtils.degToRad(deltaPitchDeg), 0, maxTiltAngleRad);
        if (mapView.projection.type === 1 /* Spherical */ ) {
            var maxPitch = Math.asin(EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad) / mapView.camera.position.length());
            newPitch = Math.min(newPitch, maxPitch);
        }
        mapView.camera.rotateX(newPitch - pitch);
    };
    var getCameraRotationAtTarget = function getCameraRotationAtTarget(projection, target, yawDeg, pitchDeg) {
        var result = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new THREE97.Quaternion();
        var transform = cache4.transforms[0];
        projection.localTangentSpace(target, transform);
        cache4.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
        result.setFromRotationMatrix(cache4.matrix4[0]);
        cache4.quaternions[0].setFromAxisAngle(cache4.vector3[1].set(0, 0, 1), THREE97.MathUtils.degToRad(yawDeg));
        cache4.quaternions[1].setFromAxisAngle(cache4.vector3[1].set(1, 0, 0), THREE97.MathUtils.degToRad(pitchDeg));
        result.multiply(cache4.quaternions[0]);
        result.multiply(cache4.quaternions[1]);
        return result;
    };
    var setRotation = function setRotation(mapView, yawDeg, pitchDeg) {
        getCameraRotationAtTarget(mapView.projection, mapView.geoCenter, yawDeg, pitchDeg, mapView.camera.quaternion);
    };
    var extractCameraTilt = function extractCameraTilt(camera, projection) {
        if (projection.type === 0 /* Planar */ ) {
            var lookAt = camera.getWorldDirection(cache4.vector3[0]).normalize();
            var normal = projection.surfaceNormal(camera.position, cache4.vector3[1]).negate();
            var cosTheta = lookAt.dot(normal);
            return Math.acos(THREE97.MathUtils.clamp(cosTheta, -1, 1));
        } else {
            assert(projection.type === 1 /* Spherical */ );
            var targetGeoCoords = MapViewUtils2.getGeoTargetFromCamera(camera, projection);
            if (targetGeoCoords !== null) {
                return MapViewUtils2.extractTiltAngleFromLocation(projection, camera, targetGeoCoords);
            } else {
                logger28.warn("MapView camera is pointing in the void, using maxTilt: ", MapViewUtils2.MAX_TILT_RAD);
                return MapViewUtils2.MAX_TILT_RAD;
            }
        }
    };
    var extractAttitude = function extractAttitude(mapView, object) {
        cache4.vector3[1].setFromMatrixPosition(object.matrixWorld);
        mapView.projection.localTangentSpace(cache4.vector3[1], {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache4.vector3[0]
        });
        cache4.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);
        cache4.matrix4[0].copy(cache4.matrix4[1]).invert().multiply(object.matrixWorld);
        space.x.setFromMatrixColumn(cache4.matrix4[0], 0);
        space.y.setFromMatrixColumn(cache4.matrix4[0], 1);
        space.z.setFromMatrixColumn(cache4.matrix4[0], 2);
        var yaw = 0;
        var pitch = 0;
        var roll = 0;
        var d = space.z.dot(cache4.vector3[1].set(0, 0, 1));
        if (d < 1 - Number.EPSILON) {
            if (d > -1 + Number.EPSILON) {
                yaw = Math.atan2(space.z.x, -space.z.y);
                pitch = Math.acos(space.z.z);
                roll = Math.atan2(space.x.z, space.y.z);
            } else {
                yaw = -Math.atan2(-space.y.x, space.x.x);
                pitch = 180;
                roll = 0;
            }
        } else {
            yaw = Math.atan2(-space.y.x, space.x.x);
            pitch = 0;
            roll = 0;
        }
        return {
            yaw: yaw,
            pitch: pitch,
            roll: roll
        };
    };
    var extractSphericalCoordinatesFromLocation = function extractSphericalCoordinatesFromLocation(mapView, object, location) {
        mapView.projection.localTangentSpace(location, {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache4.vector3[0]
        });
        var tilt = 0;
        var azimuth = 0;
        cache4.vector3[1].copy(object.position).sub(cache4.vector3[0]).normalize();
        if (cache4.vector3[1].dot(tangentSpace.z) > 1 - Number.EPSILON) {
            azimuth = Math.PI - extractAttitude(mapView, object).yaw;
            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));
            tilt = 0;
            return {
                tilt: tilt,
                azimuth: azimuth
            };
        }
        tilt = cache4.vector3[1].angleTo(tangentSpace.z);
        cache4.vector3[1].copy(object.position).sub(cache4.vector3[0]).projectOnPlane(tangentSpace.z).normalize();
        azimuth = cache4.vector3[1].angleTo(tangentSpace.y);
        if (cache4.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {
            azimuth = -azimuth;
        }
        return {
            tilt: tilt,
            azimuth: azimuth
        };
    };
    var extractTiltAngleFromLocation = function extractTiltAngleFromLocation(projection, object, location, tiltAxis) {
        projection.localTangentSpace(location, {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache4.vector3[0]
        });
        var dirVec = cache4.vector3[2].copy(object.position).sub(cache4.vector3[0]);
        if (tiltAxis) {
            dirVec.projectOnPlane(tiltAxis);
            tangentSpace.z.projectOnPlane(tiltAxis).normalize();
        }
        var dirLen = dirVec.length();
        if (dirLen < epsilon2) {
            logger28.error("Can not calculate tilt for the zero length vector!");
            return 0;
        }
        dirVec.divideScalar(dirLen);
        var cosTheta = dirVec.dot(tangentSpace.z);
        if (cosTheta >= 1 - Number.EPSILON) {
            return 0;
        }
        return Math.acos(THREE97.MathUtils.clamp(cosTheta, -1, 1));
    };
    var getCameraFrustumPlanes = function getCameraFrustumPlanes(camera) {
        var near = camera.near;
        var far = camera.far;
        var top = near * Math.tan(THREE97.MathUtils.degToRad(0.5 * camera.fov)) / camera.zoom;
        var height = 2 * top;
        var width = camera.aspect * height;
        var left = -0.5 * width;
        var view = camera.view;
        if (view !== null && view.enabled) {
            var fullWidth = view.fullWidth;
            var fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        left += camera.filmOffset !== 0 ? near * camera.filmOffset / camera.getFilmWidth() : 0;
        return {
            left: left,
            right: left + width,
            top: top,
            bottom: top - height,
            near: near,
            far: far
        };
    };
    var rayCastGeoCoordinates = function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {
        var worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);
        if (!worldCoordinates) {
            return null;
        }
        return mapView.projection.unprojectPoint(worldCoordinates);
    };
    var calculateDistanceToGroundFromZoomLevel = function calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel) {
        var cameraPitch = extractAttitude(mapView, mapView.camera).pitch;
        var tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return mapView.focalLength * tileSize / 256 * Math.cos(cameraPitch);
    };
    var calculateDistanceFromZoomLevel = function calculateDistanceFromZoomLevel(options, zoomLevel) {
        var tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return options.focalLength * tileSize / 256;
    };
    var calculateZoomLevelFromDistance = function calculateZoomLevelFromDistance(options, distance) {
        var tileSize = 256 * distance / options.focalLength;
        var zoomLevel = THREE97.MathUtils.clamp(Math.log2(EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), options.minZoomLevel, options.maxZoomLevel);
        return snapToCeilingZoomLevel(zoomLevel);
    };
    var calculateDepthFromClipDistance = function calculateDepthFromClipDistance(clipDistance, camera) {
        var perspCam = camera;
        var cameraRange = perspCam.far - perspCam.near;
        var viewSpaceDistance = clipDistance * perspCam.far;
        return (1 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);
    };
    var cameraToWorldDistance2 = function cameraToWorldDistance2(distance, camera) {
        var perspCam = camera;
        return distance * perspCam.far;
    };
    var calculateVerticalFovByHorizontalFov = function calculateVerticalFovByHorizontalFov(hFov, aspect) {
        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);
    };
    var calculateHorizontalFovByVerticalFov = function calculateHorizontalFovByVerticalFov(vFov, aspect) {
        tmpCamera.fov = THREE97.MathUtils.radToDeg(vFov);
        tmpCamera.aspect = aspect;
        return CameraUtils.getHorizontalFov(tmpCamera);
    };
    var calculateFocalLengthByVerticalFov = function calculateFocalLengthByVerticalFov(vFov, height) {
        CameraUtils.setPrincipalPoint(tmpCamera, new THREE97.Vector2());
        CameraUtils.setVerticalFov(tmpCamera, vFov, height);
        return CameraUtils.getFocalLength(tmpCamera);
    };
    var calculateFovByFocalLength = function calculateFovByFocalLength(focalLength, height) {
        CameraUtils.setPrincipalPoint(tmpCamera, new THREE97.Vector2());
        CameraUtils.setFocalLength(tmpCamera, focalLength, height);
        return tmpCamera.fov;
    };
    var mapViewIsLoading = function mapViewIsLoading(mapView) {
        var numTilesLoading = 0;
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = mapView.visibleTileSet.dataSourceTileList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var tileList = _step.value;
                numTilesLoading += tileList.numTilesLoading;
                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                try {
                    for(var _iterator1 = tileList.visibleTiles[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                        var tile = _step1.value;
                        if (!tile.allGeometryLoaded) {
                            numTilesLoading++;
                        }
                    }
                } catch (err) {
                    _didIteratorError1 = true;
                    _iteratorError1 = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                            _iterator1.return();
                        }
                    } finally{
                        if (_didIteratorError1) {
                            throw _iteratorError1;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var isLoading = numTilesLoading > 0;
        if (mapView.textElementsRenderer !== void 0) {
            isLoading = isLoading || mapView.textElementsRenderer.loading;
        }
        isLoading = isLoading || !mapView.poiTableManager.finishedLoading || !mapView.visibleTileSet.allVisibleTilesLoaded;
        return isLoading;
    };
    var closeToFrustum = function closeToFrustum(point, camera) {
        var eps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-13;
        var ndcPoint = new THREE97.Vector3().copy(point).project(camera);
        if (Math.abs(ndcPoint.x) - eps < 1 && Math.abs(ndcPoint.y) - eps < 1 && Math.abs(ndcPoint.z) - eps < 1) {
            return true;
        }
        return false;
    };
    MapViewUtils2.MAX_TILT_DEG = 89;
    MapViewUtils2.MAX_TILT_RAD = MapViewUtils2.MAX_TILT_DEG * THREE97.MathUtils.DEG2RAD;
    MapViewUtils2.zoomOnTargetPosition = zoomOnTargetPosition;
    MapViewUtils2.orbitAroundScreenPoint = orbitAroundScreenPoint;
    MapViewUtils2.getGeoTargetFromCamera = getGeoTargetFromCamera;
    MapViewUtils2.getWorldTargetFromCamera = getWorldTargetFromCamera;
    MapViewUtils2.constrainTargetAndDistanceToViewBounds = constrainTargetAndDistanceToViewBounds;
    MapViewUtils2.getTargetAndDistance = getTargetAndDistance;
    MapViewUtils2.getCameraPositionFromTargetCoordinates = getCameraPositionFromTargetCoordinates;
    MapViewUtils2.wrapGeoPointsToScreen = wrapGeoPointsToScreen;
    MapViewUtils2.wrapWorldPointsToView = wrapWorldPointsToView;
    MapViewUtils2.geoBoxToGeoPoints = geoBoxToGeoPoints;
    MapViewUtils2.getFitBoundsDistance = getFitBoundsDistance;
    MapViewUtils2.getFitBoundsLookAtParams = getFitBoundsLookAtParams;
    MapViewUtils2.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;
    MapViewUtils2.rayCastWorldCoordinates = rayCastWorldCoordinates;
    MapViewUtils2.panCameraAboveFlatMap = panCameraAboveFlatMap;
    MapViewUtils2.panCameraAroundGlobe = panCameraAroundGlobe;
    MapViewUtils2.rotate = rotate;
    MapViewUtils2.getCameraRotationAtTarget = getCameraRotationAtTarget;
    MapViewUtils2.setRotation = setRotation;
    MapViewUtils2.extractCameraTilt = extractCameraTilt;
    MapViewUtils2.extractAttitude = extractAttitude;
    MapViewUtils2.extractSphericalCoordinatesFromLocation = extractSphericalCoordinatesFromLocation;
    MapViewUtils2.extractTiltAngleFromLocation = extractTiltAngleFromLocation;
    MapViewUtils2.getCameraFrustumPlanes = getCameraFrustumPlanes;
    MapViewUtils2.rayCastGeoCoordinates = rayCastGeoCoordinates;
    MapViewUtils2.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;
    MapViewUtils2.calculateDistanceFromZoomLevel = calculateDistanceFromZoomLevel;
    MapViewUtils2.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;
    MapViewUtils2.calculateDepthFromClipDistance = calculateDepthFromClipDistance;
    MapViewUtils2.cameraToWorldDistance = cameraToWorldDistance2;
    MapViewUtils2.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;
    MapViewUtils2.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;
    MapViewUtils2.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;
    MapViewUtils2.calculateFovByFocalLength = calculateFovByFocalLength;
    MapViewUtils2.calculateScreenSizeByFocalLength = CameraUtils.convertWorldToScreenSize;
    MapViewUtils2.calculateWorldSizeByFocalLength = CameraUtils.convertScreenToWorldSize;
    MapViewUtils2.estimateObject3dSize = Object3DUtils.estimateSize;
    MapViewUtils2.mapViewIsLoading = mapViewIsLoading;
    MapViewUtils2.closeToFrustum = closeToFrustum;
    MapViewUtils2.getBrowserLanguages = DOMUtils.getBrowserLanguages;
})(MapViewUtils || (MapViewUtils = {}));
var TileOffsetUtils;
(function(TileOffsetUtils2) {
    TileOffsetUtils2.getKeyForTileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset;
    TileOffsetUtils2.extractOffsetAndMortonKeyFromKey = TileKeyUtils.extractOffsetAndMortonKeyFromKey;
    TileOffsetUtils2.getParentKeyFromKey = TileKeyUtils.getParentKeyFromKey;
})(TileOffsetUtils || (TileOffsetUtils = {}));
// src/mapview/PlaneViewBounds.ts
var PlaneViewBounds = /*#__PURE__*/ function() {
    function PlaneViewBounds(camera, projection, m_options) {
        _classCallCheck(this, PlaneViewBounds);
        this.camera = camera;
        this.projection = projection;
        this.m_options = m_options;
        __publicField(this, "m_groundPlaneNormal", new import_three14.Vector3(0, 0, 1));
        __publicField(this, "m_groundPlane", new import_three14.Plane(this.m_groundPlaneNormal.clone()));
        assert(projection.type === 0 /* Planar */ );
    }
    _createClass(PlaneViewBounds, [
        {
            key: "generate",
            value: function generate() {
                var _this = this;
                var coordinates = [];
                this.addCanvasCornerIntersection(coordinates);
                if (coordinates.length === 4) {
                    return this.createPolygon(coordinates);
                }
                this.addHorizonIntersection(coordinates);
                var frustum = new import_three14.Frustum().setFromProjectionMatrix(new import_three14.Matrix4().multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse));
                var worldCorners = this.getWorldConers(this.projection);
                if (!this.m_options.tileWrappingEnabled) {
                    ;
                    [
                        worldCorners.ne,
                        worldCorners.nw,
                        worldCorners.se,
                        worldCorners.sw
                    ].forEach(function(corner) {
                        _this.addPointInFrustum(corner, frustum, coordinates);
                    });
                }
                if (!this.m_options.tileWrappingEnabled) {
                    ;
                    [
                        new import_three14.Line3(worldCorners.sw, worldCorners.se),
                        new import_three14.Line3(worldCorners.ne, worldCorners.nw),
                        new import_three14.Line3(worldCorners.se, worldCorners.ne),
                        new import_three14.Line3(worldCorners.nw, worldCorners.sw)
                    ].forEach(function(edge) {
                        _this.addFrustumIntersection(edge, frustum, coordinates);
                    });
                } else {
                    var directionEast = new import_three14.Vector3().subVectors(worldCorners.sw, worldCorners.se).normalize();
                    var directionWest = new import_three14.Vector3().subVectors(worldCorners.se, worldCorners.sw).normalize();
                    [
                        new import_three14.Ray(worldCorners.se, directionEast),
                        new import_three14.Ray(worldCorners.se, directionWest),
                        new import_three14.Ray(worldCorners.ne, directionEast),
                        new import_three14.Ray(worldCorners.ne, directionWest)
                    ].forEach(function(ray) {
                        _this.addFrustumIntersection(ray, frustum, coordinates);
                    });
                }
                return this.createPolygon(coordinates);
            }
        },
        {
            key: "createPolygon",
            value: function createPolygon(coordinates) {
                if (coordinates.length > 2) {
                    return new GeoPolygon(coordinates, true);
                }
                return void 0;
            }
        },
        {
            key: "getWorldConers",
            value: function getWorldConers(projection) {
                var worldBox = projection.worldExtent(0, 0);
                return {
                    sw: worldBox.min,
                    se: new import_three14.Vector3(worldBox.max.x, worldBox.min.y, 0),
                    nw: new import_three14.Vector3(worldBox.min.x, worldBox.max.y, 0),
                    ne: worldBox.max
                };
            }
        },
        {
            key: "addNDCRayIntersection",
            value: function addNDCRayIntersection(ndcPoints, geoPolygon) {
                var _this = this;
                ndcPoints.forEach(function(corner) {
                    var intersection = MapViewUtils.rayCastWorldCoordinates({
                        camera: _this.camera,
                        projection: _this.projection
                    }, corner[0], corner[1]);
                    if (intersection) {
                        _this.validateAndAddToGeoPolygon(intersection, geoPolygon);
                    }
                });
            }
        },
        {
            key: "addHorizonIntersection",
            value: function addHorizonIntersection(geoPolygon) {
                var verticalHorizonPosition = this.getVerticalHorizonPositionInNDC();
                if (!verticalHorizonPosition) {
                    return;
                }
                this.addNDCRayIntersection([
                    [
                        -1,
                        verticalHorizonPosition
                    ],
                    [
                        1,
                        verticalHorizonPosition
                    ]
                ], geoPolygon);
            }
        },
        {
            key: "addCanvasCornerIntersection",
            value: function addCanvasCornerIntersection(geoPolygon) {
                this.addNDCRayIntersection([
                    [
                        -1,
                        -1
                    ],
                    [
                        1,
                        -1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        -1,
                        1
                    ]
                ], geoPolygon);
            }
        },
        {
            key: "validateAndAddToGeoPolygon",
            value: function validateAndAddToGeoPolygon(point, geoPolygon) {
                if (this.isInVisibleMap(point)) {
                    geoPolygon.push(this.projection.unprojectPoint(point));
                }
            }
        },
        {
            key: "isInVisibleMap",
            value: function isInVisibleMap(point) {
                if (point.y < 0 || point.y > EarthConstants.EQUATORIAL_CIRCUMFERENCE) {
                    return false;
                }
                if (!this.m_options.tileWrappingEnabled && (point.x < 0 || point.x > EarthConstants.EQUATORIAL_CIRCUMFERENCE)) {
                    return false;
                }
                return true;
            }
        },
        {
            key: "addPointInFrustum",
            value: function addPointInFrustum(point, frustum, geoPolygon) {
                if (frustum.containsPoint(point)) {
                    var geoPoint = this.projection.unprojectPoint(point);
                    geoPoint.altitude = 0;
                    geoPolygon.push(geoPoint);
                }
            }
        },
        {
            key: "addFrustumIntersection",
            value: function addFrustumIntersection(edge, frustum, geoPolygon) {
                var _this = this;
                frustum.planes.forEach(function(plane) {
                    var intersection = null;
                    var target = new import_three14.Vector3();
                    if (_instanceof(edge, import_three14.Ray) && edge.intersectsPlane(plane)) {
                        intersection = edge.intersectPlane(plane, target);
                    } else if (_instanceof(edge, import_three14.Line3) && plane.intersectsLine(edge)) {
                        intersection = plane.intersectLine(edge, target);
                    }
                    if (intersection) {
                        if (MapViewUtils.closeToFrustum(intersection, _this.camera)) {
                            var geoIntersection = _this.projection.unprojectPoint(intersection);
                            geoIntersection.altitude = 0;
                            geoPolygon.push(geoIntersection);
                        }
                    }
                });
            }
        },
        {
            key: "getVerticalHorizonPositionInNDC",
            value: function getVerticalHorizonPositionInNDC() {
                var bottomMidFarPoint = new import_three14.Vector3(-1, -1, 1).unproject(this.camera).add(new import_three14.Vector3(1, -1, 1).unproject(this.camera)).multiplyScalar(0.5);
                var topMidFarPoint = new import_three14.Vector3(-1, 1, 1).unproject(this.camera).add(new import_three14.Vector3(1, 1, 1).unproject(this.camera)).multiplyScalar(0.5);
                var farPlaneVerticalCenterLine = new import_three14.Line3(bottomMidFarPoint, topMidFarPoint);
                var verticalHorizonPosition = new import_three14.Vector3();
                if (!this.m_groundPlane.intersectLine(farPlaneVerticalCenterLine, verticalHorizonPosition)) {
                    return void 0;
                }
                return verticalHorizonPosition.project(this.camera).y;
            }
        }
    ]);
    return PlaneViewBounds;
}();
// src/mapview/SphereViewBounds.ts
var import_three15 = require("three");
// src/mapview/SphereHorizon.ts
var THREE98 = __toESM(require("three"));
var twoPi = Math.PI * 2;
function nextCanvasSide(side) {
    return (side + 1) % 4;
}
function previousCanvasSide(side) {
    return (side + 3) % 4;
}
var SphereHorizon = /*#__PURE__*/ function() {
    function SphereHorizon(m_camera, m_cornerIntersects) {
        _classCallCheck(this, SphereHorizon);
        this.m_camera = m_camera;
        this.m_cornerIntersects = m_cornerIntersects;
        __publicField(this, "m_matrix");
        __publicField(this, "m_radius");
        __publicField(this, "m_normalToTangentAngle");
        __publicField(this, "m_distanceToHorizonCenter");
        __publicField(this, "m_intersections", []);
        __publicField(this, "m_isFullyVisible", true);
        __publicField(this, "m_cameraPitch");
        var earthRadiusSq = EarthConstants.EQUATORIAL_RADIUS * EarthConstants.EQUATORIAL_RADIUS;
        var xAxis = new THREE98.Vector3().setFromMatrixColumn(m_camera.matrixWorld, 0).normalize();
        var zAxis = m_camera.position.clone().normalize();
        var yAxis = new THREE98.Vector3().crossVectors(zAxis, xAxis);
        var cameraHeight = m_camera.position.length();
        this.m_normalToTangentAngle = Math.asin(EarthConstants.EQUATORIAL_RADIUS / cameraHeight);
        var tangentDistance = Math.sqrt(cameraHeight * cameraHeight - earthRadiusSq);
        this.m_distanceToHorizonCenter = tangentDistance * Math.cos(this.m_normalToTangentAngle);
        var horizonCenterLength = cameraHeight - this.m_distanceToHorizonCenter;
        this.m_radius = Math.sqrt(earthRadiusSq - horizonCenterLength * horizonCenterLength);
        this.m_cameraPitch = MapViewUtils.extractAttitude({
            projection: sphereProjection
        }, this.m_camera).pitch;
        var horizonCenter = new THREE98.Vector3().copy(zAxis).setLength(horizonCenterLength);
        this.m_matrix = new THREE98.Matrix4().makeBasis(xAxis, yAxis, zAxis).setPosition(horizonCenter);
        this.computeIntersections();
    }
    _createClass(SphereHorizon, [
        {
            key: "getPoint",
            value: function getPoint(t) {
                var arcStart = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, arcEnd = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, target = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new THREE98.Vector3();
                var startAngle = arcStart * twoPi;
                var endAngle = arcEnd >= arcStart ? arcEnd * twoPi : (arcEnd + 1) * twoPi;
                var deltaAngle = endAngle - startAngle;
                var angle = startAngle + t * deltaAngle;
                target.set(this.m_radius * Math.cos(angle), this.m_radius * Math.sin(angle), 0);
                target.applyMatrix4(this.m_matrix);
                return target;
            }
        },
        {
            key: "getDivisionPoints",
            value: function getDivisionPoints(callback) {
                var tStart = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, tEnd = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, maxNumPoints = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;
                var numPoints = Math.max(Math.ceil(((tEnd < tStart ? 1 + tEnd : tEnd) - tStart) * maxNumPoints), 1);
                for(var d = 0; d < numPoints; d++){
                    callback(this.getPoint(d / numPoints, tStart, tEnd));
                }
            }
        },
        {
            key: "isFullyVisible",
            get: function get() {
                return this.m_isFullyVisible;
            }
        },
        {
            key: "getSideIntersections",
            value: function getSideIntersections(side) {
                return this.m_intersections[side];
            }
        },
        {
            key: "isTangentVisible",
            value: function isTangentVisible(side) {
                switch(side){
                    case 2 /* Top */ :
                        {
                            var eyeToTangentAngle = this.m_normalToTangentAngle - this.m_cameraPitch;
                            return CameraUtils.getTopFov(this.m_camera) >= Math.abs(eyeToTangentAngle);
                        }
                    case 0 /* Bottom */ :
                        {
                            var eyeToTangentAngle1 = this.m_normalToTangentAngle + this.m_cameraPitch;
                            return CameraUtils.getBottomFov(this.m_camera) >= Math.abs(eyeToTangentAngle1);
                        }
                    case 3 /* Left */ :
                        {
                            var eyeToTangentAngle2 = this.m_normalToTangentAngle;
                            return CameraUtils.getLeftFov(this.m_camera) >= Math.abs(eyeToTangentAngle2) && this.m_cameraPitch <= CameraUtils.getBottomFov(this.m_camera);
                        }
                    case 1 /* Right */ :
                        {
                            var eyeToTangentAngle3 = this.m_normalToTangentAngle;
                            return CameraUtils.getRightFov(this.m_camera) >= Math.abs(eyeToTangentAngle3) && this.m_cameraPitch <= CameraUtils.getBottomFov(this.m_camera);
                        }
                }
            }
        },
        {
            key: "getTangentOnSide",
            value: function getTangentOnSide(side) {
                switch(side){
                    case 0 /* Bottom */ :
                        return 0.75;
                    case 1 /* Right */ :
                        return 0;
                    case 2 /* Top */ :
                        return 0.25;
                    case 3 /* Left */ :
                        return 0.5;
                }
            }
        },
        {
            key: "computeIntersections",
            value: function computeIntersections() {
                var _this = this, _loop = function(side) {
                    if (_this.isTangentVisible(side)) {
                        _this.m_intersections.push([
                            _this.getTangentOnSide(side)
                        ]);
                        return "continue";
                    }
                    var sideIntersections = new Array();
                    _this.m_isFullyVisible = false;
                    switch(side){
                        case 0 /* Bottom */ :
                            {
                                var _sideIntersections;
                                (_sideIntersections = sideIntersections).push.apply(_sideIntersections, _toConsumableArray(_this.computeTBIntersections(yBottom)));
                                break;
                            }
                        case 1 /* Right */ :
                            {
                                var rightFov = CameraUtils.getRightFov(_this.m_camera);
                                var intersections = _this.computeLRIntersections(yBottom, rightFov);
                                if (intersections) {
                                    ;
                                    var ref;
                                    ref = _slicedToArray(intersections, 2), tTopRight = ref[0], tBottomRight = ref[1], ref;
                                    sideIntersections.push(tBottomRight !== void 0 ? 1 + tBottomRight : void 0, tTopRight);
                                }
                                break;
                            }
                        case 2 /* Top */ :
                            {
                                var _sideIntersections1;
                                var yTop = _this.m_distanceToHorizonCenter * Math.tan(_this.m_cameraPitch + CameraUtils.getTopFov(_this.m_camera));
                                (_sideIntersections1 = sideIntersections).push.apply(_sideIntersections1, _toConsumableArray(_this.computeTBIntersections(yTop).reverse()));
                                break;
                            }
                        case 3 /* Left */ :
                            {
                                var leftFov = CameraUtils.getLeftFov(_this.m_camera);
                                if (leftFov === CameraUtils.getRightFov(_this.m_camera)) {
                                    sideIntersections.push(tTopRight !== void 0 ? 0.5 - tTopRight : void 0, tBottomRight !== void 0 ? 0.5 - tBottomRight : void 0);
                                } else {
                                    var isections = _this.computeLRIntersections(yBottom, leftFov);
                                    if (isections) {
                                        sideIntersections.push(0.5 - isections[0], isections[1] !== void 0 ? 0.5 - isections[1] : void 0);
                                    }
                                }
                                break;
                            }
                    }
                    var hasCorners = [
                        _this.m_cornerIntersects[side],
                        _this.m_cornerIntersects[nextCanvasSide(side)]
                    ];
                    _this.m_intersections.push(sideIntersections.filter(function(val, i) {
                        return val !== void 0 && !hasCorners[i];
                    }));
                };
                var yBottom = this.m_distanceToHorizonCenter * Math.tan(this.m_cameraPitch - CameraUtils.getBottomFov(this.m_camera));
                var tTopRight;
                var tBottomRight;
                for(var side = 0 /* Bottom */ ; side < 4; side++)_loop(side);
            }
        },
        {
            key: "computeTBIntersections",
            value: function computeTBIntersections(y) {
                var radiusSq = this.m_radius * this.m_radius;
                var x = Math.sqrt(radiusSq - y * y);
                var t = Math.atan2(y, x) / twoPi;
                return [
                    0.5 - t,
                    t > 0 ? t : 1 + t
                ];
            }
        },
        {
            key: "computeLRIntersections",
            value: function computeLRIntersections(yBottom, sideFov) {
                var eyeToHorizon = this.m_distanceToHorizonCenter / Math.cos(this.m_cameraPitch);
                var yMiddle = this.m_distanceToHorizonCenter * Math.tan(this.m_cameraPitch);
                var xMiddle = eyeToHorizon * Math.tan(sideFov);
                var bottomFov = CameraUtils.getBottomFov(this.m_camera);
                var eyeToBottom = this.m_distanceToHorizonCenter * Math.cos(bottomFov) / Math.cos(this.m_cameraPitch - bottomFov);
                var xBottom = xMiddle * eyeToBottom / eyeToHorizon;
                var intersections = Math2D.intersectLineAndCircle(xBottom, yBottom, xMiddle, yMiddle, this.m_radius);
                if (!intersections) {
                    return void 0;
                }
                var yTopRight = intersections.y1;
                var tTop = Math.atan2(yTopRight, intersections.x1) / twoPi;
                var hasBottomIntersection = -yTopRight >= yBottom && intersections.x2 !== void 0;
                var tBottom = hasBottomIntersection ? Math.atan2(intersections.y2, intersections.x2) / twoPi : void 0;
                return [
                    tTop,
                    tBottom
                ];
            }
        }
    ]);
    return SphereHorizon;
}();
// src/mapview/SphereViewBounds.ts
function computeEdgeDivisions(geoStart, geoEnd) {
    var maxLatitudeSpan = 20;
    var maxLongitudeSpan = 5;
    var latitudeSpan = Math.abs(geoEnd.latitude - geoStart.latitude);
    var longitudeSpan = geoStart.minLongitudeSpanTo(geoEnd);
    return Math.ceil(Math.max(latitudeSpan / maxLatitudeSpan, longitudeSpan / maxLongitudeSpan));
}
var ccwCanvasCornersNDC = [
    {
        x: -1,
        y: -1
    },
    {
        x: 1,
        y: -1
    },
    {
        x: 1,
        y: 1
    },
    {
        x: -1,
        y: 1
    }
];
var SphereViewBounds = /*#__PURE__*/ function() {
    function SphereViewBounds(camera, projection) {
        _classCallCheck(this, SphereViewBounds);
        this.camera = camera;
        this.projection = projection;
        assert(projection.type === 1 /* Spherical */ );
    }
    _createClass(SphereViewBounds, [
        {
            key: "generate",
            value: function generate() {
                var coordinates = this.findBoundsIntersections();
                this.wrapAroundPoles(coordinates);
                return coordinates.length > 2 ? new GeoPolygon(coordinates, false, true) : void 0;
            }
        },
        {
            key: "addSideSegmentSubdivisions",
            value: function addSideSegmentSubdivisions(coordinates, NDCStart, NDCEnd, geoStart, geoEnd) {
                coordinates.push(geoStart);
                var divisionCount = computeEdgeDivisions(geoStart, geoEnd);
                if (divisionCount <= 1) {
                    return;
                }
                var NDCStep = new import_three15.Vector2(NDCEnd.x - NDCStart.x, NDCEnd.y - NDCStart.y).multiplyScalar(1 / divisionCount);
                var NDCDivision = new import_three15.Vector2(NDCStart.x, NDCStart.y);
                for(var i = 0; i < divisionCount - 1; i++){
                    NDCDivision.add(NDCStep);
                    var intersection = MapViewUtils.rayCastWorldCoordinates({
                        camera: this.camera,
                        projection: this.projection
                    }, NDCDivision.x, NDCDivision.y);
                    if (intersection) {
                        coordinates.push(this.projection.unprojectPoint(intersection));
                    }
                }
            }
        },
        {
            key: "addSideIntersections",
            value: function addSideIntersections(coordinates, side, geoStartCorner, geoEndCorner, horizon) {
                var _this = this;
                var startNDCCorner = ccwCanvasCornersNDC[side];
                var endNDCCorner = ccwCanvasCornersNDC[nextCanvasSide(side)];
                if (geoStartCorner && geoEndCorner) {
                    this.addSideSegmentSubdivisions(coordinates, startNDCCorner, endNDCCorner, geoStartCorner, geoEndCorner);
                    return;
                }
                if (!horizon) {
                    return;
                }
                var horizonIntersections = horizon.getSideIntersections(side);
                if (horizonIntersections.length === 0) {
                    return;
                }
                if (geoStartCorner) {
                    var worldHorizonPoint = horizon.getPoint(horizonIntersections[horizonIntersections.length - 1]);
                    var geoHorizonPoint = this.projection.unprojectPoint(worldHorizonPoint);
                    this.addSideSegmentSubdivisions(coordinates, startNDCCorner, worldHorizonPoint.project(this.camera), geoStartCorner, geoHorizonPoint);
                } else {
                    var prevSide = previousCanvasSide(side);
                    var prevSideIntersections = horizon.getSideIntersections(prevSide);
                    if (prevSideIntersections.length === 0) {
                        prevSideIntersections = horizon.getSideIntersections(previousCanvasSide(prevSide));
                    }
                    assert(prevSideIntersections.length > 0);
                    horizon.getDivisionPoints(function(point) {
                        coordinates.push(_this.projection.unprojectPoint(point));
                    }, prevSideIntersections[prevSideIntersections.length - 1], horizonIntersections[0]);
                }
                if (horizonIntersections.length > 1) {
                    var worldHorizonStart = horizon.getPoint(horizonIntersections[0]);
                    var worldHorizonEnd = horizon.getPoint(horizonIntersections[1]);
                    var geoHorizonStart = this.projection.unprojectPoint(worldHorizonStart);
                    var geoHorizonEnd = this.projection.unprojectPoint(worldHorizonEnd);
                    this.addSideSegmentSubdivisions(coordinates, worldHorizonStart.project(this.camera), worldHorizonEnd.project(this.camera), geoHorizonStart, geoHorizonEnd);
                }
                if (geoEndCorner) {
                    var worldHorizonPoint1 = horizon.getPoint(horizonIntersections[0]);
                    var geoHorizonPoint1 = this.projection.unprojectPoint(worldHorizonPoint1);
                    this.addSideSegmentSubdivisions(coordinates, worldHorizonPoint1.project(this.camera), endNDCCorner, geoHorizonPoint1, geoEndCorner);
                }
            }
        },
        {
            key: "findBoundsIntersections",
            value: function findBoundsIntersections() {
                var _this = this;
                var coordinates = [];
                var ref = _slicedToArray(this.addCanvasCornerIntersection(), 2), cornerCoordinates = ref[0], numCorners = ref[1];
                var horizon = numCorners < 4 ? new SphereHorizon(this.camera, cornerCoordinates.map(function(value2) {
                    return value2 !== void 0;
                })) : void 0;
                if (numCorners === 0 && horizon.isFullyVisible) {
                    horizon.getDivisionPoints(function(point) {
                        coordinates.push(_this.projection.unprojectPoint(point));
                    });
                    return coordinates;
                }
                for(var side = 0 /* Bottom */ ; side < 4; side++){
                    var startCorner = cornerCoordinates[side];
                    var endCorner = cornerCoordinates[nextCanvasSide(side)];
                    this.addSideIntersections(coordinates, side, startCorner, endCorner, horizon);
                }
                return coordinates;
            }
        },
        {
            key: "wrapAroundPoles",
            value: function wrapAroundPoles(coordinates) {
                var northPoleCenter = new import_three15.Vector3(0, 0, EarthConstants.EQUATORIAL_RADIUS);
                var southPoleCenter = new import_three15.Vector3(0, 0, -EarthConstants.EQUATORIAL_RADIUS);
                var northPoleInView = MapViewUtils.closeToFrustum(northPoleCenter, this.camera);
                var southPoleInView = MapViewUtils.closeToFrustum(southPoleCenter, this.camera);
                if (!northPoleInView && !southPoleInView) {
                    return;
                }
                var camLon = this.projection.unprojectPoint(this.camera.position).lng;
                var wrapLat = northPoleInView ? 90 : -90;
                var wrapLon = northPoleInView ? camLon + 180 : camLon - 180;
                var geoWrapTopRight = new GeoCoordinates(wrapLat, wrapLon);
                var geoWrapTopRightNorm = geoWrapTopRight.normalized();
                var crossLon = geoWrapTopRightNorm.lng;
                var prevLon = coordinates[coordinates.length - 1].lng;
                var isGwAntimerCross = false;
                var hSphereCrossEndIndex = coordinates.findIndex(function(value2) {
                    var crossesAntimer = isAntimeridianCrossing(prevLon, value2.lng);
                    var sameSign = Math.sign(crossLon - value2.lng) === Math.sign(crossLon - prevLon);
                    if (sameSign === crossesAntimer) {
                        isGwAntimerCross = crossesAntimer;
                        return true;
                    }
                    prevLon = value2.lng;
                    return false;
                });
                if (hSphereCrossEndIndex < 0) {
                    return;
                }
                var wrapSideOffset = northPoleInView ? 90 : -90;
                var wrapCornerOffset = northPoleInView ? 1e-5 : -1e-5;
                var geoWrapRight = new GeoCoordinates(wrapLat, camLon + wrapSideOffset).normalized();
                var geoWrapBottom = new GeoCoordinates(wrapLat, camLon).normalized();
                var geoWrapLeft = new GeoCoordinates(wrapLat, camLon - wrapSideOffset).normalized();
                var geoWrapTopLeft = new GeoCoordinates(wrapLat, wrapLon + wrapCornerOffset).normalized();
                var hSphereCrossStartIndex = (hSphereCrossEndIndex + coordinates.length - 1) % coordinates.length;
                var crossStart = coordinates[hSphereCrossStartIndex];
                var crossEnd = coordinates[hSphereCrossEndIndex];
                var crossLerp = GeoCoordinates.lerp(crossStart, crossEnd, 0.01, isGwAntimerCross);
                if (isGwAntimerCross && northPoleInView) {
                    crossLerp.longitude -= 360;
                } else {
                    crossLerp = crossLerp.normalized();
                }
                coordinates.splice(hSphereCrossEndIndex, 0, wrapLon < -180 ? geoWrapTopRight : geoWrapTopRightNorm, geoWrapRight, geoWrapBottom, geoWrapLeft, geoWrapTopLeft, crossLerp);
            }
        },
        {
            key: "addCanvasCornerIntersection",
            value: function addCanvasCornerIntersection() {
                var _this = this;
                var geoCorners = new Array();
                var numIntersections = 0;
                ccwCanvasCornersNDC.forEach(function(corner) {
                    var intersection = MapViewUtils.rayCastWorldCoordinates({
                        camera: _this.camera,
                        projection: _this.projection
                    }, corner.x, corner.y);
                    if (intersection) {
                        geoCorners.push(_this.projection.unprojectPoint(intersection));
                        ++numIntersections;
                    } else {
                        geoCorners.push(void 0);
                    }
                });
                return [
                    geoCorners,
                    numIntersections
                ];
            }
        }
    ]);
    return SphereViewBounds;
}();
// src/mapview/BoundsGenerator.ts
var BoundsGenerator = /*#__PURE__*/ function() {
    function BoundsGenerator(m_view) {
        _classCallCheck(this, BoundsGenerator);
        this.m_view = m_view;
        __publicField(this, "m_viewBounds");
        this.createViewBounds();
    }
    _createClass(BoundsGenerator, [
        {
            key: "generate",
            value: function generate() {
                if (this.m_view.projection !== this.m_viewBounds.projection) {
                    this.createViewBounds();
                }
                return this.m_viewBounds.generate();
            }
        },
        {
            key: "createViewBounds",
            value: function createViewBounds() {
                this.m_viewBounds = this.m_view.projection.type === 0 /* Planar */  ? new PlaneViewBounds(this.m_view.camera, this.m_view.projection, this.m_view) : new SphereViewBounds(this.m_view.camera, this.m_view.projection);
            }
        }
    ]);
    return BoundsGenerator;
}();
// src/mapview/WorkerBasedTiler.ts
var nextUniqueServiceId2 = 0;
var WorkerBasedTiler = /*#__PURE__*/ function() {
    function WorkerBasedTiler(workerSet, tilerServiceType) {
        _classCallCheck(this, WorkerBasedTiler);
        this.workerSet = workerSet;
        this.tilerServiceType = tilerServiceType;
        __publicField(this, "serviceId");
        __publicField(this, "m_serviceCreated", false);
        this.workerSet.addReference();
        this.serviceId = "".concat(this.tilerServiceType, "-").concat(nextUniqueServiceId2++);
    }
    _createClass(WorkerBasedTiler, [
        {
            key: "dispose",
            value: function dispose() {
                if (this.m_serviceCreated) {
                    this.workerSet.broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                        type: WorkerServiceProtocol.Requests.DestroyService,
                        targetServiceId: this.serviceId
                    }).catch(function() {});
                }
                this.workerSet.removeReference();
            }
        },
        {
            key: "connect",
            value: function connect() {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return _this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
                            case 2:
                                if (_this.m_serviceCreated) {
                                    _ctx.next = 6;
                                    break;
                                }
                                _ctx.next = 5;
                                return _this.workerSet.broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                                    type: WorkerServiceProtocol.Requests.CreateService,
                                    targetServiceType: _this.tilerServiceType,
                                    targetServiceId: _this.serviceId
                                });
                            case 5:
                                _this.m_serviceCreated = true;
                            case 6:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "registerIndex",
            value: function registerIndex(indexId, input) {
                var message = {
                    type: WorkerTilerProtocol.Requests.RegisterIndex,
                    id: indexId,
                    input: _instanceof(input, URL) ? input.href : input
                };
                return this.workerSet.invokeRequest(this.serviceId, message);
            }
        },
        {
            key: "updateIndex",
            value: function updateIndex(indexId, input) {
                var message = {
                    type: WorkerTilerProtocol.Requests.UpdateIndex,
                    id: indexId,
                    input: _instanceof(input, URL) ? input.href : input
                };
                return this.workerSet.invokeRequest(this.serviceId, message);
            }
        },
        {
            key: "getTile",
            value: function getTile(indexId, tileKey) {
                var tileKeyCode = tileKey.mortonCode();
                var message = {
                    type: WorkerTilerProtocol.Requests.TileRequest,
                    index: indexId,
                    tileKey: tileKeyCode
                };
                return this.workerSet.invokeRequest(this.serviceId, message);
            }
        }
    ]);
    return WorkerBasedTiler;
}();
// src/mapview/ConcurrentTilerFacade.ts
var _ConcurrentTilerFacade = /*#__PURE__*/ function() {
    function _ConcurrentTilerFacade() {
        _classCallCheck(this, _ConcurrentTilerFacade);
    }
    _createClass(_ConcurrentTilerFacade, null, [
        {
            key: "getTiler",
            value: function getTiler(tilerServiceType, scriptUrl, workerCount, workerConnectionTimeout) {
                var workerSet = this.getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout);
                return new WorkerBasedTiler(workerSet, tilerServiceType);
            }
        },
        {
            key: "getWorkerSet",
            value: function getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout) {
                if (scriptUrl === void 0) {
                    scriptUrl = this.defaultScriptUrl;
                }
                var workerSet = this.workerSets[scriptUrl];
                if (workerSet === void 0) {
                    var workerConnectionTimeoutInMs = workerConnectionTimeout !== void 0 ? workerConnectionTimeout * 1e3 : void 0;
                    workerSet = new ConcurrentWorkerSet({
                        scriptUrl: scriptUrl,
                        workerCount: workerCount !== null && workerCount !== void 0 ? workerCount : this.defaultWorkerCount,
                        workerConnectionTimeout: workerConnectionTimeoutInMs
                    });
                    this.workerSets[scriptUrl] = workerSet;
                }
                return workerSet;
            }
        },
        {
            key: "destroyWorkerSet",
            value: function destroyWorkerSet(scriptUrl) {
                var workerSet = this.workerSets[scriptUrl];
                if (workerSet !== void 0) {
                    workerSet.destroy();
                    delete this.workerSets[scriptUrl];
                }
            }
        },
        {
            key: "destroy",
            value: function destroy() {
                var _this = this;
                Object.keys(this.workerSets).forEach(function(name2) {
                    _this.workerSets[name2].destroy();
                });
                this.workerSets = {};
            }
        },
        {
            key: "destroyIfTerminated",
            value: function destroyIfTerminated() {
                var _this = this;
                var allWorkerSetsTerminated = true;
                Object.keys(this.workerSets).forEach(function(name2) {
                    if (!_this.workerSets[name2].terminated) {
                        allWorkerSetsTerminated = false;
                    }
                });
                if (allWorkerSetsTerminated) {
                    _ConcurrentTilerFacade.destroy();
                }
            }
        }
    ]);
    return _ConcurrentTilerFacade;
}();
var ConcurrentTilerFacade = _ConcurrentTilerFacade;
__publicField(ConcurrentTilerFacade, "defaultScriptUrl", "./decoder.bundle.js");
__publicField(ConcurrentTilerFacade, "defaultWorkerCount", 1);
__publicField(ConcurrentTilerFacade, "workerSets", {});
// src/mapview/copyrights/CopyrightElementHandler.ts
var CopyrightElementHandler = /*#__PURE__*/ function() {
    function CopyrightElementHandler(element, mapView) {
        var _this = this;
        _classCallCheck(this, CopyrightElementHandler);
        __publicField(this, "staticInfo");
        __publicField(this, "m_defaults", /* @__PURE__ */ new Map());
        __publicField(this, "m_element");
        __publicField(this, "m_mapViews", []);
        __publicField(this, "update", function() {
            var _staticInfo;
            var mergedCopyrightInfo = _this.m_mapViews.map(function(mapView) {
                return mapView.copyrightInfo;
            }).reduce(CopyrightInfo.mergeArrays, (_staticInfo = _this.staticInfo) !== null && _staticInfo !== void 0 ? _staticInfo : []);
            if (mergedCopyrightInfo.length === 0) {
                _this.m_element.style.display = "none";
                return;
            } else {
                _this.m_element.style.display = "block";
            }
            if (_this.m_defaults.size !== 0) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = mergedCopyrightInfo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var sourceInfo = _step.value;
                        var defaults = _this.m_defaults.get(sourceInfo.id);
                        if (defaults !== void 0) {
                            sourceInfo.year = getOptionValue(sourceInfo.year, defaults.year);
                            sourceInfo.label = getOptionValue(sourceInfo.label, defaults.label);
                            sourceInfo.link = getOptionValue(sourceInfo.link, defaults.link);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            var deduped = CopyrightInfo.mergeArrays(mergedCopyrightInfo);
            _this.m_element.innerHTML = CopyrightInfo.formatAsHtml(deduped);
        });
        if (typeof element === "string") {
            var htmlElement = document.getElementById(element);
            if (!htmlElement) {
                throw new Error("CopyrightElementHandler: unable to find DOM element #".concat(element));
            }
            this.m_element = htmlElement;
        } else {
            this.m_element = element;
        }
        if (mapView !== void 0) {
            this.attach(mapView);
        }
    }
    _createClass(CopyrightElementHandler, [
        {
            key: "destroy",
            value: function destroy() {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = this.m_mapViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var mapView = _step.value;
                        mapView.removeEventListener("copyright-changed" /* CopyrightChanged */ , this.update);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "attach",
            value: function attach(mapView) {
                this.m_mapViews.push(mapView);
                mapView.addEventListener("copyright-changed" /* CopyrightChanged */ , this.update);
                this.update();
                return this;
            }
        },
        {
            key: "detach",
            value: function detach(mapView) {
                mapView.removeEventListener("copyright-changed" /* CopyrightChanged */ , this.update);
                this.m_mapViews = this.m_mapViews.filter(function(item) {
                    return item !== mapView;
                });
                this.update();
                return this;
            }
        },
        {
            key: "setDefaults",
            value: function setDefaults(defaults) {
                this.m_defaults.clear();
                if (defaults !== void 0) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = defaults[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var item = _step.value;
                            this.m_defaults.set(item.id, item);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                return this;
            }
        },
        {
            key: "setStaticCopyightInfo",
            value: function setStaticCopyightInfo(staticInfo) {
                this.staticInfo = staticInfo;
                return this;
            }
        }
    ], [
        {
            key: "install",
            value: function install(element, mapView) {
                return new CopyrightElementHandler(element, mapView);
            }
        }
    ]);
    return CopyrightElementHandler;
}();
// src/mapview/copyrights/CopyrightCoverageProvider.ts
var RBush2 = require("rbush");
var CopyrightCoverageProvider = /*#__PURE__*/ function() {
    function CopyrightCoverageProvider() {
        _classCallCheck(this, CopyrightCoverageProvider);
        __publicField(this, "logger", LoggerManager.instance.create("CopyrightCoverageProvider"));
        __publicField(this, "m_cachedTreePromise");
    }
    _createClass(CopyrightCoverageProvider, [
        {
            key: "getTree",
            value: function getTree() {
                var _this = this;
                if (this.m_cachedTreePromise !== void 0) {
                    return this.m_cachedTreePromise;
                }
                this.m_cachedTreePromise = this.getCopyrightCoverageData().then(function(coverageInfo) {
                    return _this.initRBush(coverageInfo);
                }).catch(function(error) {
                    _this.logger.error(error);
                    return new RBush2();
                });
                return this.m_cachedTreePromise;
            }
        },
        {
            key: "getCopyrights",
            value: function getCopyrights(geoBox, level) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var tree, result, matchingEntries, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.next = 2;
                                return _this.getTree();
                            case 2:
                                tree = _ctx.sent;
                                result = [];
                                matchingEntries = tree.search({
                                    minX: geoBox.west,
                                    minY: geoBox.south,
                                    maxX: geoBox.east,
                                    maxY: geoBox.north
                                });
                                _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                _ctx.prev = 6;
                                _loop = function(_iterator, _step) {
                                    var entry = _step.value;
                                    var minLevel = getOptionValue(entry.minLevel, 0);
                                    var maxLevel = getOptionValue(entry.maxLevel, Infinity);
                                    if (level >= minLevel && level <= maxLevel) {
                                        if (result.find(function(item) {
                                            return item.id === entry.label;
                                        }) === void 0) {
                                            result.push({
                                                id: entry.label
                                            });
                                        }
                                    }
                                };
                                for(_iterator = matchingEntries[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
                                _ctx.next = 15;
                                break;
                            case 11:
                                _ctx.prev = 11;
                                _ctx.t0 = _ctx["catch"](6);
                                _didIteratorError = true;
                                _iteratorError = _ctx.t0;
                            case 15:
                                _ctx.prev = 15;
                                _ctx.prev = 16;
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            case 18:
                                _ctx.prev = 18;
                                if (!_didIteratorError) {
                                    _ctx.next = 21;
                                    break;
                                }
                                throw _iteratorError;
                            case 21:
                                return _ctx.finish(18);
                            case 22:
                                return _ctx.finish(15);
                            case 23:
                                return _ctx.abrupt("return", result);
                            case 24:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            6,
                            11,
                            15,
                            23
                        ],
                        [
                            16,
                            ,
                            18,
                            22
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "initRBush",
            value: function initRBush(entries) {
                var tree = new RBush2();
                if (!entries) {
                    this.logger.warn("No copyright coverage data provided");
                    return tree;
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var entry = _step.value;
                        var minLevel = entry.minLevel, maxLevel = entry.maxLevel, label = entry.label, alt = entry.alt;
                        if (!entry.boxes) {
                            tree.insert({
                                minX: -180,
                                minY: -90,
                                maxX: 180,
                                maxY: 180,
                                minLevel: minLevel,
                                maxLevel: maxLevel,
                                label: label,
                                alt: alt
                            });
                        } else {
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = entry.boxes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var box = _step1.value;
                                    var _box = _slicedToArray(box, 4), minY = _box[0], minX = _box[1], maxY = _box[2], maxX = _box[3];
                                    tree.insert({
                                        minX: minX,
                                        minY: minY,
                                        maxX: maxX,
                                        maxY: maxY,
                                        minLevel: minLevel,
                                        maxLevel: maxLevel,
                                        label: label,
                                        alt: alt
                                    });
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return tree;
            }
        }
    ]);
    return CopyrightCoverageProvider;
}();
// src/transfer-manager/DeferredPromise.ts
var DeferredPromise = /*#__PURE__*/ function() {
    function DeferredPromise(executor) {
        var _this = this;
        _classCallCheck(this, DeferredPromise);
        this.executor = executor;
        __publicField(this, "promise");
        __publicField(this, "resolveFunc");
        __publicField(this, "rejectFunc");
        this.promise = new Promise(function(resolve, reject) {
            _this.resolveFunc = resolve;
            _this.rejectFunc = reject;
        });
    }
    _createClass(DeferredPromise, [
        {
            key: "exec",
            value: function exec() {
                var _this = this;
                this.executor().then(function(result) {
                    return _this.resolveFunc(result);
                }).catch(function(error) {
                    return _this.rejectFunc(error);
                });
            }
        }
    ]);
    return DeferredPromise;
}();
// src/transfer-manager/TransferManager.ts
var _TransferManager = /*#__PURE__*/ function() {
    function _TransferManager() {
        var fetchFunction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : fetch, maxRetries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        _classCallCheck(this, _TransferManager);
        this.fetchFunction = fetchFunction;
        this.maxRetries = maxRetries;
        __publicField(this, "activeDownloadCount", 0);
        __publicField(this, "downloadQueue", new Array());
        __publicField(this, "activeDownloads", /* @__PURE__ */ new Map());
    }
    _createClass(_TransferManager, [
        {
            key: "downloadJson",
            value: function downloadJson(url, init) {
                return this.downloadAs(function(response) {
                    return response.json();
                }, url, init);
            }
        },
        {
            key: "downloadArrayBuffer",
            value: function downloadArrayBuffer(url, init) {
                return this.download(url, init).then(function(response) {
                    return response.arrayBuffer();
                });
            }
        },
        {
            key: "download",
            value: function download(url, init) {
                var _this = this;
                if (this.activeDownloadCount >= _TransferManager.maxParallelDownloads) {
                    var deferred = new DeferredPromise(function() {
                        return _this.doDownload(url, init);
                    });
                    this.downloadQueue.push(deferred);
                    return deferred.promise;
                }
                return this.doDownload(url, init);
            }
        },
        {
            key: "doDownload",
            value: function doDownload(url, init) {
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var response;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.prev = 0;
                                ++_this.activeDownloadCount;
                                _ctx.next = 4;
                                return _TransferManager.fetchRepeatedly(_this.fetchFunction, 0, _this.maxRetries, url, init);
                            case 4:
                                response = _ctx.sent;
                                _this.onDownloadDone();
                                return _ctx.abrupt("return", response);
                            case 9:
                                _ctx.prev = 9;
                                _ctx.t0 = _ctx["catch"](0);
                                _this.onDownloadDone();
                                throw _ctx.t0;
                            case 13:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            0,
                            9
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "onDownloadDone",
            value: function onDownloadDone() {
                --this.activeDownloadCount;
                this.execDeferredDownload();
            }
        },
        {
            key: "execDeferredDownload",
            value: function execDeferredDownload() {
                var future = this.downloadQueue.pop();
                if (future === void 0) {
                    return;
                }
                future.exec();
            }
        },
        {
            key: "downloadAs",
            value: function downloadAs(converter, url, init) {
                var _this = this;
                var cacheKey = url;
                var pendingFetch = this.activeDownloads.get(cacheKey);
                if (pendingFetch !== void 0) {
                    return Promise.resolve(pendingFetch);
                }
                var newFetch = this.download(url, init).then(function(response) {
                    _this.activeDownloads.delete(cacheKey);
                    if (response.ok) {
                        return converter(response);
                    }
                    throw new Error(JSON.stringify(response));
                }).catch(function(err) {
                    _this.activeDownloads.delete(cacheKey);
                    throw err;
                });
                this.activeDownloads.set(cacheKey, newFetch);
                return newFetch;
            }
        }
    ], [
        {
            key: "instance",
            value: function instance() {
                return _TransferManager.defaultInstance;
            }
        },
        {
            key: "fetchRepeatedly",
            value: function fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var response, responseText;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                _ctx.prev = 0;
                                if (!(retryCount < maxRetries)) {
                                    _ctx.next = 17;
                                    break;
                                }
                                _ctx.next = 4;
                                return fetchFunction(url, init);
                            case 4:
                                response = _ctx.sent;
                                if (!(response.status === 200 || response.status === 204)) {
                                    _ctx.next = 9;
                                    break;
                                }
                                return _ctx.abrupt("return", response);
                            case 9:
                                if (!(response.status >= 400 && response.status < 500)) {
                                    _ctx.next = 15;
                                    break;
                                }
                                retryCount = maxRetries;
                                _ctx.next = 13;
                                return response.text();
                            case 13:
                                responseText = _ctx.sent;
                                throw new Error(responseText);
                            case 15:
                                _ctx.next = 18;
                                break;
                            case 17:
                                throw new Error("Max number of retries reached");
                            case 18:
                                _ctx.next = 24;
                                break;
                            case 20:
                                _ctx.prev = 20;
                                _ctx.t0 = _ctx["catch"](0);
                                if (!(_ctx.t0.hasOwnProperty("isCancelled") || _ctx.t0.name === "AbortError" || retryCount >= maxRetries)) {
                                    _ctx.next = 24;
                                    break;
                                }
                                throw _ctx.t0;
                            case 24:
                                _ctx.next = 26;
                                return _TransferManager.waitFor(_TransferManager.retryTimeout * retryCount).then(function() {
                                    return _TransferManager.fetchRepeatedly(fetchFunction, retryCount + 1, maxRetries, url, init);
                                });
                            case 26:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 27:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee, null, [
                        [
                            0,
                            20
                        ]
                    ]);
                }))();
            }
        },
        {
            key: "waitFor",
            value: function waitFor(milliseconds) {
                return new Promise(function(resolve) {
                    return setTimeout(resolve, milliseconds);
                });
            }
        }
    ]);
    return _TransferManager;
}();
var TransferManager = _TransferManager;
__publicField(TransferManager, "retryTimeout", 500);
__publicField(TransferManager, "maxParallelDownloads", 16);
__publicField(TransferManager, "defaultInstance", new _TransferManager());
// src/mapview/copyrights/UrlCopyrightProvider.ts
var UrlCopyrightProvider = /*#__PURE__*/ function(CopyrightCoverageProvider) {
    _inherits(UrlCopyrightProvider, CopyrightCoverageProvider);
    var _super = _createSuper(UrlCopyrightProvider);
    function UrlCopyrightProvider(m_fetchURL, m_baseScheme, m_requestHeaders) {
        var m_transferManager = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : TransferManager.instance();
        _classCallCheck(this, UrlCopyrightProvider);
        var _this;
        _this = _super.call(this);
        _this.m_fetchURL = m_fetchURL;
        _this.m_baseScheme = m_baseScheme;
        _this.m_requestHeaders = m_requestHeaders;
        _this.m_transferManager = m_transferManager;
        __publicField(_assertThisInitialized(_this), "m_cachedCopyrightResponse");
        return _this;
    }
    _createClass(UrlCopyrightProvider, [
        {
            key: "setRequestHeaders",
            value: function setRequestHeaders(headers) {
                this.m_requestHeaders = headers;
            }
        },
        {
            key: "getCopyrightCoverageData",
            value: function getCopyrightCoverageData(abortSignal) {
                var _this = this;
                if (this.m_cachedCopyrightResponse !== void 0) {
                    return this.m_cachedCopyrightResponse;
                }
                this.m_cachedCopyrightResponse = this.m_transferManager.downloadJson(this.m_fetchURL, {
                    headers: this.m_requestHeaders,
                    signal: abortSignal
                }).then(function(json) {
                    return json[_this.m_baseScheme];
                }).catch(function(error) {
                    _this.logger.error(error);
                    return [];
                });
                return this.m_cachedCopyrightResponse;
            }
        }
    ]);
    return UrlCopyrightProvider;
}(CopyrightCoverageProvider);
// src/mapview/FixedClipPlanesEvaluator.ts
var FixedClipPlanesEvaluator = /*#__PURE__*/ function() {
    function FixedClipPlanesEvaluator() {
        var minNear = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, minFarOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
        _classCallCheck(this, FixedClipPlanesEvaluator);
        this.minNear = minNear;
        this.minFarOffset = minFarOffset;
        __publicField(this, "minFar");
        __publicField(this, "m_nearPlane");
        __publicField(this, "m_farPlane");
        this.minFar = minNear + minFarOffset;
        this.m_nearPlane = minNear;
        this.m_farPlane = this.minFar;
    }
    _createClass(FixedClipPlanesEvaluator, [
        {
            key: "nearPlane",
            get: function get() {
                return this.m_nearPlane;
            },
            set: function set(fixedNear) {
                this.invalidatePlanes(fixedNear, this.m_farPlane);
            }
        },
        {
            key: "farPlane",
            get: function get() {
                return this.m_farPlane;
            },
            set: function set(fixedFar) {
                this.invalidatePlanes(this.m_nearPlane, fixedFar);
            }
        },
        {
            key: "minElevation",
            get: function get() {
                return 0;
            },
            set: function set(elevation) {}
        },
        {
            key: "maxElevation",
            get: function get() {
                return 0;
            },
            set: function set(elevation) {}
        },
        {
            key: "evaluateClipPlanes",
            value: function evaluateClipPlanes(camera, projection, elevationProvider) {
                var viewRanges = {
                    near: this.m_nearPlane,
                    far: this.m_farPlane,
                    minimum: this.minNear,
                    maximum: this.m_farPlane
                };
                return viewRanges;
            }
        },
        {
            key: "invalidatePlanes",
            value: function invalidatePlanes(near, far) {
                var nearDist = Math.max(this.minNear, near);
                var farDist = Math.max(this.minFar, far, nearDist + this.minFarOffset);
                this.m_nearPlane = nearDist;
                this.m_farPlane = farDist;
            }
        }
    ]);
    return FixedClipPlanesEvaluator;
}();
// src/mapview/MapViewAtmosphere.ts
var THREE99 = __toESM(require("three"));
var AtmosphereLightMode = /* @__PURE__ */ function(AtmosphereLightMode2) {
    AtmosphereLightMode2[AtmosphereLightMode2["LightOverhead"] = 0] = "LightOverhead";
    AtmosphereLightMode2[AtmosphereLightMode2["LightDynamic"] = 1] = "LightDynamic";
    return AtmosphereLightMode2;
}(AtmosphereLightMode || {});
var SKY_ATMOSPHERE_ALTITUDE_FACTOR = 0.025;
var GROUND_ATMOSPHERE_ALTITUDE_FACTOR = 1e-4;
var cache5 = {
    clipPlanes: {
        near: 0,
        far: 0
    }
};
var _MapViewAtmosphere = /*#__PURE__*/ function() {
    function _MapViewAtmosphere(m_mapAnchors, m_sceneCamera, m_projection, m_rendererCapabilities, m_updateCallback) {
        var m_atmosphereVariant = arguments.length > 5 && arguments[5] !== void 0 /* SkyAndGround */  ? arguments[5] : 3, m_materialVariant = arguments.length > 6 && arguments[6] !== void 0 /* ScatteringShader */  ? arguments[6] : 0;
        _classCallCheck(this, _MapViewAtmosphere);
        this.m_mapAnchors = m_mapAnchors;
        this.m_sceneCamera = m_sceneCamera;
        this.m_projection = m_projection;
        this.m_rendererCapabilities = m_rendererCapabilities;
        this.m_updateCallback = m_updateCallback;
        this.m_atmosphereVariant = m_atmosphereVariant;
        this.m_materialVariant = m_materialVariant;
        __publicField(this, "m_enabled", true);
        __publicField(this, "m_skyGeometry");
        __publicField(this, "m_skyMaterial");
        __publicField(this, "m_skyMesh");
        __publicField(this, "m_groundGeometry");
        __publicField(this, "m_groundMaterial");
        __publicField(this, "m_groundMesh");
        __publicField(this, "m_clipPlanesEvaluator", new TiltViewClipPlanesEvaluator(EarthConstants.EQUATORIAL_RADIUS * SKY_ATMOSPHERE_ALTITUDE_FACTOR, 0, 1, 0.05, 1e7));
        __publicField(this, "m_lightDirection", new THREE99.Vector3(0, 1, 0));
        if (this.m_atmosphereVariant & 2 /* Sky */ ) {
            this.createSkyGeometry();
        }
        if (this.m_atmosphereVariant & 1 /* Ground */ ) {
            this.createGroundGeometry();
        }
        this.addToMapAnchors(this.m_mapAnchors);
    }
    _createClass(_MapViewAtmosphere, [
        {
            key: "skyMesh",
            get: function get() {
                return this.m_skyMesh;
            }
        },
        {
            key: "groundMesh",
            get: function get() {
                return this.m_groundMesh;
            }
        },
        {
            key: "enabled",
            get: function get() {
                return this.m_enabled;
            },
            set: function set(enable) {
                if (this.disposed) {
                    return;
                }
                if (this.m_enabled === enable) {
                    return;
                }
                this.m_enabled = enable;
                var isAdded = _MapViewAtmosphere.isPresent(this.m_mapAnchors);
                if (enable && !isAdded) {
                    this.addToMapAnchors(this.m_mapAnchors);
                } else if (!enable && isAdded) {
                    this.removeFromMapAnchors(this.m_mapAnchors);
                }
            }
        },
        {
            key: "lightMode",
            set: function set(lightMode) {
                if (this.m_materialVariant !== 0 /* ScatteringShader */ ) {
                    return;
                }
                var dynamicLight = lightMode === 1 /* LightDynamic */ ;
                if (this.m_groundMaterial !== void 0) {
                    var groundMat = this.m_groundMaterial;
                    groundMat.setDynamicLighting(dynamicLight);
                }
                if (this.m_skyMaterial !== void 0) {
                    var skyMat = this.m_skyMaterial;
                    skyMat.setDynamicLighting(dynamicLight);
                }
            }
        },
        {
            key: "dispose",
            value: function dispose() {
                var ref, ref1, ref2, ref3;
                if (this.enabled) {
                    this.enabled = false;
                }
                (ref = this.m_skyMaterial) === null || ref === void 0 ? void 0 : ref.dispose();
                (ref1 = this.m_groundMaterial) === null || ref1 === void 0 ? void 0 : ref1.dispose();
                (ref2 = this.m_skyGeometry) === null || ref2 === void 0 ? void 0 : ref2.dispose();
                (ref3 = this.m_groundGeometry) === null || ref3 === void 0 ? void 0 : ref3.dispose();
                this.m_skyGeometry = void 0;
                this.m_groundGeometry = void 0;
                this.m_skyMaterial = void 0;
                this.m_groundMaterial = void 0;
                this.m_skyMesh = void 0;
                this.m_groundMesh = void 0;
            }
        },
        {
            key: "reset",
            value: function reset(theme) {}
        },
        {
            key: "disposed",
            get: function get() {
                return this.m_skyMesh === void 0 && this.m_groundMesh === void 0;
            }
        },
        {
            key: "addToMapAnchors",
            value: function addToMapAnchors(mapAnchors) {
                assert(!_MapViewAtmosphere.isPresent(mapAnchors), "Atmosphere already added");
                if (this.m_skyMesh !== void 0) {
                    mapAnchors.add(createMapAnchor(this.m_skyMesh, Number.MIN_SAFE_INTEGER));
                }
                if (this.m_groundMesh !== void 0) {
                    mapAnchors.add(createMapAnchor(this.m_groundMesh, Number.MAX_SAFE_INTEGER));
                }
                if (this.m_updateCallback) {
                    this.m_updateCallback();
                }
            }
        },
        {
            key: "removeFromMapAnchors",
            value: function removeFromMapAnchors(mapAnchors) {
                if (!_MapViewAtmosphere.isPresent(mapAnchors)) {
                    return;
                }
                var update = false;
                if (this.m_skyMesh !== void 0) {
                    mapAnchors.remove(this.m_skyMesh);
                    update = true;
                }
                if (this.m_groundMesh !== void 0) {
                    mapAnchors.remove(this.m_groundMesh);
                    update = true;
                }
                if (update && this.m_updateCallback) {
                    this.m_updateCallback();
                }
            }
        },
        {
            key: "createSkyGeometry",
            value: function createSkyGeometry() {
                switch(this.m_projection.type){
                    case 1 /* Spherical */ :
                        this.m_skyGeometry = new THREE99.SphereGeometry(EarthConstants.EQUATORIAL_RADIUS * (1 + SKY_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);
                        break;
                    default:
                        {
                            this.m_skyGeometry = new THREE99.PlaneGeometry(200, 200);
                            break;
                        }
                }
                this.m_skyGeometry.translate(0, 0, 0);
                if (this.m_materialVariant === 0 /* ScatteringShader */ ) {
                    this.m_skyMaterial = new SkyAtmosphereMaterial({
                        rendererCapabilities: this.m_rendererCapabilities
                    });
                } else if (this.m_materialVariant === 1 /* SimpleColor */ ) {
                    this.m_skyMaterial = new THREE99.MeshBasicMaterial({
                        color: new THREE99.Color(12908781),
                        opacity: 0.4,
                        transparent: false,
                        depthTest: true,
                        depthWrite: false,
                        side: THREE99.BackSide,
                        blending: THREE99.NormalBlending,
                        fog: false
                    });
                } else {
                    this.m_skyMaterial = new THREE99.MeshStandardMaterial({
                        color: 8388607,
                        depthTest: false,
                        depthWrite: false,
                        normalScale: new THREE99.Vector2(-1, -1),
                        side: THREE99.BackSide,
                        wireframe: true
                    });
                }
                this.m_skyMesh = new THREE99.Mesh(this.m_skyGeometry, this.m_skyMaterial);
                this.m_skyMesh.name = _MapViewAtmosphere.SkyAtmosphereUserName;
                this.setupSkyForRendering();
            }
        },
        {
            key: "createGroundGeometry",
            value: function createGroundGeometry() {
                switch(this.m_projection.type){
                    case 1 /* Spherical */ :
                        this.m_groundGeometry = new THREE99.SphereGeometry(EarthConstants.EQUATORIAL_RADIUS * (1 + GROUND_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);
                        break;
                    default:
                        {
                            this.m_groundGeometry = new THREE99.PlaneGeometry(200, 200);
                            break;
                        }
                }
                this.m_groundGeometry.translate(0, 0, 0);
                if (this.m_materialVariant === 0 /* ScatteringShader */ ) {
                    this.m_groundMaterial = new GroundAtmosphereMaterial({
                        rendererCapabilities: this.m_rendererCapabilities
                    });
                } else if (this.m_materialVariant === 1 /* SimpleColor */ ) {
                    this.m_groundMaterial = new THREE99.MeshBasicMaterial({
                        color: new THREE99.Color(50687),
                        opacity: 0.4,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE99.FrontSide,
                        blending: THREE99.NormalBlending,
                        fog: false
                    });
                } else {
                    this.m_groundMaterial = new THREE99.MeshStandardMaterial({
                        color: 1149338,
                        depthTest: true,
                        depthWrite: false,
                        side: THREE99.FrontSide,
                        wireframe: true
                    });
                }
                this.m_groundMesh = new THREE99.Mesh(this.m_groundGeometry, this.m_groundMaterial);
                this.m_groundMesh.name = _MapViewAtmosphere.GroundAtmosphereUserName;
                this.setupGroundForRendering();
            }
        },
        {
            key: "setupSkyForRendering",
            value: function setupSkyForRendering() {
                var _this = this;
                if (this.m_skyMesh === void 0) {
                    return;
                }
                var onBeforeCallback;
                if (this.m_materialVariant !== 0 /* ScatteringShader */ ) {
                    onBeforeCallback = function(camera, _material) {
                        _this.overrideClipPlanes(camera);
                    };
                } else {
                    onBeforeCallback = function(camera, material) {
                        _this.overrideClipPlanes(camera);
                        assert(_instanceof(material, SkyAtmosphereMaterial));
                        var mat = _this.m_skyMaterial;
                        mat.updateUniforms(mat, _this.m_skyMesh, camera, _this.m_lightDirection);
                    };
                }
                assert(this.m_skyMaterial !== void 0);
                this.m_skyMesh.onBeforeRender = function(_renderer, _scene, camera, _geometry, material, _group) {
                    onBeforeCallback(camera, material);
                };
                this.m_skyMesh.onAfterRender = function(_renderer, _scene, camera, _geometry, _material, _group) {
                    _this.revertClipPlanes(camera);
                };
            }
        },
        {
            key: "setupGroundForRendering",
            value: function setupGroundForRendering() {
                var _this = this;
                if (this.m_groundMesh === void 0) {
                    return;
                }
                if (this.m_materialVariant !== 0 /* ScatteringShader */ ) {
                    return;
                }
                assert(this.m_groundMaterial !== void 0);
                this.m_groundMesh.onBeforeRender = function(_renderer, _scene, camera, _geometry, material, _group) {
                    assert(_instanceof(material, GroundAtmosphereMaterial));
                    var mat = _this.m_groundMaterial;
                    mat.updateUniforms(mat, _this.m_groundMesh, camera, _this.m_lightDirection);
                };
            }
        },
        {
            key: "overrideClipPlanes",
            value: function overrideClipPlanes(rteCamera) {
                var sceneCam = this.m_sceneCamera;
                cache5.clipPlanes.near = sceneCam.near;
                cache5.clipPlanes.far = sceneCam.far;
                var viewRanges = this.m_clipPlanesEvaluator.evaluateClipPlanes(this.m_sceneCamera, this.m_projection);
                assert(_instanceof(rteCamera, THREE99.PerspectiveCamera));
                var c = rteCamera;
                c.near = viewRanges.near;
                c.far = viewRanges.far + EarthConstants.EQUATORIAL_RADIUS * 0.1;
                c.updateProjectionMatrix();
            }
        },
        {
            key: "revertClipPlanes",
            value: function revertClipPlanes(rteCamera) {
                assert(_instanceof(rteCamera, THREE99.PerspectiveCamera));
                var c = rteCamera;
                c.near = cache5.clipPlanes.near;
                c.far = cache5.clipPlanes.far;
                c.updateProjectionMatrix();
            }
        }
    ], [
        {
            key: "isPresent",
            value: function isPresent(mapAnchors) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = mapAnchors.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var mapAnchor = _step.value;
                        if (mapAnchor.name === _MapViewAtmosphere.SkyAtmosphereUserName || mapAnchor.name === _MapViewAtmosphere.GroundAtmosphereUserName) {
                            return true;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return false;
            }
        }
    ]);
    return _MapViewAtmosphere;
}();
var MapViewAtmosphere = _MapViewAtmosphere;
__publicField(MapViewAtmosphere, "SkyAtmosphereUserName", "SkyAtmosphere");
__publicField(MapViewAtmosphere, "GroundAtmosphereUserName", "GroundAtmosphere");
function createMapAnchor(mesh, renderOrder) {
    var anchor = mesh;
    anchor.renderOrder = renderOrder;
    anchor.pickable = false;
    anchor.anchor = new THREE99.Vector3(0, 0, 0);
    return anchor;
}
// src/mapview/TextureLoader.ts
var THREE100 = __toESM(require("three"));
var TextureLoader5 = /*#__PURE__*/ function() {
    function TextureLoader5() {
        _classCallCheck(this, TextureLoader5);
        __publicField(this, "m_textureLoader", new THREE100.TextureLoader());
    }
    _createClass(TextureLoader5, [
        {
            key: "load",
            value: function load(url, requestHeaders, abortSignal) {
                var crossOrigin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                var _this = this;
                return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                    var response, blob, texture, isJPEG;
                    return regeneratorRuntime.wrap(function _callee$(_ctx) {
                        while(1)switch(_ctx.prev = _ctx.next){
                            case 0:
                                if (!(requestHeaders === void 0)) {
                                    _ctx.next = 4;
                                    break;
                                }
                                _ctx.next = 3;
                                return _this.loadWithThreeLoader(url);
                            case 3:
                                return _ctx.abrupt("return", _ctx.sent);
                            case 4:
                                _ctx.next = 6;
                                return fetch(url, {
                                    headers: requestHeaders,
                                    signal: abortSignal,
                                    mode: crossOrigin ? "cors" : "no-cors"
                                });
                            case 6:
                                response = _ctx.sent;
                                _ctx.next = 9;
                                return response.blob();
                            case 9:
                                blob = _ctx.sent;
                                _ctx.next = 12;
                                return _this.loadWithThreeLoader(URL.createObjectURL(blob));
                            case 12:
                                texture = _ctx.sent;
                                isJPEG = blob.type === "image/jpeg/" || url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                                texture.format = isJPEG ? THREE100.RGBFormat : THREE100.RGBAFormat;
                                return _ctx.abrupt("return", texture);
                            case 16:
                            case "end":
                                return _ctx.stop();
                        }
                    }, _callee);
                }))();
            }
        },
        {
            key: "loadWithThreeLoader",
            value: function loadWithThreeLoader(url) {
                var _this = this;
                return new Promise(function(resolve, reject) {
                    _this.m_textureLoader.setCrossOrigin("");
                    _this.m_textureLoader.load(url, function(texture) {
                        return resolve(texture);
                    }, void 0, function() {
                        return reject(new Error("failed to load texture"));
                    });
                });
            }
        }
    ]);
    return TextureLoader5;
}();
// src/lines/HighPrecisionLines.ts
var THREE103 = __toESM(require("three"));
// src/lines/HighPrecisionUtils.ts
var import_three16 = require("three");
// src/lines/HighPrecisionPoints.ts
var THREE101 = __toESM(require("three"));
var HighPrecisionPoints = /*#__PURE__*/ function(_Points) {
    _inherits(HighPrecisionPoints, _Points);
    var _super = _createSuper(HighPrecisionPoints);
    function HighPrecisionPoints(geometry, material, positions, color, opacity) {
        _classCallCheck(this, HighPrecisionPoints);
        var _this;
        if (material === void 0) {
            material = new HighPrecisionPointMaterial({
                color: color ? color : HighPrecisionPointMaterial.DEFAULT_COLOR,
                opacity: opacity !== void 0 ? opacity : 1
            });
        }
        _this = _super.call(this, geometry === void 0 ? new THREE101.BufferGeometry() : geometry, material);
        __publicField(_assertThisInitialized(_this), "matrixWorldInverse");
        __publicField(_assertThisInitialized(_this), "dimensionality");
        _this.matrixWorldInverse = new THREE101.Matrix4();
        if (positions) {
            _this.setPositions(positions);
        }
        return _this;
    }
    _createClass(HighPrecisionPoints, [
        {
            key: "bufferGeometry",
            get: function get() {
                return this.geometry;
            }
        },
        {
            key: "clearGeometry",
            value: function clearGeometry() {
                return this.geometry = new THREE101.BufferGeometry();
            }
        },
        {
            key: "shaderMaterial",
            get: function get() {
                return this.material;
            }
        },
        {
            key: "setPositions",
            value: function setPositions(positions) {
                HighPrecisionUtils.setPositions(this, positions);
            }
        },
        {
            key: "setupForRendering",
            value: function setupForRendering() {
                var _this = this;
                if (this.material.isHighPrecisionPointsMaterial && this.dimensionality !== void 0) {
                    ;
                    this.material.setDimensionality(this.dimensionality);
                }
                this.onBeforeRender = function(_renderer, _scene, camera, _geometry, _material, _group) {
                    HighPrecisionUtils.updateHpUniforms(_this, camera, _this.shaderMaterial);
                };
            }
        },
        {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
                var doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
                _get(_getPrototypeOf(HighPrecisionPoints.prototype), "updateMatrixWorld", this).call(this, force);
                if (doUpdateMatrixWorldInverse) {
                    this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
            }
        }
    ]);
    return HighPrecisionPoints;
}(THREE101.Points);
// src/lines/TriangulateLines.ts
var THREE102 = __toESM(require("three"));
var UNIT_Z = new THREE102.Vector3(0, 0, 1);
var POINTS = [
    0,
    1,
    2,
    1,
    3,
    2
];
var BEVEL_POINTS = [
    0,
    1,
    3,
    3,
    1,
    2,
    0,
    3,
    4,
    5,
    4,
    3
];
var SECTORS_IN_CIRCLE = 8;
var STEP = Math.PI / SECTORS_IN_CIRCLE;
function addCircle(x, y, lineAngle, radius, vertices, indices) {
    var baseVertex = vertices.length / 3;
    vertices.push(x, y, 0);
    for(var i = 0; i < SECTORS_IN_CIRCLE + 1; ++i){
        var angle = STEP * i + Math.PI / 2 + lineAngle;
        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);
        indices.push(baseVertex, baseVertex + i + 1, baseVertex + (i + 1) % (SECTORS_IN_CIRCLE + 1) + 1);
    }
}
function triangulateLine(points, width, vertices, indices) {
    var startWithCircle = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true, endWithCircle = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : startWithCircle;
    if (points.length < 3) {
        return;
    }
    var angleVec = new THREE102.Vector2();
    if (startWithCircle) {
        var lineAngle = points.length !== 3 ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle() : 0;
        addCircle(points[0], points[1], lineAngle, width, vertices, indices);
    }
    var baseVertex = vertices.length / 3;
    var prevBt = new THREE102.Vector3();
    var p = new THREE102.Vector3();
    var n = new THREE102.Vector3();
    var bt = new THREE102.Vector3();
    var averageBt = new THREE102.Vector3();
    var p0 = new THREE102.Vector3();
    var p1 = new THREE102.Vector3();
    var p2 = new THREE102.Vector3();
    var p3 = new THREE102.Vector3();
    var N = points.length / 3;
    var vertexOffset = 0;
    for(var i = 0; i < N; ++i){
        var useBevel = false;
        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);
        if (i + 1 < N) {
            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);
            bt.copy(n).sub(p).normalize().cross(UNIT_Z);
            averageBt.copy(bt);
            if (i > 0) {
                averageBt.add(prevBt).multiplyScalar(1 - 0.5 * bt.dot(prevBt));
                useBevel = prevBt.angleTo(bt) > Math.PI / 2;
                if (useBevel) {
                    var inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);
                    p0.copy(bt).add(prevBt).normalize().multiplyScalar(-inclineWidth).add(p);
                    p1.copy(prevBt).multiplyScalar(width).add(p);
                    p2.copy(bt).add(prevBt).normalize().multiplyScalar(inclineWidth).add(p);
                    p3.copy(bt).multiplyScalar(width).add(p);
                }
            }
            if (useBevel) {
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
            } else {
                p0.copy(averageBt).multiplyScalar(-width).add(p);
                p1.copy(averageBt).multiplyScalar(width).add(p);
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
            prevBt.copy(bt);
        } else {
            p0.copy(prevBt).multiplyScalar(-width).add(p);
            p1.copy(prevBt).multiplyScalar(width).add(p);
            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
        }
        if (i !== N - 1) {
            ;
            (useBevel ? BEVEL_POINTS : POINTS).forEach(function(o) {
                return indices.push(baseVertex + vertexOffset + o);
            });
            vertexOffset += useBevel ? 4 : 2;
        }
    }
    if (endWithCircle) {
        var lineAngle1 = points.length !== 2 ? angleVec.set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1]).angle() : Math.PI;
        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle1, width, vertices, indices);
    }
}
function reconstructLineWidth(inBuffer, startIndex) {
    var xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];
    var yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];
    var zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];
    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;
}
// src/lines/HighPrecisionUtils.ts
var HighPrecisionUtils;
(function(HighPrecisionUtils2) {
    var doubleToFloatVec = function doubleToFloatVec(v) {
        return new import_three16.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));
    };
    var makeFloatVec = function makeFloatVec(v) {
        var majorX = Math.fround(v.x);
        var majorY = Math.fround(v.y);
        var majorZ = Math.fround(v.z);
        var minorVec = new import_three16.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);
        v.x = Math.fround(majorX);
        v.y = Math.fround(majorY);
        v.z = Math.fround(majorZ);
        return minorVec;
    };
    var createHighPrecisionCameraPos = function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {
        var _projScreenMatrix = new import_three16.Matrix4().copy(camera.projectionMatrix);
        var mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);
        var eyePos = new import_three16.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);
        var eyePosFloat = doubleToFloatVec(eyePos);
        var eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));
        return {
            viewProjection: mvp,
            eyePosHi: eyePosFloat,
            eyePosLo: eyePosLo
        };
    };
    var updateHpUniforms = function updateHpUniforms(object, camera, shaderMaterial) {
        var highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);
        var mvp = highPrecisionCameraInfo.viewProjection;
        if (shaderMaterial !== void 0 && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms && shaderMaterial.uniforms.u_mvp && shaderMaterial.uniforms.u_eyepos && shaderMaterial.uniforms.u_eyepos_lowpart) {
                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);
                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());
                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());
            } else {
                throw Error("High pecision material has missing uniforms");
            }
        } else {
            throw Error("High pecision line has no high precision material");
        }
    };
    var createAttributes = function createAttributes(positions) {
        if (positions.length > 0) {
            var v = positions[0];
            if (v === void 0 || v === null) {
                throw Error("Empty element in positions");
            }
            var positionVec = new Array();
            var positionVecLow = new Array();
            var addHPValue = function() {
                for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){
                    values[_key] = arguments[_key];
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var value2 = _step.value;
                        var major = Math.fround(value2);
                        positionVecLow.push(value2 - major);
                        positionVec.push(major);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            };
            var addHPVector = function(vec) {
                addHPValue(vec.x, vec.y, vec.z);
            };
            var vAny = v;
            if (vAny.z !== void 0) {
                ;
                positions.forEach(function(vec) {
                    addHPVector(vec);
                });
            } else {
                if (positionVec.length % 3 !== 0) {
                    throw Error("Positions must be 3D, not 2D");
                }
                ;
                positions.forEach(function(n) {
                    addHPValue(n);
                });
            }
            return {
                positionHigh: new import_three16.Float32BufferAttribute(positionVec, 3),
                positionLow: new import_three16.Float32BufferAttribute(positionVecLow, 3)
            };
        } else {
            return {
                positionHigh: new import_three16.Float32BufferAttribute([], 3),
                positionLow: new import_three16.Float32BufferAttribute([], 3)
            };
        }
    };
    var addInterleavedAttributes3 = function addInterleavedAttributes3(positions, stride) {
        var positionOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var newPositions = new Array();
        var end = positions.length;
        for(var i = 0; i < end; i += stride){
            for(var j = 0; j < positionOffset; j++){
                newPositions.push(positions[i + j]);
            }
            var x = positions[i + positionOffset];
            var y = positions[i + positionOffset + 1];
            var z = positions[i + positionOffset + 2];
            var majorX = Math.fround(x);
            var minorX = x - majorX;
            var majorY = Math.fround(y);
            var minorY = y - majorY;
            var majorZ = Math.fround(z);
            var minorZ = z - majorZ;
            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);
            for(var j1 = positionOffset + 3; j1 < stride; j1++){
                newPositions.push(positions[i + j1]);
            }
        }
        return newPositions;
    };
    var setPositions = function setPositions(object, positions) {
        var attributes = createAttributes(positions);
        object.bufferGeometry.setAttribute("position", attributes.positionHigh);
        object.bufferGeometry.setAttribute("positionLow", attributes.positionLow);
        return attributes.positionHigh.itemSize;
    };
    var convertPositions = function convertPositions(positions) {
        if (positions.length <= 0) {
            return {
                positions: []
            };
        }
        var v = positions[0];
        if (v === void 0 || v === null) {
            throw Error("Empty element in positions");
        }
        var vAny = v;
        if (vAny.y === void 0 && vAny.z === void 0) {
            return {
                positions: positions
            };
        }
        var returnPositions = new Array();
        positions.forEach(function(vec) {
            returnPositions.push(vec.x, vec.y, vec.z);
        });
        return {
            positions: returnPositions
        };
    };
    var createLine = function createLine(linePositions, params) {
        var lineWidth = params.lineWidth !== void 0 ? params.lineWidth : 5;
        var addCircles = params.addCircles !== void 0 ? params.addCircles : false;
        var wireFrame = params.wireFrame !== void 0 ? params.wireFrame : false;
        var positions = [];
        var indices = [];
        triangulateLine(linePositions, lineWidth, positions, indices, addCircles);
        var hpLineGeometry = new import_three16.BufferGeometry();
        var hpPositions = addInterleavedAttributes3(positions, 3);
        var buffer = new import_three16.InterleavedBuffer(new Float32Array(hpPositions), 6);
        var positionAttribute = new import_three16.InterleavedBufferAttribute(buffer, 3, 0, false);
        var positionLowAttribute = new import_three16.InterleavedBufferAttribute(buffer, 3, 3, false);
        hpLineGeometry.setAttribute("position", positionAttribute);
        hpLineGeometry.setAttribute("positionLow", positionLowAttribute);
        hpLineGeometry.setIndex(new import_three16.BufferAttribute(new Uint32Array(indices), 1));
        var hpSolidMaterial = new HighPrecisionLineMaterial(params);
        var lineObject = wireFrame ? new HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial) : new HighPrecisionLine(hpLineGeometry, hpSolidMaterial);
        lineObject.setupForRendering();
        return lineObject;
    };
    var createPoints = function createPoints(pointPositions, materialParameters) {
        var indices = [];
        for(var i = 0; i < pointPositions.length; i++){
            indices.push(indices.length / 3);
        }
        var hpPointsGeometry = new import_three16.BufferGeometry();
        var hpPointsMaterial = isHighPrecisionPointMaterial(materialParameters) ? materialParameters : new HighPrecisionPointMaterial(materialParameters);
        var pointsObject = new HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);
        setPositions(pointsObject, pointPositions);
        pointsObject.setupForRendering();
        return pointsObject;
    };
    HighPrecisionUtils2.doubleToFloatVec = doubleToFloatVec;
    HighPrecisionUtils2.makeFloatVec = makeFloatVec;
    HighPrecisionUtils2.createHighPrecisionCameraPos = createHighPrecisionCameraPos;
    HighPrecisionUtils2.updateHpUniforms = updateHpUniforms;
    HighPrecisionUtils2.createAttributes = createAttributes;
    HighPrecisionUtils2.addInterleavedAttributes3 = addInterleavedAttributes3;
    HighPrecisionUtils2.setPositions = setPositions;
    HighPrecisionUtils2.convertPositions = convertPositions;
    HighPrecisionUtils2.createLine = createLine;
    HighPrecisionUtils2.createPoints = createPoints;
})(HighPrecisionUtils || (HighPrecisionUtils = {}));
// src/lines/HighPrecisionLines.ts
var HighPrecisionWireFrameLine = /*#__PURE__*/ function(_Line) {
    _inherits(HighPrecisionWireFrameLine, _Line);
    var _super = _createSuper(HighPrecisionWireFrameLine);
    function HighPrecisionWireFrameLine(geometry, material, positions) {
        _classCallCheck(this, HighPrecisionWireFrameLine);
        var _this;
        _this = _super.call(this, geometry, material);
        __publicField(_assertThisInitialized(_this), "matrixWorldInverse");
        _this.matrixWorldInverse = new THREE103.Matrix4();
        if (positions) {
            _this.setPositions(positions);
        }
        return _this;
    }
    _createClass(HighPrecisionWireFrameLine, [
        {
            key: "bufferGeometry",
            get: function get() {
                return this.geometry;
            }
        },
        {
            key: "shaderMaterial",
            get: function get() {
                return this.material;
            }
        },
        {
            key: "setPositions",
            value: function setPositions(positions) {
                HighPrecisionUtils.setPositions(this, positions);
            }
        },
        {
            key: "setupForRendering",
            value: function setupForRendering() {
                var _this = this;
                this.onBeforeRender = function(_renderer, _scene, camera, _geometry, _material, _group) {
                    HighPrecisionUtils.updateHpUniforms(_this, camera, _this.shaderMaterial);
                };
            }
        },
        {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
                var doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
                _get(_getPrototypeOf(HighPrecisionWireFrameLine.prototype), "updateMatrixWorld", this).call(this, force);
                if (doUpdateMatrixWorldInverse) {
                    this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
            }
        }
    ]);
    return HighPrecisionWireFrameLine;
}(THREE103.Line);
var HighPrecisionLine = /*#__PURE__*/ function(_Mesh) {
    _inherits(HighPrecisionLine, _Mesh);
    var _super = _createSuper(HighPrecisionLine);
    function HighPrecisionLine(geometry, material, positions) {
        _classCallCheck(this, HighPrecisionLine);
        var _this;
        _this = _super.call(this, geometry, material);
        __publicField(_assertThisInitialized(_this), "matrixWorldInverse");
        _this.matrixWorldInverse = new THREE103.Matrix4();
        if (positions) {
            _this.setPositions(positions);
        }
        return _this;
    }
    _createClass(HighPrecisionLine, [
        {
            key: "bufferGeometry",
            get: function get() {
                return this.geometry;
            }
        },
        {
            key: "shaderMaterial",
            get: function get() {
                return this.material;
            }
        },
        {
            key: "setPositions",
            value: function setPositions(positions) {
                HighPrecisionUtils.setPositions(this, positions);
            }
        },
        {
            key: "setupForRendering",
            value: function setupForRendering() {
                var _this = this;
                this.onBeforeRender = function(_renderer, _scene, camera, _geometry, _material, _group) {
                    HighPrecisionUtils.updateHpUniforms(_this, camera, _this.shaderMaterial);
                };
            }
        },
        {
            key: "updateMatrixWorld",
            value: function updateMatrixWorld(force) {
                var doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
                _get(_getPrototypeOf(HighPrecisionLine.prototype), "updateMatrixWorld", this).call(this, force);
                if (doUpdateMatrixWorldInverse) {
                    this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
            }
        }
    ]);
    return HighPrecisionLine;
}(THREE103.Mesh);
// src/lines/Lines.ts
var THREE104 = __toESM(require("three"));
var tmpV5 = new THREE104.Vector3();
var tmpNormal = new THREE104.Vector3();
var tmpTangent0 = new THREE104.Vector3();
var tmpTangent1 = new THREE104.Vector3();
var tmpBitangent = new THREE104.Vector3();
var LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        {
            name: "extrusionCoord",
            itemSize: 3,
            offset: 0
        },
        {
            name: "position",
            itemSize: 3,
            offset: 3
        },
        {
            name: "tangent",
            itemSize: 3,
            offset: 6
        },
        {
            name: "biTangent",
            itemSize: 4,
            offset: 9
        }
    ],
    stride: 13
};
var NORMAL_UV_VERTEX_ATTRIBUTES = {
    attributes: [
        {
            name: "uv",
            itemSize: 2,
            offset: LINE_VERTEX_ATTRIBUTES.stride
        },
        {
            name: "normal",
            itemSize: 3,
            offset: LINE_VERTEX_ATTRIBUTES.stride + 2
        }
    ],
    stride: 5
};
var LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: _toConsumableArray(LINE_VERTEX_ATTRIBUTES.attributes).concat(_toConsumableArray(NORMAL_UV_VERTEX_ATTRIBUTES.attributes)),
    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
var HP_LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        {
            name: "extrusionCoord",
            itemSize: 2,
            offset: 0
        },
        {
            name: "position",
            itemSize: 3,
            offset: 2
        },
        {
            name: "positionLow",
            itemSize: 3,
            offset: 5
        },
        {
            name: "tangent",
            itemSize: 3,
            offset: 8
        },
        {
            name: "biTangent",
            itemSize: 4,
            offset: 11
        }
    ],
    stride: 15
};
var HP_LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: _toConsumableArray(HP_LINE_VERTEX_ATTRIBUTES.attributes).concat(_toConsumableArray(NORMAL_UV_VERTEX_ATTRIBUTES.attributes)),
    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
// src/mapview/geometry/TileGeometry.ts
var logger29 = LoggerManager.instance.create("TileGeometry");
function isLineAccessor(arg) {
    return typeof arg.isLineAccessor === "function" && arg.isLineAccessor() === true;
}
function isObject3dAccessor(arg) {
    return typeof arg.isObject3dAccessor === "function" && arg.isObject3dAccessor() === true;
}
var BufferedGeometryAccessorBase = /*#__PURE__*/ function() {
    function BufferedGeometryAccessorBase(object, geometryType, bufferGeometry) {
        _classCallCheck(this, BufferedGeometryAccessorBase);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        __publicField(this, "start", -1);
        __publicField(this, "end", -1);
        __publicField(this, "startCapSize", 0);
        __publicField(this, "endCapSize", 0);
        __publicField(this, "position");
        __publicField(this, "itemSize");
        assert(!!object);
        if (bufferGeometry.type !== "BufferGeometry") {
            logger29.error("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
        }
        assert(bufferGeometry.type === "BufferGeometry", "IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
        this.position = this.bufferGeometry.getAttribute("position");
        this.itemSize = this.position.itemSize;
        if (!this.position) {
            logger29.warn("BufferedGeometryAccessor#constructor: BufferGeometry has no position attribute");
        }
        if (this.position.array.constructor !== Float32Array) {
            logger29.warn("BufferedGeometryAccessor#constructor: BufferGeometry.position: unsupported ArrayBuffer");
        }
    }
    _createClass(BufferedGeometryAccessorBase, [
        {
            key: "getCount",
            value: function getCount() {
                return this.position.count;
            }
        },
        {
            key: "renderOrder",
            get: function get() {
                return this.object.renderOrder;
            }
        },
        {
            key: "setRange",
            value: function setRange(start, end) {
                var startCapSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, endCapSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                assert(start >= 0);
                assert(end >= 0);
                assert(start <= end);
                this.start = start;
                this.end = end;
                this.startCapSize = startCapSize;
                this.endCapSize = endCapSize;
            }
        },
        {
            key: "color",
            get: function get() {
                var getColor = function(material) {
                    var meshMaterial = material;
                    if (meshMaterial.type === "MeshBasicMaterial" || meshMaterial.type === "MeshStandardMaterial") {
                        return meshMaterial.color;
                    } else if (meshMaterial.type === "RawShaderMaterial") {
                        var rawShaderMaterial = material;
                        if (rawShaderMaterial.name === "SolidLineMaterial") {
                            return rawShaderMaterial.uniforms.diffuseColor.value;
                        }
                        logger29.warn("BufferedGeometryAccessor#color: unknown shader material name", rawShaderMaterial.name);
                    } else {
                        logger29.warn("BufferedGeometryAccessor#color: unknown material type", meshMaterial.type);
                    }
                    return void 0;
                };
                if (Array.isArray(this.object.material)) {
                    var results = new Array();
                    var materials = this.object.material;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = materials[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var material = _step.value;
                            results.push(getColor(material));
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    return results;
                } else {
                    return getColor(this.object.material);
                }
            }
        }
    ]);
    return BufferedGeometryAccessorBase;
}();
var BufferedGeometryAccessor = /*#__PURE__*/ function(BufferedGeometryAccessorBase) {
    _inherits(BufferedGeometryAccessor, BufferedGeometryAccessorBase);
    var _super = _createSuper(BufferedGeometryAccessor);
    function BufferedGeometryAccessor(object, geometryType, bufferGeometry, stride) {
        _classCallCheck(this, BufferedGeometryAccessor);
        var _this;
        _this = _super.call(this, object, geometryType, bufferGeometry);
        _this.object = object;
        _this.geometryType = geometryType;
        _this.bufferGeometry = bufferGeometry;
        _this.stride = stride;
        return _this;
    }
    _createClass(BufferedGeometryAccessor, [
        {
            key: "clear",
            value: function clear() {
                assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
                var positionsArray = this.position.array;
                var start = this.start * this.itemSize;
                var end = this.end * this.itemSize;
                for(var i = start; i < end; i++){
                    positionsArray[i] = 0;
                }
                this.position.needsUpdate = true;
            }
        },
        {
            key: "getVertices",
            value: function getVertices() {
                assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
                var start = this.start;
                var end = this.end;
                return this.position.array.subarray(start * this.itemSize, end * this.itemSize);
            }
        },
        {
            key: "checkSetUp",
            value: function checkSetUp() {
                return this.position !== void 0 && this.start !== void 0 && this.end !== void 0 && this.start >= 0 && this.end <= this.position.count && this.start <= this.end;
            }
        }
    ]);
    return BufferedGeometryAccessor;
}(BufferedGeometryAccessorBase);
var BufferedGeometryLineAccessor = /*#__PURE__*/ function(BufferedGeometryAccessor) {
    _inherits(BufferedGeometryLineAccessor, BufferedGeometryAccessor);
    var _super = _createSuper(BufferedGeometryLineAccessor);
    function BufferedGeometryLineAccessor(object, geometryType, bufferGeometry) {
        _classCallCheck(this, BufferedGeometryLineAccessor);
        var _this;
        _this = _super.call(this, object, geometryType, bufferGeometry, 3);
        _this.object = object;
        _this.geometryType = geometryType;
        _this.bufferGeometry = bufferGeometry;
        return _this;
    }
    _createClass(BufferedGeometryLineAccessor, [
        {
            key: "isLineAccessor",
            value: function isLineAccessor() {
                return true;
            }
        },
        {
            key: "width",
            get: function get() {
                assert(this.checkSetUp(), "RoBufferedGeometryLineAccessor not setup");
                return void 0;
            }
        }
    ]);
    return BufferedGeometryLineAccessor;
}(BufferedGeometryAccessor);
var BufferedGeometryObject3dAccessor = /*#__PURE__*/ function(BufferedGeometryAccessor) {
    _inherits(BufferedGeometryObject3dAccessor, BufferedGeometryAccessor);
    var _super = _createSuper(BufferedGeometryObject3dAccessor);
    function BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry) {
        _classCallCheck(this, BufferedGeometryObject3dAccessor);
        var _this;
        _this = _super.call(this, object, geometryType, bufferGeometry, 1);
        _this.object = object;
        _this.geometryType = geometryType;
        _this.bufferGeometry = bufferGeometry;
        return _this;
    }
    _createClass(BufferedGeometryObject3dAccessor, [
        {
            key: "isObject3dAccessor",
            value: function isObject3dAccessor() {
                return true;
            }
        },
        {
            key: "getVertices",
            value: function getVertices() {
                return _get(_getPrototypeOf(BufferedGeometryObject3dAccessor.prototype), "getVertices", this).call(this);
            }
        }
    ]);
    return BufferedGeometryObject3dAccessor;
}(BufferedGeometryAccessor);
var IndexedBufferedGeometryAccessor = /*#__PURE__*/ function(BufferedGeometryAccessorBase) {
    _inherits(IndexedBufferedGeometryAccessor, BufferedGeometryAccessorBase);
    var _super = _createSuper(IndexedBufferedGeometryAccessor);
    function IndexedBufferedGeometryAccessor(object, geometryType, bufferGeometry, start, end) {
        _classCallCheck(this, IndexedBufferedGeometryAccessor);
        var _this;
        _this = _super.call(this, object, geometryType, bufferGeometry);
        _this.object = object;
        _this.geometryType = geometryType;
        _this.bufferGeometry = bufferGeometry;
        __publicField(_assertThisInitialized(_this), "indices");
        _this.indices = _this.bufferGeometry.index !== null ? _this.bufferGeometry.index.array : void 0;
        if (!_this.indices) {
            logger29.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no index");
            assert(!!_this.indices);
        } else {
            if (!_instanceof(_this.indices, Uint32Array)) {
                logger29.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry index has wrong type");
                assert(_instanceof(_this.indices, Uint32Array));
            }
        }
        return _this;
    }
    _createClass(IndexedBufferedGeometryAccessor, [
        {
            key: "getCount",
            value: function getCount() {
                return this.indices.length;
            }
        },
        {
            key: "checkSetUp",
            value: function checkSetUp() {
                return !!this.indices && this.start !== void 0 && this.end !== void 0 && this.start >= 0 && this.end <= this.indices.length && this.start <= this.end;
            }
        }
    ]);
    return IndexedBufferedGeometryAccessor;
}(BufferedGeometryAccessorBase);
var IndexedBufferedGeometryLineAccessor = /*#__PURE__*/ function(IndexedBufferedGeometryAccessor) {
    _inherits(IndexedBufferedGeometryLineAccessor, IndexedBufferedGeometryAccessor);
    var _super = _createSuper(IndexedBufferedGeometryLineAccessor);
    function IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry) {
        _classCallCheck(this, IndexedBufferedGeometryLineAccessor);
        var _this;
        _this = _super.call(this, object, geometryType, bufferGeometry, 3);
        _this.object = object;
        _this.geometryType = geometryType;
        _this.bufferGeometry = bufferGeometry;
        return _this;
    }
    _createClass(IndexedBufferedGeometryLineAccessor, [
        {
            key: "isLineAccessor",
            value: function isLineAccessor() {
                return true;
            }
        },
        {
            key: "width",
            get: function get() {
                assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
                if (this.geometryType === 6 /* ExtrudedLine */ ) {
                    var start = this.start + this.startCapSize;
                    var positionArray = this.position.array;
                    return reconstructLineWidth(positionArray, start);
                }
                return void 0;
            }
        },
        {
            key: "clear",
            value: function clear() {
                assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
                var start = this.start;
                var end = this.end;
                for(var i = start; i < end; i++){
                    this.indices[i] = 0;
                }
                if (this.bufferGeometry.index !== null) {
                    this.bufferGeometry.index.needsUpdate = true;
                }
            }
        },
        {
            key: "getVertices",
            value: function getVertices() {
                assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
                var itemSize = this.itemSize;
                var start = this.start;
                var end = this.end;
                var result = new Float32Array((end - start) * itemSize);
                var positionArray = this.position.array;
                if (itemSize === 2) {
                    for(var i = start, j = 0; i < end; i++, j += itemSize){
                        var index = this.indices[i];
                        result[j + 0] = positionArray[index * itemSize + 0];
                        result[j + 1] = positionArray[index * itemSize + 1];
                    }
                }
                if (itemSize === 3) {
                    for(var i1 = start, j1 = 0; i1 < end; i1++, j1 += itemSize){
                        var index1 = this.indices[i1];
                        result[j1 + 0] = positionArray[index1 * itemSize + 0];
                        result[j1 + 1] = positionArray[index1 * itemSize + 1];
                        result[j1 + 2] = positionArray[index1 * itemSize + 2];
                    }
                } else {
                    for(var i2 = start, j2 = 0; i2 < end; i2++, j2++){
                        var index2 = this.indices[i2];
                        for(var k = 0; k < itemSize; k++){
                            result[j2 * itemSize + k] = positionArray[index2 * itemSize + k];
                        }
                    }
                }
                return result;
            }
        }
    ]);
    return IndexedBufferedGeometryLineAccessor;
}(IndexedBufferedGeometryAccessor);
// src/mapview/geometry/TileDataAccessor.ts
var logger30 = LoggerManager.instance.create("TileDataAccessor");
var TileDataAccessor = /*#__PURE__*/ function() {
    function TileDataAccessor(tile, visitor, options) {
        _classCallCheck(this, TileDataAccessor);
        this.tile = tile;
        this.visitor = visitor;
        __publicField(this, "m_wantsPoints");
        __publicField(this, "m_wantsLines");
        __publicField(this, "m_wantsAreas");
        __publicField(this, "m_wantsObject3D");
        var wantsAll = options.wantsAll === true;
        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);
        this.m_wantsLines = wantsAll || !(options.wantsLines === false);
        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);
        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);
    }
    _createClass(TileDataAccessor, [
        {
            key: "visitAll",
            value: function visitAll() {
                var objects = this.tile.objects;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var object = _step.value;
                        this.visitObject(object);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        {
            key: "visitObject",
            value: function visitObject(object) {
                var featureData = object.userData !== void 0 ? object.userData.feature : void 0;
                if (featureData === void 0 || featureData.objInfos !== void 0 && featureData.objInfos.length === 1 && !this.visitor.wantsFeature(getFeatureId(featureData.objInfos[0]))) {
                    return;
                }
                var geometryType = featureData.geometryType;
                if (geometryType === void 0) {
                    logger30.warn("#visitObject: visiting object failed, no geometryType", object);
                    return;
                }
                assert(featureData.objInfos !== void 0, "featureData.ids missing");
                assert(featureData.starts !== void 0, "featureData.starts missing");
                assert(Array.isArray(featureData.starts), "featureData.starts is not an array");
                if (featureData.objInfos !== void 0 && featureData.starts !== void 0) {
                    assert(featureData.objInfos.length === featureData.starts.length, "featureData.ids and featureData.starts have unequal length");
                }
                switch(geometryType){
                    case 1 /* Point */ :
                    case 4 /* Text */ :
                        if (!this.m_wantsPoints) {
                            return;
                        }
                        break;
                    case 3 /* SolidLine */ :
                    case 6 /* ExtrudedLine */ :
                    case 5 /* TextPath */ :
                        if (!this.m_wantsLines) {
                            return;
                        }
                        break;
                    case 7 /* Polygon */ :
                    case 8 /* ExtrudedPolygon */ :
                        if (!this.m_wantsAreas) {
                            return;
                        }
                        break;
                    case 9 /* Object3D */ :
                        if (!this.m_wantsObject3D) {
                            return;
                        }
                        break;
                    default:
                        logger30.warn("#visitObject: invalid geometryType");
                }
                if (object.type !== "Mesh") {
                    logger30.warn("#visitObject: visiting object failed, not of type 'Mesh'", object);
                    return;
                }
                var mesh = object;
                this.visitMesh(mesh, featureData);
            }
        },
        {
            key: "getBufferGeometry",
            value: function getBufferGeometry(object) {
                var geometry = object.geometry;
                if (geometry.type !== "BufferGeometry") {
                    logger30.warn("#visitObject: object does not have BufferGeometry");
                    return void 0;
                }
                var bufferGeometry = geometry;
                var position = bufferGeometry.getAttribute("position");
                if (!position) {
                    logger30.warn("#visitLines: BufferGeometry has no position attribute");
                    return void 0;
                }
                return bufferGeometry;
            }
        },
        {
            key: "getGeometryAccessor",
            value: function getGeometryAccessor(geometryType, object, bufferGeometry) {
                switch(geometryType){
                    case 1 /* Point */ :
                    case 4 /* Text */ :
                        return void 0;
                    case 3 /* SolidLine */ :
                    case 6 /* ExtrudedLine */ :
                    case 5 /* TextPath */ :
                        return new BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                    case 7 /* Polygon */ :
                    case 8 /* ExtrudedPolygon */ :
                        return void 0;
                    case 9 /* Object3D */ :
                        return new BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);
                    default:
                        logger30.warn("#getGeometryAccessor: invalid geometryType");
                }
                return void 0;
            }
        },
        {
            key: "getIndexedGeometryAccessor",
            value: function getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {
                switch(geometryType){
                    case 1 /* Point */ :
                    case 4 /* Text */ :
                        return void 0;
                    case 3 /* SolidLine */ :
                    case 6 /* ExtrudedLine */ :
                    case 5 /* TextPath */ :
                        return new IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                    case 7 /* Polygon */ :
                    case 8 /* ExtrudedPolygon */ :
                        return void 0;
                    case 9 /* Object3D */ :
                        return void 0;
                    default:
                        logger30.warn("#getIndexedGeometryAccessor: invalid geometryType");
                }
                return void 0;
            }
        },
        {
            key: "visitMesh",
            value: function visitMesh(meshObject, featureData) {
                var objInfos = featureData.objInfos, starts = featureData.starts;
                var geometryType = featureData.geometryType;
                if (objInfos === void 0 || starts === void 0 || geometryType === void 0) {
                    return;
                }
                var geometryAccessor;
                for(var featureIndex = 0; featureIndex < objInfos.length; featureIndex++){
                    var featureId = getFeatureId(objInfos[featureIndex]);
                    if (!this.visitor.wantsFeature(featureId)) {
                        continue;
                    }
                    var featureStart = starts[featureIndex];
                    var featureEnd = -1;
                    if (geometryAccessor === void 0) {
                        var bufferGeometry = this.getBufferGeometry(meshObject);
                        if (bufferGeometry === void 0) {
                            continue;
                        }
                        if (bufferGeometry.index !== null) {
                            geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);
                        } else {
                            geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);
                        }
                        if (geometryAccessor === void 0) {
                            logger30.warn("#visitObject: no accessor geometryType", geometryType);
                            continue;
                        }
                    }
                    featureEnd = featureIndex < starts.length - 1 ? starts[featureIndex + 1] : geometryAccessor.getCount();
                    geometryAccessor.setRange(featureStart, featureEnd);
                    switch(geometryType){
                        case 1 /* Point */ :
                        case 4 /* Text */ :
                            this.visitor.visitPoint(featureId);
                            break;
                        case 3 /* SolidLine */ :
                        case 6 /* ExtrudedLine */ :
                        case 5 /* TextPath */ :
                            assert(isLineAccessor(geometryAccessor));
                            this.visitor.visitLine(featureId, geometryAccessor);
                            break;
                        case 7 /* Polygon */ :
                        case 8 /* ExtrudedPolygon */ :
                            this.visitor.visitArea(featureId);
                            break;
                        case 9 /* Object3D */ :
                            assert(isObject3dAccessor(geometryAccessor));
                            this.visitor.visitObject3D(featureId, geometryAccessor);
                            break;
                        default:
                            logger30.warn("#visitObject: invalid geometryType");
                    }
                }
            }
        }
    ]);
    return TileDataAccessor;
}();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    AnimatedExtrusionHandler: AnimatedExtrusionHandler,
    AnimatedExtrusionState: AnimatedExtrusionState,
    ArcadeMap: ArcadeMap,
    AtmosphereLightMode: AtmosphereLightMode,
    BASE_TECHNIQUE_NON_MATERIAL_PROPS: BASE_TECHNIQUE_NON_MATERIAL_PROPS,
    BaseTileLoader: BaseTileLoader,
    BoundsGenerator: BoundsGenerator,
    BufferedGeometryAccessor: BufferedGeometryAccessor,
    BufferedGeometryAccessorBase: BufferedGeometryAccessorBase,
    BufferedGeometryLineAccessor: BufferedGeometryLineAccessor,
    BufferedGeometryObject3dAccessor: BufferedGeometryObject3dAccessor,
    CalculationStatus: CalculationStatus,
    CameraMovementDetector: CameraMovementDetector,
    CameraUtils: CameraUtils,
    Circles: Circles,
    ColorCache: ColorCache,
    ConcurrentDecoderFacade: ConcurrentDecoderFacade,
    ConcurrentTilerFacade: ConcurrentTilerFacade,
    CopyrightCoverageProvider: CopyrightCoverageProvider,
    CopyrightElementHandler: CopyrightElementHandler,
    CopyrightInfo: CopyrightInfo,
    DEFAULT_FONT_CATALOG_NAME: DEFAULT_FONT_CATALOG_NAME,
    DEFAULT_FOV_CALCULATION: DEFAULT_FOV_CALCULATION,
    DEFAULT_MAX_THEME_INTHERITANCE_DEPTH: DEFAULT_MAX_THEME_INTHERITANCE_DEPTH,
    DEFAULT_TEXT_DISTANCE_SCALE: DEFAULT_TEXT_DISTANCE_SCALE,
    DEPTH_PRE_PASS_STENCIL_MASK: DEPTH_PRE_PASS_STENCIL_MASK,
    DataSource: DataSource,
    DebugContext: DebugContext,
    ElevationBasedClipPlanesEvaluator: ElevationBasedClipPlanesEvaluator,
    EventDispatcher: EventDispatcher,
    FixedClipPlanesEvaluator: FixedClipPlanesEvaluator,
    FrameStats: FrameStats,
    FrameStatsArray: FrameStatsArray,
    ImageCache: ImageCache,
    ImageItem: ImageItem,
    IndexedBufferedGeometryAccessor: IndexedBufferedGeometryAccessor,
    IndexedBufferedGeometryLineAccessor: IndexedBufferedGeometryLineAccessor,
    LoadingState: LoadingState,
    MAX_FOV_DEG: MAX_FOV_DEG,
    MAX_FOV_RAD: MAX_FOV_RAD,
    MIN_FOV_DEG: MIN_FOV_DEG,
    MIN_FOV_RAD: MIN_FOV_RAD,
    MSAARenderPass: MSAARenderPass,
    MSAASampling: MSAASampling,
    MapAnchors: MapAnchors,
    MapRenderingManager: MapRenderingManager,
    MapView: MapView,
    MapViewAtmosphere: MapViewAtmosphere,
    MapViewEventNames: MapViewEventNames,
    MapViewFog: MapViewFog,
    MapViewImageCache: MapViewImageCache,
    MapViewPoints: MapViewPoints,
    MapViewUtils: MapViewUtils,
    MultiStageTimer: MultiStageTimer,
    Pass: Pass,
    PerformanceStatistics: PerformanceStatistics,
    PickHandler: PickHandler,
    PickObjectType: PickObjectType,
    PoiManager: PoiManager,
    PoiTable: PoiTable,
    PoiTableManager: PoiTableManager,
    PolarTileDataSource: PolarTileDataSource,
    ResourceComputationType: ResourceComputationType,
    RingBuffer: RingBuffer,
    SampledTimer: SampledTimer,
    SimpleTimer: SimpleTimer,
    Squares: Squares,
    Statistics: Statistics,
    TextElement: TextElement,
    TextElementType: TextElementType,
    TextElementsRenderer: TextElementsRenderer,
    TextStyleCache: TextStyleCache,
    TextureLoader: TextureLoader,
    ThemeLoader: ThemeLoader,
    Tile: Tile,
    TileDataAccessor: TileDataAccessor,
    TileGeometryCreator: TileGeometryCreator,
    TileLoaderState: TileLoaderState,
    TileOffsetUtils: TileOffsetUtils,
    TileTaskGroups: TileTaskGroups,
    TiltViewClipPlanesEvaluator: TiltViewClipPlanesEvaluator,
    TopViewClipPlanesEvaluator: TopViewClipPlanesEvaluator,
    UrlCopyrightProvider: UrlCopyrightProvider,
    VisibleTileSet: VisibleTileSet,
    WorkerBasedDecoder: WorkerBasedDecoder,
    WorkerBasedTiler: WorkerBasedTiler,
    WorkerLoader: WorkerLoader,
    applyBaseColorToMaterial: applyBaseColorToMaterial,
    applySecondaryColorToMaterial: applySecondaryColorToMaterial,
    buildMetricValueEvaluator: buildMetricValueEvaluator,
    buildObject: buildObject,
    computeArrayAverage: computeArrayAverage,
    computeArrayStats: computeArrayStats,
    createDefaultClipPlanesEvaluator: createDefaultClipPlanesEvaluator,
    createDepthPrePassMaterial: createDepthPrePassMaterial,
    createDepthPrePassMesh: createDepthPrePassMesh,
    createMaterial: createMaterial,
    debugContext: debugContext,
    evaluateBaseColorProperty: evaluateBaseColorProperty,
    evaluateColorProperty: evaluateColorProperty,
    getBufferAttribute: getBufferAttribute,
    getFeatureDataSize: getFeatureDataSize,
    getMaterialConstructor: getMaterialConstructor,
    isDepthPrePassMesh: isDepthPrePassMesh,
    isLineAccessor: isLineAccessor,
    isObject3dAccessor: isObject3dAccessor,
    isRenderDepthPrePassEnabled: isRenderDepthPrePassEnabled,
    poiIsRenderable: poiIsRenderable,
    setDepthPrePassStencil: setDepthPrePassStencil,
    usesObject3D: usesObject3D
}); //!!!!!!!ALTITUDE IS NOT TAKEN INTO ACCOUNT!!!!!!!!!
